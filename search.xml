<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>林肯葛底斯堡演说中英互译</title>
      <link href="/archives/2be104af.html"/>
      <url>/archives/2be104af.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在1863年11月19日，正值美国内战中葛底斯堡战役结束后四个半月，林肯在宾夕法尼亚州葛底斯堡的葛底斯堡国家公墓（Gettysburg National Cemetery）揭幕式中发表这篇演说，哀悼在长达5个半月的葛底斯堡之役中阵亡的将士。林肯的演讲于当天第二顺位发表，修辞细腻周密，其后成为美国历史上最伟大的演说之一。出乎意料的是，尽管这场演说名垂青史，声震寰宇，其确切之措辞却颇受争议。五份已知的演说稿，与当时新闻报导中的誊抄本，于若干细节上彼此互异。</p><p><a href="https://zh.wikipedia.org/wiki/%E4%BA%9A%E4%BC%AF%E6%8B%89%E7%BD%95%C2%B7%E6%9E%97%E8%82%AF">◎ 亚伯拉罕·林肯</a> | <a href="https://zh.wikipedia.org/wiki/%E8%93%8B%E8%8C%B2%E5%A0%A1%E6%BC%94%E8%AA%AA">葛底斯堡演说</a> | <a href="https://chegva.com/3768.html">林肯励志名言</a></p><p><strong>Gettysburg Address</strong> </p><p>（Delivered on the 19th Day of November, 1863 Cemetery Hill, Gettysburg, Pennsylvania ）</p><p> 1863年11月19日,葛底斯堡,宾夕法尼亚</p><p>Four score and seven years ago, our fathers brought forth upon this continent, a new Nation, conceived in Liberty, and dedicated to the proposition that all men are created equal.　</p><p>87年前，我们的先辈们在这个大陆上创立了一个新国家，它孕育于自由之中，奉行一切人生来平等的原则。</p><p>Now, we are engaged in a great Civil War, testing whether that Nation, or any nation so conceived and so dedicated, can long endure.　We are met on a great battlefield of that war.　We have come to dedicate a portion of that field as a final resting-place for those who gave their lives that Nation might live.　It is altogether fitting and proper that we should do this.</p><p>现在我们正从事一场伟大的内战，以考验这个国家，或者任何一个孕育于自由和奉行上述原则的国家是否能够长久存在下去。我们在这场战争中的一个伟大战场上集会。烈士们为使这个国家能够生存下去而献出了自己的生命，我们来到这里，是要把这个战场的一部分奉献给他们作为最后安息之所。我们这样做是完全应该而且是非常恰当的。</p><p>But, in a larger sense, we cannot dedicate, we cannot consecrate, we can not hallow this ground.　The brave men, living and dead, who struggled here have consecrated it far above our power to add or detract.　The world will little note nor long remember what we say here, but it can never forget what they did here.　It is for us, the living, rather to be dedicated to the great task remaining before us; that from these honored dead, we take increased devotion to that cause for which they gave the last full measure of devotion; that this Nation, under GOD, shall have a new birth of freedom; and that government of the People by the People and for the People shall not perish from the earth.</p><p>但是，从更广泛的意义上来说，我们并不能献祭这块土地，我们不能够使之神圣，我们也不能使之光荣。那些曾在这里战斗过的勇士们，活着的和去世的，已经使这块土地神圣了，这远不是我们微薄的力量所能增减的。我们今天在这里所说的话，全世界不大会注意，也不会长久地记住，但勇士们在这里所做过的事，全世界却永远不会忘记。毋宁说，倒是我们这些还活着的人，应该在这里把自己奉献于勇士们已经如此崇高地向前推进但尚未完成的事业。倒是我们应该在这里把自己奉献于仍然留在我们面前的伟大任务——我们要从这些光荣的死者身上汲取更多的献身精神，来完成他们已经完全彻底为之献身的事业；我们要在这里下定最大的决心，不让这些死者白白牺牲；我们要使国家在上帝福佑下得到自由的新生，要使这个民有、民治、民享的政府永世长存。</p>]]></content>
      
      
      <categories>
          
          <category> 摘录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摘录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>80个文化典故</title>
      <link href="/archives/e25bd3cc.html"/>
      <url>/archives/e25bd3cc.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>如果说，诗文是一匹锦缎，那么典故就是华美的刺绣，一道水波，一片禽羽，都有很深的“讲究”。</p><p>精致的文笔，可寻诗文的来路；恰到好处的典故，可寻诗文的归处。</p><p>全都记住之后，纵使不能“赌书泼茶”，也可更深层次地了解“诗书中华”。</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI2NDI3ODk0OQ==&amp;mid=2247583879&amp;idx=4&amp;sn=dc4120000dffab82e786b87f96272782&amp;chksm=eaacce4ddddb475bc0345232039de96c52cfe9fd6347fc0a29a2f131baa3b99d2d255711daac&amp;scene=132#wechat_redirect">◎50个成语，50个历史名人，你真不一定知道！</a></p><p><a href="https://cdn.chegva.com/ueditor/php/upload/image/20201210/1607587107939262.jpeg"><img src="https://cdn.chegva.com/ueditor/php/upload/image/20201210/1607587107939262.jpeg" alt="80个文化典故，信手拈来即文章"></a></p><p><strong>1、斑竹</strong></p><p>湘妃竹。舜死后，舜的妃子娥皇和女英在湘水上啼哭，眼泪洒在竹子上，竹上生了斑痕。</p><p>唐刘禹锡《泰娘歌》：<strong>“如何将此千行泪，更洒湘江斑竹枝。”</strong></p><p><strong>2、比翼鸟、连理枝</strong></p><p>传说中鹣鹣只有一只眼、一只翅膀，所以一定要两只鸟在一起才能飞，比喻夫妻。连生在一起的两个树枝，<strong>比如恩爱夫妻。</strong></p><p>唐白居易《长恨歌》：<strong>“在天愿为比翼鸟，在地愿为连理枝。”</strong></p><p><strong>3、破镜重圆</strong></p><p>乐昌公主与丈夫失散后凭借每人一半的镜子重聚，<strong>比****喻夫妻失散后重新相会。</strong>唐罗虬《比红儿诗》之五十八：<strong>“红儿若向隋朝见，破镜无因更重寻。”</strong></p><p><strong>4、烂柯</strong></p><p>任昉《述异记》讲述晋人王质上山砍柴，看见有几个小孩在下棋唱歌，过了一会儿，小孩催他回去，他发现斧头柄已全烂了。回到家，原来的人一个都不在世了。<strong>后便以“烂柯”喻离家年久。</strong></p><p>刘禹锡《酬乐天扬州初逢席上见赠》：<strong>“怀旧空吟闻笛赋，到乡翻似烂柯人。”</strong></p><p><strong>5、长城</strong></p><p>南朝将领檀道济自称为“万里长城”。后以此称<strong>能抵御敌人入侵的英雄人物。</strong>宋陆游《书愤》：<strong>“塞上长城空自许，镜中衰鬓已先斑。”</strong></p><p><strong>6、采薇</strong></p><p>殷朝末年，周武王伐殷，孤竹国国君的儿子伯夷、叔齐认为这是以臣弑君，就拦马谏阻。殷之后，两人不食周粟，隐居首阳山，采薇而食，终饿死。<strong>后以此喻隐居避世。</strong></p><p>唐王绩《野望》：<strong>“相顾无相识，长歌怀采薇。”</strong></p><p><strong>7、长亭</strong></p><p>古代驿站在路上约隔十里设一长亭，五里设一短亭，供游人休息送别。<strong>后“长亭”成为送别之地的代称。</strong></p><p>宋柳永《雨霖铃》：<strong>“寒蝉凄切，对长亭晚，骤雨初歇。”</strong></p><p><strong>8、尺素</strong></p><p>语出古乐府《饮马长城窟行》：“客从远方来，遗我双鲤鱼。呼童烹鲤鱼，中有尺素书。”后为书信代称。</p><p>宋秦观《踏莎行》：<strong>“驿寄梅花，鱼传尺素，砌成此恨无重数。”</strong></p><p><a href="https://cdn.chegva.com/ueditor/php/upload/image/20201210/1607587198735693.jpeg"><img src="https://cdn.chegva.com/ueditor/php/upload/image/20201210/1607587198735693.jpeg" alt="80个文化典故，信手拈来即文章"></a></p><p><strong>9、登高</strong></p><p>重阳有登高习俗。唐王维《九月九日忆山东兄弟》：<strong>“遥知兄弟登高处，遍插茱萸少一人。”</strong></p><p><strong>10、东山高卧</strong></p><p>东晋谢安辞官隐居东山。<strong>后指隐居。</strong>唐李白《梁园吟》：<strong>“东山高卧时起来，欲济苍生末应晚。”</strong></p><p><strong>11、杜康</strong></p><p>传说杜康发明了酒。<strong>后以此作为酒的代称。</strong>曹操《短歌行》：<strong>“何以解忧，唯有杜康。”</strong></p><p><strong>12、东篱</strong></p><p>语出东晋陶渊明“采菊东篱下，悠然见南山”。<strong>后多以“东篱”表现归隐之后的田园生活或闲雅的情致。</strong></p><p>宋李清照《醉花阴》：<strong>“东篱把酒黄昏后，有暗香盈袖。”</strong></p><p><strong>13、寒食</strong></p><p>节日名，清明节前一天或两天。</p><p>传说晋国介子推隐居山中，晋文公用烧山之法逼他出来做官，介子推不出被烧死。晋文公为纪念介子推，在其死亡之日禁止举火，只吃冷食。该节由此而来。</p><p>唐韩翃《寒食》：<strong>“****春城无处不飞花，寒食东风御柳斜。”</strong></p><p><strong>14、汗青</strong></p><p>古时字写在竹简上，先用火烧竹简，使其干燥，叫“杀青”；因烘时竹简出水如汗，故又叫“汗青”。<strong>后指书稿、史书。</strong></p><p>宋文天样《过零丁洋》：<strong>“人生自古谁无死，留取丹心照汗青。”</strong></p><p><strong>15、红豆</strong></p><p>南方的一种植物，又叫“相思子”。古人常<strong>用以象征爱情或相思。</strong>唐温庭筠《新添声杨柳枝词》之二：<strong>“玲珑骰子安红豆，入骨相思知不知？”</strong></p><p><a href="https://cdn.chegva.com/ueditor/php/upload/image/20201210/1607588223577973.jpeg"><img src="https://cdn.chegva.com/ueditor/php/upload/image/20201210/1607588223577973.jpeg" alt="80个文化典故，信手拈来即文章"></a></p><p><strong>16、画眉</strong></p><p>西汉张敞夫妻恩爱，曾为其妻画眉。<strong>后以此形容夫妻相爱。</strong>唐朱庆馀《近试上张水部》：<strong>“妆罢低声问夫婿，画眉深浅入时无？”</strong></p><p><strong>17、金乌</strong></p><p>传说太阳里有三足乌。后以“金乌”<strong>作为太阳的代称。</strong>唐韩愈《李花赠张十一署》：<strong>“金乌海底初飞来，朱辉散射青霞开。”</strong></p><p><strong>18、劳歌</strong></p><p>在劳劳亭送客时唱的歌。劳劳亭旧址在南京，<strong>是古代著名的送别之地。</strong></p><p>唐许浑《谢亭送别》：<strong>“劳歌一曲解行舟，红叶青山水急流。日暮酒醒人已远，满天风雨下西楼。”</strong></p><p><strong>19、楼兰</strong></p><p>楼兰国王贪财，多次杀害前往西域的汉使，后傅介子出使西域，计斩楼兰王。故<strong>“楼兰”常代指边境之敌。</strong></p><p>唐王昌龄《从军行》：<strong>“青海长云暗雪山，孤城遥望玉门关。黄沙百战穿金甲，不破楼兰终不还。”</strong></p><p><strong>20、梦蝶、化蝶</strong></p><p>战国时庄子有一次做梦，自己变成了蝴蝶。<strong>后比喻做梦、梦幻。</strong>后人用来借指迷惑的梦幻和变化无常的事物。</p><p>唐李商隐《无题》：<strong>“庄生晓梦迷蝴蝶，望帝春心托杜鹃。”</strong></p><p><strong>21、青鸟</strong></p><p>传说汉武帝七月七日在永华殿祭祀，忽有一只青鸟从西方飞来，东方朔说这是因为西王母要来了。<strong>后以此为传信的使者。</strong></p><p>唐李商隐《无题》：<strong>“蓬山此去无多路，青鸟殷勤为探看。”</strong></p><p><strong>22、三径</strong></p><p>西汉末，王莽专权，刺史蒋诩辞官隐居，在园里竹阴下“开三径”，只和羊仲、求仲两人相交。<strong>后以此代指隐士居住的地方。</strong></p><p>唐白居易《欲与元八卜邻先有是赠》：<strong>“明月好同三径夜，绿杨宜作两家春。”</strong></p><p><strong>23、桑榆</strong></p><p>传说太阳落在崦嵫，日影照在桑榆树上。<strong>以此比日暮，后比喻人的晚年。</strong>唐王勃《滕王阁序》：<strong>“东榆已逝，桑榆非晚。”</strong></p><p><strong>24、射天狼</strong></p><p>天狼，星名。古人以为主侵掠。后以“射天狼”<strong>比喻打击入侵的异族。</strong>宋苏轼《江城子•密州出猎》：<strong>“会挽雕弓如满月，西北望，射天狼。”</strong></p><p><a href="https://cdn.chegva.com/ueditor/php/upload/image/20201210/1607587258922402.jpeg"><img src="https://cdn.chegva.com/ueditor/php/upload/image/20201210/1607587258922402.jpeg" alt="80个文化典故，信手拈来即文章"></a></p><p><strong>25、双鲤、双鱼</strong></p><p>古人寄信，将信结成双鲤形状。古乐府《饮马长城窟行》：<strong>“客从远方来，遗我双鲤鱼。”后因此将其比作书信。</strong></p><p><strong>26、黍离</strong></p><p>语出《诗经·黍离》，东周大夫路经西周故都，见其满地禾黍，遂有宫室宗庙毁坏之叹。<strong>后以此表示对国家昔盛今衰的痛惜伤感之情。</strong></p><p>唐许浑《登洛阳故城》：<strong>“禾黍离离半野蒿，昔人城此岂知劳？”</strong></p><p><strong>27、商女</strong></p><p>语出唐杜牧《泊秦淮》：“商女不知亡国恨，隔江犹唱后庭花。”<strong>商女即歌女。</strong>后以此为不顾国家兴亡而醉生梦死的典故。</p><p>宋王安石《桂枝香》：<strong>“至今商女，时时犹唱，后庭遗曲。”</strong></p><p><strong>28、投笔</strong></p><p>东汉班超年轻时，以替宫府抄写公文为生。他曾投笔感叹，要效仿傅介子、张骞立功异域，取爵封侯。<strong>后指弃文从武。</strong></p><p>宋辛弃疾《水调歌头》：<strong>“莫学班超投笔，纵得封侯万里，憔悴老边州。”</strong></p><p><strong>29、阳关</strong></p><p>阳关，古关名，今甘肃敦煌西南。</p><p>唐王维《送元二使安西》：“劝君更尽一杯酒，西出阳关无故人。”后谱成送别之曲，名《阳关曲》。</p><p>唐李商隐《饮席戏赠同舍》：<strong>“唱尽阳关无限叠，半杯松叶冻颇黎。”</strong></p><p><strong>30、折柳</strong></p><p>汉代京城习俗，凡送远客，都要送到长安东面的霸桥，并折柳枝相赠。<strong>后指送别。</strong></p><p>唐李白《春夜洛城闻笛》：<strong>“此夜曲中闻折柳，何人不起故园情。”</strong></p><p><strong>31、折腰</strong></p><p>陶渊明因不愿为五斗米而向乡里小儿折腰，遂辞官归隐，<strong>后喻指屈身事人。</strong></p><p>唐李白《梦游天姥吟留别》：<strong>“安能摧眉折腰事权贵，使我不得开心颜。”</strong></p><p><strong>32、哀鸿</strong></p><p><strong>比喻悲伤苦痛、流离失所的人。</strong>清龚自珍《己亥杂诗》：<strong>“三更忽轸哀鸿思，九月无襦淮水湄。”</strong></p><p><a href="https://cdn.chegva.com/ueditor/php/upload/image/20201210/1607587774278861.jpeg"><img src="https://cdn.chegva.com/ueditor/php/upload/image/20201210/1607587774278861.jpeg" alt="80个文化典故，信手拈来即文章"></a></p><p><strong>33、巴歌</strong></p><p>亦称巴唱、巴讴、巴人之曲。<strong>借指鄙俗之作，多作谦辞。</strong></p><p>唐李群玉《自泮浦东游江表途出巴秋投员外从公虞》“巴歌掩白雪，鲍肆埋兰芳。”</p><p>元谢应芳《水调歌头·再和寄酬袁子英萧寺》:<strong>“多谢寄来双鲤，白雪阳春数曲，为我和巴讴。”</strong>多和“阳春白雪”比照着来写，表达自己的微不足道。</p><p><strong>34、白云苍狗</strong></p><p>亦叫白衣苍狗，<strong>比喻世事变幻无常。</strong>出自杜甫诗《可叹》:<strong>“天上浮云似白衣，斯须改变如苍狗。</strong></p><p>古往今来共一时，人生万事无不有。人事变化犹如浮云，一会儿像白云，一会儿像苍狗。</p><p><strong>35、献芹</strong></p><p>也说“芹献”。《列子·杨朱》有一个故事说，从前有个人在乡里的豪绅前大肆吹嘘芹菜如何好吃，豪绅尝了之后，竟“蜇于口，惨于腹”。<strong>后来就用“献芹”谦称赠人的礼品菲薄，或所提的建议浅陋。</strong></p><p><strong>36、抱柱</strong></p><p>相传古代尾生同一女子相约在桥下见面。他等了很久，不见女子到来，这时河水猛涨，淹没桥梁，尾生为了坚守信约，不肯离去，抱住桥柱，淹死在水里后<strong>比****喻坚守信约。</strong></p><p>唐李白《长干行》:<strong>“常存抱柱信，岂上望夫台。”</strong></p><p><strong>37、冰心、冰雪</strong></p><p>①以冰雪的晶莹比喻心志的忠贞、品格的高尚。如<strong>“洛阳亲友如相问，一片冰心在玉壶。”</strong></p><p>②高洁的心性,古人用“清如玉壶冰”。<strong>比喻一个人光明磊落的心性。</strong></p><p><strong>38、草木</strong></p><p>以草木繁盛反衬荒凉，以抒发盛衰兴亡的感伤。</p><p>宋姜夔《扬州慢》：“过春风十里,尽荠麦青青。”春风十里，十分繁华的扬州路，如今长满了青青荠麦，一片荒凉了。</p><p>“旧苑荒台杨柳新，菱歌清唱不胜春。”吴国的旧苑荒台上的杨柳又长出新枝，遥想当年这里笙歌曼舞，那盛景比春光还美。这里是以杨柳的繁茂衬托荒凉。</p><p><strong>39、婵娟</strong></p><p><strong>原指姿态美好，多用来形容女子。</strong>因人们常以美女喻月，故也称月亮为婵。宋苏轼《水调歌头》<strong>“但愿人长久，千里共婵娟。”</strong></p><p><strong>40、柳营</strong></p><p><strong>指军营，</strong>《史记》记载，汉文帝时，汉军分扎霸上、棘门、细柳以备匈奴，细柳营主将为周亚夫。周亚夫细柳营纪律严明，军容整齐，连文帝及随从也得经周亚夫许可，方可入营。<strong>后也代称纪律严明的军营。</strong></p><p>唐鲍溶《赠李黯将军》：<strong>“细柳连营石堑牢，平安狼火赤星高。”</strong></p><p><a href="https://cdn.chegva.com/ueditor/php/upload/image/20201210/1607587831102657.jpeg"><img src="https://cdn.chegva.com/ueditor/php/upload/image/20201210/1607587831102657.jpeg" alt="80个文化典故，信手拈来即文章"></a></p><p><strong>41、楚帐、楚歌</strong></p><p>《史记·项羽本纪》：“项王军壁垓下兵少食尽，汉军及诸侯兵围之数重。夜间汉军四面皆楚歌，项王乃大惊曰：‘汉皆已得楚乎？是何楚人之多也！’” <strong>喻孤军被围或处境窘迫。</strong></p><p>唐李商隐《泪》：<strong>“人去紫台秋人塞，兵残楚帐夜闻歌。”</strong></p><p><strong>42、雕虫</strong></p><p>语出汉代杨雄《法言》“童子雕虫篆刻壮夫不为也。”后来<strong>比喻微不足道的技术,多指文学技巧。</strong></p><p>唐李贺的《南园》<strong>“寻章摘句老雕虫，晓月当帘挂玉弓。不见年年辽海上，文章何处哭秋风？”</strong></p><p><strong>43、豆蔻</strong></p><p>豆蔻是一种多年生草本植物。<strong>后来称女子十三四岁的年纪为豆蔻年华。</strong>唐杜牧《赠别》:<strong>“娉娉袅袅十三余，豆蔻梢头二月初。”</strong></p><p><strong>44、风骚</strong></p><p>原指《诗经》的《国风》和《楚辞》的《离骚》，<strong>后泛指优秀的文学作品或指文采。</strong></p><p>如毛泽东《沁园春》:<strong>“秦皇汉武，略输文采；唐宗宋祖，稍逊风骚。”</strong></p><p><strong>45、古乐曲</strong></p><p>①关山月——乐府曲调，多写征戍离别之情。</p><p>如王昌龄《从军行七首》：“琵琶起舞换新声，总是关山旧别情。”</p><p>②梅花落——曲调名。</p><p>李白《与史郎中钦听黄鹤楼上吹笛》：“黄鹤楼中吹玉笛，江城五月《落梅花》。”</p><p>由《落梅花》的笛声想像梅花满天飘落的景象，再有梅花的飘落产生凛然生寒的感觉，这正与诗人当时的心境切合。这样，诗人由笛声想到梅花，由听觉诉诸视觉，以通感的方式描绘了冷落的感受。</p><p>③霓裳羽衣曲——相传是唐玄宗改变的乐舞曲，主要表现歌舞升平的景象。</p><p>唐白居易《长恨歌》：“渔阳颦鼓动起来，惊破霓裳羽衣曲。” </p><p>④后庭花——即玉树后庭花，相传是南朝后主所制的乐曲，为靡靡之音。</p><p>唐杜牧《泊秦淮》：“商女不知亡国恨，隔江犹唱后庭花。”</p><p>⑤杨柳曲——乐府曲调“杨柳枝”，有时也作“折杨柳”，主要写军旅生活，从梁、陈到唐代，多为伤别之词，以怀念征人为主。</p><p>唐王之涣《凉州词》：“羌笛何须怨杨柳，春风不度玉门关。”唐李白《塞下曲》：“笛中闻折柳，春色未曾看。”</p><p>⑥行路难——古曲，多言世路艰辛及离别伤悲之情。</p><p>唐李益《从军北正》：“天山雪后海风寒，横笛遍吹《行路难》。”</p><p>⑦高山流水——也作“流水高山”。</p><p>相传春秋时期，俞伯牙善于弹琴，钟子期善于听琴。每当伯牙弹到关于高山、流水的曲调时，钟子期就感到他的琴声犹如巍峨的高山、浩荡的江河。钟子期死后，伯牙叹无知音感知乐曲的高妙。</p><p>明唐寅《世情歌》：“清风明月用不竭，高山流水情相投。”辛弃疾《谒金门》：“流水高山弦断绝，怒蛙声自咽。”</p><p><strong>46、红叶</strong></p><p><strong>代称传情之物。</strong>朱淑真《恨春》：“碧云信断惟劳梦，红叶成诗想到秋。”</p><p>据说唐人卢渥从宫墙外水沟中拾到一片写有怨诗的红叶，后珍藏起来。宣宗放宫女嫁人，卢渥选巾的宫女，正巧就是在红叶上题诗的人。后借指以诗传情。</p><p>元高明《二郎神·秋怀》：<strong>“无情红叶偏向御沟流，诗句上分明永配偶，对景触目恨悠悠。”</strong></p><p><a href="https://cdn.chegva.com/ueditor/php/upload/image/20201210/1607587940918387.jpeg"><img src="https://cdn.chegva.com/ueditor/php/upload/image/20201210/1607587940918387.jpeg" alt="80个文化典故，信手拈来即文章"></a></p><p><strong>47、鸿鹄</strong></p><p>《史记·陈涉世家》载，秦末农民起义军领袖陈胜少有鸿鹄之志，后揭竿起义大泽乡。后来就以“鸿鹄”比喻远大志向。</p><p>宋吴潜《八声甘州》：<strong>“矫首看鸿鹄，远举高飞。”</strong></p><p><strong>48、碧血、化碧</strong></p><p>《庄子·外物》“人主莫不欲其臣之忠，而忠未必信，故伍员流于江，苌弘死于蜀，藏其血三年而化为碧玉。”</p><p>苌弘是周朝的贤臣，无辜获罪而被流放蜀地。他在蜀地自杀后，当地人用玉匣把他的血藏起来，三年后血变成了碧玉。后来也用“碧血”、“苌弘化碧”<strong>比喻刚直中正的人为正义事业而蒙冤受屈而死或忠心不泯。</strong></p><p>如《窦娥冤》<strong>“不是我窦娥发下这等无头愿，委实的冤情不浅……这就是咱苌弘化碧，望帝啼鹃。</strong>”</p><p><strong>49、杜鹃</strong></p><p>杜鹃鸟俗称布谷，又名子规、 杜宇、子鹃。春夏季节，杜鹃彻夜不停啼鸣， <strong>啼声清脆而短促，唤起人们多种情思。</strong></p><p>古代有“望帝啼鹃”的神话传说。望帝，是传说中周朝末年蜀地的君主，名叫杜宇，国亡身死，死后魂化为鸟，暮春啼苦，至于口中流血，其声哀怨凄悲，动人肺腑，名为杜鹃。李白诗云：“杨花飘落子规啼，闻道龙标过五溪。”</p><p>秦观《踏莎行》<strong>“可堪孤馆闭春寒，杜鹃声里斜阳暮。”</strong></p><p><strong>50、还珠</strong></p><p>古时合浦地盘产珍珠，可地方官员很贪，珍珠都自动移到别的地方。东汉的孟尝到这里来当太守，革除贪污流弊，珍珠又回到合浦来了。<strong>故以“还珠”喻官吏为政清廉。</strong></p><p>唐杜牧《春日言虢州李长侍十韵》：<strong>“今日还珠守,何年执戟郎？”</strong></p><p><strong>51、怀橘</strong></p><p><strong>指孝顺双亲。</strong>典故出自《三国志》“陆郎做宾客而怀橘乎？”</p><p>宋范成大《送詹道子教授祠养亲》：<strong>“下马入门怀橘拜，身今却在白云边。”</strong></p><p><strong>52、鸡黍</strong></p><p>子路随孔子出游时落了后，遇见了一位正在劳动的老人，就向他打听，由于子路的态度非常恭敬，老人就留子路住宿，还杀鸡做黍米饭厚待他。<strong>后来就用“鸡黍”专指招待客人的饭菜。</strong></p><p>唐孟浩然《过故人庄》：<strong>“故人具鸡黍，邀我至田家。”</strong></p><p><strong>53、昆山玉</strong></p><p><strong>比喻杰出的人才。</strong>唐刘禹锡《送李中赴楚州》：<strong>“忆君初得昆山玉，同向扬州携手行。”</strong></p><p><strong>54、梨园</strong></p><p>梨园原是皇帝禁苑中的果木园圃，唐玄宗开元年间，将其作为教习歌舞的地方，且在这里培养出了大批优秀的音乐舞蹈表演人才，在历史上产生了深远的影响。</p><p>后世的戏曲班社常以“梨园”为其代称，<strong>戏曲艺人称“梨园弟子”。</strong>唐白居易《长恨歌》：<strong>“梨园子弟白发新，椒房阿监青娥老。”</strong></p><p><strong>55、柳岸</strong></p><p>古人送别有折柳的习惯，<strong>后来就用“柳岸”指送别的地方。</strong>宋柳永《雨霖铃》：<strong>“今宵酒醒何处？杨柳岸，晓风残月。”</strong></p><p><strong>56、南浦</strong></p><p>指在水边送别。屈原《九歌·河伯》：“与子交手兮东行，送美人兮南浦。”<strong>“南浦”指南面的水滨，古人常在南浦送别亲友，后来常用来代指送别地。</strong></p><p>宋范成大《横塘》：<strong>“南浦春来绿一川，石桥朱塔两依然。”</strong></p><p><strong>57、南冠</strong></p><p><strong>指囚犯。</strong>如骆宾王《在狱咏蝉》：<strong>“西陆蝉声响，南冠客思深。”</strong>唐李白《留夜郎闻不预》：“北阙圣人歌太康，南冠君子窜遐荒。”</p><p><strong>58、青梅竹马</strong></p><p>出自李白的《长干行》：“郎骑竹马来，绕床弄青梅。同居长千里，两小无嫌猜。”<strong>形容男女小时候天真无邪，也指幼小时就相识的伴侣。</strong></p><p><strong>59、青眼</strong></p><p>相传三国魏的名仕阮籍，能为青白眼， 对所憎恶的眼，眼睛向上或向旁边看，表示轻视或憎恨；对喜爱或尊敬的人，就对他正视，青黑的眼珠在中间，表示尊重。</p><p>他见到嵇康的哥哥嵇喜，就以白眼相待，见到嵇康就用青眼，<strong>后以“青眼”指对人喜爱或器重。</strong></p><p>杜甫《短歌行》中：<strong>“仲宣楼头春色深，青眼高歌望吾子。”</strong></p><p><strong>60、请缨</strong></p><p>汉武帝派年轻的近臣终军到南越劝说南越王朝。终军说：“请给一根长缨，我一定把南越王抓来。”<strong>后比喻杀敌报国。</strong></p><p>宋岳飞《满江红·遥望中原》：<strong>“叹江山如故，千村落寥。何日请缨提锐旅，一鞭直渡清河洛。”</strong></p><p><strong>61、秦晋</strong></p><p>春秋时，<strong>秦国和晋国联姻，后因称两姓联姻为“秦晋之好”。</strong>《西厢记》第二本第一折：<strong>“倒赔家门，情愿与英雄结婚姻，成秦晋。”</strong></p><p><strong>62、琴瑟</strong></p><p><strong>比喻夫妻感情和谐，</strong>《诗经》“窈窕淑女，琴瑟友之。”<strong>也比喻兄弟朋友的情谊，</strong>陈子昂《春夜别友人诗》：<strong>“离堂思琴瑟，别路绕山川。”</strong></p><p><strong>63、问鼎</strong></p><p>春秋时，楚庄王北伐，陈兵洛水，向周王朝炫耀武力。周定王派王孙满慰劳楚师，楚庄王向王孙满询问周朝的传国之宝九鼎的大小和轻重。<strong>后遂意“问鼎”比喻篡夺政权，今常比喻谋求夺得。</strong></p><p><strong>64、五柳</strong></p><p>陶渊明《五柳先生传》：<strong>“宅边有五柳树，因以为号焉。”后来，五柳成了隐者的代称。</strong></p><p><strong>65、吴钩</strong></p><p>泛指宝刀、利剑。辛弃疾《水龙吟·登建康赏心亭》：<strong>“把吴钩看了，栏杆拍遍，无人会，登临意。”</strong></p><p><strong>通过看吴钩、拍栏杆，表达了自己意欲投效祖国、建功立业，而又无人领会的诗意情怀。</strong></p><p><strong>66、谢家</strong></p><p>在诗词里常用“谢家”做典故，意思也不尽相同。</p><p>①用谢安、谢玄家事，意指人有风度。</p><p>《世说新语·言语》载，谢安曾问子侄：为什么人们总希望自己的子弟好？侄子谢玄回答说：“譬如芝兰玉树，欲使其生于阶庭耳。”</p><p>这是说，谢安子弟讲究举止风度，其服饰端庄大方如芝兰玉树一般。故用其事指有风度的人。</p><p>宋辛弃疾《沁园春·叠嶂西驰》:“似谢家子弟，衣冠磊落相如庭户，车骑雍容。”</p><p>②指山水诗人谢灵运之事。《宋书·谢灵运传》载：灵运于会稽山“修营别业，傍山带江，尽幽居之美”。后用此事指居家的幽美。</p><p><strong>67、阳关</strong></p><p>阳关，古关名，今甘肃敦煌西南。</p><p>唐王维《送元二使安西》:<strong>“劝君更尽一杯酒，西出阳关无故人。”后谱成送别之曲，名《阳关曲》。</strong></p><p>唐李商隐《饮席戏赠同舍》:“唱尽阳关无限叠,半杯松叶冻颇黎。”</p><p><strong>68、执牛耳</strong></p><p>古代诸侯订立盟约，要每人尝一口牲血，立盟的人亲自割牛耳取血，故用“执牛耳”指盟主。</p><p>在《左传》记载：<strong>“诸侯盟，谁执牛耳？”后常指在某一方面居领导地位。</strong></p><p><strong>69、北辰</strong></p><p><strong>原指北极星。</strong>《尔雅》中说：“北极谓之北辰。”后用来喻指国君或受尊崇的人，也指帝都，如王勃《滕王阁序》：<strong>“地势极而南溟深，天柱高而北辰远。”</strong></p><p><strong>70、莼鲈之思</strong></p><p><strong>指家乡风味，</strong>典出《晋书·张翰传》：“翰因秋风起，乃恩吴中菰菜、莼羹、鲈鱼脍，曰‘人生贵得适志尔，何能羁宦效千里以要名爵’遵命驾便归。”</p><p>后来的人将思念家乡、弃官归隐成为莼鲈之思。张翰字季鹰，故辛弃疾《水龙吟·登建康赏心亭》云；“休说鲈鱼堪脍，尽西风，季鹰归未？”</p><p><strong>71、辞第</strong></p><p>典故名，典出《史记·卫将军骠骑列传》。霍去病辞去君王赏赐的宅第。</p><p>表现了霍去病“匈奴未灭，何以家为”的名将风度和以国家为重的爱国思想。<strong>后又以“辞第”比喻为国忘家的爱国精神。</strong></p><p>唐杜甫《奉和严中丞西城晚眺十韵》：<strong>“辞第输高义，观图忆古人。”</strong></p><p><strong>72、鸡口牛后</strong></p><p>《战国策》：“宁为鸡口，无为牛后。”<strong>比喻宁愿在局面小的地方当家做主，不愿在局面大的地方任人支配。</strong></p><p><a href="https://cdn.chegva.com/ueditor/php/upload/image/20201210/1607588118803221.jpeg"><img src="https://cdn.chegva.com/ueditor/php/upload/image/20201210/1607588118803221.jpeg" alt="80个文化典故，信手拈来即文章"></a></p><p><strong>73、岁寒三友</strong></p><p>指<strong>松、竹、梅</strong>。松、竹经冬不凋，梅则耐寒开花，故有“岁寒三友”之称。</p><p><strong>74、秋水</strong></p><p><strong>喻指眼睛，形容盼望迫切。</strong>《西厢记》第三本第二折：<strong>“望穿他盈盈秋水，蹙损他淡淡春山。”春山，指眉眼。</strong></p><p><strong>75、三尺</strong></p><p>①代指法律，古代把法律写在三尺长的竹简上，所以称“三尺法”。</p><p>②指剑，剑长约三尺，故用来代称剑。《汉书》：“<strong>吾以布衣提三尺，取天下。</strong>”</p><p><strong>76、神器</strong></p><p><strong>指帝位、政权。</strong>《老子》：“将欲取天下而为之，吾见其不得已。天下神器，不可为也。”</p><p><strong>77、青衿</strong></p><p>语出《诗经·郑风·子衿》：“青青子衿，悠悠我心。”毛传：“青衿，青领也，学子之所服。”因此用它指读书人。</p><p>唐杜甫《折槛行》：“青衿胄子困泥涂，白马将军若雷屯。”<strong>也可作为贤士的代称。</strong></p><p><strong>78、陶朱</strong></p><p>春秋时期越国大夫范蠡的别号。相传他帮主勾践灭吴后，离开越国到陶，善于经营生计，积累了很多财富，<strong>后世因此用陶朱公或陶朱来代指富商。</strong></p><p><strong>79、咏絮才</strong></p><p>东晋谢道韫曾以“未若柳絮因风起”之句来比拟雪花飞舞，叔父谢安大为赞赏。后以“咏絮”或“咏絮才”称女子善于吟咏。</p><p>如《红楼梦》第五回“可叹停机德，谁怜咏絮才。”中，<strong>咏絮才指的就是林黛玉非凡的吟诗才华。</strong></p><p><strong>80、逐鹿</strong></p><p>《汉书》：“秦失其鹿，天下共逐之。”颜师古注引张晏曰：“以鹿喻帝位。”<strong>后来用逐鹿比喻群雄并起，争夺天下。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 文学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 典故 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欧阳修朋党论</title>
      <link href="/archives/fb91f846.html"/>
      <url>/archives/fb91f846.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="欧阳修《朋党论》"><a href="#欧阳修《朋党论》" class="headerlink" title="欧阳修《朋党论》"></a>欧阳修《朋党论》</h1><p><a href="https://cdn.chegva.com/ueditor/php/upload/image/20220610/1654865603213677.jpeg"><img src="https://cdn.chegva.com/ueditor/php/upload/image/20220610/1654865603213677.jpeg" alt="欧阳修《朋党论》"></a></p><h4 id><a href="#" class="headerlink" title="** **"></a>** **</h4><h4 id="◎欧阳修简介"><a href="#◎欧阳修简介" class="headerlink" title="◎欧阳修简介"></a><strong>◎欧阳修简介</strong></h4><p><strong>欧阳修</strong>（1007年8月6日－1072年9月22日），字永叔，号醉翁、六一居士，谥号文忠。籍贯吉州庐陵（今江西省吉安市），生于绵州（今四川绵阳），北宋时期文学家、史学家、政治家。欧阳修于宋仁宗天圣八年（1030年）以<a href="https://baike.baidu.com/item/%E8%BF%9B%E5%A3%AB%E5%8F%8A%E7%AC%AC/4339334">进士及第</a>，历仕<a href="https://zh.wikipedia.org/wiki/%E5%AE%8B%E4%BB%81%E5%AE%97">仁宗</a>、<a href="https://zh.wikipedia.org/wiki/%E5%AE%8B%E8%8B%B1%E5%AE%97">英宗</a>、<a href="https://zh.wikipedia.org/wiki/%E5%AE%8B%E7%A5%9E%E5%AE%97">神宗</a>三朝，官至<a href="https://zh.wikipedia.org/wiki/%E7%BF%B0%E6%9E%97%E5%AD%A6%E5%A3%AB">翰林学士</a>、<a href="https://zh.wikipedia.org/wiki/%E6%9E%A2%E5%AF%86%E5%89%AF%E4%BD%BF">枢密副使</a>、<a href="https://zh.wikipedia.org/wiki/%E5%8F%83%E7%9F%A5%E6%94%BF%E4%BA%8B">参知政事</a>，曾积极参与<a href="https://zh.wikipedia.org/wiki/%E8%8C%83%E4%BB%B2%E6%B7%B9">范仲淹</a>所领导的<a href="https://zh.wikipedia.org/wiki/%E6%85%B6%E6%9B%86%E6%96%B0%E6%94%BF">庆历新政</a>政治改革。死后累赠太师、楚国公，谥号“文忠”，故世称欧阳文忠公。</p><p>文学方面，欧阳修成就斐然，是唐代<a href="https://zh.wikipedia.org/wiki/%E9%9F%93%E6%84%88">韩愈</a>、<a href="https://zh.wikipedia.org/wiki/%E6%9F%B3%E5%AE%97%E5%85%83">柳宗元</a>所倡导之<a href="https://zh.wikipedia.org/wiki/%E5%8F%A4%E6%96%87%E8%BF%90%E5%8A%A8">古文运动</a>的继承者及推动者，为古文发展作出了巨大贡献。其散文风格平易自然，韵味深美，诗歌风格平易清新，为宋诗奠下基础，其辞赋创立文赋的新体裁，使中国辞赋有柳暗花明的新发展，所著两部史书《<a href="https://zh.wikipedia.org/wiki/%E6%96%B0%E5%94%90%E6%9B%B8">新唐书</a>》及《<a href="https://zh.wikipedia.org/wiki/%E6%96%B0%E4%BA%94%E4%BB%A3%E5%8F%B2">新五代史</a>》列入<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8D%81%E5%9B%9B%E5%8F%B2">廿四部</a><a href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%8F%B2">正史</a>之中，所定家谱格式为后世历代沿用，经学上开创宋人直接解经、不依注疏的新风气，易学上打破易传的权威地位，在中国金石学、诗话及花谱撰作三方面，都是开山始祖。政治上文化上，皆属当世最高领袖之一，在文学、史学、经学，俱有划时代的成就。</p><p>1072年9月22日，欧阳修在家中逝世，享年六十六岁。</p><h4 id="◎创作背景"><a href="#◎创作背景" class="headerlink" title="◎创作背景"></a><strong>◎创作背景</strong></h4><p>《朋党论》选自《欧阳文忠集》，是北宋大文学家欧阳修于宋仁宗庆历三年(1043)所写的一封奏章，是一篇很有名的政论散文。</p><p>宋仁宗景祐三年(1036)，以吏部员外郎任开封知府的范仲淹因上《百官图》，讥刺权相吕夷简，被吕指为朋党，遭到贬谪。当时涉世未深、血性方刚的欧阳修写了《与高司谏书》，为范辩护，亦被称为朋党，同时被贬。庆历三年，吕夷简罢相。杜衍掌政，起用富弼、范仲淹、韩琦等人，推行以“明黜陟、抑侥幸、精贡举、择官长、均公田”等十项改革措施，称为“庆历新政”。这些政治改革措施遭到夏竦、王拱辰等保守势力的反对，他们攻击杜衍、范仲淹等人引用朋党。欧阳修因积极支持新政，也被保守派列入朋党之内。为回击这些诬蔑，欧阳修写了这篇著名的政论文。</p><h4 id="◎正文"><a href="#◎正文" class="headerlink" title="◎正文"></a><strong>◎正文</strong></h4><p>臣闻朋党之说，自古有之，惟幸人君辨其君子小人而已。大凡君子与君子，以同道为朋; 小人与小人，以同利为朋。此自然之理也。</p><p>然臣谓小人无朋，惟君子则有之。其故何哉?小人所好者利禄也，所贪者财货也。当其同利之时，暂相党引以为朋者，伪也。及其见利而争先，或利尽而交疏，则反相贼害，虽其兄弟亲戚，不能相保。故臣谓小人无朋，其暂为朋者，伪也。君子则不然。所守者道义，所行者忠信，所惜者名节。以之修身，则同道而相益; 以之事国，则同心而共济; 终始如一，此君子之朋也。故为人君者，但当退小人之伪朋，用君子之真朋，则天下治矣。</p><p>尧之时，小人共工、驩兜等四人为一朋，君子八元、八恺十六人为一朋。舜佐尧，退四凶小人之朋，而进元、恺君子之朋，尧之天下大治。及舜自为天子，而皋、夔、稷、契等二十二人，并列于朝，更相称美，更相推让，凡二十二人为一朋，为舜皆用之，天下亦大治。</p><p>《书》曰： “纣有臣亿万，惟亿万心; 周有臣三千，惟一心。”纣之时，亿万人各异心，可谓不为朋矣，然纣以亡国。周武王之臣三千人为一大朋，而周用以兴。</p><p>后汉献帝时，尽取天下名士囚禁之，目为党人。及黄巾贼起，汉室大乱，后方悔悟，尽解党人而释之，然已无救矣。</p><p>唐之晚年，渐起朋党之论。及昭宗时，尽杀朝之名士，或投之黄河，曰： “此辈清流，可投浊流。”而唐遂亡矣。</p><p>夫前世之主，能使人人异心不为朋，莫如纣?能禁绝善人为朋，莫如汉献帝; 能诛戮清流之朋，莫如唐昭宗之世。然皆乱亡其国。更相称美推让而不自疑，莫如舜之二十二臣，舜亦不疑而皆用之。然而后世不诮舜为二十二人朋党所欺，而称舜为聪明之圣者，以能辨君子与小人也。周武之世，举其国之臣三千人共为一朋。自古为朋之多且大，莫如周。然周用此以兴者，善人虽多而不厌也。</p><p>夫兴亡治乱之迹，为人君者，可以鉴矣!</p>]]></content>
      
      
      <categories>
          
          <category> 文学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摘录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>鲁迅经典语录大全</title>
      <link href="/archives/be642688.html"/>
      <url>/archives/be642688.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://cdn.chegva.com/ueditor/php/upload/image/20220529/1653833722636274.jpeg"><img src="https://cdn.chegva.com/ueditor/php/upload/image/20220529/1653833722636274.jpeg" alt="鲁迅经典语录大全"></a></p><p><strong>鲁迅（1881年9月25日－1936年10月19日）</strong>，曾用名周樟寿，后改名周树人，字豫山，后改豫才，曾留学日本仙台医科专门学校（肄业）。“鲁迅”是他1918年发表《狂人日记》时所用的笔名，也是他影响最为广泛的笔名，浙江绍兴人。著名文学家、思想家、民主战士，五四新文化运动的重要参与者，<a href="https://zh.wikipedia.org/wiki/%E6%96%B0%E6%96%87%E5%8C%96%E8%BF%90%E5%8A%A8">新文化运动</a>领袖之一。鲁迅一生在文学创作、文学批评、思想研究、文学史研究、翻译、美术理论引进、基础科学介绍和古籍校勘与研究等多个领域具有重大贡献。他对于<a href="https://zh.wikipedia.org/wiki/%E4%BA%94%E5%9B%9B%E8%BF%90%E5%8A%A8">五四运动</a>以后的中国社会思想文化发展具有重大影响，蜚声世界文坛，尤其在韩国、日本思想文化领域有极其重要的地位和影响，韩国文学评论家金良守称他为“二十世纪东亚文化地图上占最大领土的作家”，鲁迅在中国有“民族魂”之称。</p><p>◎ <a href="https://baike.baidu.com/item/%E9%B2%81%E8%BF%85/36231">百度百科：鲁迅</a> | <a href="https://zh.wikipedia.org/wiki/%E9%B2%81%E8%BF%85">维基百科：鲁迅</a></p><hr><p><a href="https://cdn.chegva.com/ueditor/php/upload/image/20220529/1653834050133791.jpeg"><img src="https://cdn.chegva.com/ueditor/php/upload/image/20220529/1653834050133791.jpeg" alt="鲁迅经典语录大全"></a></p><p>\1. 什么是路？就是从没有路的地方践踏出来的，从只有荆棘的地方开辟出来的</p><p>\2. 横眉冷对千夫指，俯首甘为孺子牛。</p><p>\3. 不在沉默中爆发，就在沉默中死亡。</p><p>\4. 倘能生存，我当然仍要学习。</p><p>\5. 墨写的谎言掩盖不了血写的事实。</p><p>\6. 从来如此，便对么？</p><p>\7. 其实，以文笔做生活，是世上最苦的职业。</p><p>\8. 书看多了，文章自然就会写了。</p><p>\9. 时间就是性命。无端的空耗别人的时间，其实是无异于谋财害命的。</p><p>\10. 时间对于我来说是很宝贵的，用经济学的眼光看是一种财富。</p><p>\11. 时间，就象海棉里的水，只要愿挤，总还是有的。</p><p>\12. 人生得一知已足矣，斯世当以同怀视之。</p><p>\13. 愿中国青年都摆脱冷气，只是向上走，不必听自暴自弃者流的话。能做事的做事，能发声的发声。有一分热，发一分光。就令萤火一般，也可以在黑暗里发一点光，不必等候炬火。</p><p>\14. 从喷泉里出来的都是水，从血管里出来的都是血。</p><p>\15. 勇者愤怒，抽刃向更强者；怯者愤怒，却抽刃向更弱者。</p><p>\16. 无论她有多大错，她哭的一霎那，都是我的错。</p><p>\17. 猛兽总是独行，牛羊才成群结队。</p><p>\18. 面具戴太久，就会长到脸上，再想揭下来，除非伤筋动骨扒皮。</p><p>\19. 当我沉默的时候，我觉得很充实，当我开口说话，就感到了空虚。</p><p>\20. 友谊是两颗心真诚相待，而不是一颗心对另一颗心的敲打。</p><p>\21. 悲剧将人生的有价值的东西毁灭给人看，喜剧将那无价值的撕破给人看。</p><p>\22. 贪安稳就没有自由，要自由就要历些危险。只有这两条路。</p><p>\23. 其实地上本没有路，走的人多了，也便成了路。</p><p>\24. 中国人的性情是总喜欢调和折中的，譬如你说，这屋子太暗，须在这里开一个窗，大家一定不允许的。但如果你主张拆掉屋顶他们就来调和，愿意开窗了。</p><p>\25. 哀其不幸，怒其不争。</p><p>\26. 伟大的心胸，应该表现出这样的气概——用笑脸来迎接悲惨的厄运，用百倍的勇气来应付一切的不幸。</p><p>\27. 一见短袖子，立刻想到白臂膊，立刻想到全裸体，立刻想到生殖器，立刻想到性交，立刻想到杂交，立刻想到私生子。中国人的想象唯在这一层能够如此跃进。</p><p>\28. 度尽劫波兄弟在，相逢一笑泯恩仇。</p><p>\29. 卑怯的人，即使有万丈的怒火，除弱草以外，又能烧掉什么呢？</p><p>\30. 岂有豪情似旧时,花开花落两由之。</p><p>\31. 待我成尘时，你将见我的微笑。</p><p>\32. 死者倘不埋在活人的心中,那就真的死掉了</p><p>\33. 我翻开历史一查，这历史没有年代。歪歪斜斜的每页上都写着“仁义道德”几个字，我横竖睡不着，仔细看了半夜，才从字缝里看出来，满本上都写着两个字“吃人’！</p><p>\34. 怀疑并不是缺点。总是疑，而并不下断语，这才是缺点。</p><p>\35. 上人生的旅途罢。前途很远，也很暗。然而不要怕。不怕的人的面前才有路。</p><p>\36. 必须敢于正视，这才可望敢想敢说敢做敢当。</p><p>\37. 时间，每天得到的都是二十四小时，可是一天的时间给勤勉的人带来智慧和力量，给懒散的人只留下一片悔恨。</p><p>\38. 如果一个人没有能力帮助他所爱的人，最好不要随便谈什么爱与不爱。当然，帮助不等于爱情，但爱情不能不包括帮助。</p><p>\39. 血沃中原肥劲草，寒凝大地发春华。——《无题》</p><p>\40. 寄意寒星荃不察，我以我血荐轩辕。——《自题小像》</p><p>\41. 忍看朋辈成新鬼，怒向刀丛觅小诗。——《为了忘却的纪念》</p><p>\42. 无情未必真豪杰，怜子如何不丈夫，知否兴风狂啸者，回眸时看小於菟。</p><p>\43. 凡事总须研究，才会明白。——《狂人日记》</p><p>\44. 杀了’现在’，也便杀了’将来’。——将来是子孙的时代。</p><p>\45. 发思古之幽情，往往为了现在。</p><p>\46. 人生最苦痛的是梦醒了无路可走。做梦的人是幸福的；倘没有看出可走的路，最要紧的是不要去惊醒他。</p><p>\47. 自由固不是钱所能买到的，但能够为钱而卖掉</p><p>\48. 事实是毫无情面的东西，它能够将空言打得粉碎</p><p>\49. 一个人做到只剩了回忆的时候，生涯大概总要算是无聊了吧，但有时竟会连回忆也没有。</p><p>\50. 有些人毕生所追求的东西往往是另一些人与生就俱来的东西。而当人生将走到尽头时,也许必生追求的人得到了所渴望的,而与生俱来的人却失去了他们仅有的。</p><p><a href="https://cdn.chegva.com/ueditor/php/upload/image/20220529/1653834132125434.jpeg"><img src="https://cdn.chegva.com/ueditor/php/upload/image/20220529/1653834132125434.jpeg" alt="鲁迅经典语录大全"></a></p><p>\51. 在人人说假话的年代讲真话；在人人麻木的年代拥有充实的心灵。</p><p>\52. 没有思索和悲哀，就不会有文学</p><p>\53. 群众，——尤其是中国的，——永远是戏剧的看客。</p><p>\54. 有缺点的战士终竟是战士，完美的苍蝇也终竟不过是苍蝇</p><p>\55. 我每看运动会时，常常这样想：优胜者固然可敬，但那虽然落后而仍非跑至终点不止的竞技者和见了这样的竞技者肃然不笑的看客，乃正是中国将来的脊梁。</p><p>\56. 做奴隶虽然不幸，但并不可怕，因为知道挣扎，毕竟还有挣脱的希望；若是从奴隶生活中寻出美来，赞叹陶醉，就是万劫不复的奴才了。</p><p>\57. 我以为就是圣贤豪杰，也不必自惭他的童年，自惭，倒是一个错误。</p><p>\58. 诚信为人之本。</p><p>\59. 倘若说，作品愈高，知音愈少，那么，推论起来，谁也不懂的东西，就是世界上的绝作了。</p><p>\60. 使一个人的有限的生命，更加有效，也即等于延长了人的生命。</p><p>\61. 要在文化上有成绩，则非韧不可。</p><p>\62. 时间就像海绵里的水，只要愿挤，总还是有的。</p><p>\63. 经历一多，便能从前因而知后果，我的预测时时有验，只不过由此一端。</p><p>\64. 哪里有天才，我是把别人喝咖啡的工夫都用在了工作上了。</p><p>\65. 不孝的人是世界最可恶的人。</p><p>\66. 惟沉默是最高的轻蔑。</p><p>\67. 面具戴太久，就会长到脸上，再想揭下来，除非伤筋动骨扒皮。</p><p>\68. 不满是向上的车轮，能够载着不自满的人类，向人道前进。</p><p>\69. 多有不自满的人的种族，永远前进，永远有希望。</p><p>\70. 多有只知责人不知反省的人的种族，祸哉祸哉！</p><p>\71. 当我沉默的时候，我觉得很充实，当我开口说话，就感到了空虚。</p><p>\72. 面具戴太久，就会长到脸上，再想揭下来，除非伤筋动骨扒皮。</p><p>\73. 哀其不幸，怒其不争。</p><p>\74. 金子做了骨髓，也还是站不直。</p><p>\75. 希望是附丽于存在的，有存在，便有希望，有希望，便是光明。</p><p>\76. 我自爱我的野草，但我憎恶这以野草作装饰的地面。</p><p>\77. 正如逆水行舟，无论怎样看风看水，目的只有一个一一向前。</p><p>\78. 只要能培一朵花，就不妨做做会朽的腐土。</p><p>\79. 人生最苦痛的是梦醒了无路可走。</p><p>\80. 杀了现在，也便杀了将来。</p><p>\81. 以无赖的手段对付无赖，以流氓的手段对付流氓。</p><p>\82. 我们先前比你阔多啦，你算是什么东西！</p><p>\83. 人世间真是难处的地方，说一个人“不通世故”，固然不是好话，但说他“深于世故”，也不是好话。</p><p>\84. 谦以待人，虚以接物。</p><p>\85. 不惮以最坏的恶意来推测中国人。</p><p>\86. 保持友谊的最好办法就是任何事情也不假手于他，同时也不借钱给他。</p><p>\87. 其实先驱者本是容易变成绊脚石的。</p><p>\88. 游戏是儿童最正当的行为，玩具是儿童的天使。</p><p>\89. 新年对我来说，就是离死亡又近了一年。</p><p>\90. 伟大人格的素质，重要的是一个诚字。</p><p>\91. 浪费时间等于是慢性自杀。</p><p>\92. 教育植根于爱。</p><p>\93. 自卑和自负都不是很好，最好的办法的成不骄败不馁。</p><p>\94. 无论什么事，如果不断收集材料，积之十年，总可成一学者。</p><p>\95. 我又愿中国青年只是向上走，不必理会这冷笑和暗箭。</p><p>\96. 敌人是不足惧的，最可怕的是自己营垒里的蛀虫，许多事情都败在他们手里。</p><p>\97. 怀疑并不是缺点，总是疑，而并不下断语，这才是缺点。</p><p>\98. 无论如何，流言总不能吓哑我的。</p><p>\99. 即使慢，驰而不息，纵会落后，纵会失败，但一定可以达到他所向的目标。</p><p>\100. 损着别人的牙眼，却反对报复，主张宽容的人，万勿和他接近。</p><p><a href="https://cdn.chegva.com/ueditor/php/upload/image/20220529/1653834307598174.png"><img src="https://cdn.chegva.com/ueditor/php/upload/image/20220529/1653834307598174.png" alt="鲁迅经典语录大全"></a></p><p>\101. 虽生之日，犹死之年。</p><p>\102. 生活太安逸了，工作就会被生活所累。</p><p>\103. 天才可贵，培养天才的泥土更可贵。</p><p>\104. 真的猛士，敢于直面惨淡的人生，敢于正视淋漓的鲜血。</p><p>\105. 要竭力将可有可无的字句段删去，毫不可惜。</p><p>\106. 我好像是一只牛，吃的是草，挤出的是奶。</p><p>\107. 倘有陌生的声音叫你的名字，你万不可答应它。</p><p>\108. 有时候仍不免呐喊几声，聊以慰藉那在寂寞里奔驰的猛士，使他不惮于前驱。</p><p>\109. 没有思索和悲哀，就不会有文学。</p><p>\110. 一碗酸辣汤，耳闻口讲的，总不如亲自呷一口的明白。</p><p>\111. 弄文学的人，只要一坚韧，二认真，三韧长，就可以了</p><p>\112. 删掉枝叶的人，决定得不到花果。</p><p>\113. 不知怎地我们便都笑起来，是互相的嘲弄和悲哀。</p><p>\114. 一滴水，用显微镜看，也是一个大世界。</p><p>\115. 旧朋云散尽，余亦等轻尘。</p><p>\116. 我的确时时解剖别人，然而更多的是更无情面地解剖我自己。</p><p>\117. 小的时候，不把他当人，大了以后也做不了人。</p><p>\118. 苛求君子，宽纵小人，自以为明察秋毫，而实则反助小人张目。</p><p>\119. 中国人越是懦夫越会欺负比自己更加弱小的人群。</p><p>\120. 没有艺术手段，没有锋利的文笔，没有幽默，没有图景，就没有小品。</p><p>\121. 咀嚼一己小小的悲欢，并视之为大世界。</p><p>\122. 世间本无路，走的人多了，也就成了路。</p><p>\123. 唾沫还是静静的咽下去好，免得后来自己舐回去。</p><p>\124. 不能只为了爱——盲目的爱，——而将别的人生的要义全盘疏忽了。</p><p>\125. 人何必增添末路的人的苦恼。</p><p>\126. 我们要感谢第一个吃螃蟹的人，也感谢第一个被吃的螃蟹。</p><p>\127. 小市民总爱听人们的丑闻，尤其是有些熟识人的丑闻。</p><p>\128. 梦里依稀慈母泪，城头变幻大王旗。</p><p>\129. 全然忘却，毫无怨恨，又有什么宽恕可言呢？无怨的恕，说谎罢了。</p><p>\130. 一个人如果不活在别人心里，那他就真的死了。</p><p>\131. 生活如花，姹紫嫣红。</p><p>\132. 奴才总不过是寻人诉苦，只要这样，也只能这样。</p><p>\133. 精诚无间同忧乐，笃爱有缘共死生。</p><p>\134. 我姑且举黑灰的手装作喝干一杯酒，我将在不知道时候的时候独自远行。</p><p>\135. “一劳永逸”的话，有是有的，而“一劳永逸”的事却极少……</p><p>\136. 灵台无计逃神矢，风雨如磐暗故园，寄意寒星荃不察，我以我血荐轩辕。</p><p>\137. 可是我实在无话可说，我只觉得所住的并非人间。</p><p>\138. 文学史上，我没有见过用阴谋除去了文学上的敌手，便成为文豪的人。</p><p>\139. 我本来也无可尊敬，也不愿受人尊敬，免得不如人意的时候，又被人摔下来。</p><p>\140. 抉心自食，欲知本味，创痛酷烈，本味何能知。</p><p>\141. 把酒论天下，先生小酒人，大圜犹酩酊，微醉合沉沦。</p><p>\142. 投机取巧或能胜利于一时，终难立足于世界。</p><p>\143. 婚姻中最折磨人的，并非冲突，而是厌倦。</p><p>\144. 万家墨面没蒿莱，敢有歌吟动地哀，心事浩芒连广宇，于无声处听惊雷。</p><p>\145. 奢侈和淫靡只是一种社会崩溃腐化的现象，决不是原因。</p><p>\146. 做人处世的法子，恐怕要自己斟酌，许多别人开来的良方，往往不过是废纸。</p><p>\147. 写不出的时候不硬写。</p><p>\148. 我的心分外地寂寞，然而我的心很平安：没有爱憎，没有哀乐，也没有颜色和声音。</p><p>\149. 社会上崇敬名人，于是以为名人的话就是名言，却忘记了他所以得名是那一种学问和事业。</p><p>\150. 中国人是一向被同族屠戮奴隶敲掠刑辱压迫下来的，非人类所能忍受的楚痛，也都身受过，每一考查，真教人觉得不像活在人间。</p><p><a href="https://cdn.chegva.com/ueditor/php/upload/image/20220529/1653834528770664.jpeg"><img src="https://cdn.chegva.com/ueditor/php/upload/image/20220529/1653834528770664.jpeg" alt="鲁迅经典语录大全"></a></p><p>\151. 即使天才，在生下来的时候的第一声啼哭，也和平常的儿童一样，决不会就是一首好诗。因为幼稚，当头加以件戕贼，也可以萎死的。</p><p>\152. 谎语当然也是一个空虚，然而临末，至多也不过这样的沉重。</p><p>\153. 要极省俭的画出一个人的特点，最好是画他的眼睛。</p><p>\154. 读死书是害己，一开口就害人；但不读书也并不见得好。</p><p>\155. 人们因为能忘却，所以自己能渐渐的脱离了受过的苦痛，也因为能忘却，所以照样得再犯前人的错误。</p><p>\156. 三种人对待钱的态度：曾经有钱的人想复古，现在有钱的人想维持现状；现在没钱的人想改革。</p><p>\157. 学习专看文学书，也是不好的，先前的文学青年，往往厌恶数学理化史地生物学，以为这些都无足轻重，后来变成连常识也没有。</p><p>\158. 希望本无所谓有，也无所谓无，这就像地上的路，其实地上本没有路，走的人多了，也便成了路。</p><p>\159. 我们中国人对于不是自己的东西，或者将不为自己所有的东西，总要破坏了才快活的。</p><p>\160. 我常想在纷扰中寻出一点闲静来，然而委实不容易，目前是这么离奇，心里是这么芜杂，一个人做到只剩了回忆的时候，生涯大概总要算是无聊了罢，但有时竟会连回忆也没有。</p><p>\161. 只看一个人的著作，结果是不大好的：你就得不到多方面的优点，必须如蜜蜂一样，采过许多花，这才能酿出蜜来，倘若叮在一处，所得就非常有限，枯燥了。</p><p>\162. 天空一碧如洗，灿烂的阳光正从密密的松针的缝隙间射下来，形成一束束粗粗细细的光柱，把飘荡着轻纱般薄雾的林荫照的通亮。</p><p>\163. 凡是精神愚昧的国民纵使体格如何强健，也只能沦为毫无意义的示众的材料和无知的看客罢了。</p><p>\164. 倘只看书，便变成书橱。</p><p>\165. 天才并不是自生自长在深林荒野里的怪物，是由可以使天才生长的民众产生，长育出来的，所以没有这种民众，就没有天才。所以我想，在要求天才的产生之前，应该先要求可以使天才生长的民众。——譬如想有乔木，想看好花，一定要有好土；没有土，便没有花木了；所以土实在较花木还重要。</p><p>\166. 中国自古以来，就在埋头苦干的人，就有拼命硬干的人，就有为民请命的人，就有舍身求法的人。——他们是中国的脊梁。</p><p>\167. 有地方特色，倒容易成为世界的。即为被别国所注意。</p><p>\168. 哈儿狗往往比它的主人更严厉。</p><p>\169. 明言着轻蔑什么人，并不是十足的轻蔑。</p><p>\170. 惟沉默是最高的轻蔑一一最高的轻蔑是无言，而且连眼珠也不转过去。</p><p>\171. 只要能培一朵花，就不妨做做会朽的腐草。</p><p>\172. 当我沉默的时候，我觉得充实；我将开口，同时感到空虚。</p><p>\173. 我自爱我的野草，但我憎恶这以野草作装饰的地面。</p><p>\174. 你不说我还明白，你越说我越糊涂了。</p><p>\175. 勇者愤怒，抽刃向更强者；怯者愤怒，却抽刃向更弱者。不可救药的民族中，一定有许多英雄，专向孩子们瞪眼。这些孱头们！孩子们在瞪眼中长大了，又向别的孩子们瞪眼，并且想：他们一生都过在愤怒中。</p><p>\176. 我独不解中国人何以于旧状况那么心平气和，于较新的机运就这么疾首蹙额；于已成之局那么委曲求全；于初兴之事就这么求全责备？</p><p>\177. 我先前的攻击社会，其实也是无聊的。社会没有知道我在攻击，倘一知道，我早已死无葬身之所了……我之得以偷生者，因为他们大多数不识字，不知道，并且我的话也无效力，如一箭之入大海。否则，几条杂感，就可以送命的。民众的惩罚之心，并不下于学者和军阀。</p><p>\178. 但我坦然，欣然。我将大笑，我将歌唱。</p><p>\179. 曾经阔气的要复古，正在阔气的要保持现状，未曾阔气的要革新，大抵如此，大抵！</p><p>\180. 单是说不行，要紧的是做。</p><p>\181. 即使艰难，也还要做；愈艰难，就愈要做。改革，是向来没有一帆风顺的，冷笑家的赞成，是在见了成功之后……</p><p>\182. 我一向不相信昭君出塞会安汉，木兰从军就可以保隋；也不信妲己亡殷，西施沼吴，杨妃乱唐的那些古老话。我以为在男权社会里，女人是决不会有这种大力量的，兴亡的责任，都应该男的负责。但向来的男性的作者，大抵将败亡的大罪，推在女性身上，这真是一钱不值的没有出息的男人。</p><p>\183. 文人作文，农人掘锄，本是平平常常的，若照相之际，文人偏要装做粗人，玩什么“荷锄带笠图”；农夫则在柳下捧一本书，装作“深柳读书图”之类，就要令人肉麻。</p><p>\184. 假使做事要面面顾到，那就什么事都不能做了。</p><p>\185. 与名流者谈，对于他之所讲，当装作偶有不懂之处。太不懂被看轻，太懂了被厌恶。偶有不懂之处，彼此最为合宜。</p><p>\186. 激烈得快的，也平和的快，甚至于也颓废的快。</p><p>\187. 改造自己，总比禁止别人来的难。</p><p>\188. 我自爱我的野草，但我憎恶这以野草作装饰的地面。</p><p>\189. 宁可与敌人明打，不欲受同人暗算。</p><p>\190. 明言着轻蔑什么人，并不是十足的轻蔑。</p><p>\191. 希望原来是无所谓有又无所谓无的。</p><p>\192. 一个没有伟大人物出现的民族是一个没有希望的生物之群，一个有了伟大人物出现却不知道尊重的民族是世界上最可怜的奴隶之邦。</p><p>\193. 孔雀拼命开屏，却露出屁眼。</p><p>\194. 我们是奴隶，革命之后我们发现受了骗，做了奴隶的奴隶。</p><p>\195. 人生最痛苦的是梦醒了，无路可以走。</p><p>\196. 没有这种民众，就没有天才。所以我想，在要求天才的产生之前，应该先要求可以使天才生长的民众。——譬如想有乔木，想看好花，一定要有好土；没有土，便没有花木了；所以土实在较花木还重要。</p><p>\197. 中国的男人，本来大半可以做圣贤的，可惜全被女人给毁了。</p><p>\198. 唯有民族魂是值得宝贵的，唯有它发扬起来，中国才有真进步。</p><p>\199. 我的确时时解剖别人，然而更多的是更无情面地解剖自己。</p><p>\200. 一要生存，二要温饱，三要发展，有敢来阻碍这三事者，无论是谁，我们都反抗他，扑灭他！</p><p><a href="https://cdn.chegva.com/ueditor/php/upload/image/20220529/1653834666838180.png"><img src="https://cdn.chegva.com/ueditor/php/upload/image/20220529/1653834666838180.png" alt="鲁迅经典语录大全"></a></p><p>\201. 有真意，去粉饰，少做作，勿卖弄。</p><p>\202. 孩子是要别人教的，毛病是要别人医的，即使自己是教员或医生。但做人处事的法子，却恐怕要自己斟酌，许多人开来的良方，往往不过是废纸。</p><p>\203. 读书要眼到口到心到手到脑到。</p><p>\204. 过去的生命已经死亡。我对于这死亡有大欢喜，因为我借此知道它</p><p>\205. 一滴水，用显微镜看，也是一个大世界。</p><p>\206. 中国大约太老了，社会上事无大小，都恶劣不堪，像一只黑色的染缸，无论加进甚么新东西去，都变成漆黑。可是除了再想法子来改革之外，也再没有别的路。我看一切理想家，不是怀念过去，就是希望将来，而对于现在这一个题目，都缴了白卷，因为谁也开不出药方。所有最好的药方即所谓希望将来的就是。</p><p>\207. 我每看运动会时，常常这样想：优胜者固然可敬，但那虽然落后仍非跑至终点不止的竞技者，和见了这样竞技者而肃然不笑的看客，乃正是中国将来的脊梁。</p><p>\208. 中国人有一种矛盾思想，即是：要子孙生存，而自己也想活得长久，永远不死；及至知道没法可想，非死不可了，却希望自己的尸身永远不腐烂。</p><p>\209. 即使艰难，也还要做；愈艰难，就愈要做。改革，是向来没有一帆风顺的，冷笑家的赞成，是在见了成功之后。</p><p>\210. 在中国，尤其是在都市里，倘使路上有暴病倒地，或翻车捽摔伤的人，路人围观或甚至高兴的人尽有，有肯伸手来扶助一下的人却是极少的。</p><p>\211. 中国人不疑自己的多疑。</p><p>\212. 我独不解中国人何以于旧状况那么心平气和，于较新的机运就这么疾首蹙额；于已成之局那么委曲求全；于初兴之事就这么求全责备？</p><p>\213. 我想，要中国得救，也不必添甚么东西进去，只要青年们将这两种性质的古传用法，反过来一用就够了；对手如凶兽时就如凶兽，对手如羊时就如羊！</p><p>\214. 中国人不但“不以戎首”“不为祸始”，甚至于“不为福先”。所以凡事都不容易有改革；前驱和闯将，大抵是谁也怕得做。然而人性岂真能如道家所说的那样恬淡；欲得的却多。既然不敢径取，就只好用阴谋和手段。以此，人们也就日见其卑怯了，既是“不为最先”，自然也不敢“不耻最后”，所以虽以是一大堆群众，略见危机，便“纷纷作鸟兽散”了。</p><p>\215. 中国的孩子，只要生，不管他好不好，只要多，不管他才不才，生他们的人，不负教他的责任。虽然“人口众多”这一句话，很可以闭了眼睛自负，然而这许多人口，便只在尘土中辗转，小的时候，不把他当人，大了以后也做不了人。</p><p>\216. 不满是向上的车轮，能够载着不自满的人类，向人道前进。多有不自满的人的种族，永远前进，永远有希望。多有只知责人不知反省的人的种族，祸哉祸哉！</p><p>\217. 在要求天才的产生之前，应该先要求可以使天才生长的民众。譬如想有乔木，想看好花，一定要有好土；没有土，便没有花木了；所以土实在较花木还重要。</p><p>\218. 中国人没记性，因为没记性，所以昨天听过的话，今天忘记了，明天再听到，还是觉得很新鲜。做事也是如此，昨天做坏了的事，今天忘记了，明天做起来，也还不是“仍旧贯”的老调子。</p><p>\219. 巨大的建筑，总是一木一石叠起来的，我们何妨做这一木一石呢？我时常做些零碎事，就是为此。</p><p>\220. 我先前总以为人是有罪，所以枪毙或坐监的。现在才知道其中的许多，是先因为被人认为“可恶”，这才终于犯了罪。</p><p>\221. 中国人的不敢正视各方面，用瞒和骗，造出奇妙的逃路来，而自以为正路。在这路上，就证明着国民性的怯弱，懒惰而又巧滑。一天一天的满足，即一天一天的堕落，但却又觉得日见其光荣。在事实上，亡国一次，即添加几个殉难的忠臣，后来每不想光复旧物，而只去赞美那几个忠臣；遭劫一次，即造成一群不辱的烈女，事过之后，也每每不思惩凶，自卫，却只顾歌咏那一群烈女。</p><p>\222. 中国各处是壁，然而无形，像“鬼打墙”一般，使你随时能“碰”，能打这墙的，能碰而不感到痛苦的，是胜利者。</p><p>\223. 中国中流的家庭，教孩子大抵只有两种法。其一是任其跋扈，一点也不管，骂人固可，打人亦无不可，在门内或门前是暴主，是霸王，但到外面便如失了网的蜘蛛一般，立刻毫无能力。其二，是终日给以冷遇或呵斥，甚于打扑，使他畏葸退缩，彷佛一个奴才，一个傀儡，然而父母却美其名曰“听话”，自以为是教育的成功，待到他们外面来，则如暂出樊笼的小禽，他决不会飞鸣，也不会跳跃。</p><p>\224. 战士死了的时候，苍蝇所首先发见的是他的缺点和伤痕，嘬着，营营地叫，以为得意，以为比死了的战士更英雄。但是战士已经死了，不再来挥去它们。于是乎苍蝇们即更其营营地叫，自以为倒是不朽的声音，因为它们的完全，远在战士之上。的确的，谁也没有发见过苍蝇们的缺点和创伤。然而，有缺点的战士终竟是战士，完美的苍蝇也终竟不过是苍蝇。</p><p>\225. 楼下一个男人病得要死，那间隔壁的一家唱着留声机，对面是弄孩子。楼上有两人狂笑；还有打牌声。河中的船上有女人哭着她死去的母亲。人类的悲欢并不相通，我只觉得他们吵闹。</p><p>\226. 专制者反面就是奴才，有权时无所不为，失势时即奴性十足。</p><p>\227. 其实，中国人并非没有“自知之明”的，缺点只在有些人安于“自欺”，由此并想“欺人”。比如病人，患有浮肿，而讳疾忌医，但愿别人胡涂，误认他为肥胖。</p><p>\228. 酷的教育，使人们见酷而不再觉其酷，例如无端杀死几个民众，先前是大家就会嚷来的，现在只是如见了日常茶饭事。人民真被治得好象厚皮的，没有感觉的癞象一样了，但正因为成了癞皮，所以又会踏残酷前进，这也是虎吏和暴吏所不及料，而即使料及，也还是毫无办法的。</p><p>\229. 许多历史的教训，都是用极大的牺牲换来的。譬如吃东西吧，某种是毒物不能吃，我们好象全惯了，很平常了。不过，还一定是以前有多少人吃死了，才知的。所以我想，第一次吃螃蟹的人是很可佩服的，不是勇士谁敢去吃它呢？螃蟹有人吃，蜘蛛一定也有人吃过，不过不好吃，所以后人不吃了，像这种人我们当极端感谢的。</p><p>\230. 从生活窘迫过来的人，一到了有钱，容易变成两种情形：一种是理想世界，替处同一境遇的人着想，便成为人道主义；一种是甚么都是自己挣起来，从前的遭遇，使他觉得甚么都是冷酷，便流为个人主义。我们中国大概是变成个人主义者多。</p><p>\231. 只要从来如此，便是宝贝。即使无名肿毒，倘若生在中国人身上，也便红肿之处，艳若桃花；溃烂之时，美如乳酪，妙不可言。</p><p>\232. 我们中国人对于不是自己的东西，或者将不为自己所有的东西，总要破坏了才快活的。</p><p>\233. 中国的有一些士大夫，总爱无中生有，移花接木地造出故事来，他们不但歌颂生平，还粉饰黑暗。</p><p>\234. 说过的话不算数，是中国人的大毛病。</p><p>\235. 搞鬼有术，也有效，然而有限，所以以此成大事者，古来无有。</p><p>\236. 我每看运动会时，常常这样想：优胜者固然可敬，但那虽然落后仍非跑至终点不止的竞技者，和见了这样竞技者而肃然不笑的看客，乃正是中国将来的脊梁。</p><p>\237. 在中国，尤其是在都市里，倘使路上有暴病倒地，或翻车捽摔伤的人，路人围观或甚至高兴的人尽有，有肯伸手来扶助一下的人却是极少的。</p><p>\238. 不满是向上的车轮，能够载着不自满的人类，向人道前进。多有不自满的人的种族，永远前进，永远有希望。多有只知责人不知反省的人的种族，祸哉祸哉！</p><p>\239. 中国各处是壁，然而无形，像“鬼打墙”一般，使你随时能“碰”，能打这墙的，能碰而不感到痛苦的，是胜利者。</p><p>\240. 专制者反面就是奴才，有权时无所不为，失势时即奴性十足。</p><p>\241. 我自爱我的野草，但我憎恶这以野草作装饰的地面。</p><p>\242. 真的勇士敢于直面惨淡的人生，敢于正视淋漓的鲜血。</p><p>\243. 一个没有伟大人物出现的民族是一个没有希望的生物之群，一个有了伟大人物出现却不知道尊重的民族是世界上最可怜的奴隶之邦。</p><p>\244. 人生最痛苦的是梦醒了，无路可以走。</p><p>\245. 没有这种民众，就没有天才。所以我想，在要求天才的产生之前，应该先要求可以使天才生长的民众。——譬如想有乔木，想看好花，一定要有好土；没有土，便没有花木了；所以土实在较花木还重要。</p><p>\246. 社会上崇敬名人，于是以为名人的话就是名言，却忘记了他之所以得名是那一种学问或事业。</p><p>\247. 待到伟大的人物成为化石，人们都称他伟人时，他已经变了傀儡了。</p><p>\248. 孩子是要别人教的，毛病是要别人医的，即使自己是教员或医生。但做人处事的法子，却恐怕要自己斟酌，许多人开来的良方，往往不过是废纸。</p><p>\249. 哪里有什么天才，我只是把别人喝咖啡的时间用在工作上了。</p><p>\250. 伟大的成绩和辛勤劳动是成正比例的，有一分劳动就有一分收获，日积月累，从少到多，奇迹就可以创造出来。</p><p><a href="https://cdn.chegva.com/ueditor/php/upload/image/20220529/1653834752374374.png"><img src="https://cdn.chegva.com/ueditor/php/upload/image/20220529/1653834752374374.png" alt="鲁迅经典语录大全"></a></p><p>\251. 我寄你的信，总要送往邮局,不喜欢放在街边的绿色邮筒中，我总疑心那里会慢一点。</p><p>\252. 无穷的远方，无数的人们，都与我有关。</p><p>\253. 必须敢于正视，这才可望敢想，敢说，敢做，敢当。</p><p>\254. 谣言世家的子弟是以谣言杀人，也以谣言被杀的。</p><p>\255. 讽刺和冷嘲只隔一张纸，有趣和肉麻也一样。</p><p>\256. 若举世唯科学是崇，则人生必将归于枯寂。</p><p>\257. 我之所谓生存，并不是苟活，所谓温饱，不是奢侈，所谓发展，也不是放纵。</p><p>\258. 人生最苦痛的是梦醒了无路可走，做梦的人是幸福的；倘没有看出可走的路，最要紧的是不要去惊醒他。</p><p>\259. 同是不满于现状，但打破现状的手段却不同：一是革新，一是复古。</p><p>\260. 生命是以时间为单位的，浪费别人的时间等于谋财害命；浪费自己的时间，等于慢性自杀。</p><p>\261. 苛求君子，宽纵小人，自以为明察秋毫，而实则反助小人张目。</p><p>\262. 凡对于以真话为笑话的，以笑话为真话的，以笑话为笑话的，只有一个方法：就是不说话。于是我从此尽量少说话。</p><p>\263. 所谓天才，只不过是把别人喝咖啡的工夫都用在工作上了。</p><p>\264. 这个世界上有许多你不得不去做的事，这就是责任。</p><p>\265. 幸福永远存在于人类不安的追求中，而不存在于和谐与稳定之中。</p><p>\266. 人类是一种使思想开花结果的植物。</p><p>\267. 真的猛士，敢于直面惨淡的人生，敢于正视淋漓的鲜血。</p><p>\268. 与名流者谈，对于他之所讲，当装作偶有不懂之处。太不懂被看轻，太懂了被厌恶。偶有不懂之处，彼此最为合宜。</p><p>\269. 在我自己，本以为现在是已经并非一个迫切而不能已于言的人，但或者也还未能忘怀于当日自己的寂寞的悲哀罢了，所以有时候仍不免呐喊几声，聊以慰藉那在寂寞里奔驰的猛士，使他不惮于前驱。</p><p>\270. 假如一间铁屋子，是绝无窗户而万难破毁的，里面有许多熟睡的人们，不久都要闷死了，然而是从昏睡去死灭，并不感到就死的悲哀。现在你大嚷起来，惊起了较为清醒的几个人，使这不幸的少数者来受无可挽救的临终的痛楚，你倒以为对得起他们么？然而几个人既然起来，你不能说决没有毁坏这铁屋子的希望。</p><p>\271. 我觉得医学并非一件紧要事，凡事愚弱的国民，即使体格如何健全，如何茁壮，也只能做毫无意义的示众的材料和看客，病死多少是不必以为不幸的。所以我们的第一要著，是在改变他们的精神，而善于改变精神的是，我那时以为当然要推文艺，于是想提倡文艺运动了。</p><p>\272. 凡有一个人的主张，得了赞和，是促其前进的，得了反对，是促其奋斗的，独有叫喊于生人中，而生人并无反应，既非赞同，也无反对，如置身毫无边际的荒原，无可措手的了，这是怎样的悲哀呵，我于是以我所感到者为寂寞。</p><p>\273. 死亡的生命已经朽腐。我对于这朽腐有大欢喜，因为我借此知道它还非空虚。</p><p>\274. 绝望正与希望相同，大恨恰恰是大爱的起点。</p><p>\275. 我自爱我的野草，但我憎恶这以野草作装饰的地面。地火在地下运行，奔突；熔岩一旦喷出，将烧尽一切野草，以及乔木，于是并且无可朽腐。但我坦然，欣然。我将大笑，我将歌唱。</p><p>\276. 人的言行，在白天和在深夜，在日下和在灯前，常常显得两样。</p><p>\277. 残象，已使我目不忍视，流言，犹使我耳不忍闻。</p><p>\278. 他们应该有新的生活,为我们所未经生活过的。</p><p>\279. 有人说：有些胜利者，愿意敌手如虎，如鹰，他才感得胜利的欢喜；假使如羊，如小鸡，他便反觉得胜利的无聊。又有些胜利者，当克服一切之后，看见死的死了，降的降了，’臣诚惶诚恐死罪死罪’，他于是没有了敌人，没有了对手，没有了朋友，只有自己在上，一个，孤零零，凄凉，寂寞，便反而感到了胜利的悲哀。</p><p>\280. 一个人做到只剩了回忆的时候，生涯大概总要算是无聊了吧，但有时竟会连回忆也没有。</p><p>\281. 人生如一本书，应该多一些精彩的细节，少一些乏味的字眼；人生如一支歌，应该多一些昂扬的旋律，少一些忧伤的音符；人生如一幅画，应该多一些亮丽的色彩，少一些灰暗的色调。</p><p>\282. 有一分热，发一分光，就令萤火一般，也可以在黑暗里发一点光，不必等候炬火。此后如竟没有炬火：我便是唯一的光。</p><p>\283. 其实，中国人并非没有“自知之明”的，缺点只在有些人安于“自欺”，由此并想“欺人”。比如病人，患有浮肿，而讳疾忌医，但愿别人胡涂，误认他为肥胖。</p><p>\284. 我们中国人对于不是自己的东西，或者将不为自己所有的东西，总要破坏了才快活的。</p><p>\285. 幼稚对于老成，有如孩子对于老人，决没有什么耻辱的作品也一样，起初幼稚，不算耻辱的。</p><p>\286. 贪安稳就没有自由，要自由就要历些危险。只有这两条路。</p><p>\287. 真的勇士敢于直面惨淡的人生，敢于正视淋漓的鲜血。</p><p>\288. 我们是奴隶，革命之后我们发现受了骗，做了奴隶的奴隶。</p><p>\289. 人生最痛苦的是梦醒了，无路可以走。</p><p>\290. 没有这种民众，就没有天才。所以我想，在要求天才的产生之前，应该先要求可以使天才生长的民众。——譬如想有乔木，想看好花，一定要有好土；没有土，便没有花木了；所以土实在较花木还重要。</p><p>\291. 悲剧将人生的有价值的东西毁灭给人看，喜剧将那无价值的撕破给人看。</p><p>\292. 节省时间，也就是使一个人的有限的生命更加有效，而也即等于延长了人的生命。</p><p>\293. 一要生存，二要温饱，三要发展，有敢来阻碍这三事者，无论是谁，我们都反抗他，扑灭他！</p><p>\294. 伟大的成绩和辛勤劳动是成正比例的，有一分劳动就有一分收获，日积月累，从少到多，奇迹就可以创造出来。</p><p>\295. 我寄你的信，总要送往邮局,不喜欢放在街边的绿色邮筒中，我总疑心那里会慢一点。</p><p>\296. 我们自古以来，就有埋头苦干的人，有拼命硬干的人，有为民请命的人，有舍身求法的人。虽是等于为帝王将相作家谱的所谓“正史”，也往往掩不住他们的光辉，这就是中国的脊梁。</p><p>\297. 讽刺和冷嘲只隔一张纸，有趣和肉麻也一样。</p><p>\298. 若举世唯科学是崇，则人生必将归于枯寂。</p><p>\299. 同是不满于现状，但打破现状的手段却不同：一是革新，一是复古。</p><p>\300. 从原虫到人类，从野蛮到文明，就因为没有一刻不在革命。</p><p><a href="https://cdn.chegva.com/ueditor/php/upload/image/20220529/1653834959546177.jpeg"><img src="https://cdn.chegva.com/ueditor/php/upload/image/20220529/1653834959546177.jpeg" alt="鲁迅经典语录大全"></a></p><p>\301. 既然像螃蟹这样的东西，人们都很爱吃，那么蜘蛛也一定有人吃过，只不过后来知道不好吃才不吃了，但是第一个吃螃蟹的人一定是个勇士。</p><p>\302. 伟大的成绩和辛勤劳动是成正比例的，有一分劳动就有一分收获，日积月累，从少到多，奇迹就可以创造出来。</p><p>\303. 只看一个人的著作，结果是不大好的：你就得不到多方面的优点。必须如蜜蜂一样，采过许多花，这才能酿出蜜来。倘若叮在一处，所得就非常有限，枯燥了。</p><p>\304. 中国虽发明火药，却只会用来放烟花炮竹；发明罗盘，也是用来看风水。</p><p>\305. 在行进时，也时时有人退伍，有人落荒，有人颓唐，有人叛变，然而只要无碍于进行，则越到后来，这队伍也就越成为纯粹精锐的队伍了。</p><p>\306. 空谈之类，是谈不久，也谈不出什麽来的，它始终被事实的镜子照出原形，拖出尾巴而去。</p><p>\307. 躲进小楼成一统，管他春夏与秋冬。</p><p>\308. 以人为鉴，明白非常，是使人能够反省的妙法。</p><p>\309. 父母对于子女，应该健全的产生，尽力的教育，完全的解放。</p><p>\310. “不耻最后。”即使慢，驰而不息，纵令落后，纵令失败，但一定可以达到他所向往的目标。</p><p>\311. 泥土和天才比，当然是不足齿数的，然而不是坚苦卓绝者，也怕不容易做；不过事在人为，比空等天赋的天才有把握。这一点，是泥土的伟大的地方，也是反有大希望的地方。</p><p>\312. 我们从古以来，就有埋头苦干的人，有拼命硬干的人，有为民请命的人，有舍身求法的人，……虽是等于为帝王将相作家谱的所谓“正史”，也往往掩不住他们的光耀，这就是中国的脊梁。</p><p>\313. 沉着勇猛，有辨别，不自私。</p><p>\314. 愈艰难，就愈要做。改革，是向来没有一帆风顺的。</p><p>\315. 曾经阔气的要复古，正在阔气的要保持现状，未曾阔气的要革新，大抵如此，大抵！</p><p>\316. 人类总不会寂寞，因为生命是进步的，是天生的。</p><p>\317. “奴才”做了主人，是绝不肯废除“老爷”的称号，她的摆架子，恐怕比他的主人还十足，还可笑。</p><p>\318. 一定要有自信的勇气，才会有工作的勇气。</p><p>\319. 死亡的生命已经朽腐。我对于这朽腐有大欢喜，因为我借此知道它还非空虚。</p><p>\320. 我懂得衰亡民族之所以默无声息的原由了。沉默啊，沉默，不在沉默中爆发，就在沉默中灭亡。</p><p>\321. 唯独革命家，无论他生或死，都能给大家以幸福。</p><p>\322. 现在的青年最要紧的是“行”，不是“言”</p><p>\323. 应做的功课已完而有余暇，大可以看看各样的书，即使和本业毫不相干的，也要泛览。</p><p>\324. 学习专看文学书，也是不好的。先前的文学青年，往往厌恶数学理化史地生物学，以为这些都无足轻重，后来变成连常识也没有。</p><p>\325. 要竭力将可有可无的字句段删去，毫不可惜。</p><p>\326. 走自己的路，让别人去说。</p><p>\327. 伟大的成绩和辛勤劳动是成正比例的，有一分劳动就有一分收获，日积月累，从少到多，奇迹就可以创造出来。</p><p>\328. 革命是痛苦，其中也必然混有污秽和血，决不是如诗人所想象的那般有趣，那般完美；革命尤其是现实的故事，需要各种卑贱的，麻烦的工作，决不如诗人想象的那般浪漫；革命当然有破坏，然而更需要建设，破坏是痛快的，但建设却是麻烦的事。所以对于革命抱着浪漫谛克的幻想的人，一和革命接近，一到革命进行，便容易失望。</p><p>\329. 教育植根于爱。</p><p>\330. 青年应当天真烂漫。</p><p>\331. 青年们先可以将中国变成一个有声的中国。大胆地说话，勇敢地进行，忘掉一切利害，推开了古人，将自己的真心的话发表出来。</p><p>\332. 天才并不是自生自长在深林荒野里的怪物，是由可以使天才生长的民众产生长育出来的，所以没有这种民众，就没有天才。</p><p>\333. 爱看书的青年，大可以看看本分以外的书，即课外的书，不要只将课内的书抱住。</p><p>\334. 战士的日常生活，是并不全部可歌可泣的，然而又无不和可歌可泣相关联，这才是实际上的战士。</p><p>\335. 写不出的时候不硬写。</p><p>\336. 从喷泉里出来的都是水，从血管里出来的都是血。</p><p>\337. 我们和朋友在一起，可以脱掉衣服，但上阵要穿甲。</p><p>\338. 与其找糊涂导师，倒不如自己走，可以省却寻觅的功夫，横竖他也什么都不知道。</p><p>\339. 不是很大的鞭子打在背上，中国自己是不肯动弹的。</p><p>\340. 我很早就希望中国的站出来，对于中国的社会文明，都毫无忌惮地加以批评。</p><p>\341. 在生活的路上，将血一滴一滴地滴过去，以饲别人，虽自觉渐渐瘦弱，也以为快活。</p><p>\342. 我觉得坦途在前，人又何必因了一点小障碍而不走路呢？</p><p>\343. 看别的书也一样，仍要自己思索，自己观察。倘只看书，便变成书橱，即使自己觉得有趣，而那趣味其实是已在逐渐硬化，逐渐死去了。</p><p>\344. 凡事以理想为因，实行为果。</p><p>\345. 散文的体裁，其实是大可以随便的。有破绽也不妨。做作的写信和日记，恐怕也还不免有破绽，而一有破绽，便破灭到不可收拾了。与其防破绽，不如忘破绽。</p><p>\346. 用秕谷来养青年，是决不会壮大的，将来的成就，且要更渺小。</p><p>\347. 造化常为庸人设计。</p><p>\348. 养成他们有耐劳作的体力，纯洁高尚的道德，广博自由能容纳新潮流的精神，也就是能在世界新潮流中游泳，不被淹没的力量。</p><p>\349. 做一件事，无论大小，倘无恒心，是很不好的。而看一切太难，固然能使人无成，但若看得太容易，也能使事情无结果。</p><p>\350. 穿掘着灵魂的深处，使人受了精神底苦刑而得到创伤，又即从这得伤和养伤和愈合中，得到苦的涤除，而上了苏生的路。</p><p><a href="https://cdn.chegva.com/ueditor/php/upload/image/20220529/1653835002112910.png"><img src="https://cdn.chegva.com/ueditor/php/upload/image/20220529/1653835002112910.png" alt="鲁迅经典语录大全"></a></p><p>\351. 一个人的生命是可宝贵的，但一代的真理更可宝贵，生命牺牲了而真理昭然于天下，这死是值得的。</p><p>\352. 让别人过得舒服些，自己没有幸福不要紧，看见别人得到幸福生活也是舒服的。</p><p>\353. 时间就是生命，无端地空耗别人的时间，无异于谋财害命。</p><p>\354. 天才并不是自生自长在深林荒野里的怪物，是由可以使天才生长的民众产生长育出来的，所以没有这种民众，就没有天才。</p><p>\355. 智识太多，不是心活，就是心软。心活就会胡思乱想，心软就不肯下辣子手……所以智识非铲除不可。</p><p>\356. 做人时想要成仙，身在地上你想上天。</p><p>\357. 小时候不把他当人看，长大后他就做不了人。家长在对小孩子小时候的教育上，应该注意这一点。</p><p>\358. 所写的事迹，大抵有一点见过或者听过的缘由，但决不会用这事实，只是采取一端，加以改造，或者生发开去，到足以几乎完全发表我的意见为止。人物的模特儿也一样，没有专用一个人，往往嘴在浙江，脸在北京，衣服在山西，是一个拼凑起来的角色。</p><p>\359. 没有冲破一切传统思想和手法的闯将，中国不会有真的新文艺的。文艺是国民精神所发的火光，同时也是引导国民精神前途的灯光。</p><p>\360. 写小说，说到底，就是写人物。小说艺术的精髓就是创造人物的艺</p><p>\361. 中国人现在胆子格外小了……这样的害怕，一动也不敢动，怎样能够有进步呢？</p><p>\362. 中国的文人，对于人生，至少是对于社会现象，向来就多没有正视的勇气。</p><p>\363. 灵魂的深处并不平安，敢于正视的本来就不多，更何况写出？</p><p>\364. 但人于现状，总该有点不平，反抗，改良的意思。</p><p>\365. 由历史所示，凡有改革，最初，总是觉悟的智识者的任务。但这些智识者，却必须有研究，能思索，有决断，而且有毅力。他也用权，却不是骗人，他利导，却并非迎合。</p><p>\366. 真的知识阶级是不顾利害的，如想到种种利害，就是假的，冒充的知识阶级；只是假的知识阶级的寿命倒比较长一点。象今天发表这个主张，明天发表那个意见的人，思想似乎天天在进步；只是真的知识阶级的进步，决不能如此快的。不过他们对于社会永不会满意的，所感受的永远是痛苦，所看到的永远是缺点，他们预备着将来的牺牲，社会也因为有了他们而热闹，不过他的本身心身方面总是痛苦的；因为这也是旧式社会传下来的遗物。</p><p>\367. 我希望有若干留心各方面的人，将所见，所受，所感到的都写出来，无论是好的，坏的，象样的，丢脸的，可耻的，可悲的，全给它发表……</p><p>\368. 世上如果还有真要活下去的人们，就先该敢说，敢笑，敢哭，敢怒，敢骂，敢打，在这可诅咒的地方击退了可诅咒的时代！</p><p>\369. 因为讲过刘庚生的罪名，就想到开口和动笔，在现在的中国，实在也很难的，要稳当，还是不想的好。要不然，就常不免反弄到自己的头上来。</p><p>\370. 一认真，便容易趋于激烈，发扬则送掉自己的命，沈静着，又啮碎了自己的心。</p><p>\371. 所以我想，在青年，须是有不平而不悲观，常抗战而亦自卫，倘荆棘非践不可，固然不得不践，但若无须必践，即不必随便去践，其实也无非想多留下几个战士，以得更多的战绩。</p><p>\372. 战斗当首先守住营垒，若专一冲锋，而反遭覆灭，乃无谋之勇，非真勇也。</p><p>\373. ……震骇一时的牺牲，不如深沈的韧性的战斗。</p><p>\374. 作者的任务，是在对于有害的事物，立刻给以反响或抗争，是感应的神经，是攻守的手足。</p><p>\375. 凡有文学，都是宣传，因为其中总不免传布着什么，但后来却有人解为文学必须故意做成宣传文字的样子了。诗必用口号，其误正等。</p><p>\376. 说话到真人厌恶，比毫无动静来，还是一种幸福。</p><p>\377. 人能说话，已经是祸胎了，而况有时还要做文章。</p><p>\378. 我现在要说的是：说话难，不说亦不易。弄笔的人们，总要写文章，一写文章，就难免惹灾祸。</p><p>\379. 要写下去，在中国的现在，还是没有写处的。年青时读向子期《思旧赋》，很怪他为什么只有寥寥的几行，刚开头却煞了尾。然而，现在我懂得了。</p><p>\380. 现在的报章之不能像个报章，是真的；评论的不能逞心而谈，失了威力，也是真的……</p><p>\381. 事实常没有字面这么好看。例如《自由谈》，其实是不自由的，现在叫作《自由谈》，总算我们是这么自由地在这里谈着。</p><p>\382. 有救人之英雄，亦有杀人之英雄，世上通例，但有作文之文学家，而又有禁人作文之’文学家’，则似中国所独有也。</p><p>\383. 然而社会讽刺家究竟是危险的，尤其是在有些’文学家’明明暗暗的成了’王之爪牙’的时代。人们谁高兴做’文字狱’中的主角呢，但倘不死绝，肚子里总还有半口闷气，要借着笑的幌子，哈哈的吐他出来。</p><p>\384. 他所讽刺的是社会，社会不变，这讽刺就跟着存在……</p><p>\385. 歌颂中国文明的也惟以光明示人，隐匿了黑的一面。</p><p>\386. 讲来讲去总是这几套，纵使记性坏，多听了也会烦厌的。</p><p>\387. 我想，便是说教的人，恐怕自己也未必相信罢。所以听的人也不相信。</p><p>\388. 只有真的声音，才能感动中国的人和世界的人；必须有了真的声音，才能和世界的人同在世界上生活。</p><p>\389. 但说谎的得好报，说必然的遭打。</p><p>\390. 承认其有而掩饰为无，非有绝技是不行的。</p><p>\391. 穷人的孩子，蓬头垢面在街上转，阔人的孩子，妖形妖势，娇声娇气的在家里转，转大了，都昏天黑地的在社会转，同他们的父亲一样，或者还不如。</p><p>\392. 无论从那里来的，只要是食物，壮健者大抵就无需思索，承认是吃的东西。惟有衰病的，却总常想到害胃，伤身，特有许多禁例，许多避忌；还有一大套比较利害而终于不得要领的理由，例如吃固无妨，而不吃尤稳，食之或当有益，然究以不吃为宜云云之类。但这一类人物总要日见其衰弱的，自己先已失了活气了。</p><p>\393. 中国人的虽然想了各种苟活的理想乡，可惜终于没有实现。但我却替他们发现了，你们大概知道的罢，就是北京的第一监狱。这监狱在宣武门外的空地里，不怕邻家的火灾；每日两餐，不虑冻馁；起居有定，不会伤生；构造坚固，不会倒塌；禁卒管，不会再犯；强盗是决不会来抢的。住在里面，何等安全，真是『千金之子坐不垂堂』了。但缺少的就有一件事：自由。</p><p>\394. 群众，尤其是中国的──永远是戏剧的看客。牺牲上场，如果显得慷慨，他们就看了悲壮剧；如果显得觳觫（即恐惧颤抖），他们就看了滑稽剧。北京的羊肉铺常有几个人张嘴看剥羊，仿佛颇为愉快，人的牺牲能给他们的益处，也不过如此。而况事后走不几步，他们并这一点也就忘了。</p><p>\395. 中国人自己诚然不善于战争，却并没有诅咒战争；自己诚然不愿出战，却并未同情于不愿出战的他人；虽然想到自己，却没有想到他人的自己。</p><p>\396. 凡中国所有的，外国也都有。外国人说中国多臭虫，但西洋也有臭虫……假使世界上只有一家有臭虫，而遭别人指摘的时候，实在也不太舒服的……最好还是希望别家也有臭虫，而竟发现了就更好。</p><p>\397. 上司的行动不必征求下属的意见，这是天经地义。但是，有时候上司会对下属解释。</p><p>\398. ……这种解释的作用，在于制造自己威权的宗教上哲学上科学上，世界潮流上的根据，使得奴隶和牛马恍然大悟这世界的公律，而抛弃一切翻案的梦想。</p><p>\399. 当上司对于下属解释的时候，你做下属的切不可误解这是在征求你的同意，因为即使你绝对的不同意，他还是干他的。</p><p>\400. 暴君的臣民，只愿暴政暴在他人的头上，他却看着高兴，拏“残酷”做娱乐，拏“他人的苦”做赏玩，做慰安。</p><p><a href="https://cdn.chegva.com/ueditor/php/upload/image/20220529/1653835091132067.png"><img src="https://cdn.chegva.com/ueditor/php/upload/image/20220529/1653835091132067.png" alt="鲁迅经典语录大全"></a></p><p>\401. 自己的本领只是“倖免”。</p><p>\402. 暴君治下的臣民，大抵比暴君更暴；暴君的暴政，时常还不能餍足暴君治下的臣民的欲望。中国不要提了罢。在外国举一个例：小事件则如果格里的剧本《按察使》，众人都禁止他，俄皇却准开演；大事件则如巡抚想放耶酥，众人却要求将他钉上十字架。</p><p>\403. 然而倘说中国现在正如唐虞盛世，却又未免是’世故’之谈。耳闻目睹的……也就可以知道社会上有多少不平，人们有多少冤抑。</p><p>\404. 直到事实给了我教训，我才分明省悟了做今人和做古人一样难。</p><p>\405. 就是秦始皇隋炀帝，他会自承无道么？百姓就只好永远箝口结舌，相率被杀，被奴。</p><p>\406. 古人做过的事，无论什么，今人都会做出来。而辩护古人，也就是辩护今人。</p><p>\407. 但是结果往往和英雄们的预算不同。始皇想皇帝传至万世，而偏偏二世而亡，赦免了农书和医书，而秦以前的这一类书，现在却偏偏一部也不剩。</p><p>\408. 即以皇帝一伦而言，便难免时常改姓易代，终没有’万年有道之长’，《二十四史》而多至二十四，就是可悲的铁证。</p><p>\409. 在我自己，觉得中国现在是一个进向大时代的时代。但这所谓大，并不一定指可以由此得生，而也可以由此得死。</p><p>\410. 中国人现在是在发展着’自欺力’。’自欺’也并非现在的新东西，现在只不过日见其明显，笼罩了一切罢了。</p><p>\411. 其实，中国人是并非“没有自知”之明的，缺点只在有些安于“自欺”，由此并想“欺人”。</p><p>\412. 而中国现行的所谓宣传，则不但后来只有证明这’宣传’确凿就是说谎的事实而已，还有一种坏结果，是令人对于凡有记述文字逐渐起了疑心，临末弄得索性不看。</p><p>\413. 但是现在的有些文章觉得不少是“高论”，文章虽好，能说而不能行，一下子就消灭，而问题却依然如故。</p><p>\414. 历来都竭力表彰“五世同堂”，便足见实际上同居的为难；拼命的劝孝，也足见事实上孝子的缺少。而其原因，便全在一意提倡虚伪的道德，蔑视了真的人情。</p><p>\415. 然则圣人为什么大呼’中庸’呢？曰：这正因为大家并不中庸的缘故。人必有所缺，这才想起他所需。</p><p>\416. 向来听说中国人具有大国民的大度，现在看看，也未必然。但是我们要说得好，那么，就说好清静，有志气罢。所以总愿意自己是第一，是唯一，不爱见别的东西共存。</p><p>\417. 我们“皇汉”人实在有些怪脾气的：外国人论及我们缺点的不欲闻，说好处就相信……</p><p>\418. 一般的幻灭的悲哀，我以为不在假，而在以假为真。</p><p>\419. 幻灭之来，多不在假中见真，而在真中见假。</p><p>\420. 叫我们用自己的老调子唱完我们自己的时候，是已经要到了。</p><p>\421. 中国的事情往往是招牌一挂就算成功了。</p><p>\422. 中国有许多事情都只剩下一个空名和假样，就为了不认真的缘故。</p><p>\423. 中国人将办事和做戏太混为一谈，而别人却很切实……</p><p>\424. 在中国要寻求滑稽，不可看所谓滑稽文，倒要看所谓正经事，但必须想一想。</p><p>\425. 这些现象，实在可以使中国败亡，无论有没有外敌。要救正这些，也只好先行发露各样的劣点，撕下那好看的假面具来。</p><p>\426. 将先前一切自欺欺人的希望之谈全都扫除，将无论是谁的自欺欺人的假面都撕掉，将无论是谁的自欺欺人的手段全都排斥，总而言之，就是将华夏传统的所有小巧的玩艺儿全都放掉，倒去屈尊学学枪击我们的洋鬼子，这才可望有新的希望的萌芽。</p><p>\427. 一个人处在沈闷的时代，是容易喜欢看古书的……</p><p>\428. 你看’现代’派下的小卒就这样阴鸷，无孔不入，真是可怕可厌。不过我想这实在难对付，譬如要我去和此辈周旋，就必须将别的事情放下，另用一番心机，本业抛荒，所得的成绩就有限了。’现代’派学者之无不浅薄，即因为分心于此等下流事情之故也。</p><p>\429. 但我对于此后的方针，实在很有些徘徊不决，那就是：做文章呢，还是教书？因为这两件事是势不两立的：做文要热情，教书要冷静。……我自己想，我如写点东西，也许于中国不无小好处，不写也可惜；但如使我研究一种关于中国文学的事，大概也可以说出点别人没有见到的话来，所以放下也似乎可惜。</p><p>\430. 我也时时感到寂寞，常常想改掉文学买卖，不做了，并且离开上海。不过这是暂时的愤慨，结果大约还是这样的干下去，到真的干不来了的时候。</p><p>\431. 而且自从弄笔以来，有一种坏习气，就是一件事情开手，不做完就不舒服，也不能同时做两件事，所以每作一文，不写完就不放手，倘若一天弄不完，则必须做到没有力气了，才可以放下，但躺着也还要想到。</p><p>\432. 时亦有意，去此危邦，而眷念旧乡，仍不能绝裾径去，野人怀土，小草恋山，亦可哀也。</p><p>\433. 我一生的失计，即在向来不为自己生活打算，一切听人安排，因为那时预料是活不久的。</p><p>\434. 但自问数十年来，于自己保存之外，也时时想到中国，想到将来，愿为大家出一点微力，却可以自白的。</p><p>\435. 我的文章，未有阅历的人实在不见得看得懂，而中国的读书人，又是不注意世事的居多，所以真是无法可想。</p><p>\436. 别人应许给你的事物，不可当真。</p><p>\437. 你要是把假痴假呆当做真痴真呆，当真认为可笑可怜，那就未免傻到不可救药了。</p><p>\438. ‘急不择言’的病根，并不在没有想的工夫，而在有工夫的时候没有想。</p><p>\439. 兄之常常觉得为难，我想，其缺点即在想得太仔细，要毫无错处。其实，这样的事，是极难的。凡细小的事情，都可以不必介意。</p><p>\440. 我的意思是以为有些事情万不要想得太深，想得太忠厚，太老实……</p><p>\441. 既无“患得患失”的念头，心情也自然安泰……</p><p>\442. 但我也没有在古今的名人中，发见能够确保决无虚伪的人，所以对于人，我以为只能随时取其一段一节。</p><p>\443. 耶稣说，见车要翻了，扶他一下。……我自然是赞成耶稣的话；但以为倘若不愿你扶，便不必硬扶，听他罢了。此后能不翻，固然很好，倘若终于翻倒，然后再切切实实的帮他抬。</p><p>\444. 老兄，硬扶比抬更为费力，更难见效。翻后再抬比将翻便扶，于他们更为有益。</p><p>\445. 侠客为了自己的’功绩’不能打尽不平，正如慈善家为了自己的阴功，不能救助社会上的困苦一样。而且是’非徒无益’而又害之的。</p><p>\446. 人不能将别人都作坏人看，能帮的也还是帮，不过最好是量力，不要拼命就是了。</p><p>\447. 生了孩子，还要想怎样教育，才能使这生下来的孩子，将来成一个完全的人。</p><p>\448. 我希望你们有记性，将来上了年纪，不要随便打孩子。不过孩子也会有错处的，要好好的对他说。</p><p>\449. 但不以实力为根本的民气，结果也只能以固有而不假外求的天灵盖自豪，也就是以自暴自弃当作得胜。</p><p>\450. 一到不再自欺欺人的时候，也就是到了看见希望的萌芽的时候。</p><p><a href="https://cdn.chegva.com/ueditor/php/upload/image/20220529/1653835282789640.jpeg"><img src="https://cdn.chegva.com/ueditor/php/upload/image/20220529/1653835282789640.jpeg" alt="鲁迅经典语录大全"></a></p><p>\451. 失掉了现在就等于没有了未来。</p><p>\452. 愚民的发生，是愚民政策的结果，秦始皇已经死了二千多年，看看历史，是没有再用这种政策的了，然而，那效果的遗留，却久远得多么骇俗。</p><p>\453. 智识太多了，不是心活，就是心软。心活就会胡思乱想，心软就不肯下辣手。结果，不是自己不镇静，就是妨害别人的镇静。于是灾祸就来了。所以智识非铲除不可。</p><p>\454. 总之，人若一经走出麻木境界，便即增加苦痛，而且无法可想，所谓’希望将来’，不过是自慰或者简直是自欺之法，即所谓’随顺现在’者也一样。必须麻木到不想’将来’也不知’现在’，这才和中国的时代环境相合，但一有知识，就不能再回到这地步去了。</p><p>\455. 中国人于是也骂起知识阶级来了；后来便要打倒知识阶级……知识就仿佛是罪恶，但是，一方面虽有人骂知识阶级；一方面却又有人以此自豪……</p><p>\456. 现在的所谓教育，世界上无论那一国，其实都不过是制造许多适应环境的机器的方法罢了。</p><p>\457. 就是所谓’教科书’，在近三十年中，真不知变化了多少。忽而这么说，忽而那么说，今天是这样的宗旨，明天又是那样的主张，不加’教育’则已，一加’教育’，就从学校里造成了许多矛盾冲突的人。</p><p>\458. 看中国现在情形，几乎要陷于无教育状态，此后如何，实在是在不可知之数。</p><p>\459. 还有，知识阶级对于别人的行动，往往以为这样也不好，那样也不好。</p><p>\460. 今之青年，似乎比我们青年时代的青年精明，而有些也更重目前之益，为了一点小利，而反噬构陷，真有大出于意料之外者……</p><p>\461. 现在的青年，似乎所注意的范围，大抵很狭小……</p><p>\462. 走’人生’的长途，最易遇到的有两大难关。其一是’歧路’，倘是墨翟先生，相传是恸哭而返的，但我不哭也不返，先在歧路头坐下，歇一会，或者睡觉，于是选一条似乎可走的路再走，倘遇见老实人，也许夺他食物来充饥，但是不问路，因为我料定他并不知道的。如果遇见老虎，我就爬上树去，等它饿得走去了再下来，倘它竟不走，我就自己饿死在树上，而且先用带子缚住，连死尸也决不给它吃。但倘若没有树呢？那么，没有法子，只好请它吃了，但也不妨也咬它一口。其二便是’穷途’了，听说阮籍先生也大哭而回，我却也像在歧路的办法一样，还是跨进去，在刺丛里姑且走走。</p><p>\463. 现在做人，似乎只能随时随手做点有益于人之事，倘其不能，就做些利己而不损人之事，又不能，则做些损人利己之事。只有损人而不利己的事，我是反对的，如强盗之放火是也。</p><p>\464. 但总之，即使未能徑上战线，一切稍为大家着想，为将来着想，这大约总不会是错了路的。</p><p>\465. 志愿愈大，希望愈高，可以致力之处就愈少，可以自解之处也愈多。</p><p>\466. 幻想飞得太高，堕在现实上的时候，伤就格外沈重了；力气用得太骤，歇下来的时候，身体就难于动弹了。</p><p>\467. 志极高而心不专，就永远只能传扬一个可惊可喜的消息……</p><p>\468. 无论爱什么，饭，异性，国，民族，人类等等，只有纠缠如毒蛇，执着如怨鬼，二六时中，没有已时者有望。</p><p>\469. 是你还以为前途太光明，所以一碰钉子，便大失望，如果先前不期必胜，则即使失败，苦痛恐怕会小得多罢。</p><p>\470. 中国是古国，历史长了，花样也多，情形复杂，做人也特别难，我觉得别的国度里，处事法总还要简单，所以每个人可以有工夫做些事，在中国，则单是为生活，就要化去生命的几乎全部。</p><p>\471. 往往须费额外的力，受无谓的气，无论做什么事，都是如此。我想此后只要能以工作赚得生活费，不受意外的气，又有一点自己玩玩的余暇，就可以算是万分幸福了。</p><p>\472. 驯良之类并不是恶德。但发展开去，对一切事无不驯良，却决不是美德，也许简直倒是没出息。</p><p>\473. 我以为人类为向上，即发展起见，应该活动，活动而有若干失错，也不要紧。惟独半死半生的苟活，是全盘失错的。因为他挂了生活的招牌，其实却引人到死路上去。</p><p>\474. 苟活就是活不下去的初步，所以到后来，他就活不下去了。意图生存，而太卑怯，结果就得死亡</p><p>\475. 生活在人们的同情之下，已经是不自由了……</p><p>\476. 我想：一个人也许应该做点事，但也无须劳而无功。</p><p>\477. 人固然应该办’公’，然而总须大家都办，倘人们偷懒，而只有几个人拼命，未免太不’公’了，就应该适可而止……</p><p>\478. 现在的许多论客，多说我会发脾气，其实我觉得自己倒是从来没有因为一点小事情，就成友或成仇的人。我还不少几十年的老朋友，要点就在彼此略小节而取其大。</p><p>\479. 不能提出真凭实据，而任意诬我的朋友为’内奸’，为’卑劣’者，我是要加以辩正的，这不仅是我的交友的道义，也是看人看事的结果</p><p>\480. 古之师道，实在也太尊，我对此颇有反感。我以为师如荒谬，不妨叛之，但师如非罪而遭冤，却不可乘机下石，以图快敌人之意而自救。</p><p>\481. 叭儿之类，是不足惧的。最可怕的确是口是心非的所谓’战友’，因为防不胜防。</p><p>\482. 对于只想以笔墨问世的青年，我现在却敢据几年的经验，以诚恳的心，进一个苦口的忠告。那就是：不断的（！）努力一些，切勿想以一年半载，几篇文字和几本期刊，便立了空前绝后的大勋业。还有一点是：不要只用力于抹杀别人，使他与自己一样的空无，而必须跨过那站着的前人，比前人更加高大。初出阵的时候，幼稚和浅薄都不要紧，然而也须不断的（！）生长起来才好。</p><p>\483. 一个人做事不专，这样弄一点，那样弄一点，既要翻译，又要做小说，还要做批评，并且也要做诗，这怎么弄得好呢？</p><p>\484. 教书和写东西是势不两立的，或者死心塌地地教书，或者发狂变死地写东西，一个人走不了方向不同的两条路。</p><p>\485. 研究是要用理智，要冷静的，而创作须情感，至少总得发点热，于是忽冷忽热，弄得头昏，这也是职业和嗜好不能合一的苦处。苦倒也罢了，结果还是什么都弄不好。那证据，是试翻世界文学史，那里面的人，几乎没有兼做教授的。</p><p>\486. 研究文章的历史或理论的，是文学家；做做诗，或戏曲小说的，是做文章的人，就是古时候所谓文人，此刻所谓创作家。创作家不妨毫不理会文学史或理论，文学家也不妨做不出一句诗。然而中国社会上还很误解，你做几篇小说，便以为你一定懂得小说理论，做几句新诗，就让你讲诗之原理。</p><p>\487. 文章应该怎样做，我说不出来，因为自己的作文，是由于多看和多练习，此外并无心得或方法的。</p><p>\488. 这也难怪，因为创作是并没有什么秘诀，能够交头接耳，一句话就传授给别一个的……</p><p>\489. 此后要创作，第一须观察，第二是要看别人的作品，但不要专看一个人的作品，以防被他束缚住，必须博采众家，取其所长，这才后来能够独立。</p><p>\490. 倘若看看文艺作品呢，则先看几种名家的选本，从中觉得谁的作品自己最爱看，然后再看这个作者的专集，然后从文学史上看看他在史上的位置；倘要知道得更详细，就看一两本这人的传记，那便可以大略了解了。</p><p>\491. 不过只看一个人的著作，结果是不大好的：你就得不到多方面的优点。必须如蜜蜂一样，采过许多花，这才能酿出蜜来，倘若叮住一处，所得就非常有限，枯燥了。</p><p>\492. 读者的读选本，自以为是由此得了古人文笔的精华的，殊不知却被选者缩小了眼界……</p><p>\493. 不过我总以为倘要论文，最好是顾及全篇，并且顾及作者的全人，以及他所处的社会状态，这才较为确凿。要不然，是很容易近乎说梦的。</p><p>\494. 有一种所谓’文士’而又似批评家的，则专是一个人的御前侍卫，托尔斯泰呀，托尔斯泰呀，指东画西的，就只为一个人做屏风。</p><p>\495. 不过我并非要大家不看批评，不过说看了之后，仍要看看本书，自己思索，自己做主。看别的书也一样，仍要自己思索，自己观察。</p><p>\496. 作文要誊清，是因为不常写的缘故：手生。我也这样，翻译多天之后，写评论便涩滞；写过几篇之后，再翻译，却又觉得不大顺手了。</p><p>\497. 以后应该立定格局之后，一直写下去，不管修辞，也不要回头看。等到成后，搁它几天，然后再来复看，删去若干，改换几字。在创作的塗中，一面练字，真要把感兴打断的</p><p>\498. 我以为内容且不说，新诗先要有节调，押大致相近的韵，给大家容易记，又顺口，唱得出来。</p><p>\499. 诗须有形式，要易记，易懂，易唱，动听，但格式不要太严。要有韵，但不必依旧诗韵，只要顺口就行。</p><p>\500. 我以为一切好诗，到唐已经被做完……</p><p><a href="https://cdn.chegva.com/ueditor/php/upload/image/20220529/1653835381520722.jpeg"><img src="https://cdn.chegva.com/ueditor/php/upload/image/20220529/1653835381520722.jpeg" alt="鲁迅经典语录大全"></a></p><p>\501. 现在的文学也一样，有地方色彩的，倒容易成为世界的，即为别国所注意。</p><p>\502. 关于研究文学的事，真是头绪纷繁，无从说起；外国文却非精通不可，至少一国，英法德日都可，俄更好。这并不难，青年记性好，日记生字数个，常常看书，不要间断，积四五年，一定能到看书的程度的。</p><p>\503. 但学外国文须每日不放下，记生字和文法是不够的，要硬看。比如一本书，拿来硬看，一面翻生字，记文法；到看完，自然不大懂，便放下，再看别的。数月或半年之后，再看前一本，一定比第一次懂得多。这是小儿学语一样的方法。</p><p>\504. 虽然有人数我为’无病呻吟’党之一，但我以为自家有病自家知，旁人大概是不很能够明白底细的。倘没有病，谁来呻吟？如果竟要呻吟，那就已经有了呻吟病了，无法可医。</p><p>\505. 可是我有一种毛病，自己也疑心是自讨苦吃的根苗，就是偶尔要想想。</p><p>\506. 我自然不想太欺骗人，但也未尝将心里的话照样说尽，大约只要看得可以交卷就算完。……因为，我还没有这样勇敢，那原因就是我还想生活，在这社会里。</p><p>\507. 真话呢，我也不想公开，因为现在还是言行不大一致的好。</p><p>\508. 讲话和写文章，似乎都是失败者的征象。……又好像楚霸王救赵破汉，追奔逐北的时候，他并不说什么；等到摆出诗人面孔，饮酒唱歌，那已经兵败势穷，死日临头了。</p><p>\509. 木刻是一种作某用的工具，是不错的，但万不要忘记它是艺术。它之所以是工具，就因为它是艺术的缘故。</p><p>\510. 我所遇见的随便谈谈的青年，我很少失望过，但哗啦哗啦大写口号理论的作家，我却觉得他大抵是呆鸟。</p><p>\511. 中国人的眼睛倘此后渐渐亮起来，无论创作翻译，自然只有坚实者站得住，《狂飙》式的恫吓，只能欺骗一时。</p><p>\512. 因为文艺家至少须有直抒己见的诚心和勇气的，倘不肯吐露本心，就更谈不到什么意识。</p><p>\513. 试翻唐以前的文苑传，大抵是秉承意旨，草檄作颂的人，然而那些作者的文章，流传至今者偏偏少得很。</p><p>\514. 革命成功以后，闲空了一点；有人恭维革命，有人颂扬革命，这已不是革命文学。他们恭维革命，颂扬革命，就是颂扬有权力者，和革命有什么关系？</p><p>\515. 这时，也许有感觉灵敏的文学家，又感到现状的不满意，又要出来开口。从前文艺家的话，政治革命家原是赞同过；直到革命成功，政治家把从前所反对那些人用过的老法子重新采用起来，在文艺家仍不免于不满意，又非被排轧出去不可，或是割掉他的头。</p><p>\516. 但是，文艺家的话，其实还是社会的话，他不过感觉灵敏，早感到早说出来（有时，他说得太早，连社会也反对他，也排轧他）。</p><p>\517. 怒吼的文学一出现，反抗就快到了；他们已经很愤怒，所以与革命爆发时代接近的文学每每带有愤怒之音；他要反抗，他要复仇</p><p>\518. 穷人的孩子，蓬头垢面在街上转，阔人的孩子，妖形妖势，娇声娇气的在家里转，转大了，都昏天黑地的在社会转，同他们的父亲一样，或者还不如。</p><p>\519. 我们目下的当务之急，是：一要生存，二要温饱，三要发展。苟有阻碍这前途者，无论是古是今，是人是鬼，是《三填五典》百宋千元，天球河图，金人玉佛，祖传丸散，秘制膏丹，全都踏倒他。</p><p>\520. 道德这事，必须普遍，人人应做，人人能行，又于自他两利，才有存在的价值。</p><p>\521. 虫蛆也许是不干净的，但它们并没有自鸣清高。</p><p>\522. 散文的体裁，其实是大可以随便的。有破绽也不妨。做作的写信和日记，恐怕也还不免有破绽，而一有破绽，便破灭到不可收拾了。与其防破绽，不如忘破绽。</p><p>\523. 改造自己，总比禁止别人来得难。</p><p>\524. 史家之绝唱，无韵之《离骚》。</p><p>\525. 愈艰难，就愈要做。改革，是向来没有一帆风顺的。</p><p>\526. 唯有民族魂是值得宝贵的，唯有它发扬起来，中国才有真进步。</p><p>\527. 曾经阔气的要复古，正在阔气的要保持现状，未曾阔气的要革新，大抵如此，大抵！</p><p>\528. 要竭力将可有可无的字句段删去，毫不可惜。</p><p>\529. 天才并不是自生自长在深林荒野里的怪物，是由可以使天才生长的民众产生长育出来的，所以没有这种民众，就没有天才。</p><p>\530. 假使做事要面面顾到，那就什么事都不能做了。</p>]]></content>
      
      
      <categories>
          
          <category> 摘录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摘录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈耶克经典语录</title>
      <link href="/archives/a9d8b4e8.html"/>
      <url>/archives/a9d8b4e8.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://cdn.chegva.com/ueditor/php/upload/image/20221126/1669444566190995.jpeg"><img src="https://cdn.chegva.com/ueditor/php/upload/image/20221126/1669444566190995.jpeg" alt="哈耶克经典语录"></a></p><p><a href="https://baike.baidu.com/item/%E5%BC%97%E9%87%8C%E5%BE%B7%E9%87%8C%E5%B8%8C%C2%B7%E5%A5%A5%E5%8F%A4%E6%96%AF%E7%89%B9%C2%B7%E5%86%AF%C2%B7%E5%93%88%E8%80%B6%E5%85%8B">弗里德里希·奥古斯特·冯·哈耶克</a>，（又译为海耶克，Friedrich August von Hayek，1899年5月8日－1992年3月23日）是奥地利出生的英国知名经济学家、政治哲学家，1974年诺贝尔经济学奖得主，被广泛誉为二十世纪最具影响力的经济学家及社会思想家之一。   </p><p>哈耶克的学术生涯主要任教于英国伦敦政治经济学院、美国芝加哥大学以及德国弗赖堡大学，他被广泛视为奥地利经济学派最重要的成员之一，但与芝加哥经济学派关系密切。他坚持自由市场资本主义、自由主义，主要代表作包括《通往奴役之路》《致命的自负》《自由秩序原理》等。1947年，哈耶克主持创办了朝圣山学社（Mont Pelerin Society）。1984年，他获颁英国的荣誉勋爵，以表彰其对经济学研究所做出的贡献。1991年，他获颁美国的总统自由勋章。1992年3月23日，哈耶克于德国弗赖堡逝世，享年92岁。</p><p><a href="https://chegva.com/5573.html">◎《哈耶克作品集：通往奴役之路/自由宪章/致命的自负》全套六册</a></p><hr><p>1、<strong>如果一个人不需要服从任何人，只服从法律，那么，他就是自由的。这样说无论如何都不过分，那就是，法律的目的不是废除和限制自由，而是保护和扩大自由</strong>。</p><p>2、经验和利益的结合，往往会向人们揭示出事件中人们还很少了解的方方面面。</p><p>3、在这个世界上，<strong>平等待人和试图使他人平等这两者之间的差别总是存在</strong>。前者是一个自由社会的前提条件，<strong>而后者意味着“一种新的奴役方式”</strong>。</p><p>4、民主在自由之中寻求平等，而SH主义则在约束和奴役之中寻求平等。</p><p>5、如果从长远考虑，我们是自己命运的创造者，那么，从短期着眼，我们就是我们所创造的观念或思想的俘虏。我们只有及时认识到这种危险，才能指望去避免它。</p><p>6、我们这一代人的共同信念将把我们引向何处，并不是某一党派或国家的问题，而是我们每一个人的问题，是一个有着最重大意义的问题。</p><p>7、<strong>使一个国家变成人间地狱的东西，恰恰是那些“大人物”们总想试图将其变成天堂的东西****。</strong></p><p>8、<strong>民主本质上是一种手段</strong>，<strong>一种保障国内安定和个人自由的实用手段。它本身绝不是一贯正确和可靠无疑的</strong>。</p><p>9、<strong>愿意放弃自由来换取保障的人，其最终既得不到自由，也得不到保障****。</strong></p><p>10、最能清楚地将一个自由国家的状态和一个在专制政府统治下的国家的状况区分开的，莫过于前者遵循着被称为法治的这一伟大原则，而后者不会。</p><p>11、<strong>金钱是人类发明的最伟大的自由工具，只有金钱会向穷人开放，而权力则将永远不会。</strong></p><p>12、在社会的演变、进化过程中，没有什么东西是不可避免的，<strong>使其成为不可避免的是思想</strong>。</p><p>13、<strong>尽最大的可能保护私有财产，肯定是人类社会延续最为重要的必要条件</strong>。</p><p>14、在我们竭尽全力自觉地根据一些崇高的理想缔造我们的未来时，我们却在实际上不知不觉地创造出与我们一直为之奋斗的东西截然相反的结果，人们还想象得出比这更大的悲剧吗?</p><p>15、<strong>一个富人掌权的国家远远比一个掌权之后才能成为富人的国家好得多</strong>。</p><p>16、在还没有领悟到我们做过了许多蠢事这一点之前，我们将不会变得更为明智。</p><p>17、<strong>如果都由一个大得远非一般人所能测度或理解的组织去独揽一切权力和作出大多数重要决定，我们将丝毫不能维护和培育民主</strong>。对此，如果我们能够创造一个适合于小国生存的世界，那对我们大家都会更有好处。</p><p>18、我们这一代人突出的特点并不是我们对物质福利有任何反感，甚或对它的欲望有所收敛或抵制，而是相反，<strong>我们对物质、欲望的追求往往是不加思考和鉴别的照单全收，以至于丢失了自己的初心和其他最好的东西</strong>。</p><p>19、<strong>联邦制组织原则只须善为运用，确能成为对世界上某些最为棘手的问题的最好解决办法</strong>。</p><p>20、有些人争辩说，我们己经以令人惊骇的程度学会了如何驾驭自然力量，但可惜的是，我们在如何成功地利用社会合作的可能性这一方面是落后了。如果此话就此打住，那么它是相当对头的。但是，如果他们继续作出对比并且争辩说，我们必须像学会如何驾驭自然力量那样学会如何驾驭社会力量，那他们就错了。这不仅是一条通向极权主义的道路，而且是一条通向我们文明的毁灭的道路，一条必然阻碍未来进步的道路。</p><p>21、法治的意思就是指政府在一切行动中都受到事前规章的约束。这些规章使得个人可以十分肯定地预见到当局在某种情况下，会如何使用它的强制能力，再根据这种预见规划他的个人事务。</p><p>22、<strong>“科学教会了我们谦卑，我们根本不可能全知全能，无所不通，这就像一切伟大宗教的教诲一样：人不是神，也绝不可能变成神，在神的面前，人必须俯首称臣”</strong>。</p><p>23、只有竞争普遍发生时，也就是说只有在个别生产者必得调整自己的活动以适应价格的变化但不能控制价格的变化时，价格体系才能完成这种职能。</p><p>24、<strong>自由–服从共同的抽象规则；奴役–服从共同的具体目标</strong>。</p><p>25、技术文明越是进步，我们对物或工具的研究就越会获得更重要且有影响的地位，这种地位与对人及其观念研究的地位相对应，这对应着的两种类型的研究之间的分裂就变得越发严重：一种类型代表的是这样的人，他们最大的雄心是把自己、及其周围的世界改造成一架庞大的机器，只要一按电钮，其中每一部分便会按照他们设计的运行；另一种类型则是以这样的人为代表，他们主要关心的是人类心智的全方位发展，他们从历史、文学、艺术或法律的研究中认识到，个人是人类发展、演化过程的一部分，他在这个过程中做出的贡献不是被逼迫的，而是自发的，心甘情愿。他协助创造了一些比他或其他任何单一的头脑所能筹划的东西更伟大的事物。可悲的是，我们目前单纯的科技或文化教育未能提供的，正是这种身为社会演进过程一分子的意识，这种个人的努力相互作用的意识。</p><p>26、<strong>在一个政府是唯一的雇主的国家里，反抗就等于慢慢地饿死。”不劳动者不得食”这个旧的原则，已被”不服从者不得食”这个新的原则所代替</strong>。</p><p>27、在竞争的社会里，穷人的机会比富人的机会所受到的限制要多得多，这一事实丝毫也不影响另一事实的存在，那就是在这种社会里的穷人比在另外一种专制独裁的社会里拥有很大的物质享受的人要自由得多。</p><p>28、经济变化往往只能影响我们的需求的边缘或”边际”。有许多事情远比经济上的得失可能影响到的事情来得重要，对于我们来说，它们的重要性远远超过受经济波动影响的生活上的舒适品，甚至超过许多生活必需品。和它们相比，我们在经济上是否拮据一些或是否宽裕一些的问题，似乎没有多大重要性。</p><p>29、<strong>SH主义所允诺的不是绝对的平等，而是一种更加公平、更加平等的分配。****人们认真想要达到的唯一目标，并不是绝对意义的平等，而只是”较大的平等”而已</strong>。</p><p>30、过去50年中垄断组织不断发展，竞争法则的领域愈来愈受限制，这个历史事实当然是无可争辩的——虽然这种现象的程度常常被大大地夸张了。重要的问题是，这一发展是技术进步的必然后果，还是大多数国家所遵循的政策的后果。我们不久就会看到，这种发展的实际历史强有力地使人想到后者。但我们必须首先考虑一下，<strong>现代技术的这种发展在多大程度上使广泛领域中垄断的发展不可避免</strong>。</p><p>31、<strong>一个秩序之所以可取，不是因为它让其中的要素各就其位，而是在这个秩序上能够生长出其他情况下不能生长出的新力量</strong>。</p><p>32、经济价值对于我们之所以没有许多东西那么重要，正是由于在经济事务上，我们能够自由决定什么对我们比较重要，什么对我们比较次要的缘故。或者我们也许可以这样说，是由于在现在的社会中，必须去解决我们生活中的经济问题的，乃是我们自已。</p><p>33、自由主义者对社会的态度，像一个照顾植物的园丁，为了创造最适宜于它成长的条件，必须尽可能了解它们的结构、所处的环境以及这些结构、环境是如何起作用的。</p><p>34、SH主义者信仰两种截然不同甚至也许是<strong>相互矛盾的东西：自由和组织</strong>。</p><p>35、当代种种事件不同于过去的历史事件之处，就在于我们不能确切知道它们会产生什么后果。</p><p>36、政府不能乱印钞票，因为这样会造成经济环境趋于恶劣，实业出现寡头化，导致金融系统或金融企业成为社会中的特权贵族；<strong>事实证明，多年的加印钞票往往使得大多数普通民众的工资涨幅远远比不上货币贬值（物价上涨）的速度；而惩罚储蓄导致没有储蓄，拉大贫富差距；还有中小企业破产、失业率增加和金融系统、房地产领域的泡沫会一起导致并加重社会整体经济的周期性萧条</strong>。</p><p>37、<strong>市场经济</strong>是人类迄今所能发现的最有效率且较为理想的一种资源配置体制。</p><p>38、SH主义者有许多特点：<strong>日益崇拜国家，倾慕权力，好大喜功</strong>，热衷于使任何事情都<strong>“组织化”</strong>和<strong>“不能让任何事情听命于有机发展的简单力量”</strong>。</p><p>39、<strong>法治意味着，政府除非实施众所周知的规则，否则不得对个人实施强制</strong>。</p><p>40、<strong>经济活动的完全集中管理这一观念</strong>，仍然使大多数人感到胆寒，这不仅是由于这项任务存在着极大的困难，而更多地是由于每一件事都要由一个独一无二的中心来加以指导的观念所引起的恐惧。</p><p>41、我们认为我们个人排列各种价值的顺序不仅是个人的排列顺序，而是在有理性的人们的自由讨论中，我们会使别人相信我们的顺序是正确的。</p><p>42、竞争和集中管理二者如果是不完全的，都将成为拙劣的和无效率的工具，它们是用来解决同一问题的只能任择其一的原则，把两者混合起来就意味着哪一个也不能真正地起作用，其结果反而比始终只凭借二者之一的情况还要糟些。或者换一种说法：<strong>计划与竞争只有在为竞争而计划而不是运用计划反对竞争的时候，才能够结合起来</strong>。</p><p>43、<strong>对财富生产的控制，就是对人类生活本身的控制</strong>。</p><p>44、在共同目标对人们并非一种终极目标而是一种能够用于多种多样意图的手段的地方，人们才最可能对共同行动达成共识。</p><p>45、<strong>通往地狱的路，都是由善意铺成的</strong>。</p><p>46、只有在自由主义时代，法治才被有意识地加以发展，并且是自由主义时代最伟大的成就之一，它不仅是自由的保障，而且也是自由在法律上的体现。</p><p>47、自生自发秩序在处理正义问题时完全满足‘纯粹程序正义’的主要特征：‘<strong>不存在判定正当结果的独立标准，而是存在一种正确的或公平的程序</strong>’，这种程序若被人们恰当地遵守，其结果也会是正确的或公平的，而无论它们可能会是一些什么样的结果。</p><p>48、<strong>通过赋予政府以无限制的权力，可以把最专断的统治合法化</strong>；并且一个民主制度就可以以这样一种方式建立起一种可以想象得到的最完全的专制政治来。</p><p>49、不错，除非利用感官知觉，即利用对自然事实的观察，我们对别人的心思一无所知。然而这并不意味着我们只知道自然事实。我们在一门学科中必须研究哪些事实，不取决于我们学科所研究的特定对象所具有的全部属性，而仅仅取决于我们为了这门学科而分离出的那些属性。</p><p>50、我们这一代人的巨大不幸是，自然科学令人称奇的进步所导致的对支配的兴趣，并没有帮助我们理解这个我们只是其中一部分的更大过程，或使我们认识到在不支配这个过程也不服从别人命令的情况下，我们如何不断地为共同的努力做着贡献。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《三国志》精华50则</title>
      <link href="/archives/9de6303f.html"/>
      <url>/archives/9de6303f.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>《三国志》是由西晋史学家陈寿所著，记载中国三国时代的断代史，同时也是二十四史中评价最高的“前四史”之一。</p><p>诗词君从中精心整理了50则，句句智慧，读懂受益一生，让我们一起细细品味！</p><p>转载自：<a href="https://mp.weixin.qq.com/s/TUP4Z0ZeHuIVrZGLCSvrqg">https://mp.weixin.qq.com/s/TUP4Z0ZeHuIVrZGLCSvrqg</a></p><p>相关：<a href="https://chegva.com/3027.html">鉴古知今,经典名言45句,全是智慧！</a></p><p><strong>——修身篇——</strong></p><p><strong>1、经危蹈险，不易其节；金声玉色，久而弥彰。</strong></p><p>虽经历危险，而不改变节操；如同金声玉色般的高贵品质，时间愈久愈能显现出来。</p><p><strong>2、戒慎乎其所不睹，恐惧乎其所弗闻。</strong></p><p>在别人看不见的时候知道戒慎，在别人听不见的时候知道警惕。</p><p><strong>3、但知乐，不知苦；不知苦，必将以骄奢为失。</strong></p><p>只知道享乐，不知道艰苦；不知道艰苦的人，一定会因为骄奢而犯过失。</p><p><strong>4、物速成则疾亡，晚就则善终。</strong></p><p>事情成功得快就败亡得快，成功得晚就能始终保持长久。</p><p>所谓欲速则不达、大器晚成；速成的，往往根基不牢。</p><p><strong>5、救寒莫若重裘，止谤莫如自修。</strong></p><p>解除寒冷没有比多穿一件皮衣更好的了，让别人停止对自己的诽谤没有比加强自身修养更好的了。</p><p>自修以止谤，既是止谤的良法，又是一个人教养的表现。</p><p><strong>6、人或毁己，当退而求知于身。</strong></p><p>如果有人说自己的坏话，应当回过头反省自己。有则改之，无则加勉。</p><p><strong>7、君子之行，皆积小以成高大。</strong></p><p>君子的品行，都是积累小的德行而后成为大的德行。</p><p><strong>8、勿以恶小而为之，勿以善小而不为。</strong></p><p>不要因为是件较小的坏事就去干，不要因为是件较小的善事就毫不关心。</p><p><strong>9、畜德之厚，在于多识往行。</strong></p><p>蓄积德行而使之深厚，在于多了解<a href="https://chegva.com/tag/%E5%8E%86%E5%8F%B2/">历史</a>、过往。</p><p><strong>10、立身之根本，莫大于言行。</strong></p><p>在社会上立身，没有比言行更重要的了。</p><p>言行得体，需要修养深厚，因为言行本是修养自内而外的展现。</p><p><strong>11、事不可自谓己长。</strong></p><p>凡事不可自以为比别人强。</p><p>天外有天、人外有人，谦虚谨慎，不断地弃己之短、学人之长，才能不断进步。</p><p><strong>12、闻恶必改，而不矜过。</strong></p><p>知道了自己的缺点错误就一定改正，而不坚持过错。</p><p><strong>13、良药苦口，惟疾者能甘之；忠言逆耳，惟达者能受之。</strong></p><p>良药吃到嘴里很苦，只有得病的人甘愿吃它；忠告的话听起来很不顺耳，只有明达的人能接受它。</p><p><strong>14、能知其所短而不用，此贤者之大也，知所短则知所长。</strong></p><p>能够了解自己的短处而避开不用，这是贤者中的大贤；知道了自己的短处就知道了自己的长处。</p><p><strong>15、外同乎俗，内秉纯洁。</strong></p><p>表面同一般人一样，而内心坚守纯洁的美德。世事复杂，需要我们和光同尘、入乡随俗。</p><p>**<br>**</p><p><strong>——<a href="https://chegva.com/tag/%E8%AF%BB%E4%B9%A6/">读书</a>篇——</strong></p><p>**<br>**</p><p><strong>1、升堂入室，究其阃奥。</strong></p><p>由表及里，由浅入深，是探究学问的奥秘所在。</p><p>凡读书，要想有所成就，必须如此，而决不可浮光掠影、浅尝辄止。</p><p><strong>2、读书百遍，而义自见。</strong></p><p>书读多遍，意思自然就明白了。</p><p><strong>3、冬者岁之余，夜者日之余，阴雨者时之余。</strong></p><p>冬季是一年的多余时间，夜晚是白天的多余时间，阴雨天是四季都有的多余时间。</p><p>读书学习，要善于自己找时间、挤时间。</p><p><strong>4、学猥则倦，倦则意怠。</strong></p><p>读书多而杂乱就会失去兴趣，失去兴趣读书的意志就会懈怠。</p><p>书海无涯，学必专精，专精才能有所得，有所得而后愈增学习的兴趣。</p><p><strong>5、盲者欲视黑白，聋者欲听清音，苦而无功。</strong></p><p>瞎子而想看见颜色，聋子而想听到声音，再苦也终不可得。</p><p>任何一门学问有其学习的方法和门径。</p><p><strong>6、书籍之事，患人不好，好之无伤也。</strong></p><p>关于读书，就怕人不喜欢，喜欢就绝没有坏处。</p><p>所以对于读书，兴趣是第一位的，培养自己的兴趣是最关键的。</p><p><strong>——奋斗篇——</strong></p><p><strong>1、居世间，当自为之，而但观他人乎？</strong></p><p>人活在世上，应当靠自己努力，怎能只看他人呢！</p><p><strong>2、有其志，必成其事。</strong></p><p>有那种志向，就一定能成就那种事业。</p><p>有志者，事竟成。</p><p><strong>3、良田百倾，不在一亩；但有远志，不在当归。</strong></p><p>我已有百亩良田，心不在一亩；我只有远大志向，心不在归家。</p><p>心怀远大志向，不在归家，年轻人应当有这样的干云豪气和思想境界。</p><p><strong>4、志行万里者，不中道而辍足；图四海者，匪怀细以害大。</strong></p><p>志在远行千里的人，不中途而停足不前；有天下大志的人，不计较细小的事情以免损害大计。</p><p><strong>5、少壮真当努力，年一过往，何可攀援！</strong></p><p>少壮的时候真应当努力，年华一过，还怎么可以留得住！</p><p>人年轻时就要奋发上进，否则年华老去，一事无成，只能悔之晚矣。</p><p><strong>6、行非常之事，乃有非常之功。</strong></p><p>只有干非常之事，才能取得非常的成功。</p><p><strong>——处世篇——</strong></p><p><strong>1、士之出处，宜度德投趾，可不之节，必审于所蹈。</strong></p><p>士人出仕或处世，应该先用德的标准来衡量然后再决定自己的行动，当遇到可行与不可行的抉择时刻，一定要审慎地做出选择。</p><p><strong>2、志士不探乱以侥幸，智者不诡道以自危。</strong></p><p>志士不混迹乱世中意图投机，智者不用欺诈手段使自己陷身危险。</p><p><strong>3、知足不辱。</strong></p><p>人知道满足，就不会遭受屈辱。知足不辱与贪得无厌恰成鲜明对比。</p><p><strong>4、巧诈不如拙诚。</strong></p><p>善于巧诈，还不如拙笨诚实。</p><p><strong>5、以善相待，无不致快也；以不善相待，无不致嫌隙也。</strong></p><p>对人以善意相待，没有不愉快的；以不善意相待，没有不造成矛盾的。</p><p><strong>6、凡人行事，年少立身，不可不慎，勿轻论人，勿轻说事。</strong></p><p>人从年轻时候起，立身行事，不可不谨慎，不要轻易议论别人，也不要轻易评论事情。</p><p><strong>7、有南威之容，乃可以论于淑媛；有龙渊之利，乃可以议于割断。</strong></p><p>有南威（春秋时晋国美女）那样的容貌，才可以议论美女；有龙渊剑（战国时韩国宝剑）那样的锋利，才可以议论宝剑。</p><p>人不可好为人师，有其才而后可论其事。才陋而不知谦下，喜欢轻易诋毁他人，只能招人反感愤恨。</p><p><strong>8、势可得而我勤之，此重得也；势不可得而我勤之，此重失也。</strong></p><p>根据形势可以得到的东西我努力争取，就可以获得重大成功；根据形势不可以得到的东西我去努力争夺，就会遭到重大失败。</p><p><strong>9、知人者智，自知者明；凡在贤达之流，固必兼而有焉。</strong></p><p>能知人的人称智，能自知的人称明。能在贤达之列的人，一定兼具这两种能力。</p><p><strong>10、记人之善，忘人之过。</strong></p><p>要记别人的善行、善举，忘记别人的过失、过错。</p><p><strong>11、非才而据，咎悔必至。</strong></p><p>不具备某项才能而担任某个职务，失误和过错会接踵而至。</p><p><strong>12、素丝无常，唯所染之。</strong></p><p>尚未染色的绢没有颜色，给它染什么颜色它就是什么颜色。</p><p><strong>13、功高而居之以让，势尊而居之以卑。</strong></p><p>立了大功知道礼让，地位高贵能够谦卑。居功自傲，必招致失败。</p><p><strong>14、开诚心，布公道。</strong></p><p>对人以诚心相待，公正无私地发表自己的见解。</p><p><strong>15、信言不艳。</strong></p><p>诚实的话不玩弄辞藻。信言不艳，贵在诚实。花言巧语，实藏诈伪。</p><p><strong>——谋略篇——</strong></p><p><strong>1、事留变生，后机祸至。</strong></p><p>事情滞留不办就会发生变化，贻误时机就会招来灾祸。</p><p><strong>2、权不失机，功在速捷。</strong></p><p>权变而不失时机，成功在于行动迅速。</p><p><strong>3、事固有弃此取彼者：以大易小可也，以安易危可也，权一时之势不患本之不固可也。</strong></p><p>事情确实常有抛弃这个而采取那个的情况：用大的换掉小的可以做，用安全的换掉危险的可以做，权衡一时的形势而不必担心根本不得巩固可以做。</p><p><strong>4、难得而易失者，时也；时至而不旋踵者，机也。</strong></p><p>难以得到而容易失去的东西是时间，时间到了就会来但却无不转瞬即逝的是机遇。</p><p><strong>5、观古今之成败，能先见事机者，则恒受其福。</strong></p><p>考察一下古今成败的例子，能先发现事机的人，就总是能得到好处。</p><p><strong>6、权变之时，固非一道能定。</strong></p><p>权宜机变的时候，本来就不是一种办事原则能定的。</p><p><strong>7、能屈以为伸，让以为得，弱以为强，鲜不遂矣。</strong></p><p>能够以屈求伸，以让求得，以弱求强，很少有不成功的。</p><p><strong>8、智者不为小利移目，不为意似改步，时可而后动，数合而后举。</strong></p><p>有智慧的人不被小利与似是而非的状况蒙蔽，时机成熟、条件具备后才开始行动。</p>]]></content>
      
      
      <categories>
          
          <category> 文学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摘录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《史记》中30句名言和注解</title>
      <link href="/archives/ee568259.html"/>
      <url>/archives/ee568259.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="《史记》中30句名言和注解，句句经典，受益无穷！"><a href="#《史记》中30句名言和注解，句句经典，受益无穷！" class="headerlink" title="《史记》中30句名言和注解，句句经典，受益无穷！"></a>《史记》中30句名言和注解，句句经典，受益无穷！</h1><p>1.天下熙熙，皆为利来；天下攘攘，皆为利往。</p><p>释：天下吵吵嚷嚷，都是为私利而来；天下拥挤奔忙，都是为私利而往。</p><p>2.桃李不言，下自成蹊。</p><p>释：桃树和李树不招引人，但人们会在它下面走来走去，自然而然地走出一条小路。比喻人只要真诚、忠实，就能感动别人。</p><p>3.飞鸟尽，良弓藏，狡兔死，走狗烹，敌国破，谋臣亡。</p><p>释：把鸟打尽了，打完了，那良弓就没有用处了；兔子已死，那狗也没用了，不如烹了吃掉；攻陷了敌国，将臣也就没用了，可以杀掉了。指一个人失去了利用价值，就可能会落得很惨的下场。</p><p>4.以权利合者，权利尽而交疏。</p><p>释：因权势利益而结合的朋友．一旦权尽利绝，交情就会疏远。</p><p>5.众口铄金，积毁销骨。</p><p>释：众口一词，能把金石熔化；多次诽谤，能把人才毁灭。</p><p>6.人弃我取，人取我与。</p><p>释：原指商人廉价收买滞销物品，待涨价卖出以获取厚利。后用来表示自己的志趣、见地与他人不同。</p><p>7.家累千金，坐不垂堂。</p><p>释：意指家财富有的人常自珍爱，不自蹈险地。</p><p>8.当断不断，反受其乱。</p><p>释：应当采取果断行动时没有果断采取，贻误了时机，反而会遭受到祸乱。</p><p>9.千羊之皮，不如一狐之腋；千人之诺诺，不如一士之谔谔。</p><p>释：一千张羊皮也不如一张狐狸皮；众多唯唯诺诺之人，不如一名诤谏之士可贵。</p><p>10.相马失之瘦，相士失之贫。</p><p>释：相马者往往因为马瘦而看错马的材质，相人者往往因为人穷而忽略人的才能。</p><p>11.能行之者未必能言，能言之者未必能行。</p><p>释：能做的人未必能说，能说的人未必能做。</p><p>12.智者千虑，必有一失；愚者千虑，必有一得。</p><p>释：聪明的人在上千次考虑中，总会有一次失误；愚蠢的人在上千次考虑中，总会有一次收获。</p><p>13.前虑不定，后有大患。</p><p>释：做事之前考虑不成熟，到后来就可能发生大灾祸。</p><p>14.规小节者不能成荣名，恶小耻者不能立大功。</p><p>释：谋求小节的人不能成就荣耀的名声，以小耻为耻的人不能建立大的功业。</p><p>15.家贫则思良妻，国乱则思良相。</p><p>释：家庭贫穷就想到应有贤良的妻子，国家混乱就想到要有贤能的宰相。</p><p>16.运筹策帷帐之中，决胜于千里之外。</p><p>释：运筹谋于帷帐之中，而能决定胜利于千里以外。</p><p>17.燕雀安知鸿鹄之志哉！</p><p>释：燕雀怎么能知道鸿鹄的远大志向，比喻平凡的人哪里知道英雄人物的志向。</p><p>18.王侯将相宁有种乎？</p><p>释：那些称王侯拜将相的人，天生就是好命、贵种吗？</p><p>19.富而不骄，贵而不舒。</p><p>释：很富有但不趾高气扬，富贵了也不和自己以前的亲朋好友疏远怠慢。</p><p>20.善用兵者，不以短击长，而以长击短。</p><p>释：善于用兵打仗的将领，不用自己的短处去攻击敌人的长处，而是以自己的长处去攻击敌人的短处。</p><p>21.人方为刀俎，我为鱼肉。</p><p>释：生杀大权掌握在别人手里，自己处在被宰割的地位。</p><p>22.得黄金百，不如得季布一诺。</p><p>释：得到一百斤黄金，不如得到季布一句表示允诺的话。形容季布信守诺言的可贵。</p><p>23.一死一生，乃知交情；一贫一富，乃知交态；一贵一贱，交情乃见。</p><p>释：生死关头，才能看出友情的忠贞与否；在贫富变化的时候，才能看出友情的深浅；在得势与失势的变化中，才能考验出友情的真假。</p><p>24.士为知己者死，女为悦己者容。</p><p>释：男人愿意为赏识自己的人赴死，女人愿意为欣赏自己的人精心妆扮。</p><p>25.骐骥之跼躅，不如驽马之安步。</p><p>释：骏马徘徊不进，不如劣马稳步向前。比喻做大事的人，不要受细小的事情所羁绊，做事情要果断。</p><p>26.项庄舞剑，意在沛公。</p><p>释：项庄席间舞剑，企图刺杀刘邦。比喻说话和行动的真实意图别有所指。</p><p>27.物有必至，事有固然。</p><p>释：事物发展有它必然的归宿，人情世态有它本来的面貌。</p><p>28.恃德者昌，恃力者亡。</p><p>释：依靠美德的一定兴旺发达，凭借暴力的必将灭亡。</p><p>29.将在军，君命有所不受。</p><p>释：意指将领在军队中指挥作战，君主的命令在特殊紧急地情况下可以不接受。</p><p>30.鸟之将死，其鸣也哀；人之将死，其言也善。</p><p>释：鸟将要死去的时候，它的鸣叫声是悲哀的；而人将要去世之时，他的话语往往会是善意的。</p>]]></content>
      
      
      <categories>
          
          <category> 文学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摘录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis-plus笔记</title>
      <link href="/archives/afec5f7c.html"/>
      <url>/archives/afec5f7c.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、MyBatis-Plus"><a href="#一、MyBatis-Plus" class="headerlink" title="一、MyBatis-Plus"></a>一、MyBatis-Plus</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p><a href="https://github.com/baomidou/mybatis-plus">MyBatis-Plus (opens new window)</a>（简称 MP）是一个 <a href="https://www.mybatis.org/mybatis-3/">MyBatis (opens new window)</a>的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p><blockquote><p>我们的愿景是成为 MyBatis 最好的搭档，就像 <a href="https://baomidou.com/img/contra.jpg">魂斗罗</a> 中的 1P、2P，基友搭配，效率翻倍。</p></blockquote><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/relationship-with-mybatis.png" alt="img"></p><span id="more"></span><h2 id="2-特性"><a href="#2-特性" class="headerlink" title="2.特性"></a>2.特性</h2><ul><li><strong>无侵入</strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑</li><li><strong>损耗小</strong>：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作</li><li><strong>强大的 CRUD 操作</strong>：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求</li><li><strong>支持 Lambda 形式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</li><li><strong>支持主键自动生成</strong>：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题</li><li><strong>支持 ActiveRecord 模式</strong>：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作</li><li><strong>支持自定义全局通用操作</strong>：支持全局通用方法注入（ Write once, use anywhere ）</li><li><strong>内置代码生成器</strong>：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用</li><li><strong>内置分页插件</strong>：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询</li><li><strong>分页插件支持多种数据库</strong>：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库</li><li><strong>内置性能分析插件</strong>：可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询</li><li><strong>内置全局拦截插件</strong>：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作</li></ul><h2 id="3-支持数据库"><a href="#3-支持数据库" class="headerlink" title="3.支持数据库"></a>3.支持数据库</h2><blockquote><p>任何能使用 <code>MyBatis</code> 进行 CRUD, 并且支持标准 SQL 的数据库，具体支持情况如下，如果不在下列表查看分页部分教程 PR 您的支持。</p></blockquote><ul><li>MySQL，Oracle，DB2，H2，HSQL，SQLite，PostgreSQL，SQLServer，Phoenix，Gauss ，ClickHouse，Sybase，OceanBase，Firebird，Cubrid，Goldilocks，csiidb</li><li>达梦数据库，虚谷数据库，人大金仓数据库，南大通用(华库)数据库，南大通用数据库，神通数据库，瀚高数据库</li></ul><h2 id="4-框架结构"><a href="#4-框架结构" class="headerlink" title="4.框架结构"></a>4.框架结构</h2><p><img src="https://baomidou.com/img/mybatis-plus-framework.jpg" alt="framework"></p><h2 id="5-官方地址"><a href="#5-官方地址" class="headerlink" title="5.官方地址"></a>5.官方地址</h2><blockquote><p><strong>官方网站</strong>：<a href="https://baomidou.com/">https://baomidou.com/</a></p><p><strong>官方文档</strong>：<a href="https://baomidou.com/pages/24112f/">https://baomidou.com/pages/24112f/</a></p></blockquote><h1 id="二、入门案例"><a href="#二、入门案例" class="headerlink" title="二、入门案例"></a>二、入门案例</h1><h2 id="1-开发环境"><a href="#1-开发环境" class="headerlink" title="1.开发环境"></a>1.开发环境</h2><ul><li><strong>IDE：IDEA 2019.3.5</strong></li><li><strong>JDK：JDK8+</strong></li><li><strong>构建工具：Maven 3.5.4</strong></li><li><strong>MySQL：MySQL 8.0.24</strong></li><li><strong>Navicat：Navicat Premium 15</strong></li><li><strong>Spring Boot：2.6.7</strong></li><li><strong>MyBatis-Plus：3.5.1</strong></li></ul><h2 id="2-建库建表"><a href="#2-建库建表" class="headerlink" title="2.建库建表"></a>2.建库建表</h2><ul><li><p><strong>打开Navicat运行以下SQL脚本进行建库建表</strong></p><pre class="line-numbers language-none"><code class="language-none">CREATE DATABASE `mybatis_plus` /*!40100 DEFAULT CHARACTER SET utf8mb4 */; use `mybatis_plus`; CREATE TABLE `user` (     `id` bigint(20) NOT NULL COMMENT '主键ID',     `name` varchar(30) DEFAULT NULL COMMENT '姓名',     `age` int(11) DEFAULT NULL COMMENT '年龄',     `email` varchar(50) DEFAULT NULL COMMENT '邮箱',     PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>插入几条测试数据</strong></p><pre class="line-numbers language-none"><code class="language-none">INSERT INTO user (id, name, age, email) VALUES (1, 'Jone', 18, 'test1@baomidou.com'), (2, 'Jack', 20, 'test2@baomidou.com'), (3, 'Tom', 28, 'test3@baomidou.com'), (4, 'Sandy', 21, 'test4@baomidou.com'), (5, 'Billie', 24, 'test5@baomidou.com');sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="3-创建工程"><a href="#3-创建工程" class="headerlink" title="3.创建工程"></a>3.创建工程</h2><ul><li><p><strong>使用<code>Spring Initializer</code>快速初始化一个 Spring Boot 工程</strong></p></li><li><p><strong>引入<code>MyBatis-Plus</code>的依赖</strong></p><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;    &lt;version&gt;3.5.1&lt;/version&gt;&lt;/dependency&gt;xml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>安装<code>Lombok</code>插件</strong></p></li></ul><h2 id="4-配置编码"><a href="#4-配置编码" class="headerlink" title="4.配置编码"></a>4.配置编码</h2><ul><li><p><strong>配置<code>application.yml</code>文件</strong></p><pre class="line-numbers language-none"><code class="language-none">#配置端口server:  port: 80spring:  #配置数据源  datasource:    #配置数据源类型    type: com.zaxxer.hikari.HikariDataSource    #配置连接数据库的信息    driver-class-name: com.mysql.cj.jdbc.Driver    url: jdbc:mysql://localhost:3306/mybatis_plus?characterEncoding=utf-8&amp;useSSL=false    username: {username}    password: {password}#MyBatis-Plus相关配置mybatis-plus:  configuration:    #配置日志    log-impl: org.apache.ibatis.logging.stdout.StdOutImplyml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>在 Spring Boot 启动类中添加 <code>@MapperScan</code> 注解，扫描 Mapper 文件夹</strong></p><pre class="line-numbers language-none"><code class="language-none">@SpringBootApplication@MapperScan("指定Mapper接口所在的包")public class MybatisPlusDemoApplication {public static void main(String[] args) {SpringApplication.run(MybatisPlusDemoApplication.class, args);}}java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>编写实体类 <code>User.java</code>（此处使用了 Lombok 简化代码）</strong></p><pre class="line-numbers language-none"><code class="language-none">@Datapublic class User {    private Long id;    private String name;    private Integer age;    private String email;}java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>编写 Mapper 包下的 <code>UserMapper</code>接口</strong></p><pre class="line-numbers language-none"><code class="language-none">public interface UserMapper extends BaseMapper&lt;User&gt; {}java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h2 id="5-测试查询"><a href="#5-测试查询" class="headerlink" title="5.测试查询"></a>5.测试查询</h2><ul><li><p><strong>编写一个测试类<code>MyBatisPlusTest.java</code></strong></p><pre class="line-numbers language-none"><code class="language-none">@SpringBootTestpublic class MyBatisPlusTest {    @Resource    private UserMapper userMapper;    /**     * 测试查询所有数据     */    @Test    void testSelectList(){        //通过条件构造器查询一个list集合，若没有条件，则可以设置null为参数        List&lt;User&gt; users = userMapper.selectList(null);        users.forEach(System.out::println);    }}java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>控制台打印查询结果</strong></p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220519150454211.png" alt="image-20220519150454211"></p></li></ul><h1 id="三、增删改查"><a href="#三、增删改查" class="headerlink" title="三、增删改查"></a>三、增删改查</h1><h2 id="1-BaseMapper"><a href="#1-BaseMapper" class="headerlink" title="1.BaseMapper"></a>1.BaseMapper<t></t></h2><blockquote><p>说明:</p><p>通用 CRUD 封装BaseMapper 接口，为 <code>Mybatis-Plus</code> 启动时自动解析实体表关系映射转换为 <code>Mybatis</code> 内部对象注入容器</p><p>泛型 <code>T</code> 为任意实体对象</p><p>参数 <code>Serializable</code> 为任意类型主键 <code>Mybatis-Plus</code> 不推荐使用复合主键约定每一张表都有自己的唯一 <code>id</code> 主键</p><p>对象 <code>Wrapper</code> 为条件构造器</p></blockquote><p>MyBatis-Plus中的基本CRUD在内置的BaseMapper中都已得到了实现，因此我们继承该接口以后可以直接使用。</p><p>本次演示的CRUD操作不包含参数带有条件构造器的方法，关于条件构造器将单独在一个章节进行演示。</p><hr><blockquote><p><strong>BaseMapper中提供的CRUD方法：</strong></p></blockquote><ul><li><p><strong>增加：Insert</strong></p><pre class="line-numbers language-none"><code class="language-none">// 插入一条记录int insert(T entity);java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><strong>删除：Delete</strong></p><pre class="line-numbers language-none"><code class="language-none">// 根据 entity 条件，删除记录int delete(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; wrapper);// 删除（根据ID 批量删除）int deleteBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable&gt; idList);// 根据 ID 删除int deleteById(Serializable id);// 根据 columnMap 条件，删除记录int deleteByMap(@Param(Constants.COLUMN_MAP) Map&lt;String, Object&gt; columnMap);java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>修改：Update</strong></p><pre class="line-numbers language-none"><code class="language-none">// 根据 whereWrapper 条件，更新记录int update(@Param(Constants.ENTITY) T updateEntity, @Param(Constants.WRAPPER) Wrapper&lt;T&gt; whereWrapper);// 根据 ID 修改int updateById(@Param(Constants.ENTITY) T entity);java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>查询：Selete</strong></p><pre class="line-numbers language-none"><code class="language-none">// 根据 ID 查询T selectById(Serializable id);// 根据 entity 条件，查询一条记录T selectOne(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 查询（根据ID 批量查询）List&lt;T&gt; selectBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable&gt; idList);// 根据 entity 条件，查询全部记录List&lt;T&gt; selectList(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 查询（根据 columnMap 条件）List&lt;T&gt; selectByMap(@Param(Constants.COLUMN_MAP) Map&lt;String, Object&gt; columnMap);// 根据 Wrapper 条件，查询全部记录List&lt;Map&lt;String, Object&gt;&gt; selectMaps(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 根据 Wrapper 条件，查询全部记录。注意： 只返回第一个字段的值List&lt;Object&gt; selectObjs(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 根据 entity 条件，查询全部记录（并翻页）IPage&lt;T&gt; selectPage(IPage&lt;T&gt; page, @Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 根据 Wrapper 条件，查询全部记录（并翻页）IPage&lt;Map&lt;String, Object&gt;&gt; selectMapsPage(IPage&lt;T&gt; page, @Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 根据 Wrapper 条件，查询总记录数Integer selectCount(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="2-调用Mapper层实现CRUD"><a href="#2-调用Mapper层实现CRUD" class="headerlink" title="2.调用Mapper层实现CRUD"></a>2.调用Mapper层实现CRUD</h2><h3 id="2-1-插入"><a href="#2-1-插入" class="headerlink" title="2.1 插入"></a>2.1 插入</h3><hr><blockquote><p><strong>最终执行的结果，所获取的id为1527206783590903810</strong></p><p><strong>这是因为MyBatis-Plus在实现插入数据时，会默认基于雪花算法的策略生成id</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">/**  * 测试插入一条数据  * MyBatis-Plus在实现插入数据时，会默认基于雪花算法的策略生成id  */@Testpublic void testInsert(){    User user = new User();    user.setName("Vz");    user.setAge(21);    user.setEmail("vz@oz6.cn");    int result = userMapper.insert(user);    System.out.println(result &gt; 0 ? "添加成功！" : "添加失败！");    System.out.println("受影响的行数为：" + result);    //1527206783590903810（当前 id 为雪花算法自动生成的id）    System.out.println("id自动获取" + user.getId());}java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-删除"><a href="#2-2-删除" class="headerlink" title="2.2 删除"></a>2.2 删除</h3><hr><h4 id="a、根据ID删除数据"><a href="#a、根据ID删除数据" class="headerlink" title="a、根据ID删除数据"></a>a、根据ID删除数据</h4><blockquote><p><strong>调用方法：int deleteById(Serializable id);</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">/**  * 测试根据id删除一条数据  */@Testpublic void testDeleteById(){    int result = userMapper.deleteById(1527206783590903810L);    System.out.println(result &gt; 0 ? "删除成功！" : "删除失败！");    System.out.println("受影响的行数为：" + result);}java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="b、根据ID批量删除数据"><a href="#b、根据ID批量删除数据" class="headerlink" title="b、根据ID批量删除数据"></a>b、根据ID批量删除数据</h4><blockquote><p><strong>调用方法：int deleteBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable&gt; idList);</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">/**  * 测试通过id批量删除数据  */@Testpublic void testDeleteBatchIds(){    List&lt;Long&gt; ids = Arrays.asList(6L,7L,8L);    int result = userMapper.deleteBatchIds(ids);    System.out.println(result &gt; 0 ? "删除成功！" : "删除失败！");    System.out.println("受影响的行数为：" + result);}java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="c、根据Map条件删除数据"><a href="#c、根据Map条件删除数据" class="headerlink" title="c、根据Map条件删除数据"></a>c、根据Map条件删除数据</h4><blockquote><p><strong>调用方法：int deleteByMap(@Param(Constants.COLUMN_MAP) Map&lt;String, Object&gt; columnMap);</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">/**   * 测试根据Map集合中所设置的条件删除数据   */@Testpublic void testDeleteByMap(){    //当前演示为根据name和age删除数据    //执行SQL为：DELETE FROM user WHERE name = ? AND age = ?    Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();    map.put("name","Vz");    map.put("age",21);    int result = userMapper.deleteByMap(map);    System.out.println(result &gt; 0 ? "删除成功！" : "删除失败！");    System.out.println("受影响的行数为：" + result);}java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-修改"><a href="#2-3-修改" class="headerlink" title="2.3 修改"></a>2.3 修改</h3><blockquote><p><strong>调用方法：int updateById(@Param(Constants.ENTITY) T entity);</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">/**  * 测试根据id修改用户信息  */@Testpublic void testUpdateById(){    //执行SQL为： UPDATE user SET name=?, age=?, email=? WHERE id=?    User user = new User();    user.setId(6L);    user.setName("VzUpdate");    user.setAge(18);    user.setEmail("Vz@sina.com");    int result = userMapper.updateById(user);    System.out.println(result &gt; 0 ? "修改成功！" : "修改失败！");    System.out.println("受影响的行数为：" + result);}java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-4-查询"><a href="#2-4-查询" class="headerlink" title="2.4 查询"></a>2.4 查询</h3><hr><h4 id="a、根据ID查询用户信息"><a href="#a、根据ID查询用户信息" class="headerlink" title="a、根据ID查询用户信息"></a>a、根据ID查询用户信息</h4><blockquote><p><strong>调用方法：T selectById(Serializable id);</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">/**  * 测试根据id查询用户数据  */@Testpublic void testSelectById(){    User user = userMapper.selectById(1L);    System.out.println(user);}java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="b、根据多个ID查询多个用户信息"><a href="#b、根据多个ID查询多个用户信息" class="headerlink" title="b、根据多个ID查询多个用户信息"></a>b、根据多个ID查询多个用户信息</h4><blockquote><p><strong>调用方法：List selectBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable&gt; idList);</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">/**  * 根据多个id查询用户数据  */@Testpublic void testSelectBatchIds(){    //执行SQL为：SELECT id,name,age,email FROM user WHERE id IN ( ? , ? , ? )    List&lt;Long&gt; ids = Arrays.asList(1L,2L,3L);    List&lt;User&gt; users = userMapper.selectBatchIds(ids);    users.forEach(System.out::println);}java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="c、根据Map条件查询用户信息"><a href="#c、根据Map条件查询用户信息" class="headerlink" title="c、根据Map条件查询用户信息"></a>c、根据Map条件查询用户信息</h4><blockquote><p><strong>调用方法：List selectByMap(@Param(Constants.COLUMN_MAP) Map&lt;String, Object&gt; columnMap);</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">/**  * 根据Map所设置的条件查询用户  */@Testpublic void testSelectByMap(){    //执行SQL为：SELECT id,name,age,email FROM user WHERE age = ?    Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();    map.put("age",18);    List&lt;User&gt; users = userMapper.selectByMap(map);    users.forEach(System.out::println);}java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="d、查询所有用户信息"><a href="#d、查询所有用户信息" class="headerlink" title="d、查询所有用户信息"></a>d、查询所有用户信息</h4><blockquote><p><strong>调用方法：List selectList(@Param(Constants.WRAPPER) Wrapper queryWrapper);</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">/**  * 测试查询所有数据  */@Testvoid testSelectList(){    List&lt;User&gt; users = userMapper.selectList(null);    users.forEach(System.out::println);}java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-通用Service"><a href="#3-通用Service" class="headerlink" title="3.通用Service"></a>3.通用Service</h2><blockquote><p>说明:</p><p>通用 Service CRUD 封装<code>IService</code>接口，进一步封装 CRUD 采用 <code>get 查询单行</code> <code>remove 删除</code> <code>list 查询集合</code> <code>page 分页</code> 前缀命名方式区分 <code>Mapper</code> 层避免混淆</p><p>泛型 <code>T</code> 为任意实体对象</p><p>建议如果存在自定义通用 Service 方法的可能，请创建自己的 <code>IBaseService</code> 继承 <code>Mybatis-Plus</code> 提供的基类</p><p>对象 <code>Wrapper</code> 为 条件构造器</p></blockquote><p>MyBatis-Plus中有一个接口 <code>IService</code>和其实现类 <code>ServiceImpl</code>，封装了常见的业务层逻辑，详情查看源码IService和ServiceImpl</p><p>因此我们在使用的时候仅需在自己定义的<code>Service</code>接口中继承<code>IService</code>接口，在自己的实现类中实现自己的Service并继承<code>ServiceImpl</code>即可</p><hr><blockquote><p><strong>IService中的CRUD方法</strong></p></blockquote><ul><li><p><strong>增加：Save、SaveOrUpdate</strong></p><pre class="line-numbers language-none"><code class="language-none">// 插入一条记录（选择字段，策略插入）boolean save(T entity);// 插入（批量）boolean saveBatch(Collection&lt;T&gt; entityList);// 插入（批量）boolean saveBatch(Collection&lt;T&gt; entityList, int batchSize);// TableId 注解存在更新记录，否插入一条记录boolean saveOrUpdate(T entity);// 根据updateWrapper尝试更新，否继续执行saveOrUpdate(T)方法boolean saveOrUpdate(T entity, Wrapper&lt;T&gt; updateWrapper);// 批量修改插入boolean saveOrUpdateBatch(Collection&lt;T&gt; entityList);// 批量修改插入boolean saveOrUpdateBatch(Collection&lt;T&gt; entityList, int batchSize);java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>删除：Remove</strong></p><pre class="line-numbers language-none"><code class="language-none">// 根据 entity 条件，删除记录boolean remove(Wrapper&lt;T&gt; queryWrapper);// 根据 ID 删除boolean removeById(Serializable id);// 根据 columnMap 条件，删除记录boolean removeByMap(Map&lt;String, Object&gt; columnMap);// 删除（根据ID 批量删除）boolean removeByIds(Collection&lt;? extends Serializable&gt; idList);java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>修改：Update</strong></p><pre class="line-numbers language-none"><code class="language-none">// 根据 UpdateWrapper 条件，更新记录 需要设置sqlsetboolean update(Wrapper&lt;T&gt; updateWrapper);// 根据 whereWrapper 条件，更新记录boolean update(T updateEntity, Wrapper&lt;T&gt; whereWrapper);// 根据 ID 选择修改boolean updateById(T entity);// 根据ID 批量更新boolean updateBatchById(Collection&lt;T&gt; entityList);// 根据ID 批量更新boolean updateBatchById(Collection&lt;T&gt; entityList, int batchSize);java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>查询：Get、List、Count</strong></p><pre class="line-numbers language-none"><code class="language-none">// 根据 ID 查询T getById(Serializable id);// 根据 Wrapper，查询一条记录。结果集，如果是多个会抛出异常，随机取一条加上限制条件 wrapper.last("LIMIT 1")T getOne(Wrapper&lt;T&gt; queryWrapper);// 根据 Wrapper，查询一条记录T getOne(Wrapper&lt;T&gt; queryWrapper, boolean throwEx);// 根据 Wrapper，查询一条记录Map&lt;String, Object&gt; getMap(Wrapper&lt;T&gt; queryWrapper);// 根据 Wrapper，查询一条记录&lt;V&gt; V getObj(Wrapper&lt;T&gt; queryWrapper, Function&lt;? super Object, V&gt; mapper);// 查询所有List&lt;T&gt; list();// 查询列表List&lt;T&gt; list(Wrapper&lt;T&gt; queryWrapper);// 查询（根据ID 批量查询）Collection&lt;T&gt; listByIds(Collection&lt;? extends Serializable&gt; idList);// 查询（根据 columnMap 条件）Collection&lt;T&gt; listByMap(Map&lt;String, Object&gt; columnMap);// 查询所有列表List&lt;Map&lt;String, Object&gt;&gt; listMaps();// 查询列表List&lt;Map&lt;String, Object&gt;&gt; listMaps(Wrapper&lt;T&gt; queryWrapper);// 查询全部记录List&lt;Object&gt; listObjs();// 查询全部记录&lt;V&gt; List&lt;V&gt; listObjs(Function&lt;? super Object, V&gt; mapper);// 根据 Wrapper 条件，查询全部记录List&lt;Object&gt; listObjs(Wrapper&lt;T&gt; queryWrapper);// 根据 Wrapper 条件，查询全部记录&lt;V&gt; List&lt;V&gt; listObjs(Wrapper&lt;T&gt; queryWrapper, Function&lt;? super Object, V&gt; mapper);// 查询总记录数int count();// 根据 Wrapper 条件，查询总记录数int count(Wrapper&lt;T&gt; queryWrapper);java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>分页：Page</strong></p><pre class="line-numbers language-none"><code class="language-none">// 根据 ID 查询T getById(Serializable id);// 根据 Wrapper，查询一条记录。结果集，如果是多个会抛出异常，随机取一条加上限制条件 wrapper.last("LIMIT 1")T getOne(Wrapper&lt;T&gt; queryWrapper);// 根据 Wrapper，查询一条记录T getOne(Wrapper&lt;T&gt; queryWrapper, boolean throwEx);// 根据 Wrapper，查询一条记录Map&lt;String, Object&gt; getMap(Wrapper&lt;T&gt; queryWrapper);// 根据 Wrapper，查询一条记录&lt;V&gt; V getObj(Wrapper&lt;T&gt; queryWrapper, Function&lt;? super Object, V&gt; mapper);java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="4-调用Service层操作数据"><a href="#4-调用Service层操作数据" class="headerlink" title="4.调用Service层操作数据"></a>4.调用Service层操作数据</h2><blockquote><p>我们在自己的Service接口中通过继承MyBatis-Plus提供的IService接口，不仅可以获得其提供的CRUD方法，而且还可以使用自身定义的方法。</p></blockquote><ul><li><p><strong>创建<code>UserService</code>并继承<code>IService</code></strong></p><pre class="line-numbers language-none"><code class="language-none">/**  * UserService继承IService模板提供的基础功能   */public interface UserService extends IService&lt;User&gt; {}java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>创建<code>UserService</code>的实现类并继承<code>ServiceImpl</code></strong></p><pre class="line-numbers language-none"><code class="language-none">/**  * ServiceImpl实现了IService，提供了IService中基础功能的实现   * 若ServiceImpl无法满足业务需求，则可以使用自定的UserService定义方法，并在实现类中实现  */@Servicepublic class UserServiceImpl extends ServiceImpl&lt;UserMapper,User&gt; implements UserService{}java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>测试查询记录数</strong></p><blockquote><p><strong>调用方法：int count();</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">@Testpublic void testGetCount(){    //查询总记录数    //执行的SQL为：SELECT COUNT( * ) FROM user    long count = userService.count();    System.out.println("总记录数：" + count);}java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>测试批量插入数据</strong></p><blockquote><p><strong>调用方法：boolean saveBatch(Collection entityList);</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">@Testpublic void test(){    List&lt;User&gt; list = new ArrayList&lt;&gt;();    for (int i = 1; i &lt;= 10; i++) {        User user = new User();        user.setName("Vz"+i);        user.setAge(20+i);        list.add(user);    }    boolean b = userService.saveBatch(list);    System.out.println(b ? "添加成功！" : "添加失败！");}java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h1 id="四、常用注解"><a href="#四、常用注解" class="headerlink" title="四、常用注解"></a>四、常用注解</h1><blockquote><p>MyBatis-Plus提供的注解可以帮我们解决一些数据库与实体之间相互映射的问题。</p></blockquote><h2 id="1-TableName"><a href="#1-TableName" class="headerlink" title="1.@TableName"></a>1.@TableName</h2><blockquote><p>经过以上的测试，在使用MyBatis-Plus实现基本的CRUD时，我们并没有指定要操作的表，只是在Mapper接口继承BaseMapper时，设置了泛型User，而操作的表为user表，由此得出结论，MyBatis-Plus在确定操作的表时，由BaseMapper的泛型决定，即实体类型决定，且默认操作的表名和实体类型的类名一致。</p></blockquote><h3 id="1-1-引出问题"><a href="#1-1-引出问题" class="headerlink" title="1.1 引出问题"></a>1.1 引出问题</h3><hr><blockquote><p><strong>若实体类类型的类名和要操作的表的表名不一致，会出现什么问题？</strong></p></blockquote><ul><li><p>我们将表<code>user</code>更名为<code>t_user</code>，测试查询功能</p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220520093844842.png" alt="image-20220520093844842"></p></li><li><p>程序抛出异常，<strong>Table ‘mybatis_plus.user’ doesn’t exist</strong>，因为现在的表名为<code>t_user</code>，而默认操作的表名和实体类型的类名一致，即<code>user</code>表</p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220520094126411.png" alt="image-20220520094126411"></p></li></ul><h3 id="1-2-解决问题"><a href="#1-2-解决问题" class="headerlink" title="1.2 解决问题"></a>1.2 解决问题</h3><hr><h4 id="a、使用注解解决问题"><a href="#a、使用注解解决问题" class="headerlink" title="a、使用注解解决问题"></a>a、使用注解解决问题</h4><blockquote><p><strong>在实体类类型上添加<code>@TableName("t_user")</code>，标识实体类对应的表，即可成功执行SQL语句</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">@Data@TableName("t_user")public class User {    private Long id;    private String name;    private Integer age;    private String email;}java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="b、使用全局配置解决问题"><a href="#b、使用全局配置解决问题" class="headerlink" title="b、使用全局配置解决问题"></a>b、使用全局配置解决问题</h4><blockquote><p><strong>在开发的过程中，我们经常遇到以上的问题，即实体类所对应的表都有固定的前缀，例如 <code>t_</code> 或 <code>tbl_</code> 此时，可以使用MyBatis-Plus提供的全局配置，为实体类所对应的表名设置默认的前缀，那么就不需要在每个实体类上通过@TableName标识实体类对应的表</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">mybatis-plus:  global-config:    db-config:      # 设置实体类所对应的表的统一前缀      table-prefix: t_yml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-TableId"><a href="#2-TableId" class="headerlink" title="2.@TableId"></a>2.@TableId</h2><blockquote><p><strong>经过以上的测试，MyBatis-Plus在实现CRUD时，会默认将id作为主键列，并在插入数据时，默认基于雪花算法的策略生成id</strong></p></blockquote><h3 id="2-1-引出问题"><a href="#2-1-引出问题" class="headerlink" title="2.1 引出问题"></a>2.1 引出问题</h3><hr><blockquote><p><strong>若实体类和表中表示主键的不是id，而是其他字段，例如uid，MyBatis-Plus会自动识别uid为主键列吗？</strong></p></blockquote><ul><li><p>我们实体类中的属性<code>id</code>改为<code>uid</code>，将表中的字段<code>id</code>也改为<code>uid</code>，测试添加功能</p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220520100939157.png" alt="image-20220520100939157"></p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220520100715109.png" alt="image-20220520100715109"></p></li><li><p>程序抛出异常，<strong>Field ‘uid’ doesn’t have a default value</strong>，说明MyBatis-Plus没有将<code>uid</code>作为主键赋值</p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220520101317761.png" alt="image-20220520101317761"></p></li></ul><h3 id="2-2-解决问题"><a href="#2-2-解决问题" class="headerlink" title="2.2 解决问题"></a>2.2 解决问题</h3><hr><blockquote><p><strong>在实体类中uid属性上通过<code>@TableId</code>将其标识为主键，即可成功执行SQL语句</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">@Datepublic class User {    @TableId    private Long uid;    private String name;    private Integer age;    private String email;}java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-TableId的value属性"><a href="#2-3-TableId的value属性" class="headerlink" title="2.3 @TableId的value属性"></a>2.3 @TableId的value属性</h3><hr><blockquote><p>若实体类中主键对应的属性为id，而表中表示主键的字段为uid，此时若只在属性id上添加注解@TableId，则抛出异常<strong>Unknown column ‘id’ in ‘field list’</strong>，即MyBatis-Plus仍然会将id作为表的主键操作，而表中表示主键的是字段uid此时需要通过@TableId注解的value属性，指定表中的主键字段，<code>@TableId("uid")</code>或<code>@TableId(value="uid")</code></p></blockquote><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220520103030977.png" alt="image-20220520103030977"></p><h3 id="2-4-TableId的type属性"><a href="#2-4-TableId的type属性" class="headerlink" title="2.4 @TableId的type属性"></a>2.4 @TableId的type属性</h3><hr><blockquote><p><strong>type属性用来定义主键策略：默认雪花算法</strong></p></blockquote><p><strong>常用的主键策略：</strong></p><table><thead><tr><th align="center">值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">IdType.ASSIGN_ID（默认）</td><td align="center">基于雪花算法的策略生成数据id，与数据库id是否设置自增无关</td></tr><tr><td align="center">IdType.AUTO</td><td align="center">使用数据库的自增策略，注意，该类型请确保数据库设置了id自增，</td></tr></tbody></table><p><strong>配置全局主键策略：</strong></p><pre class="line-numbers language-none"><code class="language-none">#MyBatis-Plus相关配置mybatis-plus:  configuration:    #配置日志    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl  global-config:    db-config:      #配置mp的主键策略为自增      id-type: auto      # 设置实体类所对应的表的统一前缀      table-prefix: t_yml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-TbaleField"><a href="#3-TbaleField" class="headerlink" title="3.@TbaleField"></a>3.@TbaleField</h2><blockquote><p>经过以上的测试，我们可以发现，MyBatis-Plus在执行SQL语句时，要保证实体类中的属性名和表中的字段名一致</p><p>如果实体类中的属性名和字段名不一致的情况，会出现什么问题呢？</p></blockquote><h3 id="3-1-情况一"><a href="#3-1-情况一" class="headerlink" title="3.1 情况一"></a>3.1 情况一</h3><hr><p>若实体类中的属性使用的是驼峰命名风格，而表中的字段使用的是下划线命名风格</p><p>例如实体类属性<code>userName</code>，表中字段<code>user_name</code></p><p>此时MyBatis-Plus会自动将下划线命名风格转化为驼峰命名风格</p><p>相当于在MyBatis中配置</p><h3 id="3-2-情况二"><a href="#3-2-情况二" class="headerlink" title="3.2 情况二"></a>3.2 情况二</h3><hr><blockquote><p>若实体类中的属性和表中的字段不满足情况1</p><p>例如实体类属性<code>name</code>，表中字段<code>username</code></p><p>此时需要在实体类属性上使用<code>@TableField("username")</code>设置属性所对应的字段名</p></blockquote><pre class="line-numbers language-none"><code class="language-none">public class User {    @TableId("uid")    private Long id;    @TableField("username")    private String name;    private Integer age;    private String email;}java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-TableLogic"><a href="#4-TableLogic" class="headerlink" title="4.@TableLogic"></a>4.@TableLogic</h2><h3 id="4-1-逻辑删除"><a href="#4-1-逻辑删除" class="headerlink" title="4.1 逻辑删除"></a>4.1 逻辑删除</h3><hr><blockquote><p>物理删除：真实删除，将对应数据从数据库中删除，之后查询不到此条被删除的数据</p><p>逻辑删除：假删除，将对应数据中代表是否被删除字段的状态修改为“被删除状态”，之后在数据库中仍旧能看到此条数据记录</p><p>使用场景：可以进行数据恢复</p></blockquote><h3 id="4-2-实现逻辑删除"><a href="#4-2-实现逻辑删除" class="headerlink" title="4.2 实现逻辑删除"></a>4.2 实现逻辑删除</h3><hr><ul><li><p><strong>数据库中创建逻辑删除状态列，设置默认值为0</strong></p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220520134529809.png" alt="image-20220520134529809"></p></li><li><p><strong>实体类中添加逻辑删除属性</strong></p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220520134636112.png" alt="image-20220520134636112"></p></li><li><p><strong>测试删除功能，真正执行的是修改</strong></p><pre class="line-numbers language-none"><code class="language-none">public void testDeleteById(){    int result = userMapper.deleteById(1527472864163348482L);    System.out.println(result &gt; 0 ? "删除成功！" : "删除失败！");    System.out.println("受影响的行数为：" + result);}java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220520135637388.png" alt="image-20220520135637388"></p></li><li><p><strong>此时执行查询方法，查询的结果为自动添加条件<code>is_deleted=0</code></strong></p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220520140036445.png" alt="image-20220520140036445"></p></li></ul><h1 id="五、条件构造器"><a href="#五、条件构造器" class="headerlink" title="五、条件构造器"></a>五、条件构造器</h1><h2 id="1-Wrapper介绍"><a href="#1-Wrapper介绍" class="headerlink" title="1.Wrapper介绍"></a>1.Wrapper介绍</h2><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220521092812125.png" alt="image-20220521092812125"></p><ul><li><code>Wrapper</code> ： 条件构造抽象类，最顶端父类<ul><li><code>AbstractWrapper </code>： 用于查询条件封装，生成 sql 的 where 条件</li><li><code>QueryWrapper </code>： 查询条件封装</li><li><code>UpdateWrapper </code>： Update 条件封装</li><li><code>AbstractLambdaWrapper </code>： 使用Lambda 语法<ul><li><code>LambdaQueryWrapper </code>：用于Lambda语法使用的查询Wrapper</li><li><code>LambdaUpdateWrapper </code>： Lambda 更新封装Wrapper</li></ul></li></ul></li></ul><h2 id="2-QueryWrapper"><a href="#2-QueryWrapper" class="headerlink" title="2.QueryWrapper"></a>2.QueryWrapper</h2><ul><li><p><strong>组装查询条件</strong></p><blockquote><p><strong>执行SQL</strong>：SELECT uid AS id,username AS name,age,email,is_deleted FROM t_user WHERE is_deleted=0 AND (username LIKE ? AND age BETWEEN ? AND ? AND email IS NOT NULL)</p></blockquote><pre class="line-numbers language-none"><code class="language-none">public void test01(){    //查询用户名包含a，年龄在20到30之间，邮箱信息不为null的用户信息    QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();    queryWrapper.like("username","a").between("age",20,30).isNotNull("email");    List&lt;User&gt; users = userMapper.selectList(queryWrapper);    users.forEach(System.out::println);}java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>组装排序条件</strong></p><blockquote><p><strong>执行SQL</strong>：SELECT uid AS id,username AS name,age,email,is_deleted FROM t_user WHERE is_deleted=0 ORDER BY age DESC,id ASC</p></blockquote><pre class="line-numbers language-none"><code class="language-none">public void test02(){    //查询用户信息，按照年龄的降序排序，若年龄相同，则按照id升序排序    QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();    queryWrapper.orderByDesc("age").orderByAsc("id");    List&lt;User&gt; users = userMapper.selectList(queryWrapper);    users.forEach(System.out::println);}java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>组装删除条件</strong></p><blockquote><p><strong>执行SQL</strong>：UPDATE t_user SET is_deleted=1 WHERE is_deleted=0 AND (email IS NULL)</p></blockquote><pre class="line-numbers language-none"><code class="language-none">public void test03(){    //删除邮箱地址为null的用户信息    QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();    queryWrapper.isNull("email");    int result = userMapper.delete(queryWrapper);    System.out.println(result &gt; 0 ? "删除成功！" : "删除失败！");    System.out.println("受影响的行数为：" + result);}java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>条件的优先级</strong></p><blockquote><p><strong>执行SQL</strong>：UPDATE t_user SET user_name=?, email=? WHERE is_deleted=0 AND (age &gt; ? AND user_name LIKE ? OR email IS NULL)</p></blockquote><pre class="line-numbers language-none"><code class="language-none">public void test04(){    //将（年龄大于20并且用户名中包含有a）或邮箱为null的用户信息修改    UpdateWrapper&lt;User&gt; updateWrapper = new UpdateWrapper&lt;&gt;();    updateWrapper.gt("age",20).like("username","a").or().isNull("email");    User user = new User();    user.setName("Oz");    user.setEmail("test@oz6.com");    int result = userMapper.update(user, updateWrapper);    System.out.println(result &gt; 0 ? "修改成功！" : "修改失败！");    System.out.println("受影响的行数为：" + result);}java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>执行SQL</strong>：UPDATE t_user SET username=?, email=? WHERE is_deleted=0 AND (username LIKE ? AND (age &gt; ? OR email IS NULL))</p></blockquote><pre class="line-numbers language-none"><code class="language-none">public void test05(){    //将用户名中包含有a并且（年龄大于20或邮箱为null）的用户信息修改    UpdateWrapper&lt;User&gt; updateWrapper = new UpdateWrapper&lt;&gt;();    updateWrapper.like("username","a").and(i-&gt;i.gt("age",20).or().isNull("email"));    User user = new User();    user.setName("Vz7797");    user.setEmail("test@ss8o.com");    int result = userMapper.update(user, updateWrapper);    System.out.println(result &gt; 0 ? "修改成功！" : "修改失败！");    System.out.println("受影响的行数为：" + result);}java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>组装select子句</strong></p><blockquote><p><strong>执行SQL</strong>：SELECT username,age,email FROM t_user WHERE is_deleted=0</p></blockquote><pre class="line-numbers language-none"><code class="language-none">public void test06(){    //查询用户的用户名、年龄、邮箱信息    QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();    queryWrapper.select("username","age","email");    List&lt;Map&lt;String, Object&gt;&gt; maps = userMapper.selectMaps(queryWrapper);    maps.forEach(System.out::println);}java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>实现子查询</strong></p><blockquote><p><strong>执行SQL</strong>：SELECT uid AS id,user_name AS name,age,email,is_deleted FROM t_user WHERE is_deleted=0 AND (uid IN (select uid from t_user where uid &lt;= 100))</p></blockquote><pre class="line-numbers language-none"><code class="language-none">public void test07(){    //查询id小于等于100的用户信息    QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();    queryWrapper.inSql("uid", "select uid from t_user where uid &lt;= 100");    List&lt;User&gt; list = userMapper.selectList(queryWrapper);    list.forEach(System.out::println);}java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="3-UpdateWrapper"><a href="#3-UpdateWrapper" class="headerlink" title="3.UpdateWrapper"></a>3.UpdateWrapper</h2><blockquote><p>UpdateWrapper不仅拥有QueryWrapper的组装条件功能，还提供了set方法进行修改对应条件的数据库信息</p></blockquote><pre class="line-numbers language-none"><code class="language-none">public void test08(){    //将用户名中包含有a并且（年龄大于20或邮箱为null）的用户信息修改    UpdateWrapper&lt;User&gt; updateWrapper = new UpdateWrapper&lt;&gt;();    updateWrapper.like("username","a").and( i -&gt; i.gt("age",20).or().isNull("email")).set("email","svip@qq.com");    int result = userMapper.update(null, updateWrapper);    System.out.println(result &gt; 0 ? "修改成功！" : "修改失败！");    System.out.println("受影响的行数为：" + result);}java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-condition"><a href="#4-condition" class="headerlink" title="4.condition"></a>4.condition</h2><blockquote><p>在真正开发的过程中，组装条件是常见的功能，而这些条件数据来源于用户输入，是可选的，因此我们在组装这些条件时，必须先判断用户是否选择了这些条件，若选择则需要组装该条件，若没有选择则一定不能组装，以免影响SQL执行的结果</p></blockquote><ul><li><p><strong>思路一</strong></p><blockquote><p><strong>执行SQL</strong>：SELECT uid AS id,user_name AS name,age,email,is_deleted FROM t_user WHERE is_deleted=0 AND (user_name LIKE ? AND age &lt;= ?)</p></blockquote><pre class="line-numbers language-none"><code class="language-none"> public void test09(){     String username = "a";     Integer ageBegin = null;     Integer ageEnd = 30;     QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();     if(StringUtils.isNotBlank(username)){         //isNotBlank判断某个字符创是否不为空字符串、不为null、不为空白符         queryWrapper.like("user_name", username);     }     if(ageBegin != null){         queryWrapper.ge("age", ageBegin);     }     if(ageEnd != null){         queryWrapper.le("age", ageEnd);     }     List&lt;User&gt; list = userMapper.selectList(queryWrapper);     list.forEach(System.out::println); }java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>思路二</strong></p><blockquote><p>上面的实现方案没有问题，但是代码比较复杂，我们可以使用带condition参数的重载方法构建查询条件，简化代码的编写</p></blockquote><pre class="line-numbers language-none"><code class="language-none">public void test10(){    String username = "a";    Integer ageBegin = null;    Integer ageEnd = 30;    QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();    queryWrapper.like(StringUtils.isNotBlank(username), "user_name", username)        .ge(ageBegin != null, "age", ageBegin)        .le(ageEnd != null, "age", ageEnd);    List&lt;User&gt; list = userMapper.selectList(queryWrapper);    list.forEach(System.out::println);}java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="5-LambdaQueryWrapper"><a href="#5-LambdaQueryWrapper" class="headerlink" title="5.LambdaQueryWrapper"></a>5.LambdaQueryWrapper</h2><blockquote><p>功能等同于QueryWrapper，提供了Lambda表达式的语法可以避免填错列名。</p></blockquote><pre class="line-numbers language-none"><code class="language-none">public void test11(){    String username = "a";    Integer ageBegin = null;    Integer ageEnd = 30;    LambdaQueryWrapper&lt;User&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();    queryWrapper.like(StringUtils.isNotBlank(username), User::getName, username)        .ge(ageBegin != null, User::getAge, ageBegin)        .le(ageEnd != null, User::getAge, ageEnd);    List&lt;User&gt; list = userMapper.selectList(queryWrapper);    list.forEach(System.out::println);}java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-LambdaUpdateWrapper"><a href="#6-LambdaUpdateWrapper" class="headerlink" title="6.LambdaUpdateWrapper"></a>6.LambdaUpdateWrapper</h2><blockquote><p>功能等同于UpdateWrapper，提供了Lambda表达式的语法可以避免填错列名。</p></blockquote><pre class="line-numbers language-none"><code class="language-none">public void test12(){    //将用户名中包含有a并且（年龄大于20或邮箱为null）的用户信息修改    LambdaUpdateWrapper&lt;User&gt; updateWrapper = new LambdaUpdateWrapper&lt;&gt;();    updateWrapper.like(User::getName, "a")        .and(i -&gt; i.gt(User::getAge, 20).or().isNull(User::getEmail));    updateWrapper.set(User::getName, "小黑").set(User::getEmail,"abc@atguigu.com");    int result = userMapper.update(null, updateWrapper);    System.out.println("result："+result);}java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="六、常用插件"><a href="#六、常用插件" class="headerlink" title="六、常用插件"></a>六、常用插件</h1><h2 id="1-分页插件"><a href="#1-分页插件" class="headerlink" title="1.分页插件"></a>1.分页插件</h2><blockquote><p>MyBatis Plus自带分页插件，只要简单的配置即可实现分页功能</p></blockquote><ul><li><p><strong>添加配置类<code>MyBatisPlusConfig</code></strong></p><pre class="line-numbers language-none"><code class="language-none">@Configuration@MapperScan("com.atguigu.mybatisplus.mapper")public class MyBatisPlusConfig {    @Bean    public MybatisPlusInterceptor mybatisPlusInterceptor(){        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();        //添加分页插件        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));        return interceptor;    }}java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>编写测试方法</strong></p><pre class="line-numbers language-none"><code class="language-none">@Testpublic void testPage(){    //new Page()中的两个参数分别是当前页码，每页显示数量    Page&lt;User&gt; page = userMapper.selectPage(new Page&lt;&gt;(1, 2), null);    List&lt;User&gt; users = page.getRecords();    users.forEach(System.out::println);}java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="2-自定义分页"><a href="#2-自定义分页" class="headerlink" title="2.自定义分页"></a>2.自定义分页</h2><blockquote><p>上面调用的是MyBatis-Plus提供的带有分页的方法，那么我们自己定义的方法如何实现分页呢？</p></blockquote><ul><li><p><strong>在<code>UserMapper</code>接口中定义一个方法</strong></p><pre class="line-numbers language-none"><code class="language-none">/**  * 根据年龄查询用户列表，分页显示   * @param page 分页对象,xml中可以从里面进行取值,传递参数 Page 即自动分页,必须放在第一位   * @param age 年龄   * @return   */Page&lt;User&gt; selectPageVo(@Param("page") Page&lt;User&gt; page,@Param("age") Integer age);java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>在<code>UserMapper.xml</code>中编写SQL实现该方法</strong></p><pre class="line-numbers language-none"><code class="language-none">&lt;select id="selectPageVo" resultType="User"&gt;    select id,username as name,age,email from t_user where age &gt; #{age}&lt;/select&gt;xml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>编写测试方法</strong></p><pre class="line-numbers language-none"><code class="language-none">@Testpublic void testPageVo(){    Page&lt;User&gt; page = userMapper.selectPageVo(new Page&lt;User&gt;(1,2), 20);    List&lt;User&gt; users = page.getRecords();    users.forEach(System.out::println);}java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="3-乐观锁"><a href="#3-乐观锁" class="headerlink" title="3.乐观锁"></a>3.乐观锁</h2><blockquote><p><strong>作用：当要更新一条记录的时候，希望这条记录没有被别人更新</strong></p></blockquote><p>乐观锁的实现方式：</p><ul><li>取出记录时，获取当前 version</li><li>更新时，带上这个 version</li><li>执行更新时， set version = newVersion where version = oldVersion</li><li>如果 version 不对，就更新失败</li></ul><h3 id="3-1-场景"><a href="#3-1-场景" class="headerlink" title="3.1 场景"></a>3.1 场景</h3><hr><ul><li>一件商品，成本价是80元，售价是100元。老板先是通知小李，说你去把商品价格增加50元。小李正在玩游戏，耽搁了一个小时。正好一个小时后，老板觉得商品价格增加到150元，价格太高，可能会影响销量。又通知小王，你把商品价格降低30元。</li><li>此时，小李和小王同时操作商品后台系统。小李操作的时候，系统先取出商品价格100元；小王也在操作，取出的商品价格也是100元。小李将价格加了50元，并将100+50=150元存入了数据库；小王将商品减了30元，并将100-30=70元存入了数据库。是的，如果没有锁，小李的操作就完全被小王的覆盖了。</li><li>现在商品价格是70元，比成本价低10元。几分钟后，这个商品很快出售了1千多件商品，老板亏1万多。</li></ul><h3 id="3-2-乐观锁与悲观锁"><a href="#3-2-乐观锁与悲观锁" class="headerlink" title="3.2 乐观锁与悲观锁"></a>3.2 乐观锁与悲观锁</h3><hr><ul><li>上面的故事，如果是乐观锁，小王保存价格前，会检查下价格是否被人修改过了。如果被修改过了，则重新取出的被修改后的价格，150元，这样他会将120元存入数据库。</li><li>如果是悲观锁，小李取出数据后，小王只能等小李操作完之后，才能对价格进行操作，也会保证最终的价格是120元。</li></ul><h3 id="3-3-模拟修改冲突"><a href="#3-3-模拟修改冲突" class="headerlink" title="3.3 模拟修改冲突"></a>3.3 模拟修改冲突</h3><hr><ul><li><p><strong>数据库中增加商品表</strong></p><pre class="line-numbers language-none"><code class="language-none">CREATE TABLE t_product (     id BIGINT(20) NOT NULL COMMENT '主键ID',     NAME VARCHAR(30) NULL DEFAULT NULL COMMENT '商品名称',     price INT(11) DEFAULT 0 COMMENT '价格',     VERSION INT(11) DEFAULT 0 COMMENT '乐观锁版本号',     PRIMARY KEY (id) );sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>添加一条数据</strong></p><pre class="line-numbers language-none"><code class="language-none">INSERT INTO t_product (id, NAME, price) VALUES (1, '外星人笔记本', 100);sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><strong>添加一个实体类<code>Product</code></strong></p><pre class="line-numbers language-none"><code class="language-none">@Datapublic class Product {    private Long id;    private String name;    private Integer price;    private Integer version;}java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>添加一个Mapper接口<code>ProductMapper</code></strong></p><pre class="line-numbers language-none"><code class="language-none">public interface ProductMapper extends BaseMapper&lt;Product&gt; {}java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><strong>测试方法</strong></p><pre class="line-numbers language-none"><code class="language-none">@Testpublic void testProduct01(){    //1.小李获取商品价格    Product productLi = productMapper.selectById(1);    System.out.println("小李获取的商品价格为：" + productLi.getPrice());    //2.小王获取商品价格    Product productWang = productMapper.selectById(1);    System.out.println("小李获取的商品价格为：" + productWang.getPrice());    //3.小李修改商品价格+50    productLi.setPrice(productLi.getPrice()+50);    productMapper.updateById(productLi);    //4.小王修改商品价格-30    productWang.setPrice(productWang.getPrice()-30);    productMapper.updateById(productWang);    //5.老板查询商品价格    Product productBoss = productMapper.selectById(1);    System.out.println("老板获取的商品价格为：" + productBoss.getPrice());}java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>执行结果</strong></p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220521225803162.png" alt="image-20220521225803162"></p></li></ul><h3 id="3-4-乐观锁解决问题"><a href="#3-4-乐观锁解决问题" class="headerlink" title="3.4 乐观锁解决问题"></a>3.4 乐观锁解决问题</h3><hr><ul><li><p><strong>实体类<code>version</code>字段添加注解<code>@Version</code></strong></p><pre class="line-numbers language-none"><code class="language-none">@Datapublic class Product {    private Long id;    private String name;    private Integer price;    @Version    private Integer version;}java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>添加乐观锁插件配置</strong></p><pre class="line-numbers language-none"><code class="language-none">@Beanpublic MybatisPlusInterceptor mybatisPlusInterceptor(){    MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();    //添加分页插件    interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));    //添加乐观锁插件    interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor());    return interceptor;}java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>再次执行测试方法</strong></p><blockquote><p>小李查询商品信息：</p><p> SELECT id,name,price,version FROM t_product WHERE id=?</p><p>小王查询商品信息：</p><p> SELECT id,name,price,version FROM t_product WHERE id=?</p><p>小李修改商品价格，自动将version+1</p><p> UPDATE t_product SET name=?, price=?, version=? WHERE id=? AND version=?</p><p> Parameters: 外星人笔记本(String), 150(Integer), 1(Integer), 1(Long), 0(Integer)</p><p>小王修改商品价格，此时version已更新，条件不成立，修改失败</p><p> UPDATE t_product SET name=?, price=?, version=? WHERE id=? AND version=?</p><p> Parameters: 外星人笔记本(String), 70(Integer), 1(Integer), 1(Long), 0(Integer)</p><p>最终，小王修改失败，查询价格：150</p><p> SELECT id,name,price,version FROM t_product WHERE id=?</p></blockquote></li><li><p><strong>优化执行流程</strong></p><pre class="line-numbers language-none"><code class="language-none">@Testpublic void testProduct01(){    //1.小李获取商品价格    Product productLi = productMapper.selectById(1);    System.out.println("小李获取的商品价格为：" + productLi.getPrice());    //2.小王获取商品价格    Product productWang = productMapper.selectById(1);    System.out.println("小李获取的商品价格为：" + productWang.getPrice());    //3.小李修改商品价格+50    productLi.setPrice(productLi.getPrice()+50);    productMapper.updateById(productLi);    //4.小王修改商品价格-30    productWang.setPrice(productWang.getPrice()-30);    int result = productMapper.updateById(productWang);    if(result == 0){        //操作失败，重试        Product productNew = productMapper.selectById(1);        productNew.setPrice(productNew.getPrice()-30);        productMapper.updateById(productNew);    }    //5.老板查询商品价格    Product productBoss = productMapper.selectById(1);    System.out.println("老板获取的商品价格为：" + productBoss.getPrice());}java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220521230448577.png" alt="image-20220521230448577"></p></li></ul><h1 id="七、通用枚举"><a href="#七、通用枚举" class="headerlink" title="七、通用枚举"></a>七、通用枚举</h1><blockquote><p>表中的有些字段值是固定的，例如性别（男或女），此时我们可以使用MyBatis-Plus的通用枚举来实现</p></blockquote><ul><li><p><strong>数据库表添加字段<code>sex</code></strong></p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220521231317777.png" alt="image-20220521231317777"></p></li><li><p><strong>创建通用枚举类型</strong></p><pre class="line-numbers language-none"><code class="language-none">@Getterpublic enum SexEnum {    MALE(1, "男"),    FEMALE(2, "女");    @EnumValue //将注解所标识的属性的值存储到数据库中    private int sex;    private String sexName;    SexEnum(Integer sex, String sexName) {        this.sex = sex;        this.sexName = sexName;    }}java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>User实体类中添加属性sex</strong></p><pre class="line-numbers language-none"><code class="language-none">public class User {    private Long id;    @TableField("username")    private String name;    private Integer age;    private String email;    @TableLogic    private int isDeleted;  //逻辑删除    private SexEnum sex;}java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>配置扫描通用枚举</strong></p><pre class="line-numbers language-none"><code class="language-none">#MyBatis-Plus相关配置mybatis-plus:  #指定mapper文件所在的地址  mapper-locations: classpath:mapper/*.xml  configuration:    #配置日志    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl  global-config:    banner: off    db-config:      #配置mp的主键策略为自增      id-type: auto      # 设置实体类所对应的表的统一前缀      table-prefix: t_  #配置类型别名所对应的包  type-aliases-package: com.atguigu.mybatisplus.pojo  # 扫描通用枚举的包  type-enums-package: com.atguigu.mybatisplus.enumsyml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>执行测试方法</strong></p><pre class="line-numbers language-none"><code class="language-none">@Testpublic void test(){    User user = new User();    user.setName("admin");    user.setAge(33);    user.setSex(SexEnum.MALE);    int result = userMapper.insert(user);    System.out.println("result:"+result);}java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h1 id="八、多数据源"><a href="#八、多数据源" class="headerlink" title="八、多数据源"></a>八、多数据源</h1><blockquote><p>适用于多种场景：纯粹多库、 读写分离、 一主多从、 混合模式等</p></blockquote><p>场景说明：</p><p>我们创建两个库，分别为：<code>mybatis_plus</code>（以前的库不动）与<code>mybatis_plus_1</code>（新建），将mybatis_plus库的<code>product</code>表移动到mybatis_plus_1库，这样每个库一张表，通过一个测试用例分别获取用户数据与商品数据，如果获取到说明多库模拟成功</p><h2 id="1-创建数据库及表"><a href="#1-创建数据库及表" class="headerlink" title="1.创建数据库及表"></a>1.创建数据库及表</h2><ul><li><p><strong>创建数据库<code>mybatis_plus_1</code>和表`product</strong></p><pre class="line-numbers language-none"><code class="language-none">CREATE DATABASE `mybatis_plus_1` /*!40100 DEFAULT CHARACTER SET utf8mb4 */;use `mybatis_plus_1`; CREATE TABLE product (     id BIGINT(20) NOT NULL COMMENT '主键ID',     name VARCHAR(30) NULL DEFAULT NULL COMMENT '商品名称',     price INT(11) DEFAULT 0 COMMENT '价格',     version INT(11) DEFAULT 0 COMMENT '乐观锁版本号',     PRIMARY KEY (id) );sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>添加测试数据</strong></p><pre class="line-numbers language-none"><code class="language-none">INSERT INTO product (id, NAME, price) VALUES (1, '外星人笔记本', 100);sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><strong>删除<code>mybatis_plus</code>库中的<code>product</code>表</strong></p><pre class="line-numbers language-none"><code class="language-none">use mybatis_plus; DROP TABLE IF EXISTS product;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="2-新建工程引入依赖"><a href="#2-新建工程引入依赖" class="headerlink" title="2.新建工程引入依赖"></a>2.新建工程引入依赖</h2><blockquote><p><strong>自行新建一个Spring Boot工程并选择MySQL驱动及Lombok依赖</strong></p></blockquote><p><strong>引入MyBaits-Plus的依赖及多数据源的依赖</strong></p><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;    &lt;version&gt;3.5.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;    &lt;artifactId&gt;dynamic-datasource-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;3.5.0&lt;/version&gt;&lt;/dependency&gt;xml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-编写配置文件"><a href="#3-编写配置文件" class="headerlink" title="3.编写配置文件"></a>3.编写配置文件</h2><pre class="line-numbers language-none"><code class="language-none">spring:  # 配置数据源信息  datasource:    dynamic:      # 设置默认的数据源或者数据源组,默认值即为master      primary: master      # 严格匹配数据源,默认false.true未匹配到指定数据源时抛异常,false使用默认数据源      strict: false      datasource:        master:          url: jdbc:mysql://localhost:3306/mybatis_plus?characterEncoding=utf-8&amp;useSSL=false          driver-class-name: com.mysql.cj.jdbc.Driver          username: root          password: 132537        slave_1:          url: jdbc:mysql://localhost:3306/mybatis_plus_1?characterEncoding=utf-8&amp;useSSL=false          driver-class-name: com.mysql.cj.jdbc.Driver          username: root          password: 132537yml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-创建实体类"><a href="#4-创建实体类" class="headerlink" title="4.创建实体类"></a>4.创建实体类</h2><ul><li><p>新建一个<code>User</code>实体类（如果数据库表名有t_前缀记得配置）</p><pre class="line-numbers language-none"><code class="language-none">@Datapublic class User {    private Long id;    private String name;    private Integer age;    private String email;}java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>新建一个实体类<code>Product</code></p><pre class="line-numbers language-none"><code class="language-none">@Datapublic class Product {    private Long id;    private String name;    private Integer price;    private Integer version;}java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="5-创建Mapper及Service"><a href="#5-创建Mapper及Service" class="headerlink" title="5.创建Mapper及Service"></a>5.创建Mapper及Service</h2><ul><li><p>新建接口<code>UserMapper</code></p><pre class="line-numbers language-none"><code class="language-none">public interface UserMapper extends BaseMapper&lt;User&gt; {}java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>新建接口<code>ProductMapper</code></p><pre class="line-numbers language-none"><code class="language-none">public interface ProductMapper extends BaseMapper&lt;Product&gt; {}java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>新建Service接口<code>UserService</code>指定操作的数据源</p><pre class="line-numbers language-none"><code class="language-none">@DS("master") //指定操作的数据源，master为user表public interface UserService extends IService&lt;User&gt; {}java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>新建Service接口<code>ProductService</code>指定操作的数据源</p><pre class="line-numbers language-none"><code class="language-none">@DS("slave_1")public interface ProductService extends IService&lt;Product&gt; {}java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>自行建立Service的实现类</p><pre class="line-numbers language-none"><code class="language-none">...java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h2 id="6-编写测试方法"><a href="#6-编写测试方法" class="headerlink" title="6.编写测试方法"></a>6.编写测试方法</h2><blockquote><p><strong>记得在启动类中添加注解<code>@MapperScan()</code></strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">class TestDatasourceApplicationTests {@ResourceUserService userService;@ResourceProductService productService;@Testvoid contextLoads() {User user = userService.getById(1L);Product product = productService.getById(1L);System.out.println("User = " + user);System.out.println("Product = " + product);}}java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220522113049945.png" alt="image-20220522113049945"></p><h1 id="九、MyBatisX插件"><a href="#九、MyBatisX插件" class="headerlink" title="九、MyBatisX插件"></a>九、MyBatisX插件</h1><blockquote><p>MyBatis-Plus为我们提供了强大的mapper和service模板，能够大大的提高开发效率。</p><p>但是在真正开发过程中，MyBatis-Plus并不能为我们解决所有问题，例如一些复杂的SQL，多表联查，我们就需要自己去编写代码和SQL语句，我们该如何快速的解决这个问题呢，这个时候可以使用MyBatisX插件。</p><p>MyBatisX一款基于 IDEA 的快速开发插件，为效率而生。</p></blockquote><h2 id="1-安装MyBatisX插件"><a href="#1-安装MyBatisX插件" class="headerlink" title="1.安装MyBatisX插件"></a>1.安装MyBatisX插件</h2><blockquote><p><strong>打开IDEA，File-&gt; Setteings-&gt;Plugins-&gt;MyBatisX，搜索栏搜索MyBatisX然后安装。</strong></p></blockquote><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220522115718361.png" alt="image-20220522115718361"></p><h2 id="2-快速生成代码"><a href="#2-快速生成代码" class="headerlink" title="2.快速生成代码"></a>2.快速生成代码</h2><ul><li><p>新建一个Spring Boot项目引入依赖（创建工程时记得勾选lombok及mysql驱动）</p><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;    &lt;version&gt;3.5.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;    &lt;artifactId&gt;dynamic-datasource-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;3.5.0&lt;/version&gt;&lt;/dependency&gt;xml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>配置数据源信息</p><pre class="line-numbers language-none"><code class="language-none">spring:  datasource:    type: com.zaxxer.hikari.HikariDataSource    driver-class-name: com.mysql.cj.jdbc.Driver    url: jdbc:mysql://localhost:3306/mybatis_plus?characterEncoding=utf-8&amp;useSSL=false    username: root    password: 132537yml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>在IDEA中与数据库建立链接</p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220522120758740.png" alt="image-20220522120758740"></p></li><li><p>填写数据库信息并保存</p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220522121434468.png" alt="image-20220522121434468"></p></li><li><p>找到我们需要生成的表点击右键</p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220522121613909.png" alt="image-20220522121613909"></p></li><li><p>填写完信息以后下一步</p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220522122127649.png" alt="image-20220522122127649"></p></li><li><p>继续填写信息</p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220522122525598.png" alt="image-20220522122525598"></p></li><li><p><strong>大功告成（真特么好用yyds）</strong></p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220522122612334.png" alt="image-20220522122612334"></p></li></ul><h2 id="3-快速生成CRUD"><a href="#3-快速生成CRUD" class="headerlink" title="3.快速生成CRUD"></a>3.快速生成CRUD</h2><blockquote><p>MyBaitsX可以根据我们在Mapper接口中输入的方法名快速帮我们生成对应的sql语句</p></blockquote><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220522123143852.png" alt="image-20220522123143852"></p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220522123202310.png" alt="image-20220522123202310"></p><p>笔记来自<a href="https://www.oz6.cn/articles/55">MyBatis-Plus (oz6.cn)</a></p>]]></content>
      
      
      <categories>
          
          <category> SSM框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础篇</title>
      <link href="/archives/337fcc87.html"/>
      <url>/archives/337fcc87.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、SQL"><a href="#一、SQL" class="headerlink" title="一、SQL"></a>一、SQL</h1><blockquote><p>全称 <code>Structured Query Language</code>，结构化查询语言。操作关系型数据库的编程语言，定义了一套操作关系型数据库统一<strong>标准</strong> 。</p><span id="more"></span></blockquote><h2 id="1-SQL通用语法"><a href="#1-SQL通用语法" class="headerlink" title="1.SQL通用语法"></a>1.SQL通用语法</h2><blockquote><p>在学习具体的SQL语句之前，先来了解一下SQL语言的同于语法。</p></blockquote><ol><li>SQL语句可以单行或多行书写，以分号结尾。</li><li>SQL语句可以使用空格/缩进来增强语句的可读性。</li><li>MySQL数据库的SQL语句<strong>不区分大小写</strong>，关键字建议使用大写。</li><li>注释：<ul><li>单行注释：<code>--</code> 注释内容 或 <code># </code>注释内容</li><li>多行注释：<code>/* 注释内容 */</code></li></ul></li></ol><h2 id="2-SQL分类"><a href="#2-SQL分类" class="headerlink" title="2.SQL分类"></a>2.SQL分类</h2><blockquote><p><strong>SQL语句，根据其功能，主要分为四类：<code>DDL</code>、<code>DML</code>、<code>DQL</code>、<code>DCL</code>。</strong></p><p><strong>但是作为<code>Java开发</code>的程序员我们仅需掌握<code>DML</code>及<code>DQL</code>即可。</strong></p></blockquote><table><thead><tr><th align="left">分类</th><th align="left">全称</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><strong>DDL</strong></td><td align="left">Data Definition Language</td><td align="left">数据定义语言，用来定义数据库对象（<strong>数据库、表、字段</strong>）</td></tr><tr><td align="left"><strong>DML</strong></td><td align="left">Data Manipulation Language</td><td align="left">数据操作语言，用来对数据库表中的数据进行<strong>增删改</strong></td></tr><tr><td align="left"><strong>DQL</strong></td><td align="left">Data Query Language</td><td align="left">数据查询语言，用来<strong>查询数据库中表的记录</strong></td></tr><tr><td align="left"><strong>DCL</strong></td><td align="left">Data Control Language</td><td align="left">数据控制语言，用来<strong>创建数据库用户</strong>、控制数据库的控制权限</td></tr></tbody></table><h2 id="3-DDL"><a href="#3-DDL" class="headerlink" title="3.DDL"></a>3.DDL</h2><blockquote><p><strong><code>Data Definition Language</code>，数据定义语言，用来定义数据库对象(数据库，表，字段) 。</strong></p></blockquote><h3 id="3-1-操作数据库的命令"><a href="#3-1-操作数据库的命令" class="headerlink" title="3.1 操作数据库的命令"></a>3.1 操作数据库的命令</h3><blockquote><p>下面演示的命令中出现的中括号表示为可选命令（加粗字体为常用命令）</p></blockquote><ol><li><p>查询所有数据库</p><pre class="line-numbers language-none"><code class="language-none">SHOW DATABASES;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>查询当前数据库</p><pre class="line-numbers language-none"><code class="language-none">SELECT DATABASE();sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><strong>创建数据库</strong></p><pre class="line-numbers language-none"><code class="language-none"># UTF8字符集长度为3字节，有些符号占4字节，所以推荐用utf8mb4字符集CREATE DATABASE [ IF NOT EXISTS ] 数据库名 [ DEFAULT CHARSET 字符集] [COLLATE 排序规则 ];SQL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><strong>删除数据库</strong></p><pre class="line-numbers language-none"><code class="language-none">DROP DATABASE [ IF EXISTS ] 数据库名;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>使用数据库</p><pre class="line-numbers language-none"><code class="language-none">USE 数据库名;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><h3 id="3-2-操作表的命令"><a href="#3-2-操作表的命令" class="headerlink" title="3.2 操作表的命令"></a>3.2 操作表的命令</h3><blockquote><p>下面演示的命令中出现的中括号表示为可选命令（加粗字体为常用命令）</p></blockquote><ol><li><p>查询当前数据库所有表</p><pre class="line-numbers language-none"><code class="language-none">SHOW TABLES;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><strong>查询表结构</strong></p><pre class="line-numbers language-none"><code class="language-none">DESC 表名;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><strong>查询指定表的建表语句</strong></p><pre class="line-numbers language-none"><code class="language-none">SHOW CREATE TABLE 表名;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><strong>创建表（注意：最后一个字段后面没有逗号）</strong></p><pre class="line-numbers language-none"><code class="language-none">create table 表名 (字段名1 类型(宽度) 约束条件 [COMMENT 字段1注释],字段名2 类型(宽度) 约束条件 [COMMENT 字段2注释],字段名3 类型(宽度) 约束条件 [COMMENT 字段3注释]) [ COMMENT 表注释 ];sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>添加字段</p><pre class="line-numbers language-none"><code class="language-none">ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束];sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>修改数据类型</p><pre class="line-numbers language-none"><code class="language-none">ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度);sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>修改字段名和字段类型</p><pre class="line-numbers language-none"><code class="language-none">ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束];sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>删除字段</p><pre class="line-numbers language-none"><code class="language-none">ALTER TABLE 表名 DROP 字段名;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>修改表名</p><pre class="line-numbers language-none"><code class="language-none">ALTER TABLE 表名 RENAME TO 新表名;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><strong>删除表</strong></p><pre class="line-numbers language-none"><code class="language-none">#将整张表彻底删掉DROP TABLE [IF EXISTS] 表名;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#以该方式删除的表相当于仅删除表中的数据，但是表结构保留TRUNCATE TABLE 表名;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><p><strong>Ps：实际开发中表的结构在创建时就已经确定了，后期基本上不会出现更改或者添加字段的情况，因此关于操作字段的命令可以不用死记。</strong></p><h3 id="3-3-字段的数据类型"><a href="#3-3-字段的数据类型" class="headerlink" title="3.3 字段的数据类型"></a>3.3 字段的数据类型</h3><h4 id="a）-整型"><a href="#a）-整型" class="headerlink" title="a） 整型"></a>a） 整型</h4><table><thead><tr><th align="left">MySQL数据类型</th><th align="left">含义（有符号）</th></tr></thead><tbody><tr><td align="left">tinyint</td><td align="left">1字节，范围（-128~127）</td></tr><tr><td align="left">smallint</td><td align="left">2字节，范围（-32768~32767）</td></tr><tr><td align="left">mediumint</td><td align="left">3字节，范围（-8388608~8388607）</td></tr><tr><td align="left">int</td><td align="left">4字节，范围（-2147483648~2147483647）</td></tr><tr><td align="left">bigint</td><td align="left">8字节，范围（±9.22*10的18次方）</td></tr></tbody></table><p>整型默认使用的都是有符号的，当然了，我们也可以加上<code>unsigned</code>关键字，定义成无符号的类型，那么对应的取值范围就会发生改变。</p><p>比如：<code>tinyint unsigned</code>的取值范围为<code>0~255</code>，</p><h4 id="b）-浮点型"><a href="#b）-浮点型" class="headerlink" title="b） 浮点型"></a>b） 浮点型</h4><table><thead><tr><th align="left">MySQL数据类型</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">float(m, d)</td><td align="left">4字节，单精度浮点型，m总长度，d小数位</td></tr><tr><td align="left">double(m, d)</td><td align="left">8字节，双精度浮点型，m总长度，d小数位</td></tr><tr><td align="left">decimal(m, d)</td><td align="left">decimal是存储为字符串的浮点数，对应我们java的Bigdecimal</td></tr></tbody></table><p>我们使用一个例子来判断小括号内参数的含义，针对数据类型为<code>float(5, 3)</code>的列，做了以下试验：</p><ul><li>插入<code>123.45678</code>，最后查询得到的结果为<code>99.999</code>；</li><li>插入<code>12.34567</code>，最后查询结果为<code>12.346</code>；</li></ul><p>所以，在使用浮点型的时候，还是要注意陷阱的，要以插入数据库中的实际结果为准。</p><h4 id="c）-字符串"><a href="#c）-字符串" class="headerlink" title="c） 字符串"></a>c） 字符串</h4><table><thead><tr><th align="left">MySQL数据类型</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">char(n)</td><td align="left">固定长度，最多255个字符</td></tr><tr><td align="left">varchar(n)</td><td align="left">可变长度，最大容量65535个字节</td></tr><tr><td align="left">tinytext</td><td align="left">可变长度，最大容量255个字节</td></tr><tr><td align="left">text</td><td align="left">可变长度，最大容量65535个字节</td></tr><tr><td align="left">mediumtext</td><td align="left">可变长度，最大容量2的24次方-1个字节 16MB</td></tr><tr><td align="left">longtext</td><td align="left">可变长度，最大容量2的32次方-1个字节 4GB</td></tr></tbody></table><h4 id="d）-日期和时间"><a href="#d）-日期和时间" class="headerlink" title="d） 日期和时间"></a>d） 日期和时间</h4><table><thead><tr><th align="left">MySQL数据类型</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left"><strong>date</strong></td><td align="left">3字节，日期，格式：2022-09-18</td></tr><tr><td align="left"><strong>time</strong></td><td align="left">3字节，时间，格式：08:42:30</td></tr><tr><td align="left"><strong>datetime</strong></td><td align="left">8字节，日期时间，格式：2022-09-18 08:42:30</td></tr><tr><td align="left">timestamp</td><td align="left">4字节，自动存储记录修改的时间</td></tr><tr><td align="left">year</td><td align="left">1字节，年份，格式：2020</td></tr></tbody></table><h2 id="4-DML（常用）"><a href="#4-DML（常用）" class="headerlink" title="4.DML（常用）"></a>4.DML（常用）</h2><blockquote><p><strong>DML英文全称是Data Manipulation Language(数据操作语言)，用来对数据库中表的数据记录进行<code>增、删、改</code>操作。</strong></p></blockquote><ul><li>添加数据（<code>INSERT</code>）</li><li>修改数据（<code>UPDATE</code>）</li><li>删除数据（<code>DELETE</code>）</li></ul><h3 id="4-1-添加数据"><a href="#4-1-添加数据" class="headerlink" title="4.1 添加数据"></a>4.1 添加数据</h3><ol><li><p>添加指定字段</p><pre class="line-numbers language-none"><code class="language-none">INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...);sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>添加全部字段</p><pre class="line-numbers language-none"><code class="language-none">INSERT INTO 表名 VALUES (值1, 值2, ...);sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>批量添加数据</p><pre class="line-numbers language-none"><code class="language-none">INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...),(值1, 值2, ...), (值1, 值2, ...);sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">INSERT INTO 表名 VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...);sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><p>注意事项</p><ul><li>插入数据时，指定的字段顺序需要与值的顺序是一一对应的。</li><li>字符串和日期类型数据应该包含在引号中</li><li>插入的数据大小应该在字段的规定范围内</li></ul><h3 id="4-2-修改和删除数据"><a href="#4-2-修改和删除数据" class="headerlink" title="4.2 修改和删除数据"></a>4.2 修改和删除数据</h3><ol><li><p>修改符合条件的数据</p><pre class="line-numbers language-none"><code class="language-none">UPDATE 表名 SET 字段名1 = 值1, 字段名2 = 值2, ... [ WHERE 条件 ];sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>删除复合条件的数据</p><pre class="line-numbers language-none"><code class="language-none">DELETE FROM 表名 [ WHERE 条件 ];sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><p><strong>注意：如果不加<code>WHERE</code>条件则默认操作整张表的数据</strong></p><h2 id="5-DQL（常用）"><a href="#5-DQL（常用）" class="headerlink" title="5.DQL（常用）"></a>5.DQL（常用）</h2><blockquote><p><strong><code>DQL</code>英文全称是<code>Data Query Language</code>(数据查询语言)，数据查询语言，用来查询数据库中表的记录。</strong></p></blockquote><p>小提示：</p><ul><li>查询关键字: <code>SELECT</code></li><li><code>DQL</code>是我们每天接触编写最多也是最难的SQL，该语言用来查询记录，不会修改数据库和表结构。</li><li>实际开发中<strong>查询操作</strong>的频次是要远高于<strong>增删改</strong>的。</li><li>查询可以当作一个很大的章节，其中包含<strong>单表查询、多表查询、分组查询</strong>等等。</li></ul><h3 id="5-1-课前准备"><a href="#5-1-课前准备" class="headerlink" title="5.1 课前准备"></a>5.1 课前准备</h3><blockquote><p><strong>在学习查询语句前我们需要用到一个图形化工具来操作数据库，这会使我们的学习效率及开发效率大大的提高。</strong></p></blockquote><ul><li><p>图形化界面工具（根据个人喜好选择）：<a href="https://lanzoux.com/iHtYJ05vitze">Navicat15</a></p></li><li><p>在开始学习之前我们需要执行以下SQL语句作为我们的学习素材：</p><pre class="line-numbers language-none"><code class="language-none">CREATE DATABASE IF NOT EXISTS itcast DEFAULT CHARSET utf8mb4;DROP TABLE IF EXISTS employee;CREATE TABLE emp (id int COMMENT '编号',workno varchar(10) COMMENT '工号',name varchar(10) COMMENT '姓名',gender char(1) COMMENT '性别',age tinyint UNSIGNED COMMENT '年龄',idcard char(18) COMMENT '身份证号',workaddress varchar(50) COMMENT '工作地址',entrydate date COMMENT '入职时间') COMMENT '员工表';INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (1, '00001', '柳岩666', '女', 20, '123456789012345678', '北京', '2000-01-01');INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (2, '00002', '张无忌', '男', 18, '123456789012345670', '北京', '2005-09-01');INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (3, '00003', '韦一笑', '男', 38, '123456789712345670', '上海', '2005-08-01'); INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (4, '00004', '赵敏', '女', 18, '123456757123845670', '北京', '2009-12-01'); INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (5, '00005', '小昭', '女', 16, '123456769012345678', '上海', '2007-07-01'); INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (6, '00006', '杨逍', '男', 28, '12345678931234567X', '北京', '2006-01-01'); INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (7, '00007', '范瑶', '男', 40, '123456789212345670', '北京', '2005-05-01'); INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (8, '00008', '黛绮丝', '女', 38, '123456157123645670', '天津', '2015-05-01'); INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (9, '00009', '范凉凉', '女', 45, '123156789012345678', '北京', '2010-04-01'); INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (10, '00010', '陈友谅', '男', 53, '123456789012345670', '上海', '2011-01-01'); INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (11, '00011', '张士诚', '男', 55, '123567897123465670', '江苏', '2015-05-01'); INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (12, '00012', '常遇春', '男', 32, '123446757152345670', '北京', '2004-02-01'); INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (13, '00013', '张三丰', '男', 88, '123656789012345678', '江苏', '2020-11-01'); INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (14, '00014', '灭绝', '女', 65, '123456719012345670', '西安', '2019-05-01'); INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (15, '00015', '胡青牛', '男', 70, '12345674971234567X', '西安', '2018-04-01'); INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (16, '00016', '周芷若', '女', 18, null, '北京', '2012-06-01');sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="5-2-基本语法"><a href="#5-2-基本语法" class="headerlink" title="5.2 基本语法"></a>5.2 基本语法</h3><ul><li><p>DQL 查询语句，语法结构如下：</p><pre class="line-numbers language-none"><code class="language-none">SELECT    字段列表FROM    表名字段WHERE    条件列表GROUP BY    分组字段列表HAVING    分组后的条件列表ORDER BY    排序字段列表LIMIT    分页参数sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>我们在学习的时候，会将上面的完整语法进行拆分，分为以下几个部分：</p><ul><li>基础查询（不带任何条件）</li><li>条件查询（<code>WHERE</code>）</li><li>聚合函数（<code>count</code>、<code>max</code>、<code>min</code>、<code>avg</code>、<code>sum</code>）</li><li>分组查询（<code>group by</code>）</li><li>排序查询（<code>order by</code>）</li><li>分页查询（<code>limit</code>）</li></ul></li></ul><h3 id="5-3-基础查询"><a href="#5-3-基础查询" class="headerlink" title="5.3 基础查询"></a>5.3 基础查询</h3><h4 id="a）语法格式"><a href="#a）语法格式" class="headerlink" title="a）语法格式"></a>a）语法格式</h4><ul><li><p>查询多个字段</p><pre class="line-numbers language-none"><code class="language-none">SELECT 字段1, 字段2, 字段3 ... FROM 表名 ;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">SELECT * FROM 表名 ;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>注意 : * 号代表查询所有字段，在实际开发中尽量少用（不直观、影响效率）。</strong></p></li><li><p>字段设置别名</p><pre class="line-numbers language-none"><code class="language-none">SELECT 字段1 [ AS 别名1 ], 字段2 [ AS 别名2 ], 字段3 [ AS 别名3 ], ... FROM 表名;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">SELECT 字段1 [ 别名1 ] , 字段2 [ 别名2 ] ... FROM 表名;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>去除重复记录</p><pre class="line-numbers language-none"><code class="language-none">SELECT DISTINCT 字段列表 FROM 表名;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h4 id="b）案例练习"><a href="#b）案例练习" class="headerlink" title="b）案例练习"></a>b）案例练习</h4><ul><li><p>查询指定字段 <code>name</code>, <code>workno</code>, <code>age</code>并返回</p><pre class="line-numbers language-none"><code class="language-none">select name,workno,age from emp;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>查询返回所有字段</p><pre class="line-numbers language-none"><code class="language-none">select id, workno, name, gender, age, idcard, workaddress, entrydate from emp;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">select * from emp; #不推荐sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>查询所有员工的工作地址，起别名</p><pre class="line-numbers language-none"><code class="language-none">select workaddress AS '工作地址' from emp;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">select workaddress '工作地址' from emp; #省略AS的写法sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>查询公司员工的上班地址有哪些（不要重复）</p><pre class="line-numbers language-none"><code class="language-none">select DISTINCT workaddress from emp;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h3 id="5-4-条件查询"><a href="#5-4-条件查询" class="headerlink" title="5.4 条件查询"></a>5.4 条件查询</h3><h4 id="a）语法格式-1"><a href="#a）语法格式-1" class="headerlink" title="a）语法格式"></a>a）语法格式</h4><ul><li><p>查询语句中使用<code>WHERE</code>条件</p><pre class="line-numbers language-none"><code class="language-none">SELECT 字段列表 FROM 表名 WHERE 条件列表 ;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h4 id="b）条件运算符"><a href="#b）条件运算符" class="headerlink" title="b）条件运算符"></a>b）条件运算符</h4><ul><li><p>常用的比较运算符</p><table><thead><tr><th align="left">比较运算符</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">&gt;</td><td align="left">大于</td></tr><tr><td align="left">&gt;=</td><td align="left">大于等于</td></tr><tr><td align="left">&lt;</td><td align="left">小于</td></tr><tr><td align="left">&lt;=</td><td align="left">小于等于</td></tr><tr><td align="left">=</td><td align="left">等于</td></tr><tr><td align="left">&lt;&gt; 或 !=</td><td align="left">不等于</td></tr><tr><td align="left">BETWEEN … AND …</td><td align="left">在某个范围内（含最小、最大值）</td></tr><tr><td align="left">IN(…)</td><td align="left">在in之后的列表中的值，多选一</td></tr><tr><td align="left">LIKE 占位符</td><td align="left">模糊匹配（<code>_</code>匹配单个字符，<code>%</code>匹配任意个字符）</td></tr><tr><td align="left">IS NULL</td><td align="left">是NULL</td></tr></tbody></table></li><li><p>常用的逻辑运算符</p><table><thead><tr><th align="left">逻辑运算符</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">AND 或 &amp;&amp;</td><td align="left">并且（多个条件同时成立）</td></tr><tr><td align="left">OR 或 ||</td><td align="left">或者（多个条件任意一个成立）</td></tr><tr><td align="left">NOT 或 !</td><td align="left">非，不是</td></tr></tbody></table></li></ul><h4 id="c）案例练习"><a href="#c）案例练习" class="headerlink" title="c）案例练习"></a>c）案例练习</h4><ul><li><p>查询年龄等于 88 的员工</p><pre class="line-numbers language-none"><code class="language-none">select * from emp where age = 88;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>查询年龄小于 20 的员工信息</p><pre class="line-numbers language-none"><code class="language-none">select * from emp where age &lt; 20;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>查询年龄小于等于 20 的员工信息</p><pre class="line-numbers language-none"><code class="language-none">select * from emp where age &lt;= 20;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>查询没有身份证号的员工信息</p><pre class="line-numbers language-none"><code class="language-none">select * from emp where idcard is null;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>查询有身份证号的员工信息</p><pre class="line-numbers language-none"><code class="language-none">select * from emp where idcard is not null;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>查询年龄不等于 88 的员工信息</p><pre class="line-numbers language-none"><code class="language-none">select * from emp where age != 88;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">select * from emp where age &lt;&gt; 88;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>查询年龄在15岁（包含）到 20岁（包含）之间的员工信息</p><pre class="line-numbers language-none"><code class="language-none">select * from emp where age &gt;= 15 &amp;&amp; age &lt;= 20;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">select * from emp where age &gt;= 15 and age &lt;= 20;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">select * from emp where age BETWEEN 15 AND 20;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>查询性别为 女 且年龄小于 25岁的员工信息</p><pre class="line-numbers language-none"><code class="language-none">select * from emp where gender = '女' and age &lt; 25;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>查询年龄等于18 或 20 或 40 的员工信息</p><pre class="line-numbers language-none"><code class="language-none">select * from emp where age = 18 or age = 20 or age = 40;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">select * from emp where age in(18,20,40);sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>查询姓名为两个字的员工信息</p><pre class="line-numbers language-none"><code class="language-none">select * from emp where name like '__';sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>查询身份证号最后一位是X的员工信息</p><pre class="line-numbers language-none"><code class="language-none">select * from emp where idcard like '%X';sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h3 id="5-5-聚合函数"><a href="#5-5-聚合函数" class="headerlink" title="5.5 聚合函数"></a>5.5 聚合函数</h3><blockquote><p><strong>将一列数据作为一个整体，进行纵向计算。</strong></p></blockquote><h4 id="a）常见的聚合函数"><a href="#a）常见的聚合函数" class="headerlink" title="a）常见的聚合函数"></a>a）常见的聚合函数</h4><table><thead><tr><th align="left">函数</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">count</td><td align="left">统计数量</td></tr><tr><td align="left">max</td><td align="left">最大值</td></tr><tr><td align="left">min</td><td align="left">最小值</td></tr><tr><td align="left">avg</td><td align="left">平均值</td></tr><tr><td align="left">sum</td><td align="left">求和</td></tr></tbody></table><h4 id="b）语法格式"><a href="#b）语法格式" class="headerlink" title="b）语法格式"></a>b）语法格式</h4><pre class="line-numbers language-none"><code class="language-none">SELECT 聚合函数(字段列表) FROM 表名 ;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>注意 : NULL值是不参与所有聚合函数运算的。</strong></p><h4 id="c）案例练习-1"><a href="#c）案例练习-1" class="headerlink" title="c）案例练习"></a>c）案例练习</h4><ul><li><p>统计该企业员工数量</p><pre class="line-numbers language-none"><code class="language-none">select count(*) from emp; #返回结果是16，统计的是总记录数sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">select count(idcard) from emp; #返回结果是15，统计的是idcard字段不为null的记录数sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">select count(1) from emp; #会统计表中的所有的记录数，包含字段为null 的记录sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>对于<code>count(*) </code>、<code>count(字段)</code>、 <code>count(1) </code>的具体原理，我们在进阶篇中SQL优化部分会详细讲解，此处大家只需要知道如何使用即可。</p></li><li><p>统计该企业员工的平均年龄</p><pre class="line-numbers language-none"><code class="language-none">select avg(age) from emp;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>统计该企业员工的最大年龄</p><pre class="line-numbers language-none"><code class="language-none">select max(age) from emp;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>统计该企业员工的最小年龄</p><pre class="line-numbers language-none"><code class="language-none">select min(age) from emp;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>统计西安地区员工的年龄之和</p><pre class="line-numbers language-none"><code class="language-none">select sum(age) from emp where workaddress = '西安';sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h3 id="5-6-分组查询"><a href="#5-6-分组查询" class="headerlink" title="5.6 分组查询"></a>5.6 分组查询</h3><h4 id="a）-语法格式"><a href="#a）-语法格式" class="headerlink" title="a） 语法格式"></a>a） 语法格式</h4><pre class="line-numbers language-none"><code class="language-none">SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组 后过滤条件 ];sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="b）where与having区别"><a href="#b）where与having区别" class="headerlink" title="b）where与having区别"></a>b）where与having区别</h4><ul><li>执行时机不同：<code>where</code>是分组之前进行过滤，不满足<code>where</code>条件，不参与分组；而<code>having</code>是分组之后对结果进行过滤。</li><li>判断条件不同：<code>where</code>不能对聚合函数进行判断，而<code>having</code>可以。</li></ul><h4 id="c）案例练习-2"><a href="#c）案例练习-2" class="headerlink" title="c）案例练习"></a>c）案例练习</h4><ul><li><p>根据性别分组 , 统计男性员工 和 女性员工的数量</p><pre class="line-numbers language-none"><code class="language-none">select gender, count(*) from emp group by gender ;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>根据性别分组 , 统计男性员工 和 女性员工的平均年龄</p><pre class="line-numbers language-none"><code class="language-none">select gender, avg(age) from emp group by gender ;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>查询年龄小于45的员工 , 并根据工作地址分组 , 获取员工数量大于等于3的工作地址</p><pre class="line-numbers language-none"><code class="language-none">SELECT workaddress,count(*) address_countFROM empWHERE age &lt; 45GROUP BY  workaddressHAVING address_count &gt;= 3;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>统计各个工作地址上班的男性及女性员工的数量</p><pre class="line-numbers language-none"><code class="language-none">select workaddress, gender, count(*) '数量' from emp group by gender , workaddress ;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h3 id="5-7-排序查询"><a href="#5-7-排序查询" class="headerlink" title="5.7 排序查询"></a>5.7 排序查询</h3><blockquote><p>排序在日常开发中是非常常见的一个操作，有升序排序，也有降序排序。</p></blockquote><h4 id="a）语法格式-2"><a href="#a）语法格式-2" class="headerlink" title="a）语法格式"></a>a）语法格式</h4><pre class="line-numbers language-none"><code class="language-none">SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1, 字段2 排序方式2;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="b）排序方式"><a href="#b）排序方式" class="headerlink" title="b）排序方式"></a>b）排序方式</h4><ul><li><code>ASC</code>: 升序（默认）</li><li><code>DESC</code>: 降序</li></ul><p><strong>注意：如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序。</strong></p><h4 id="c）案例练习-3"><a href="#c）案例练习-3" class="headerlink" title="c）案例练习"></a>c）案例练习</h4><ul><li><p>根据年龄对公司的员工进行升序排序</p><pre class="line-numbers language-none"><code class="language-none">select * from emp order by age asc;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">select * from emp order by age;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>根据入职时间, 对员工进行降序排序</p><pre class="line-numbers language-none"><code class="language-none">select * from emp order by entrydate desc;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>根据年龄对公司的员工进行升序排序 , 年龄相同 , 再按照入职时间进行降序排序</p><pre class="line-numbers language-none"><code class="language-none">select * from emp order by age asc , entrydate desc;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h3 id="5-8-分页查询"><a href="#5-8-分页查询" class="headerlink" title="5.8 分页查询"></a>5.8 分页查询</h3><blockquote><p>分页操作在业务系统开发时，也是非常常见的一个功能，我们在网站中看到的各种各样的分页条，后台都需要借助于数据库的分页操作。</p></blockquote><h4 id="a）语法格式-3"><a href="#a）语法格式-3" class="headerlink" title="a）语法格式"></a>a）语法格式</h4><pre class="line-numbers language-none"><code class="language-none">SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="b）注意事项"><a href="#b）注意事项" class="headerlink" title="b）注意事项"></a>b）注意事项</h4><ul><li>起始索引从<code>0</code>开始，==起始索引 = （查询页码 - 1）* 每页显示记录数==。</li><li>分页查询是数据库的方言，<strong>不同的数据库有不同的实现</strong>，<code>MySQL</code>中是<code>LIMIT</code>。</li><li>如果查询的是第一页数据，起始索引可以省略，直接简写为 limit 10。</li></ul><h4 id="c）案例练习-4"><a href="#c）案例练习-4" class="headerlink" title="c）案例练习"></a>c）案例练习</h4><ul><li><p>查询第1页员工数据, 每页展示10条记录</p><pre class="line-numbers language-none"><code class="language-none">select * from emp limit 10;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">select * from emp limit 0,10;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>查询第2页员工数据, 每页展示10条记录</p><pre class="line-numbers language-none"><code class="language-none">select * from emp limit 10,10;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h3 id="5-9-执行顺序"><a href="#5-9-执行顺序" class="headerlink" title="5.9 执行顺序"></a>5.9 执行顺序</h3><blockquote><p>在讲解DQL语句的具体语法之前，我们已经讲解了DQL语句的完整语法，及编写顺序，接下来，我们要来说明的是DQL语句在执行时的执行顺序，也就是先执行那一部分，后执行那一部分。</p></blockquote><pre class="line-numbers language-none"><code class="language-none">FROM` ➤ `WHERE `➤ `GROUP BY` ➤ `SELECT `➤ `ORDER BY` ➤ `LIMIT<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MySQL/image-20220604130048234.png" alt="image-20220604130048234"></p><h2 id="6-DCL（不重要）"><a href="#6-DCL（不重要）" class="headerlink" title="6.DCL（不重要）"></a>6.DCL（不重要）</h2><blockquote><p><code>DCL</code>英文全称是**<code>Data Control Language</code>**(数据控制语言)，用来管理数据库用户、控制数据库的访问权限。</p><p>作为Java开发程序员的话，我们是无需关心DCL这一部分的，因为在实际工作中这不是我们所负责的内容！</p></blockquote><h3 id="6-1-用户管理"><a href="#6-1-用户管理" class="headerlink" title="6.1 用户管理"></a>6.1 用户管理</h3><ul><li><p>查询用户</p><pre class="line-numbers language-none"><code class="language-none">USER mysql;SELECT * FROM user;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>创建用户</p><pre class="line-numbers language-none"><code class="language-none">CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码';sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>修改用户密码</p><pre class="line-numbers language-none"><code class="language-none">ALTER USER '用户名'@'主机名' IDENTIFIED WITH mysql_native_password BY '新密码';sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>删除用户</p><pre class="line-numbers language-none"><code class="language-none">DROP USER '用户名'@'主机名';sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><p>注意：主机名可以使用 % 通配</p><h3 id="6-2-权限控制"><a href="#6-2-权限控制" class="headerlink" title="6.2 权限控制"></a>6.2 权限控制</h3><ul><li><p>常用权限</p><table><thead><tr><th align="left">权限</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">ALL, ALL PRIVILEGES</td><td align="left">所有权限</td></tr><tr><td align="left">SELECT</td><td align="left">查询数据</td></tr><tr><td align="left">INSERT</td><td align="left">插入数据</td></tr><tr><td align="left">UPDATE</td><td align="left">修改数据</td></tr><tr><td align="left">DELETE</td><td align="left">删除数据</td></tr><tr><td align="left">ALTER</td><td align="left">修改表</td></tr><tr><td align="left">DROP</td><td align="left">删除数据库/表/视图</td></tr><tr><td align="left">CREATE</td><td align="left">创建数据库/表</td></tr></tbody></table></li><li><p>查询权限</p><pre class="line-numbers language-none"><code class="language-none">SHOW GRANTS FOR '用户名'@'主机名';sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>授予权限</p><pre class="line-numbers language-none"><code class="language-none">GRANT 权限列表 ON 数据库名.表名 TO '用户名'@'主机名';sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>撤销权限</p><pre class="line-numbers language-none"><code class="language-none">REVOKE 权限列表 ON 数据库名.表名 FROM '用户名'@'主机名';sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>注意事项</p><ul><li>多个权限用逗号分隔</li><li>授权时，数据库名和表名可以用 <code>*</code> 进行通配，代表所有</li></ul></li></ul><h1 id="二、函数"><a href="#二、函数" class="headerlink" title="二、函数"></a>二、函数</h1><blockquote><p> ==函数==是指一段可以<strong>直接被另一段程序调用</strong>的程序或代码。 也就意味着，这一段程序或代码在<code>MySQL</code>中已经给我们提供了，我们要做的就是在合适的业务场景调用对应的函数完成对应的业务需求即可。</p></blockquote><p>Ps：其实很少用到函数的，可以说基本用不到，所以我这就不记那么详细了。</p><h2 id="1-字符串函数"><a href="#1-字符串函数" class="headerlink" title="1.字符串函数"></a>1.字符串函数</h2><ul><li><p>常用函数</p><table><thead><tr><th align="left">函数</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">CONCAT(s1, s2, …, sn)</td><td align="left">字符串拼接，将s1, s2, …, sn拼接成一个字符串</td></tr><tr><td align="left">LOWER(str)</td><td align="left">将字符串全部转为小写</td></tr><tr><td align="left">UPPER(str)</td><td align="left">将字符串全部转为大写</td></tr><tr><td align="left">LPAD(str, n, pad)</td><td align="left">左填充，用字符串pad对str的左边进行填充，达到n个字符串长度</td></tr><tr><td align="left">RPAD(str, n, pad)</td><td align="left">右填充，用字符串pad对str的右边进行填充，达到n个字符串长度</td></tr><tr><td align="left">TRIM(str)</td><td align="left">去掉字符串头部和尾部的空格</td></tr><tr><td align="left">SUBSTRING(str, start, len)</td><td align="left">返回从字符串str从start位置起的len个长度的字符串</td></tr></tbody></table></li><li><p>使用示例</p><pre class="line-numbers language-none"><code class="language-none">-- 拼接SELECT CONCAT('Hello', 'World');-- 小写SELECT LOWER('Hello');-- 大写SELECT UPPER('Hello');-- 左填充SELECT LPAD('01', 5, '-');-- 右填充SELECT RPAD('01', 5, '-');-- 去除空格SELECT TRIM(' Hello World ');-- 切片（起始索引为1）SELECT SUBSTRING('Hello World', 1, 5);sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="2-数值函数"><a href="#2-数值函数" class="headerlink" title="2.数值函数"></a>2.数值函数</h2><table><thead><tr><th align="left">函数</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">CEIL(x)</td><td align="left">向上取整</td></tr><tr><td align="left">FLOOR(x)</td><td align="left">向下取整</td></tr><tr><td align="left">MOD(x, y)</td><td align="left">返回x/y的模</td></tr><tr><td align="left">RAND()</td><td align="left">返回0~1内的随机数</td></tr><tr><td align="left">ROUND(x, y)</td><td align="left">求参数x的四舍五入值，保留y位小数</td></tr></tbody></table><h2 id="3-日期函数"><a href="#3-日期函数" class="headerlink" title="3.日期函数"></a>3.日期函数</h2><table><thead><tr><th align="left">函数</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">CURDATE()</td><td align="left">返回当前日期</td></tr><tr><td align="left">CURTIME()</td><td align="left">返回当前时间</td></tr><tr><td align="left">NOW()</td><td align="left">返回当前日期和时间</td></tr><tr><td align="left">YEAR(date)</td><td align="left">获取指定date的年份</td></tr><tr><td align="left">MONTH(date)</td><td align="left">获取指定date的月份</td></tr><tr><td align="left">DAY(date)</td><td align="left">获取指定date的日期</td></tr><tr><td align="left">DATE_ADD(date, INTERVAL expr type)</td><td align="left">返回一个日期/时间值加上一个时间间隔expr后的时间值</td></tr><tr><td align="left">DATEDIFF(date1, date2)</td><td align="left">返回起始时间date1和结束时间date2之间的天数</td></tr></tbody></table><h2 id="4-流程函数"><a href="#4-流程函数" class="headerlink" title="4.流程函数"></a>4.流程函数</h2><table><thead><tr><th align="left">函数</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">IF(value, t, f)</td><td align="left">如果value为true，则返回t，否则返回f</td></tr><tr><td align="left">IFNULL(value1, value2)</td><td align="left">如果value1不为空，返回value1，否则返回value2</td></tr><tr><td align="left">CASE WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END</td><td align="left">如果val1为true，返回res1，… 否则返回default默认值</td></tr><tr><td align="left">CASE [ expr ] WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END</td><td align="left">如果expr的值等于val1，返回res1，… 否则返回default默认值</td></tr></tbody></table><h1 id="三、约束"><a href="#三、约束" class="headerlink" title="三、约束"></a>三、约束</h1><blockquote><p>约束是作用于表中字段上的规则，用于限制存储在表中的数据。</p></blockquote><p>Ps：我们仅需了解约束的含义即可，实际开发中这都是在建表时就已经确定了的。</p><h2 id="1-常用约束"><a href="#1-常用约束" class="headerlink" title="1.常用约束"></a>1.常用约束</h2><table><thead><tr><th align="left">约束</th><th align="left">描述</th><th align="left">关键字</th></tr></thead><tbody><tr><td align="left">非空约束</td><td align="left">限制该字段的数据不能为null</td><td align="left">NOT NULL</td></tr><tr><td align="left">唯一约束</td><td align="left">保证该字段的所有数据都是唯一、不重复的</td><td align="left">UNIQUE</td></tr><tr><td align="left">主键约束</td><td align="left">主键是一行数据的唯一标识，要求非空且唯一</td><td align="left">PRIMARY KEY</td></tr><tr><td align="left">默认约束</td><td align="left">保存数据时，如果未指定该字段的值，则采用默认值</td><td align="left">DEFAULT</td></tr><tr><td align="left">检查约束（8.0.1版本后）</td><td align="left">保证字段值满足某一个条件</td><td align="left">CHECK</td></tr><tr><td align="left">外键约束</td><td align="left">用来让两张图的数据之间建立连接，保证数据的一致性和完整性</td><td align="left">FOREIGN KEY</td></tr></tbody></table><p>约束是作用于表中字段上的，可以在创建表/修改表的时候添加约束。</p><h2 id="2-外键约束"><a href="#2-外键约束" class="headerlink" title="2.外键约束"></a>2.外键约束</h2><blockquote><p>用来让两张表的数据之间建立连接，从而保证数据的一致性和完整性</p></blockquote><ul><li><p>建表时添加外键约束</p><pre class="line-numbers language-none"><code class="language-none">CREATE TABLE 表名(    字段名 字段类型,    ...    [CONSTRAINT] [外键名称] FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名));sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>建表后添加外键约束</p><pre class="line-numbers language-none"><code class="language-none">ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名);sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>删除外键</p><pre class="line-numbers language-none"><code class="language-none">ALTER TABLE 表名 DROP FOREIGN KEY 外键名;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><blockquote><p>删除/更新行为</p></blockquote><table><thead><tr><th align="left">行为</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">NO ACTION</td><td align="left">当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与RESTRICT一致）</td></tr><tr><td align="left">RESTRICT</td><td align="left">当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与NO ACTION一致）</td></tr><tr><td align="left">CASCADE</td><td align="left">当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则也删除/更新外键在子表中的记录</td></tr><tr><td align="left">SET NULL</td><td align="left">当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（要求该外键允许为null）</td></tr><tr><td align="left">SET DEFAULT</td><td align="left">父表有变更时，子表将外键设为一个默认值（Innodb不支持）</td></tr></tbody></table><p>更改删除/更新行为</p><pre class="line-numbers language-none"><code class="language-none">ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名(主表字段名) ON UPDATE 行为 ON DELETE 行为;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="三、多表查询"><a href="#三、多表查询" class="headerlink" title="三、多表查询"></a>三、多表查询</h1><blockquote><p> 我们之前在讲解SQL语句的时候，讲解了DQL语句，也就是数据查询语句，但是之前讲解的查询都是单表查询，而本章节我们要学习的则是多表查询操作。</p></blockquote><p>Ps：相较于约束来讲，本章确实是个重点，多表联查会在开发中经常用到，因此需要认真学习！！！</p><h2 id="1-多表关系"><a href="#1-多表关系" class="headerlink" title="1.多表关系"></a>1.多表关系</h2><p> 项目开发中，在进行数据库表结构设计时，会根据业务需求及业务模块之间的关系，分析并设计表结构，由于业务之间相互关联，所以各个表结构之间也存在着各种联系，基本上分为三种：</p><ol><li><strong>一对多（多对一）</strong></li><li><strong>多对多</strong></li><li><strong>一对一</strong></li></ol><h3 id="1-1-一对多"><a href="#1-1-一对多" class="headerlink" title="1.1 一对多"></a>1.1 一对多</h3><ul><li>案例：部门 与 员工的关系</li><li>关系：一个部门对应多个员工，一个员工对应一个部门</li><li>实现：在多的一方建立外键，指向一的一方的主键</li></ul><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MySQL/image-20220604201130760.png" alt="image-20220604201130760"></p><h3 id="1-2-多对多"><a href="#1-2-多对多" class="headerlink" title="1.2 多对多"></a>1.2 多对多</h3><ul><li>案例：学生 与 课程的关系</li><li>关系：一个学生可以选修多门课程，一门课程也可以供多个学生选择</li><li>实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</li></ul><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MySQL/image-20220604201411978.png" alt="image-20220604201411978"></p><h3 id="1-3-一对一"><a href="#1-3-一对一" class="headerlink" title="1.3 一对一"></a>1.3 一对一</h3><ul><li>案例：用户 与 用户详情的关系</li><li>关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率</li><li>实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的(UNIQUE)</li></ul><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MySQL/image-20220604201513196.png" alt="image-20220604201513196"></p><h2 id="2-多表查询概述"><a href="#2-多表查询概述" class="headerlink" title="2.多表查询概述"></a>2.多表查询概述</h2><h3 id="2-1-数据准备"><a href="#2-1-数据准备" class="headerlink" title="2.1 数据准备"></a>2.1 数据准备</h3><ul><li><p>删除之前的 emp, dept表</p></li><li><p>执行下面SQL语句</p><pre class="line-numbers language-none"><code class="language-none">CREATE TABLE dept (id int PRIMARY KEY AUTO_INCREMENT COMMENT 'ID',name varchar(50) NOT NULL COMMENT '部门名称') COMMENT '部门表';INSERT INTO dept (id, name) VALUES (1, '研发部'), (2, '市场部'),(3, '财务部'), (4, '销售部'), (5, '总经办'), (6, '人事部');CREATE TABLE emp (id int PRIMARY KEY AUTO_INCREMENT COMMENT 'ID',name varchar(50) NOT NULL COMMENT '姓名',age int COMMENT '年龄',job varchar(20) COMMENT '职位',salary int COMMENT '薪资',entrydate date COMMENT '入职时间',managerid int COMMENT '直属领导ID',dept_id int COMMENT '部门ID') COMMENT '员工表';alter table emp add constraint fk_emp_dept_id foreign key (dept_id) references dept(id);INSERT INTO emp (id, name, age, job,salary, entrydate, managerid, dept_id)VALUES    (1, '金庸', 66, '总裁', 20000, '2000-01-01', null, 5),    (2, '张无忌', 20, '项目经理', 12500, '2005-12-05', 1, 1),    (3, '杨逍', 33, '开发', 8400, '2000-11-03', 2, 1),    (4, '韦一笑', 48, '开发', 11000, '2002-02-05', 2, 1),    (5, '常遇春', 43, '开发', 10500, '2004-09-07', 3, 1),    (6, '小昭', 19, '程序员鼓励师', 6600, '2004-10-12', 2, 1),    (7, '灭绝', 60, '财务总监', 8500, '2002-09-12', 1, 3),    (8, '周芷若', 19, '会计', 48000, '2006-06-02', 7, 3),    (9, '丁敏君', 23, '出纳', 5250, '2009-05-13', 7, 3),    (10, '赵敏', 20, '市场部总监', 12500, '2004-10-12', 1, 2),    (11, '鹿杖客', 56, '职员', 3750, '2006-10-03', 10, 2),    (12, '鹤笔翁', 19, '职员', 3750, '2007-05-09', 10, 2),    (13, '方东白', 19, '职员', 5500, '2009-02-12', 10, 2),    (14, '张三丰', 88, '销售总监', 14000, '2004-10-12', 1, 4),    (15, '俞莲舟', 38, '销售', 4600, '2004-10-12', 14, 4),    (16, '宋远桥', 40, '销售', 4600, '2004-10-12', 14, 4),    (17, '陈友谅', 42, null, 2000, '2011-10-12', 1, null);sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="2-2-笛卡尔积"><a href="#2-2-笛卡尔积" class="headerlink" title="2.2 笛卡尔积"></a>2.2 笛卡尔积</h3><blockquote><p>笛卡尔乘积是指在数学中，两个集合 A集合 和 B集合 的所有组合情况。</p></blockquote><ul><li><p>这是我们查单表的SQL语句</p><pre class="line-numbers language-none"><code class="language-none">select * from emp;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>那么我们要执行多表查询，就只需要使用逗号分隔多张表即可</p><pre class="line-numbers language-none"><code class="language-none">select * from emp , dept;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>但是这个时候查出来的结果却是102条记录</p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MySQL/image-20220605080339628.png" alt="image-20220605080339628"></p><p>与 部门表dept所有记录(6) 的所有组合情况，这种现象称之为笛卡尔积。</p></li></ul><blockquote><p>在SQL语句中，如何来去除无效的笛卡尔积呢？ 我们可以给多表查询加上连接查询的条件即可。</p></blockquote><pre class="line-numbers language-none"><code class="language-none">select * from emp , dept where emp.dept_id = dept.id;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MySQL/image-20220605080630910.png" alt="image-20220605080630910"></p><p>而由于id为17的员工，没有<code>dept_id</code>字段值，所以在多表查询时，根据连接查询的条件并没有查询到。</p><h3 id="2-3-分类"><a href="#2-3-分类" class="headerlink" title="2.3 分类"></a>2.3 分类</h3><blockquote><p>多表查询又分为以下两大类：</p></blockquote><ul><li>连接查询<ul><li>内连接：相当于查询A、B交集部分数据</li><li>外连接：<ul><li>左外连接：查询左表所有数据，以及两张表交集部分数据</li><li>右外连接：查询右表所有数据，以及两张表交集部分数据</li></ul></li><li>自连接：当前表与自身的连接查询，自连接必须使用表别名</li></ul></li><li>子查询</li></ul><h2 id="3-内连接"><a href="#3-内连接" class="headerlink" title="3.内连接"></a>3.内连接</h2><blockquote><p>内连接查询的是两张表交集部分的数据。(也就是绿色部分的数据)</p></blockquote><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MySQL/image-20220605081106113.png" alt="image-20220605081106113"></p><p>内连接的语法分为两种：<strong>隐式内连接</strong>、<strong>显式内连接</strong>。</p><h3 id="3-1-语法格式"><a href="#3-1-语法格式" class="headerlink" title="3.1 语法格式"></a>3.1 语法格式</h3><ul><li><p>隐式内连接</p><pre class="line-numbers language-none"><code class="language-none">SELECT 字段列表 FROM 表1 , 表2 WHERE 条件 ... ;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>显式内连接</p><pre class="line-numbers language-none"><code class="language-none">SELECT 字段列表 FROM 表1 [ INNER ] JOIN 表2 ON 连接条件 ... ;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h3 id="3-2-案例练习"><a href="#3-2-案例练习" class="headerlink" title="3.2 案例练习"></a>3.2 案例练习</h3><ul><li>查询每一个员工的姓名 , 及关联的部门的名称 (隐式内连接实现)</li></ul><pre class="line-numbers language-none"><code class="language-none">select e.`name`, d.`name` from emp e,dept d where e.dept_id = d.id;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><p>查询每一个员工的姓名 , 及关联的部门的名称 (显式内连接实现)</p><pre class="line-numbers language-none"><code class="language-none">select e.`name`, d.`name` from emp e join dept d on e.dept_id = d.id;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h2 id="4-外连接"><a href="#4-外连接" class="headerlink" title="4.外连接"></a>4.外连接</h2><blockquote><p>外连接和内连接一样查询的都是两个表交集的数据，不同的是左外连接会查询左表的全部数据以及交集数据，右外连接与之相对。</p></blockquote><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MySQL/image-20220605081106113.png" alt="image-20220605081106113"></p><h3 id="4-1-语法格式"><a href="#4-1-语法格式" class="headerlink" title="4.1 语法格式"></a>4.1 语法格式</h3><ul><li><p>左外连接</p><pre class="line-numbers language-none"><code class="language-none">SELECT 字段列表 FROM 表1 LEFT [ OUTER ] JOIN 表2 ON 条件 ... ;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>右外连接</p><pre class="line-numbers language-none"><code class="language-none">SELECT 字段列表 FROM 表1 RIGHT [ OUTER ] JOIN 表2 ON 条件 ...;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h3 id="4-2-案例练习"><a href="#4-2-案例练习" class="headerlink" title="4.2 案例练习"></a>4.2 案例练习</h3><ul><li><p>查询<code>emp</code>表的所有数据, 和对应的部门信息（左外）</p><pre class="line-numbers language-none"><code class="language-none">select e.*,d.name from emp e left join dept d on e.dept_id = d.id;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>查询<code>dept</code>表的所有数据, 和对应的员工信息（右外）</p><pre class="line-numbers language-none"><code class="language-none">select e.*,d.name from emp e right join dept d on e.dept_id = d.id;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><p> 左外连接和右外连接是可以相互替换的，只需要调整在连接查询时SQL中，表结构的先后顺序就可以了。而我们在日常开发使用时，更偏向于左外连接。</p><h2 id="5-自连接"><a href="#5-自连接" class="headerlink" title="5.自连接"></a>5.自连接</h2><h3 id="5-1-自链接查询"><a href="#5-1-自链接查询" class="headerlink" title="5.1 自链接查询"></a>5.1 自链接查询</h3><blockquote><p>当前表与自身的连接查询，自连接必须使用表别名</p></blockquote><ul><li><p>语法格式</p><pre class="line-numbers language-none"><code class="language-none">SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ...;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>自连接查询，可以是内连接查询，也可以是外连接查询</p></li><li><p>案例练习</p><pre class="line-numbers language-none"><code class="language-none">-- 查询员工及其所属领导的名字select a.name, b.name from employee a, employee b where a.manager = b.id;-- 没有领导的也查询出来select a.name, b.name from employee a left join employee b on a.manager = b.id;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="5-2-联合查询"><a href="#5-2-联合查询" class="headerlink" title="5.2 联合查询"></a>5.2 联合查询</h3><blockquote><p>把多次查询的结果合并，形成一个新的查询集，其实就是吧两个查询语句给连起来了。</p></blockquote><ul><li><p>语法格式</p><pre class="line-numbers language-none"><code class="language-none">SELECT 字段列表 FROM 表A ...UNION [ALL]SELECT 字段列表 FROM 表B ...sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>注意事项</p><ul><li>UNION ALL 会有重复结果，UNION 不会</li><li>联合查询比使用or效率高，不会使索引失效</li></ul></li></ul><h2 id="6-子查询"><a href="#6-子查询" class="headerlink" title="6.子查询"></a>6.子查询</h2><h3 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h3><blockquote><p>SQL语句中嵌套SELECT语句，称为嵌套查询，又称子查询。</p></blockquote><ul><li><p>语法格式</p><pre class="line-numbers language-none"><code class="language-none">SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2);sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>子查询外部的语句可以是<code>INSERT </code>/ <code>UPDATE </code>/ <code>DELETE </code>/ <code>SELECT </code>的任何一个。</p></li><li><p>根据子查询结果不同，分为：</p><ul><li>标量子查询（子查询结果为单个值）</li><li>列子查询（子查询结果为一列）</li><li>行子查询（子查询结果为一行）</li><li>表子查询（子查询结果为多行多列）</li></ul></li><li><p>根据子查询位置，分为：</p><ul><li>WHERE 之后</li><li>FROM 之后</li><li>SELECT 之后</li></ul></li></ul><h3 id="6-2-标量子查询"><a href="#6-2-标量子查询" class="headerlink" title="6.2 标量子查询"></a>6.2 标量子查询</h3><blockquote><p>子查询返回的结果是单个值（数字、字符串、日期等），最简单的形式，这种子查询称为标量子查询。</p></blockquote><p>常用操作符：<code>- &lt; &gt; &gt; &gt;= &lt; &lt;=</code></p><p>案例练习：</p><ul><li><p>查询 “销售部” 的所有员工信息</p><pre class="line-numbers language-none"><code class="language-none">select * from emp where dept_id = (select id from dept where name = '销售部');sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>查询在 “方东白” 入职之后的员工信息</p></li></ul><pre class="line-numbers language-none"><code class="language-none">select * from emp where entrydate &gt; (select entrydate from emp where name = '方东白');sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="6-3-列子查询"><a href="#6-3-列子查询" class="headerlink" title="6.3 列子查询"></a>6.3 列子查询</h3><blockquote><p>子查询返回的结果是一列（可以是多行），这种子查询称为列子查询。</p></blockquote><p>常用的操作符：<code>IN 、NOT IN 、 ANY 、SOME 、 ALL</code></p><table><thead><tr><th align="left">操作符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">IN</td><td align="left">在指定的集合范围内，多选一</td></tr><tr><td align="left">NOT IN</td><td align="left">不在指定的集合范围内</td></tr><tr><td align="left">ANY</td><td align="left">子查询返回列表中，有任意一个满足即可</td></tr><tr><td align="left">SOME</td><td align="left">与ANY等同，使用SOME的地方都可以使用ANY</td></tr><tr><td align="left">ALL</td><td align="left">子查询返回列表的所有值都必须满足</td></tr></tbody></table><p>案例练习：</p><ul><li><p>查询 “销售部” 和 “市场部” 的所有员工信息</p><pre class="line-numbers language-none"><code class="language-none">select * from emp where dept_id in (select id from dept where name = '销售部' or name = '市场部');sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>查询比 “财务部” 所有人工资都高的员工信息</p><pre class="line-numbers language-none"><code class="language-none">select * from emp where salary &gt; all ( select salary from emp where dept_id = (select id from dept where name = '财务部') );sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>查询比研发部其中任意一人工资高的员工信息</p><pre class="line-numbers language-none"><code class="language-none">select * from emp where salary &gt; any ( select salary from emp where dept_id = (select id from dept where name = '研发部') );sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h3 id="6-4-行子查询"><a href="#6-4-行子查询" class="headerlink" title="6.4 行子查询"></a>6.4 行子查询</h3><blockquote><p>子查询返回的结果是一行（可以是多列），这种子查询称为行子查询。</p></blockquote><p>常用的操作符：<code>= 、&lt;&gt; 、IN 、NOT IN</code></p><p>案例练习：</p><ul><li>查询与 “张无忌” 的薪资及直属领导相同的员工信息 ;</li></ul><pre class="line-numbers language-none"><code class="language-none">select * from emp where (salary,managerid) = (select salary, managerid from emp where name = '张无忌');sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="6-5-表子查询"><a href="#6-5-表子查询" class="headerlink" title="6.5 表子查询"></a>6.5 表子查询</h3><blockquote><p>子查询返回的结果是多行多列，这种子查询称为表子查询。</p></blockquote><p>常用操作符：<code>IN</code></p><p>案例练习：</p><ul><li><p>查询与 “鹿杖客” , “宋远桥” 的职位和薪资相同的员工信息</p><pre class="line-numbers language-none"><code class="language-none">select * from emp where (job,salary) in ( select job, salary from emp where name = '鹿杖客' or name = '宋远桥' );sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>查询入职日期是 “2006-01-01” 之后的员工信息 , 及其部门信息</p><pre class="line-numbers language-none"><code class="language-none">select e.*, d.* from (select * from emp where entrydate &gt; '2006-01-01') e left join dept d on e.dept_id = d.id ;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h1 id="四、事务"><a href="#四、事务" class="headerlink" title="四、事务"></a>四、事务</h1><h2 id="1-事务简介"><a href="#1-事务简介" class="headerlink" title="1.事务简介"></a>1.事务简介</h2><blockquote><p> <strong>事务</strong>是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p></blockquote><p>举例说明：</p><p> 张三给李四转账1000块钱，张三银行账户的钱==减少1000==，而李四银行账户的钱要==增加1000==。 这一组操作就必须在一个事务的范围内，<strong>要么都成功</strong>，<strong>要么都失败</strong>。</p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MySQL/image-20220605121214330.png" alt="image-20220605121214330"></p><p><strong>注意： 默认MySQL的事务是自动提交的，也就是说，当执行完一条DML语句时，MySQL会立即隐式的提交事务。</strong></p><h2 id="2-事务操作"><a href="#2-事务操作" class="headerlink" title="2.事务操作"></a>2.事务操作</h2><h3 id="2-1-数据准备-1"><a href="#2-1-数据准备-1" class="headerlink" title="2.1 数据准备"></a>2.1 数据准备</h3><blockquote><p>在开始学习事务之前需要先执行以下SQL语句来导入数据。</p></blockquote><pre class="line-numbers language-none"><code class="language-none">drop table if exists account;create table account(    id int primary key AUTO_INCREMENT comment 'ID',    name varchar(10) comment '姓名',    money double(10, 2) comment '余额') comment '账户表';insert into account(name, money) VALUES ('张三', 2000),('李四', 2000);sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-未控制事务"><a href="#2-2-未控制事务" class="headerlink" title="2.2 未控制事务"></a>2.2 未控制事务</h3><blockquote><p>当前情境下事务是MySQL默认的事务，也就是每执行一句更新操作都将由MySQL自动隐式提交。</p></blockquote><ul><li><p>测试转账操作的正常情况</p><pre class="line-numbers language-none"><code class="language-none">-- 1. 查询张三余额 select * from account where name = '张三'; -- 2. 张三的余额减少1000 update account set money = money - 1000 where name = '张三'; -- 3. 李四的余额增加1000 update account set money = money + 1000 where name = '李四';sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MySQL/image-20220605122748424.png" alt="image-20220605122748424"></p></li><li><p>测试异常情况（执行之前先将两个人的余额都恢复到2000）</p><pre class="line-numbers language-none"><code class="language-none">-- 1. 查询张三余额 select * from account where name = '张三'; -- 2. 张三的余额减少1000 update account set money = money - 1000 where name = '张三'; 出错了...-- 3. 李四的余额增加1000 update account set money = money + 1000 where name = '李四';sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MySQL/image-20220605123015353.png" alt="image-20220605123015353"></p></li></ul><p> 通过上面的两种情况演示，我们得知如果是异常情况的话，这种错误是非常致命的，假如真的是两个人之间的转账，一方钱减少了，另一方却没有增加的话，用户必定会勃然大怒，因此我们需要通过控制事务的方式来避免这种情况的出现！</p><h3 id="2-3-控制事务一（不常用）"><a href="#2-3-控制事务一（不常用）" class="headerlink" title="2.3 控制事务一（不常用）"></a>2.3 控制事务一（不常用）</h3><ul><li><p>查看/设置事务提交方式</p><pre class="line-numbers language-none"><code class="language-none">SELECT @@autocommit ; SET @@autocommit = 0 ;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>提交事务</p><pre class="line-numbers language-none"><code class="language-none">COMMIT;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>回滚事务</p><pre class="line-numbers language-none"><code class="language-none">ROLLBACK;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><p><strong>注意</strong>：上述的这种方式，我们是修改了事务的自动提交行为, 把默认的自动提交修改为了手动提交, 此时我们执行的DML语句都不会提交, 需要手动的执行<code>commit</code>进行提交。</p><h3 id="2-4-控制事务二（常用）"><a href="#2-4-控制事务二（常用）" class="headerlink" title="2.4 控制事务二（常用）"></a>2.4 控制事务二（常用）</h3><ul><li><p>开启事务</p><pre class="line-numbers language-none"><code class="language-none">START TRANSACTION 或 BEGIN TRANSACTION;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>提交事务</p><pre class="line-numbers language-none"><code class="language-none">COMMIT;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>回滚事务</p><pre class="line-numbers language-none"><code class="language-none">ROLLBACK;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h3 id="2-5-转账案例"><a href="#2-5-转账案例" class="headerlink" title="2.5 转账案例"></a>2.5 转账案例</h3><blockquote><p>接下来通过控制事务的方式演示一遍转账操作。</p></blockquote><pre class="line-numbers language-none"><code class="language-none">-- 开启事务 start transaction -- 1. 查询张三余额 select * from account where name = '张三'; -- 2. 张三的余额减少1000 update account set money = money - 1000 where name = '张三'; -- 3. 李四的余额增加1000 update account set money = money + 1000 where name = '李四'; -- 如果正常执行完毕, 则提交事务 commit; -- 如果执行过程中报错, 则回滚事务 -- rollback;sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-事务四大特性（ACID）"><a href="#3-事务四大特性（ACID）" class="headerlink" title="3.事务四大特性（ACID）"></a>3.事务四大特性（ACID）</h2><ul><li>原子性(<code>Atomicity</code>)：事务是不可分割的最小操作但愿，要么全部成功，要么全部失败</li><li>一致性(<code>Consistency</code>)：事务完成时，必须使所有数据都保持一致状态</li><li>隔离性(<code>Isolation</code>)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</li><li>持久性(<code>Durability</code>)：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的</li></ul><h2 id="4-并发事务问题"><a href="#4-并发事务问题" class="headerlink" title="4.并发事务问题"></a>4.并发事务问题</h2><table><thead><tr><th align="left">问题</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">脏读</td><td align="left">一个事务读到另一个事务还没提交的数据</td></tr><tr><td align="left">不可重复读</td><td align="left">一个事务先后读取同一条记录，但两次读取的数据不同</td></tr><tr><td align="left">幻读</td><td align="left">一个事务按照条件查询数据时，没有对应的数据行，但是再插入数据时，又发现这行数据已经存在</td></tr></tbody></table><ul><li><p>赃读（比如B读取到了A未提交的数据）</p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MySQL/image-20220605125309397.png" alt="image-20220605125309397"></p></li><li><p>不可重复读（事务A两次读取同一条记录，但是读取到的数据却是不一样的）</p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MySQL/image-20220605125417374.png" alt="image-20220605125417374"></p></li><li><p>幻读</p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MySQL/image-20220605125445124.png" alt="image-20220605125445124"></p></li></ul><h2 id="5-事务隔离级别"><a href="#5-事务隔离级别" class="headerlink" title="5.事务隔离级别"></a>5.事务隔离级别</h2><table><thead><tr><th align="left">隔离级别</th><th align="left">脏读</th><th align="left">不可重复读</th><th align="left">幻读</th></tr></thead><tbody><tr><td align="left">Read uncommitted</td><td align="left">√</td><td align="left">√</td><td align="left">√</td></tr><tr><td align="left">Read committed</td><td align="left">×</td><td align="left">√</td><td align="left">√</td></tr><tr><td align="left"><strong>Repeatable Read(默认)</strong></td><td align="left">×</td><td align="left">×</td><td align="left">√</td></tr><tr><td align="left">Serializable</td><td align="left">×</td><td align="left">×</td><td align="left">×</td></tr></tbody></table><ul><li><p>√表示在当前隔离级别下该问题会出现</p></li><li><p><code>Serializable </code>性能最低；<code>Read uncommitted</code> 性能最高，数据安全性最差</p></li><li><p>查看事务隔离级别：<code>SELECT @@TRANSACTION_ISOLATION;</code></p></li><li><p>设置事务隔离级别：</p><pre class="line-numbers language-none"><code class="language-none">SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE };sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>SESSION </code>是会话级别，表示只针对当前会话有效，<code>GLOBAL </code>表示对所有会话有效</p><p><strong>文章链接：</strong><a href="https://www.oz6.cn/articles/67">https://www.oz6.cn/articles/67</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>黑天鹅效应、灰犀牛事件、明斯基时刻</title>
      <link href="/archives/4f098c73.html"/>
      <url>/archives/4f098c73.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="黑天鹅效应、灰犀牛事件、明斯基时刻"><a href="#黑天鹅效应、灰犀牛事件、明斯基时刻" class="headerlink" title="黑天鹅效应、灰犀牛事件、明斯基时刻"></a>黑天鹅效应、灰犀牛事件、明斯基时刻</h1><p><strong>黑天鹅效应</strong>（英语：<strong>Black swan theory</strong>）是指极不可能发生，实际上却又发生的事件。主要具有三大特性：</p><ul><li>这个事件是个<a href="https://zh.wikipedia.org/w/index.php?title=%E9%9B%A2%E7%BE%A4%E5%80%BC&amp;action=edit&amp;redlink=1">离群值</a>，因为它出现在一般的期望范围之外，过去的经验让人不相信其出现的可能。</li><li>它会带来极大的冲击。</li><li>尽管事件处于离群值，一旦发生，人会因为天性使然而作出某种解释，让这事件成为可解释或可预测。（此非要件，只是解释人类现象的一环，仅满足前两者即可称之黑天鹅事件）</li></ul><p><a href="https://zh.wikipedia.org/wiki/%E7%B4%8D%E8%A5%BF%E5%A7%86%C2%B7%E5%B0%BC%E5%8F%AF%E6%8B%89%E6%96%AF%C2%B7%E5%A1%94%E9%9B%B7%E4%BC%AF">纳西姆·尼可拉斯·塔雷伯</a>在他的2001年书籍《*<a href="https://zh.wikipedia.org/w/index.php?title=Fooled_by_Randomness&amp;action=edit&amp;redlink=1">Fooled by Randomness</a>*》中讨论了黑天鹅事件，而该书涉及金融事件。他在2007年出版的书籍《<a href="https://zh.wikipedia.org/wiki/%E9%BB%91%E5%A4%A9%E9%B5%9D%E6%95%88%E6%87%89_(%E6%9B%B8%E7%B1%8D)">黑天鹅效应</a>》中将这个隐喻扩展到<a href="https://zh.wikipedia.org/wiki/%E9%87%91%E8%9E%8D%E5%B8%82%E5%A0%B4">金融市场</a>以外的事件。</p><h2 id="典故"><a href="#典故" class="headerlink" title="典故"></a>典故</h2><p>在18世纪欧洲人发现澳洲之前，由于他们所见过的天鹅都是白色的，所以在当时欧洲人眼中，天鹅只有白色的品种。直到欧洲人发现了澳洲，看到当地的黑天鹅后，人们认识天鹅的视野才打开，只需一个黑天鹅的观察结果就能使从无数次对白天鹅的观察中推理出的一般结论失效，引起了人们对认知的反思－以往认为对的不等于以后总是对的。“黑天鹅”隐喻那些意外事件：它们极为罕见，在通常的预期之外，在发生前，没有任何前例可以证明，但一旦发生，就会产生极端的影响。</p><p>◎<a href="https://zh.wikipedia.org/wiki/%E9%BB%91%E5%A4%A9%E9%B5%9D%E6%95%88%E6%87%89">黑天鵝效應：维基百科</a> | <a href="https://baike.baidu.com/item/%E9%BB%91%E5%A4%A9%E9%B9%85%E4%BA%8B%E4%BB%B6">黑天鹅事件：百度百科</a></p><hr><p><a href="https://cdn.chegva.com/ueditor/php/upload/image/20200219/1582101971137701.jpg"><img src="https://cdn.chegva.com/ueditor/php/upload/image/20200219/1582101971137701.jpg" alt="黑天鹅效应、灰犀牛事件、明斯基时刻"></a></p><p>灰犀牛是据古根海姆学者奖获得者<a href="https://baike.baidu.com/item/%E7%B1%B3%E6%AD%87%E5%B0%94%C2%B7%E6%B8%A5%E5%85%8B/23544598">米歇尔·渥克</a>的《灰犀牛：如何应对大概率危机》一书，“黑天鹅”比喻小概率而影响巨大的事件，而“灰犀牛”则比喻大概率且影响巨大的潜在危机。</p><p>在金融方面，“黑天鹅”一般指那些出乎意料发生的小概率风险事件；“灰犀牛”指那些经常被提示却没有得到充分重视的大概率风险事件；“明斯基时刻”主要指在经过一段时期的经济平稳发展，负债不断提高难以持续，债务风险忽然爆发的资产价值崩溃时刻(拐点)。 </p><p>2017年12月13日，“灰犀牛”入选国家语言资源监测与研究中心发布的“2017年度中国媒体十大新词语”。</p><p>工程学上有一个定律，在一次重大事故发生之前，已经有超过99次的小事故发生过了。但由于人们忽视小事故给出的信号、预兆、警示，或者即使看到危险信号也未积极采取行动阻止危机，而等到灾难真正降临时，才惊觉无处可躲、无计可施。这种由人们习以为常、不加防范的小风险引发的大事故就是“灰犀牛”事件。</p><p>非洲草原上的灰犀牛，体形庞大、行动迟缓，远远看着似乎并没有威胁，而当它一旦被触怒、向你奔袭而来时，能够逃脱的几率微乎其微。“灰犀牛”事件不是随机突发的事件，而是在出现一系列警示信号和危险迹象之后，如果不加处置就会出现的大概率事件。一般来说，它有三个特征：一是可预见性；二是发生概率高，具有一定确定性；三是波及范围广、破坏力强。很多从表象上看是让人猝不及防的偶发事件，如果顺着事件的导火索仔细分析就会发现，其实是众多小因素集聚的必然结果。</p><p><a href="https://baike.baidu.com/item/%E7%81%B0%E7%8A%80%E7%89%9B/22030944">◎ 灰犀牛：百度百科</a></p><hr><p><strong>明斯基时刻</strong>（<a href="https://zh.wikipedia.org/wiki/%E8%8B%B1%E8%AF%AD">英语</a>：Minsky Moment）指在<a href="https://zh.wikipedia.org/w/index.php?title=%E4%BF%A1%E8%B4%B7%E5%91%A8%E6%9C%9F&amp;action=edit&amp;redlink=1">信贷周期</a>或者<a href="https://zh.wikipedia.org/wiki/%E6%99%AF%E6%B0%A3%E5%BE%AA%E7%92%B0">景气循环</a>中，资产价格的大幅下跌。在长期的经济繁荣中，资产价格上涨会导致投机性的贷款增加，而过多投机所产生的债务会造成投资者的现金流紧缺，即资产产生的现金流不足以支付债务需要的利息。当债权人要求偿还债务时，深陷债务问题的投资者必须卖掉资产价格相对稳定的投资物来维持现金流，然而此时已经没有交易对手方会支付如此高的资产价格。一系列的抛售将导致资产价格进一步下跌，以及流动性紧张，并最终造成资产价格的崩溃。[<a href="https://zh.wikipedia.org/wiki/%E6%98%8E%E6%96%AF%E5%9F%BA%E6%97%B6%E5%88%BB#cite_note-guardian-1">1]</a>[<a href="https://zh.wikipedia.org/wiki/%E6%98%8E%E6%96%AF%E5%9F%BA%E6%97%B6%E5%88%BB#cite_note-WSJ20070818-2">2]</a></p><p>一种更普遍的含义是说，“明斯基周期”以一系列的明斯基时刻为特征，一段时间的稳定鼓励了风险的承担，进而导致一段时间的不稳定，而这又导致更保守和回避风险（去杠杆）的行为，直到稳定性恢复，从而继续下个周期的循环。在这种更普遍的观点中，明斯基周期可以应用到更广泛的人类活动中，而不仅限于投资经济学。</p><p>这个概念是由<a href="https://zh.wikipedia.org/w/index.php?title=%E5%A4%AA%E5%B9%B3%E6%B4%8B%E6%8A%95%E8%B5%84%E7%AE%A1%E7%90%86%E5%85%AC%E5%8F%B8&amp;action=edit&amp;redlink=1">太平洋投资管理公司</a>的<a href="https://zh.wikipedia.org/w/index.php?title=%E4%BF%9D%E7%BD%97%C2%B7%E9%BA%A6%E5%85%8B%E9%87%8C&amp;action=edit&amp;redlink=1">保罗·麦克里</a>在1998年提出用来描述<a href="https://zh.wikipedia.org/wiki/1998%E5%B9%B4%E4%BF%84%E7%BD%97%E6%96%AF%E9%87%91%E8%9E%8D%E5%8D%B1%E6%9C%BA">1998年俄罗斯金融危机</a>，[<a href="https://zh.wikipedia.org/wiki/%E6%98%8E%E6%96%AF%E5%9F%BA%E6%97%B6%E5%88%BB#cite_note-WSJ20070818-2">2]</a> 以<a href="https://zh.wikipedia.org/wiki/%E6%B5%B7%E6%9B%BC%C2%B7%E9%97%B5%E6%96%AF%E5%9F%BA">海曼·明斯基</a>名字命名。麦克里将<a href="https://zh.wikipedia.org/wiki/2007%E5%B9%B4%E2%80%932008%E5%B9%B4%E7%92%B0%E7%90%83%E9%87%91%E8%9E%8D%E5%8D%B1%E6%A9%9F">2007年–2008年环球金融危机</a>的开始，即2007年8月视为明斯基时刻，并称之后的危机是”反明斯基过程”，[<a href="https://zh.wikipedia.org/wiki/%E6%98%8E%E6%96%AF%E5%9F%BA%E6%97%B6%E5%88%BB#cite_note-3">3]</a> 而也有人将之前2007年6月的两个<a href="https://zh.wikipedia.org/wiki/%E8%B4%9D%E5%B0%94%E6%96%AF%E7%99%BB">贝尔斯登</a>基金的失败视为明斯基时刻的开始。</p><p>虽然海曼·明斯基被普遍认为是<a href="https://zh.wikipedia.org/wiki/%E5%90%8E%E5%87%AF%E6%81%A9%E6%96%AF%E5%AD%A6%E6%B4%BE">后凯恩斯学派</a>[<a href="https://zh.wikipedia.org/wiki/%E6%98%8E%E6%96%AF%E5%9F%BA%E6%97%B6%E5%88%BB#cite_note-4">4]</a>，但该理论与<a href="https://zh.wikipedia.org/w/index.php?title=%E5%A5%A5%E5%9C%B0%E5%88%A9%E7%BB%8F%E6%B5%8E%E5%91%A8%E6%9C%9F%E7%90%86%E8%AE%BA&amp;action=edit&amp;redlink=1">奥地利经济周期理论</a>类似[<a href="https://zh.wikipedia.org/wiki/%E6%98%8E%E6%96%AF%E5%9F%BA%E6%97%B6%E5%88%BB#cite_note-5">5]</a>。</p><p>经济好的时候，投资者倾向于承担更多风险，随着经济向好的时间不断推移，投资者承受的风险水平越大，直到超过收支不平衡点而崩溃。这种投机资产促使放贷人尽快回收借出去的款项。“就像引导到资产价值崩溃时刻”。</p><p>明斯基时刻表示的是市场繁荣与衰退之间的转折点。明斯基的观点简单明了：好日子的时候，投资者敢于冒险；好日子的时间越长，投资者冒险越多，直到过度冒险。一步一步地，投资者会到达一个临界点上，其资产所产生的现金不再足以偿付他们用来获得资产所举的债务。投机性资产的损失促使放贷者收回其贷款。“从而导致资产价值的崩溃。”</p>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>斯德哥尔摩综合征</title>
      <link href="/archives/42f107d8.html"/>
      <url>/archives/42f107d8.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="斯德哥尔摩综合征"><a href="#斯德哥尔摩综合征" class="headerlink" title="斯德哥尔摩综合征"></a>斯德哥尔摩综合征</h1><p><strong>斯德哥尔摩症候群</strong>（英语：Stockholm syndrome；瑞典语：Stockholmssyndromet）又称为<strong>人质情结</strong>、<strong>人质综合症</strong>，是一种心理学现象，<strong>是指被害者对于加害者产生情感，同情加害者、认同加害者的某些观点和想法，甚至反过来帮助加害者的一种情结****。</strong></p><p>斯德哥尔摩症候群可以被看作是一种创伤羁绊，不一定只发生在人质身上，只要加害者对被害者实施骚扰，都可能使被害者对加害者产生强烈的情感。根据<a href="https://www.wikiwand.com/zh-cn/%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7">弗洛伊德</a>的理论，斯德哥尔摩症候群是一种自我防卫机制，当受害者相信加害者的想法时，他们会觉得自己不再受到威胁。斯德哥尔摩症候群并非正式<strong>精神疾病</strong>名词。斯德哥尔摩症候群更倾向是人们用来掩盖不想讨论问题的假想状态。</p><ul><li><a href="https://zh.wikipedia.org/wiki/%E6%96%AF%E5%BE%B7%E5%93%A5%E7%88%BE%E6%91%A9%E7%97%87%E5%80%99%E7%BE%A4">维基：斯德哥尔摩综合征</a></li><li><a href="https://baike.baidu.com/item/%E6%96%AF%E5%BE%B7%E5%93%A5%E5%B0%94%E6%91%A9%E7%BB%BC%E5%90%88%E5%BE%81/8777985">百科：斯德哥尔摩综合征</a></li></ul><blockquote><h3 id="词语释意"><a href="#词语释意" class="headerlink" title="词语释意"></a><strong>词语释意</strong></h3></blockquote><p>更多：<a href="https://zh.wikipedia.org/wiki/%E8%AF%BA%E9%A9%AC%E5%B0%94%E5%A7%86%E5%B9%BF%E5%9C%BA%E5%8A%AB%E6%A1%88">维基百科：诺马尔姆广场劫案</a> | <a href="https://www.sohu.com/a/538606078_120271802">“斯德哥尔摩综合征”真的存在吗？</a></p><p>1973年8月23日，两名有前科的罪犯让—埃里克·欧森与克拉克·欧洛弗森，抢劫瑞典斯德哥尔摩内位于诺玛姆斯托格（英语：Norrmalmstorg）广场最大的一家信贷银行，并挟持了四位银行职员。在与警察僵持了130个小时后，歹徒最终投降。然而这起事件发生后几个月，4名曾经遭受挟持的银行职员，仍然对绑架他们的人显露出怜悯的情感，表明并不痛恨歹徒，表达他们对歹徒不但没有伤害他们却对他们多加照顾的感激，并且对警察采取敌对的态度，在案件发生后被挟持者不愿意在法庭指出歹徒，在挟持案件当中被挟持者还与歹徒成为朋友。更甚者，人质中一名女职员Christian竟然还爱上劫匪Olofsson，并与他在服刑期间订婚。</p><p>这两名抢匪劫持人质达5日之久，在这期间他们威胁被绑架者的性命，但有时也表现出仁慈的一面。在出人意表的心理错综转变下，4名人质抗拒瑞典政府最终营救他们的努力。斯德哥尔摩症候群因为在斯德哥尔摩人质挟持事件中被发现而得名。</p><p>这件事激起了社会科学家的兴趣，他们想要了解在掳人者与遭挟持者之间的这份感情结合，到底是发生在这起斯德哥尔摩银行抢案的一宗特例，还是这种情感结合代表了一种普遍的心理反应。而后来的研究显示，这起研究学者称为“斯德哥尔摩症候群”的事件，令人惊讶的普遍。研究者发现到这种症候群的例子见诸于各种不同的经验中，从<strong>集中营的囚犯</strong>、战俘、受虐妇女与乱伦的受害者，都可能发生斯德哥尔摩综合征体验。</p><p>专家深入研究：人性能承受的恐惧有一条脆弱的底线。当人被一个凶残狂暴的施暴者完全控制，随时威胁他的生命，人质就会把生命权渐渐付托给这个凶徒。时间拖久了，人质吃一口饭、喝一口水，每一呼吸，他自己都会觉得是恐怖分子对他的宽忍和慈悲。对于绑架自己的暴徒，他的恐惧，会先转化为对他的感激，然后变为一种崇拜，最后人质也下意识地以为凶徒的安全，就是自己的安全。</p><p><strong>这种屈服于暴虐的弱点</strong>，就叫<strong>“斯德哥尔摩精神症候群</strong>”。</p><p>关于进化心理学的解释，心理分析学的看法，新生婴儿会与最靠近的有力成人形成一种情绪依附，以最大化周边成人让他至少能生存（或成为理想父母）的可能，此综合征可能是由此发展而来。斯德哥尔摩综合征是角色认同防卫机制的重要范例。</p><p>正如这句话所说：<strong>人是可以被驯养的。</strong> → <a href="https://site.douban.com/106407/widget/notes/335509/note/160783335/">人是可以被驯养的——斯德哥尔摩综合症</a> | <a href="https://www.tanmizhi.com/html/3470.html">斯德哥尔摩综合症真实案例，原来人也可以被驯养？</a></p><blockquote><h3 id="绑架中出现斯德哥尔摩症候群的人质特征"><a href="#绑架中出现斯德哥尔摩症候群的人质特征" class="headerlink" title="绑架中出现斯德哥尔摩症候群的人质特征"></a><strong>绑架中出现斯德哥尔摩症候群的人质特征</strong></h3></blockquote><p>美国联邦调查局的人质数据库显示，大约8%的人质表现出斯德哥尔摩症候群的症状。据心理学者的研究，情感上会依赖他人且容易受感动的人，若遇到类似的状况，很容易产生斯德哥尔摩症候群。</p><p>出现斯德哥尔摩症候群的人质，通常有下列几项特征：</p><ol><li><strong>绑匪为了某种原因和目的而绑架人质，并逐渐得到人质认同。</strong></li><li><strong>人质必须有真正感到绑匪（加害者）威胁到自己的存活。</strong></li><li><strong>在遭挟持过程中，人质必须体会出绑匪（加害者）可能略施小惠的举动。</strong></li><li><strong>除了绑匪的单一看法之外，人质必须与所有其他观点隔离（通常得不到外界的讯息，完全无法跟外界接触）。</strong></li><li><strong>人质必须相信，要脱逃是不可能的。</strong></li></ol><p>而通常斯德哥尔摩症候群会经历以下四大历程：</p><ol><li><strong>恐惧****：因为突如其来的胁迫与威吓导致现况改变。</strong></li><li><strong>害怕****：笼罩在不安的环境中，身心皆受威胁。</strong></li><li><strong>同情****：和挟持者长期相处体谅到对方不得已行为，且并未受到‘直接’伤害。</strong></li><li><strong>帮助****：给予挟持者无形帮助如配合、不逃脱、安抚等；或有形帮助如协助逃脱、向法官说情、一起逃亡等。</strong></li></ol><blockquote><h3 id="心理学的解释"><a href="#心理学的解释" class="headerlink" title="心理学的解释"></a><strong>心理学的解释</strong></h3></blockquote><p>心理分析学的看法，新生婴儿会与最靠近的有力成人形成一种情绪依附，以最大化周边成人让他至少能生存（或成为理想父母）的可能，此症候群可能是由此发展而来。斯德哥尔摩症候群是角色认同防卫机制的重要范例。</p><p>演化心理学则认为 “斯德哥尔摩症候群是人类祖先在采集狩猎时代，为了解决所面临的问题而产生心理现象。”</p><p>其中被绑架是祖先面临的严重问题之一，尤其是女性。在人类历史上，妇女被邻近部落夺取是一个比较常见的事件。在其中一些部落（例如：雅诺马马）几乎每个人的前三代祖先当中，都曾有沦为俘虏者。也许有高达十分之一的女性是被绑架而来，并融入了部落。以色列军事历史学家阿扎尔认为，斯德哥尔摩症候群是为数不多的狩猎采集时代遗留下来的心理现象之一。绑架、强奸等致命暴力，是生殖冲突的直接原因，妇女如果反抗，孩子跟自己可能被杀。为了适应此情况，妇女产生某种程度的人择。</p><p>阿扎尔盖特认为，战争和绑架是史前时代人类常见的活动。长时间的天择结果，人类发展出适应环境的心理特征。而此特征的产生，可能与受虐待妇女综合症有关，即如果受害者长时间受到没有双方同意的BDSM、SM、集体虐待、性侵害等，也会产生此心理。</p><blockquote><h3 id="斯德哥尔摩综合征对受害者的后续影响"><a href="#斯德哥尔摩综合征对受害者的后续影响" class="headerlink" title="斯德哥尔摩综合征对受害者的后续影响"></a><strong>斯德哥尔摩综合征对受害者的后续影响</strong></h3></blockquote><p>患有斯德哥尔摩综合征的受害者在逃脱隔离环境之后重新获得自由，但是，对他们来说，离开固有环境进入新环境是十分困难的，<strong>很多人面临着从孤立和无助的状态走向超负荷的自由状态。</strong></p><p>绑架事件的幸存者往往会经历压力反应。典型的压力反应包括思想扭曲、否认既定事实、记忆力减退、过分谨慎等思想方面；过度焦虑、过度麻木、沮丧、愤怒、无助等情绪方面；以及避开家人和朋友、处于社交边缘等行动方面。</p><p>除此之外，因为已经对施暴者产生了积极情感，如果施暴者受到伤害，他们还会感到悲伤。这就构成理智和感情的进一步矛盾，引发了更大的痛苦。</p><p>对于幸存者来说，认识到这些矛盾属于斯德哥尔摩综合征的产物、并非是自己“不正常”，是十分重要的。</p><blockquote><h3 id="该如何帮助产生斯德哥尔摩综合征的受害者"><a href="#该如何帮助产生斯德哥尔摩综合征的受害者" class="headerlink" title="该如何帮助产生斯德哥尔摩综合征的受害者"></a><strong>该如何帮助产生斯德哥尔摩综合征的受害者</strong></h3></blockquote><p>十分遗憾的是，现阶段的斯德哥尔摩综合征治疗还只停留在帮助受害者缓解恐慌的阶段，对于斯德哥尔摩综合征还没有针对性的治疗。由于综合征的特殊性，相关的研究也比较少。</p><p>如果朋友或家人患有斯德哥尔摩综合征，最好的办法是建议他们接受心理治疗和药物治疗。如果他们表现出对施暴者的特殊情感，请试着理解他们，因为这只是出于自我保护的本能。</p><p>在不幸遭遇可能会产生斯德哥尔摩综合征的场景时，请尝试使用这些预防措施：</p><p><strong>1）不要忘记现实。</strong>即使施暴者表现了善意，也一定要牢记是他们强迫你进入了危险情景；</p><p><strong>2）不要相信施暴者；</strong></p><p><strong>3）逃生。</strong>即使无法真正实现，也不要放弃努力，起码，要有逃生的想法，不要让自己发生心理状态的倒退；</p><p><strong>4）和施暴者保持情感上的距离。</strong>尽量减少交流，避免对施暴者产生同情心或认同感。</p><blockquote><h3 id="斯德哥尔摩综合征和创伤应激障碍、PUA的区别？"><a href="#斯德哥尔摩综合征和创伤应激障碍、PUA的区别？" class="headerlink" title="斯德哥尔摩综合征和创伤应激障碍、PUA的区别？"></a><strong>斯德哥尔摩综合征和创伤应激障碍、PUA的区别？</strong></h3></blockquote><p>一个人在遭受创伤事件后，产生与事件相关的不安思想、身体或精神受到困扰，对相似事件持续回避，这些症状持续超过一个月，被认为是发生了创伤后应激障碍（PTSD）。</p><p>PTSD与斯德哥尔摩综合征产生的情绪是相似的，但是斯德哥尔摩综合征是出于自我保护的防御性行为，发生在事件之中；PTSD的回避行为虽然也属于自我防御，但是发生在事件之后[11]。</p><p>PUA的全称是Pick-up Artists，是以诱惑和玩弄女性为目标的一个男性团体。他们互相讨论经历，分享提升自我魅力的方法，对女性哄骗洗脑，从而在最短的时间内让女性为他倾倒，愿意为他做任何事[12]。</p><p>在PUA的过程中，不断地贬低、否定女性是一种常用方法，可以降低女性的自尊心和自信心，强调自己的主导地位，进而使女性对自己产生依赖。</p><p>PUA的过程看上去和斯德哥尔摩综合征十分相似，但是，斯德哥尔摩是受虐方不受控制地发生的防御性行为，但PUA是在施虐方刻意引导下达成的精神控制。</p><p><strong>最后一问：无论是PUA，还是斯德哥尔摩综合征，何时可以停止伤害？</strong></p><p>**<br>**</p><p><strong>更多详见：<a href="https://www.huxiu.com/article/357616.html">斯德哥尔摩综合征十问：我为什么“爱上”伤害我的人</a> | <a href="https://www.thepaper.cn/newsDetail_forward_7979552">是什么让你痛苦万分却又无法离开？ | 斯德哥尔摩综合症</a></strong><em><strong>*<br>*</strong></em></p><p><strong>参考：</strong></p><ul><li><a href="https://www.zhihu.com/topic/19668693/hot">知乎：斯德哥尔摩综合症</a></li><li><a href="https://www.zhihu.com/question/19863549">斯德哥尔摩综合征产生的原因是什么？</a></li><li><a href="https://www.zhihu.com/question/56246530">斯德哥尔摩综合征有哪些典型的真实案例？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>百年前光绪帝在京师大学堂的讲话</title>
      <link href="/archives/6382f99d.html"/>
      <url>/archives/6382f99d.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="百年前光绪帝在京师大学堂的讲话，值得深思！"><a href="#百年前光绪帝在京师大学堂的讲话，值得深思！" class="headerlink" title="百年前光绪帝在京师大学堂的讲话，值得深思！"></a>百年前光绪帝在京师大学堂的讲话，值得深思！</h1><p>光绪皇帝在京师大学堂的讲话，读后让人有一种完全不同于过往认知的感受，一个封建皇帝没有任何八股之气息，即便今天社会上流行的陈旧腐朽之气也全然感觉不到，没有任何官场报告常用的官话、套话和空话，更加没有假话、空话和废话，读后感到很新鲜，一个古代君临天下傲视黎民的封建皇帝，却看不到太多自以为“奉天承运”伟大正确的那种帝王霸气。这种气质值得身为现代人的我们深思。</p><span id="more"></span><p>　1898年戊戌变法，经光绪皇帝下诏，京师大学堂在孙家鼐的主持下在北京创立，最初校址在北京市景山东街(原马神庙)和沙滩(故宫东北)红楼(现北京五四大街29号)等处。</p><p>　　京师大学堂是北大在1898年到1912年间所使用的名称。京师大学堂是中国第一所国立综合性大学，也是当时中国的最高教育行政机关。</p><p>　　和陆军学校的一片沉寂不同，京师大学堂的开学仪式隆重之至。光绪不仅亲自为京师大学堂题写了校名，还在开学这天率着军机大臣、各部尚书一同出席，规格礼遇之高，着实罕见。就连《纽约时报》驻远东的记者怀特，也通过美国公使向总理各国事务衙门提出申请，希望开学仪式这天能参加。光绪当即同意，并且表示凡是愿意参加的西方记者，总理各国事务衙门都要大力提供方便。</p><p>　　而开学的前三天，似乎唯恐没有人知道，光绪还特意嘱咐杜怀川刻印了一批传单，满北京城都贴满了。一时之间，整个北京城像炸了锅一样，大小官员和市井百姓都是议论纷纷，这个京师大学堂究竟有何魔力，竟然会引得皇上和朝廷如此重视。</p><p>　　举行完隆重热烈的相关仪式后，光绪并没有立即离去，而是要孙家鼐将所有的学子们都召集到京师大学堂的礼堂里面，光绪要做戊戌变法和有关改革开放的重要形势报告。</p><p>　　礼堂里面黑压压的沾满了将近一千名学子，各部官员和京师大学堂的教习们站在两侧，见皇上进来后，都跪伏在地上，三呼万岁。</p><p>　　站在人群中的怀特也微微弯下腰去，按照西洋的礼节鞠躬行礼，目光却带着些许的激动，望着缓缓走到人群前面的那个年轻的皇上。</p><p>这是怀特第一次见到光绪皇帝，也正是从这一刻起，这位《纽约时报》驻远东的记者，掀开了他记者生涯中最为精彩和灿烂的一页。从一个报道远东奇闻异事的普通记者，转变成为打开中国这个神秘而古老国度的西方媒体的第一人。</p><p>　　很多年后，这位后来伴随着光绪皇帝度过了无数惊心动魄的历史关口，和这位皇帝结下了深厚情谊的怀特，在他纽约的家中写道：</p><p>　　那是北京深秋一个明亮的上午，在中国近代第一所真正意义上的大学——京师大学堂内，我第一次见到了光绪皇帝，这个古老帝国名义上的统治者。那时候，这个国家的实际权力还掌握在颐和园里面那个日渐衰老的太后，和她所信任的一大帮官员手中。而这个年轻的皇帝却选择了在这个深秋的季节，从神秘的紫禁城中走了出来，走进了他一手开创的这所大学里面。</p><p>　　他看起来有些瘦弱和苍白，嘴角带着一丝浅浅的但却是无比自信的笑容走到人群前面，平静的注视着下面的人群。那一刻，我甚至有些怀疑自己的眼睛，我无法相信我所看到的这个年轻人，竟然会是这个古老而庞大的国家的皇帝，也无法理解，他脸上那份自信和从容来源于何处。</p><p>　　站在千名京师大学堂学生前面，光绪沉默了片刻后，徐徐说道，“今天是京师大学堂正式开学的第一天，所谓学堂，在朕看来就是研习学问的地方。我们的古人有一个传统叫做坐而论道，今天，朕就和你们论一论这世间的道。”</p><p>　　说罢，光绪抬起右手轻轻的往下压了压：“大家都坐下吧，朕也坐下。”</p><p>　　众人迟疑了片刻，都纷纷席地而坐，目光有些疑惑的望着前面的皇上。</p><p>　　一旁的太监也端过来一把放有明黄色座垫的椅子，光绪一提衣襟下摆，静静地坐下说道：</p><p>　　”朕从识字开始，朕的老师就在教授朕为君之道，朕亲政后，也在不断学习治国之道。世间的道或许有所不同，但是朕一直在想，对于我们这样一个国家，什么才是真正的大道，什么才是让国家振兴之道!</p><p>　　这次开办京师大学堂遇到了很多阻力和质疑，大家也都清楚，这其中还死了人。死的这个人叫王长益，朕一直在想，他为什么会死呢?又是谁把他逼死的呢?朕想到了几百年前，也有一个姓王的人，叫王阳明，这个人大家都是知道的，他曾经说过一句话，破山中贼易，破心中贼难。</p><p>　　所以朕以为，王长益之死，就是死于心中之贼！而这个贼，不仅在他心中，也在我们每个人心中，要论清世间的大道，首先就要破除这心中之贼。</p><p>　　王长益，因为家贫如洗，在科举上面又是几番落第，颇不得意。这次听说就读京师大学堂每月都有生活津贴，将来毕业后还能谋得一个实缺，左思右想后，虽然心里也并不是十分情愿，但还是到京师大学堂报了名。不曾想，他的这一举动却惹来了同住在旅店里的其它学子们的讥讽和嘲笑。王长益为人忠厚老实，也不善言词，再加上心中多少也有些羞愧，对这些人的谩骂更加不敢还击，只是左躲右闪，尽量回避和那些学子们见面。</p><p>　　谁料到有一天晚上，那群学子们在店中饮酒作对，一时兴起，竟然在王长益的床头贴了副对联。</p><p>　　上联是：孝悌忠信礼义谦；下联是：一二三四五六七。这副对联的上联缺了一个耻字，意思是骂王长益无耻。下联少了一个八，忘八，意思就是骂王长益是王八。</p><p>　　那个时代的读书人名节观念甚重，王长益的面子又比较薄，再加上心胸不够开阔，受了这些天无数的气，心里郁结难遣。晚上躺在床上翻来覆去辗转难眠，想到科举失意，就读京师大学堂又招致如此的侮辱，一时气愤之下，竟然用床单在房间里面悬梁自尽了。”</p><p>　坐在下面的学子们隐隐的发出一些窃窃私语的声音，光绪淡淡一笑，停顿了一下接着说道：</p><p>　　“然而这个心中之贼究竟是什么呢？</p><p>　　在朕看来，这第一个贼就是伪善！平常大家学习程朱理学，学到的无非是，存天理，灭人欲。</p><p>　　可是翻翻我们的历史，历朝历代，靠圣人之学，仁义道德当真就能够治国平天下了？</p><p>　　满口仁义道德是无法挽救一个国家的危亡的，你们想想，你们所学的四书五经、你们苦苦研习的八股文，能够抵抗洋人的坚船利炮吗？能够改变贪腐横行，土地兼并，流民千里，国家积弊丛生的局面吗？</p><p>　　重名节而轻实务，这里面隐藏着的其实就是虚伪和虚弱。</p><p>　　再说说你们，如果这次朝廷没有下旨，让京师大学堂的学子们毕业后，能够享有科举及第的待遇，你们能弃科举而就新学吗?</p><p>　　朕不是责怪你们，朕只是希望你们每个人都能明白，道德改变不了一个人的命运，也根本改变不了一个国家的命运，空谈道德仁义，就是世间最大的伪善。</p><p>　　这第二个贼，就是守旧。说到这一点，朕想把17年前李鸿章写给恭王信里的一段话念给大家：</p><blockquote><p>中国士大夫沉浸于章句小楷之积习，武夫悍卒又多粗蠢而不加细心，以致所用非所学，所学非所用。无事则嗤外国之利器为奇技术巧，以为不必学;有事则惊外国之利器为变怪神奇，以为不能学……</p></blockquote><p>　　17年前李鸿章的这些话，至今仍然让朕感慨啊。</p><p>　　17年的时间过去了，我们的士大夫，乃至我们这个国家依然如故。</p><p>　　世间没有一成不变的道理，天下事穷则变，变则通。</p><p>　　今日的世势，乃是三千年未有之危局，因循守旧，固步自封，只会让我们这个国家越来越落后，越来越衰弱。长此以往，国将不国啊。</p><p>　　所以朕今日说了这么多，就是想告诉大家，朕为什么坚持要开办这个京师大学堂，就是希望在座诸君，能够破除我们心中之贼，以国家强盛为己任，不骄狂，不自卑，正视现实，发愤图强。“</p><p>　　整个礼堂内鸦雀无声，连最初的窃窃私语都没有了，只有一片凝重得让人窒息的沉默。</p><hr><p>光绪帝的讲话全文如下 :</p><p>今天是京师大学堂正式开学的第一天。</p><p>所谓学堂，在朕看来，就是研习学问的地方。</p><p>我们的古人，有一个传统叫作坐而论道。今天，朕就和你们论一论这世间的道。</p><p>大家都坐下吧，朕也坐下。</p><p>朕从识字开始，朕的老师就在教授朕，何所谓为君之道。</p><p>朕亲政后，也在不断地学习这个治国之道。</p><p>世间的道，或许有所不同，但是朕一直在想，对于我们这样的一个国家，什么才是真正的大道，什么才是国家振兴之道 ？</p><p>这次开办京师大学堂，遇到了很多阻力与质疑，大家也都清楚，这其中还死了人，这个人叫王长益。朕一直在想，他为什么会死 ? 而且，又是什么样的人，把他给逼死的呢 ?</p><p>朕想到了几百年前，也有一个姓王的人，他叫王阳明。这个人，大家都是知道的，他曾经说过一句话 : 破山中贼易，破心中贼难。</p><p>朕以为，王长益之亡故，就是缘于他的那个心中之贼 ! 而这个贼，不仅存在于他的心中，也存在于我们每个人的心中，若论清世间的大道，首先当要的是，破除我们心中之贼。</p><p>然而这个存于我们心中的贼、究竟是个什么呢? 在朕看来，这第一个贼，就是伪善 ！</p><p>平常大家学习程朱理学，学到的无非是存天理、灭人欲。</p><p>可是翻翻我们的历史，历朝历代，中国靠圣人之学，仁义道德，当真能够治国、平天下了吗?</p><p>满口的仁义道德，是无法挽救一个国家的危亡的。你们想想，你们所学的四书五经，你们苦苦研习的八股文，能够抵抗洋人的坚船利炮吗 ? 可否改变贪腐横行、土地兼并、流民千里、国家积弊丛生的局面 ?</p><p>重名节而轻实务，这里面，隐藏着的其实就是虚伪和虚弱呢。</p><p>再说说你们，如果这次朝廷没有下旨，说是京师大学堂的学子们毕业以后，能够享有科举及第的待遇，那么，你们能够放弃科举而就新学不能 ?</p><p>朕于此，非为责怪你们，朕只是希望你们中的每个人，都能明白，道德改变不了一个人的命运，也根本无济一个国家的命运，空讲道德仁义，其实就是世间最大的伪善。</p><p>而这第二个贼，就是守旧。说到这一点，朕想把17年前、李鸿章写给恭王信里的一段话念给大家 ：</p><p>中国士大夫沉浸于章句小楷之积习、武夫悍卒又多粗蠢而不加细心，以致所用非所学、所学非所用。无事则嗤外国之利器为奇技术巧，以为不必学; 有事则惊外国之利器为变怪神奇，以为不能学 ……</p><p>李鸿章17年前的这些话，至今，仍然让朕感慨 !</p><p>17年的时间过去了，我们的士大夫，乃至我们的这个国家，依然如故呢 !</p><p>而世间，却从来就没有一成不变的道理 ! 天下事，穷则变，变则通。</p><p>所以朕今日说了这么多，就是想告诉大家，朕为什么要坚持开办这所京师大学堂，其实，就是希望在座诸君，能够破除我们的心中之贼 ! 以国家的强盛为己任 —— 不骄狂，不自卑，正视现实，发愤图强！</p><p>摘录自<a href="https://chegva.com/4031.html">百年前光绪帝在京师大学堂的讲话，值得深思！ | CHEGVA</a></p>]]></content>
      
      
      <categories>
          
          <category> -摘录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摘录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中国历史年表</title>
      <link href="/archives/254986c2.html"/>
      <url>/archives/254986c2.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/F:/Picture\考公\F4zrwwza0AIVb2K.jpg"></p><p>中国<a href="https://chegva.com/tag/%E5%8E%86%E5%8F%B2/">历史</a>年表，是依年份列出中国历史上的重大事件。在朝代更迭之间，执政权经常不会立即转移，因而会有时间重叠。本年表基于年份不重叠的原则，将在下一个朝代的“记录”起始点延至前一朝代结束的下一年，并非代表该年份为朝代的真正起始点。</p><table><thead><tr><th align="left">社会形态</th><th align="left">朝代</th><th align="left">存在时间</th><th align="left">创立者</th><th align="left">都城</th><th></th></tr></thead><tbody><tr><td align="left">原始社会</td><td align="left">五帝 （仅仅是部落联盟首领，非真正的帝王）</td><td align="left">约前2528年-前2029年（约500年）</td><td align="left">黄帝 颛顼 帝喾 尧 舜</td><td align="left">/</td><td></td></tr><tr><td align="left">奴隶社会</td><td align="left">夏朝</td><td align="left">前2070年-前1600年（470年）</td><td align="left">禹</td><td align="left">偃师二里头</td><td></td></tr><tr><td align="left">商朝</td><td align="left">前1600年-前1046年（554年）</td><td align="left">汤</td><td align="left">商丘 洛阳 郑州 安阳</td><td align="left"></td><td></td></tr><tr><td align="left">西周王朝</td><td align="left">前1046年-前771年（275年）</td><td align="left">周武王（姬发）</td><td align="left">西安 洛阳</td><td align="left"></td><td></td></tr><tr><td align="left">东周王朝</td><td align="left">春秋</td><td align="left">前770年 -前221年（549年）</td><td align="left">前770年 -前476年（295年）</td><td align="left">周平王（姬宜臼）</td><td>洛阳</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td></td></tr><tr><td align="left">封建社会</td><td align="left">战国</td><td align="left">前475年 -前221年（254年）</td><td align="left"></td><td align="left"></td><td></td></tr><tr><td align="left">秦朝</td><td align="left">前221年-前207年（15年）</td><td align="left">秦始皇嬴政</td><td align="left">咸阳、西安</td><td align="left"></td><td></td></tr><tr><td align="left">西楚王朝</td><td align="left">前206年-前202年（5年）</td><td align="left">西楚霸王项羽</td><td align="left">徐州</td><td align="left"></td><td></td></tr><tr><td align="left">西汉王朝</td><td align="left">前202—公元8年11月（210年）</td><td align="left">汉高祖刘邦</td><td align="left">西安</td><td align="left"></td><td></td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td></td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td></td></tr><tr><td align="left">新朝</td><td align="left">公元8年12月-23年10月（16年）</td><td align="left">建兴帝王莽</td><td align="left">西安</td><td align="left"></td><td></td></tr><tr><td align="left">玄汉王朝</td><td align="left">23年10月-25年（2年）</td><td align="left">更始帝刘玄</td><td align="left">西安</td><td align="left"></td><td></td></tr><tr><td align="left">东汉王朝</td><td align="left">25年-220年（195年）</td><td align="left">光武帝刘秀</td><td align="left">洛阳</td><td align="left"></td><td></td></tr><tr><td align="left">三国</td><td align="left">魏</td><td align="left">220年－280年（60年）</td><td align="left">220年-265年（45年）</td><td align="left">魏文帝曹丕</td><td>洛阳</td></tr><tr><td align="left">蜀</td><td align="left">221年-263年（42年）</td><td align="left">汉昭烈帝刘备</td><td align="left">成都</td><td align="left"></td><td></td></tr><tr><td align="left">吴</td><td align="left">222年-280年（58年）</td><td align="left">吴大帝孙权</td><td align="left">南京</td><td align="left"></td><td></td></tr><tr><td align="left">晋朝</td><td align="left">西晋</td><td align="left">265—420年</td><td align="left">265年-316年（51年）</td><td align="left">晋武帝司马炎</td><td>洛阳 西安</td></tr><tr><td align="left">东晋</td><td align="left">317年-420年（103年）</td><td align="left">晋元帝司马睿</td><td align="left">南京</td><td align="left"></td><td></td></tr><tr><td align="left">五胡十六国</td><td align="left">前赵(汉赵) 成汉 前凉 后赵 前燕 前秦 后秦 后燕 西秦 后凉 南凉 南燕 西凉 胡夏 北燕 北凉 *冉魏 *西燕 *西蜀(后蜀)</td><td align="left">304年-439年（135年）</td><td align="left">（多政权存在）</td><td align="left">（多政权存在）</td><td></td></tr><tr><td align="left">南北朝</td><td align="left">南朝·宋</td><td align="left">420年—589年（169年）</td><td align="left">420年-479年（59年）</td><td align="left">刘裕</td><td>南京</td></tr><tr><td align="left">南朝·齐</td><td align="left">479年-502年（23年）</td><td align="left">萧道成</td><td align="left">南京</td><td align="left"></td><td></td></tr><tr><td align="left">南朝·梁</td><td align="left">502年-557年（55年）</td><td align="left">萧衍</td><td align="left">南京</td><td align="left"></td><td></td></tr><tr><td align="left">南朝·陈</td><td align="left">557年-589年（32年）</td><td align="left">陈霸先</td><td align="left">南京</td><td align="left"></td><td></td></tr><tr><td align="left">北朝·北魏</td><td align="left">386年-534年（148年）</td><td align="left">拓跋珪</td><td align="left">大同 洛阳</td><td align="left"></td><td></td></tr><tr><td align="left">北朝·东魏</td><td align="left">534年-550年（16年）</td><td align="left">元善见</td><td align="left">安阳</td><td align="left"></td><td></td></tr><tr><td align="left">北朝·西魏</td><td align="left">535年-557年（22年）</td><td align="left">元宝炬</td><td align="left">西安</td><td align="left"></td><td></td></tr><tr><td align="left">北朝·北齐</td><td align="left">550年-577年（27年）</td><td align="left">高洋</td><td align="left">安阳</td><td align="left"></td><td></td></tr><tr><td align="left">北朝·北周</td><td align="left">557年-581年（24年）</td><td align="left">宇文觉</td><td align="left">西安</td><td align="left"></td><td></td></tr><tr><td align="left">隋朝</td><td align="left">581年-619年（38年）</td><td align="left">隋文帝（杨坚）</td><td align="left">西安 洛阳</td><td align="left"></td><td></td></tr><tr><td align="left">唐朝前期 （武周） 唐朝中后期</td><td align="left">618年-690年（72年）690年-705年（15年） 705年-907年（202年）</td><td align="left">唐高祖（李渊） 神圣皇帝（武则天） 唐中宗（李显）</td><td align="left">西安 洛阳</td><td align="left"></td><td></td></tr><tr><td align="left">五代十国</td><td align="left">后梁 后唐 后晋 后汉 后周 前蜀 后蜀 杨吴 南唐 吴越 闽国 马楚 南汉 南平 北汉 891年-979年（89年）</td><td align="left">（多政权存在）</td><td align="left">开封 洛阳</td><td align="left"></td><td></td></tr><tr><td align="left">宋朝</td><td align="left">北宋</td><td align="left">960年-1279年（320年）</td><td align="left">960年-1127年（167年）</td><td align="left">宋太祖（赵匡胤）</td><td>开封</td></tr><tr><td align="left">南宋</td><td align="left">1127年-1279年（152年）</td><td align="left">宋高宗（赵构）</td><td align="left">杭州</td><td align="left"></td><td></td></tr><tr><td align="left"><a href="http://114.xixik.com/chaodai/liao/">辽朝</a> （西辽）</td><td align="left">916 年-1125年（210年)1124年-1218年（94年）</td><td align="left">耶律阿保机 耶律大石</td><td align="left">上京</td><td align="left"></td><td></td></tr><tr><td align="left">西夏王朝</td><td align="left">1038年-1227年（190年）</td><td align="left">李元昊</td><td align="left">兴庆</td><td align="left"></td><td></td></tr><tr><td align="left">金朝</td><td align="left">1115年-1234年（120年）</td><td align="left">完颜阿骨打</td><td align="left">中都 开封</td><td align="left"></td><td></td></tr><tr><td align="left">大理国</td><td align="left">前大理后大理</td><td align="left">937年-1094年，1096年-1253年（316年）</td><td align="left">地方政权</td><td align="left">段思平</td><td>云南大理</td></tr><tr><td align="left">（大蒙古国） 元 （北元）</td><td align="left">1206年-1271年（66年)1271年-1368年（98年) 1368年—1402年（35年)</td><td align="left">铁木真 元世祖忽必烈 元昭宗</td><td align="left">大都</td><td align="left"></td><td></td></tr><tr><td align="left">明 （南明）</td><td align="left">1368年-1644年（277年）1644年-1662年（19年）</td><td align="left">明太祖朱元璋 （明安宗朱由崧）</td><td align="left">南京 北京</td><td align="left"></td><td></td></tr><tr><td align="left">（后金） 清前期</td><td align="left">1616年-1636年（21年）1636年-1840年（205年）</td><td align="left">爱新觉罗·努尔哈赤 清太宗皇太极</td><td align="left">赫图阿拉 北京</td><td align="left"></td><td></td></tr><tr><td align="left">半殖民地半封建社会</td><td align="left">清末</td><td align="left">1840年-1912年（73年）</td><td align="left"></td><td align="left">北京</td><td></td></tr></tbody></table><p><strong>史前时期</strong></p><p><strong>旧石器时代</strong></p><p>约73万年前：北京直立人，已经会使用火，并会保存火种，有部分学者认为北京直立人与中国现代人类并无连续演化关系。</p><p>公元2万~1万年前：山顶洞人</p><p>约5万年~5千多年前：长滨文化</p><p><strong>新石器时代</strong></p><p>前7500年前：彭头山文化，最早出现稻谷的中国史前文化。</p><p>前7000年前：裴李岗文化</p><p>前6000年前：磁山文化</p><p>前3000年前：龙山文化（黑陶文化）</p><p>7,000年前-5000年前：大坌坑文化</p><p>约在公元前3300年至公元前2500年：圆山文化</p><p><strong>青铜时代</strong></p><p>约1800至500年前:十三行文化</p><p>2000年前到400年前:番仔园文化</p><p><strong>夏商周</strong></p><p><strong>夏朝</strong></p><p>约前2029年：禹建<a href="http://114.xixik.com/24jieqi/lixia/">立夏</a>朝。</p><p>约前1950年：夏王少康消灭有穷国，中兴夏朝。</p><p>约前1559年：商汤于鸣条之战打败夏桀，夏朝灭亡。</p><p><strong>商朝</strong></p><p>约前1320年：商王于盘庚时把都城自奄迁殷，甲骨文和金文得到发展。</p><p>前1264年：商王武丁分封他的叔父蔓叔于邓国。</p><p>前1147年：商王武乙继位，与巫术作斗争，实行礼制改良。</p><p>前1046年：周武王于牧野之战击败商王帝辛的军队，商朝灭亡。</p><p><strong>西周</strong></p><p>前899年：周懿王元年，郑国的天亮了两次（发生了日食）。</p><p>前842年：都城发生平民暴动，周厉王逃离至彘。</p><p>前841年：召穆公、周定公共同行政（一说由诸侯共伯和摄政），号称共和</p><p>前771年：西夷犬戎攻入西周都城镐京，杀周幽王，周平王继位。</p><p>前770年：周平王向东迁都至雒邑。</p><p><strong>春秋</strong></p><p>前722年：郑庄公平定共叔段之乱。时为鲁隐公元年，史书《春秋》编年始于此。</p><p>前720年：周平王、郑庄公互派儿子为人质，周天子地位大为降低。</p><p>前707年：周桓王率诸侯军队伐郑，被郑庄公打败且肩膀中箭，诸侯争霸时代开始。</p><p>前704年：楚武王熊通称王，为诸侯称王之始。</p><p>前685年：齐桓公立，以管仲为相，实施变法。</p><p>前656年：齐桓公率诸侯联军迫楚国签订召陵之盟，成为春秋五霸之首。</p><p>前632年：晋文公率兵救宋，在城濮之战大败楚军，后会盟于践土，成为中原霸主。</p><p>前627年：秦、晋会战于殽，秦全军覆没，其后转向西发展，称霸西戎。</p><p>前597年：楚、晋会战于邲，楚大胜。</p><p>前579年：宋大夫华元调和晋、楚，为第一次弭兵会盟。</p><p>前575年：楚、晋会战于鄢陵，晋大胜，楚共王伤目。</p><p>前546年：宋大夫向戌邀晋楚和各诸侯国举行第二次弭兵会盟，晋楚之间维持数十年和平。</p><p>前506年：吴王阖闾以伍子胥为将，统兵伐楚，攻进楚都郢。</p><p>前496年：吴军伐越，阖闾战败并因伤而亡。</p><p>前494年：吴王夫差兴兵败越，越王勾践求和。</p><p>前473年：越王勾践消灭吴国，夫差自杀。勾践与齐晋会盟于徐，为春秋最后一个霸主。</p><p><strong>战国</strong></p><p>前453年：晋国氏族韩、赵、魏三家尽灭智氏，瓜分其地。</p><p>前434年：晋哀公死，晋幽公即位。韩、赵、魏瓜分晋国剩余土地，只留绛与曲沃两地。</p><p>前409年：魏伐秦，筑临晋、元里。</p><p>前408年：魏击宋，守中山。伐秦至郑，还筑洛阴、合阳。</p><p>前403年：三家分晋。司马光《资治通鉴》所载始于此年。</p><p>前386年：周安王正式册命田和为齐侯，取代姜氏齐国。</p><p>前379年：齐康公死，姜太公一系绝祀，田氏并其食邑。</p><p>前359年：秦孝公任用商鞅，实施变法。</p><p>前354年：魏围攻赵都邯郸。</p><p>前353年：赵求救于齐，齐孙膑引兵攻魏都大梁（今河南开封），又在桂陵大败魏军。</p><p>前344年：魏侯召集逢泽之会，率诸侯朝见周天子，为中原诸侯首先称王者。</p><p>前343年：魏发兵攻韩，韩求救于齐。</p><p>前342年：齐在马陵之战大败魏军，魏将庞涓兵败自杀。</p><p>前340年：秦拜卫鞅为商君</p><p>前314年：燕国内乱，齐国占领燕国，后退兵。</p><p>前307年：赵武灵王实行胡服骑射。</p><p>前287年：赵、魏、韩、燕、楚五国联兵攻秦，秦被迫割地给赵、魏以求和。</p><p>前286年：齐国攻灭宋国。</p><p>前284年：燕、秦、韩、赵、魏五国联兵攻齐，燕军陷齐都临淄。齐失七十余城，只余莒和即墨。</p><p>前278年：即墨守将田单火牛阵大败燕军，齐国复国，但国力已衰。</p><p>前280年：楚国逆长江上游攻秦，战败而遭秦反攻。</p><p>前279年：楚国于鄢之战败于秦军。</p><p>前278年：楚都郢被秦将白起攻陷，迁都到陈；楚国诗人屈原投汨罗江自尽。</p><p>前271年：范雎向秦昭王献“远交近攻”之策。</p><p>前262年：秦伐韩，切断上党郡与韩都新郑的联系。上党求救于赵，赵派老将廉颇率军声援。</p><p>前260年：秦将白起在长平之战大败赵军，坑杀40万降卒。</p><p>前258年：魏信陵君、赵平原君、楚春申君大破秦军于邯郸城下；后信陵君率军于函谷关再胜秦军。</p><p>前256年：周赧王病逝，秦国攻入雒邑，西周公投降，周朝灭亡。</p><p>前249年：秦相吕不韦带兵灭位于巩邑的东周公。</p><p>前241年：楚再迁都至寿春以避秦军，再也无能力抗秦。</p><p>前230年：秦灭韩。</p><p>前228年：秦灭赵。</p><p>前225年：秦灭魏。</p><p>前223年：秦灭楚。</p><p>前222年：秦灭燕、越。</p><p>前221年：秦灭齐，统一中原。</p><p><strong>秦汉<a href="http://114.xixik.com/chaodai/sanguo/">三国</a></strong></p><p><strong><a href="http://114.xixik.com/chaodai/qin/">秦朝</a></strong></p><p>前219年：秦始皇举行封禅大典。</p><p>前214年：秦始皇命蒙恬率三十万大军北伐匈奴，占领河套地区。</p><p>前213年：秦始皇焚毁五经、活埋儒士。</p><p>前210年：秦始皇亡于东巡，宦官赵高与丞相李斯拥立次子胡亥，假诏赐死长子扶苏。</p><p>前209年：陈胜、吴广运送士兵逾期，为避免遭处斩，于大泽乡“揭竿起义”。</p><p>前208年：赵高陷害李斯，腰斩于咸阳，夷三族。</p><p>前207年：项羽率楚军于大破秦军。同年刘邦率军入秦都咸阳，秦亡。</p><p><strong>楚汉相争</strong></p><p>前206年：项羽尊楚怀王熊心为楚义帝。12月，项羽自封为西楚霸王，分封十八路诸侯。刘邦被封为汉王。</p><p>前206年：韩信领军暗渡陈仓大败章邯</p><p>前205年：项羽率西楚军于彭城击溃汉军。</p><p>前203年：汉立韩信为齐王。</p><p>前202年：汉军包围楚军于垓下，项羽突围后于乌江自刎而死。</p><p>**<a href="http://114.xixik.com/chaodai/han/">汉朝</a>**（两汉）</p><p><strong><a href="http://114.xixik.com/chaodai/han/">西汉</a></strong></p><p>前200年:刘邦率汉军北伐匈奴，被围困于白登，贿赂匈奴阏氏才得以脱险。韩信改封楚王。</p><p>前196年: 阳夏侯陈豨及淮南王英布起兵反叛被平定。韩信及梁王彭越被杀，击起消灭异姓王风潮。</p><p>前154年：【七国之乱】–吴王刘濞联合胶西王、楚王、赵王、济南王、菑川王及胶东王起兵叛变，为太尉周亚夫率军平定。</p><p>前140年：汉武帝始用年号【建元】。</p><p>前140年：汉武帝采儒生董仲舒之议，罢黜百家，表章六经。</p><p>前139年：张骞出使西域。</p><p>前127年：卫青北击匈奴，收复河南地、陇西、北地、上郡的北部，置朔方、五原二郡。</p><p>前126年：张骞返国。</p><p>前121年：霍去病出陇西击灭居于河西走廊的匈奴部落，以其地设酒泉郡。后又分割为张掖、敦煌、武威三郡。</p><p>前60年：汉宣帝正式设立西域都护府。</p><p>前9年：王莽继任大司马大将军。</p><p>5年：王莽立两岁的孺子婴为皇太子，自称“摄<a href="http://114.xixik.com/chinese-emperors/">皇帝</a>”或“假<a href="http://114.xixik.com/chinese-emperors/">皇帝</a>”。</p><p>8年：王莽篡位孺子婴禅让后自立为帝，改国号为新。</p><p><strong><a href="http://114.xixik.com/chaodai/xin/">新朝</a></strong></p><p>17年：绿林军兴起于荆北。</p><p>18年：赤眉军兴起于青徐地区。</p><p>23年：昆阳之战王莽被杀，<a href="http://114.xixik.com/chaodai/xin/">新朝</a>灭亡。刘玄为更始帝国号仍为汉，史称玄汉。</p><p>25年：刘玄投降赤眉军后被杀。刘秀为汉光武帝，国号仍为汉，史称<a href="http://114.xixik.com/chaodai/han/">东汉</a>或后汉。</p><p><strong><a href="http://114.xixik.com/chaodai/han/">东汉</a></strong></p><p>35年：马援击破先零羌于临洮（今甘肃岷县）。</p><p>37年：<a href="http://114.xixik.com/chaodai/han/">东汉</a>统一战争结束。</p><p>43年：马援平定交阯反叛。（今越南中部）</p><p>74年：班超出使疏勒。耿秉、窦固率1.4万骑进军西域。</p><p>89年：南匈奴与汉联合夹击北匈奴，先后败之于漠北和阿尔泰山，迫使其西迁，从此几十年后北匈奴从中国古书中消失。</p><p>92年：汉和帝与宦官郑众密谋，铲除外戚窦宪。汉和帝亲政。</p><p>97年：班超派甘英出使大秦，至安息西界而还。</p><p>166年：第一次党锢之祸。</p><p>168年：第二次党锢之祸。</p><p>184年：张角兴兵于钜鹿、广宗反汉，爆发黄巾之乱。</p><p>189年：汉灵帝崩后，何进引董卓入京，董卓废帝，各地军阀举兵反董卓。</p><p>190年：董卓挟帝迁都长安，群雄割据的局面开始。</p><p>191年：刘表击败孙坚。袁绍击败韩馥。</p><p>192年：吕布杀董卓。董卓余部李傕、郭汜等占领长安。</p><p>196年：曹操挟汉献帝到许昌。</p><p>197年：袁术称帝。张绣诈降击败曹操。</p><p>198年：曹操消灭了吕布的势力。</p><p>199年：袁绍消灭了公孙瓒的势力。</p><p>200年：曹操于官渡之战击败袁绍军。</p><p>207年：曹操统一北方。</p><p>208年：孙权、刘备联军于赤壁之战大败曹军。</p><p>211年：曹操讨伐汉中张鲁。韩遂，马超反曹。</p><p>214年：刘璋投降，刘备入主益州。</p><p>220年：汉献帝被迫禅位，曹丕篡汉自立，改国号“魏”，史称“曹魏”，<a href="http://114.xixik.com/chaodai/han/">东汉</a>亡。</p><p><strong><a href="http://114.xixik.com/chaodai/sanguo/">三国</a>（魏蜀吴）</strong></p><p>221年：刘备于成都称帝，国号仍为“汉”，史称“蜀汉”。</p><p>222年：刘备战败于夷陵之战，孙权取得大部分荆州。</p><p>223年：刘备病殁，诸葛亮辅佐其子刘禅，并与孙权恢复同盟。</p><p>225年：蜀汉诸葛亮平定南中叛军，雍闿等被杀，孟获投降。</p><p>227年：诸葛亮第一次北伐。</p><p>229年：孙权于建业称帝，国号吴。</p><p>234年：诸葛亮最后一次北伐，同年病死于五丈原。</p><p>240年：蜀汉大将姜维第一次北伐。</p><p>249年：曹魏大臣司马懿发动政变，史称高平陵之变，诛宗室曹爽。</p><p>262年：姜维最后一次北伐。</p><p>263年：曹魏灭蜀汉。</p><p>264年：灭蜀元勋锺会及姜维叛变，被司马昭平定，锺会及姜维被杀。</p><p>266年：司马炎篡魏自立，国号晋，曹魏灭亡。</p><p>280年：晋灭吴，统一中国。<a href="http://114.xixik.com/chaodai/sanguo/">三国</a>时期结束。</p><p><strong>晋十六国（<a href="http://114.xixik.com/chaodai/5hu16guo/">五胡十六国</a>）</strong></p><p><strong><a href="http://114.xixik.com/chaodai/jin/">西晋</a></strong></p><p>279年，司马炎下令六路晋军攻吴。</p><p>280年，吴主孙皓出降，吴亡。</p><p>291年，惠帝皇后贾南风唆使楚王司马玮杀汝南王司马亮，开启八王之乱。</p><p>296年，氐族人杨茂搜率部落迁至仇池，称王，史称“前仇池”。</p><p>300年，凉州刺史张轨及其子张寔守土保境，中原百姓纷纷前来避乱。张氏虽然接受<a href="http://114.xixik.com/chaodai/jin/">东晋</a>封号，但与<a href="http://114.xixik.com/chaodai/jin/">东晋</a>相距万里，实际上也是一个割据政权。</p><p>304年，匈奴贵族刘渊起兵，称汉王。同年氐族李雄在益州称成都王。</p><p>306年，李雄称帝，国号“成”。同年晋东海王司马越消灭其他对手，控制朝政，毒死惠帝，立怀帝，八王之乱结束</p><p>307年，慕容廆称前燕单于，开始割据，以龙城（今辽宁朝阳）为国都，招徕中原地区的汉族流民，组织屯田垦荒。</p><p>308年，刘渊称帝，建都平阳，国号“汉”。</p><p>310年，刘渊死，刘聪即位。</p><p>311年，汉帝刘聪攻陷洛阳，掳晋怀帝司马炽，放火焚宫，屠杀官民，史称“永嘉之祸”。</p><p>313年，祖逖受命为豫州刺史，率部属北渡长江。</p><p>316年，晋愍帝投降被杀，<a href="http://114.xixik.com/chaodai/jin/">西晋</a>灭亡。</p><p><strong><a href="http://114.xixik.com/chaodai/jin/">东晋</a>/十六国（<a href="http://114.xixik.com/chaodai/5hu16guo/">五胡十六国</a>）</strong></p><p>317年，琅邪王司马睿在建康称晋王。</p><p>318年，司马睿即帝位，为晋元帝。</p><p>319年，汉帝刘曜改国号为“赵”，史称“前赵”。同年石勒称赵王，史称“后赵”。</p><p>320年，凉州牧张茂建年号永元，已成为实质独立政权。</p><p>321年，晋元帝派戴渊为征西将军，以监督祖逖。同年祖逖激愤患病而亡。</p><p>322年，王敦起兵攻陷建康，史称“王敦之乱”。同年石勒南进，再占黄河以南之地。</p><p>329年，后赵灭前赵。</p><p>337年，慕容皝称燕王，史称“前燕”。</p><p>338年，成帝李寿改国号为“汉”，史称“成汉”。同年代王拓跋什翼犍自立，国号“代”。</p><p>342年，前燕击败了后赵的二十万大军，建都龙城。</p><p>345年，凉州张骏称凉王，都姑臧，国号“凉”，史称“前凉”。</p><p>346年，<a href="http://114.xixik.com/chaodai/jin/">东晋</a>桓温讨伐成汉。</p><p>347年，<a href="http://114.xixik.com/chaodai/jin/">东晋</a>桓温灭成汉。</p><p>350年，氐族人苻洪占据关中，称三秦王，不久为后赵毒杀。同年冉闵夺后赵政权称帝，国号“魏”，建都邺，史称“冉魏”。</p><p>351年，苻健称帝，定都长安，国号“大秦”，史称“前秦”。</p><p>352年，前燕杀冉闵，攻破邺都，冉魏亡。</p><p>354年，<a href="http://114.xixik.com/chaodai/jin/">东晋</a>桓温北伐前秦，苻健采用坚壁清野战术，打败晋军，桓温缺粮撤退。</p><p>356年，<a href="http://114.xixik.com/chaodai/jin/">东晋</a>桓温击溃河南姚襄，收复洛阳，修谒皇陵。</p><p>369年，<a href="http://114.xixik.com/chaodai/jin/">东晋</a>桓温讨伐前燕，初胜，后为燕将慕容垂败于枋头。</p><p>370年，前秦擒慕容暐，灭前燕。</p><p>371年，前秦灭前仇池。</p><p>373年，前秦攻取<a href="http://114.xixik.com/chaodai/jin/">东晋</a>梁、益二州，西南夷邛、筰、夜郎皆归附于秦。</p><p>376年，前秦灭前凉；同年，乘鲜卑拓跋氏衰乱之际，进兵灭代，统一北方。</p><p>383年，前秦将领吕光讨平西域。同年前秦出兵伐晋，大败于淝水，史称“淝水之战”。</p><p>384年，前秦原前燕降将慕容垂自称“燕王”，废除前秦年号，建立后燕。北地长史慕容泓自称济北王，建立西燕；苻坚派子苻叡及羌人将领姚苌出兵讨伐西燕，大败。姚苌逃到渭北，建立后秦。</p><p>386年，拓跋珪即代王位，重建代国；不久改国号为“魏”，史称“北魏”。同年吕光称大将军、凉州牧。后燕、后秦、西燕皆先后称帝。</p><p>389年，吕光称三河王，后改称天王，史称“后凉”。</p><p>394年，后燕灭西燕。</p><p>395年，后燕伐北魏，大败于参合陂。</p><p>399年，拓跋珪称帝，为魏道武帝。同年后秦乘<a href="http://114.xixik.com/chaodai/jin/">东晋</a>内乱，陷洛阳，淮汉以北诸城多请降。</p><p>403年，<a href="http://114.xixik.com/chaodai/jin/">东晋</a>桓玄篡位称帝，建国桓楚。</p><p>404年，刘裕举兵讨伐桓玄，桓玄败走蜀地，途中被杀。</p><p>405年，刘裕肃清桓氏势力，迎晋安帝复位，掌控朝廷。</p><p>407年，汉人冯跋灭后燕，拥立高云为天王，建都龙城，国号仍用“燕”，史称“北燕”。同年匈奴人赫连勃勃自称大夏天王、大单于，建立大夏政权。</p><p>409年，高云被部下所杀，冯跋平定政变后即天王位于昌黎。</p><p>417年，<a href="http://114.xixik.com/chaodai/jin/">东晋</a>破长安，姚泓降，后秦亡。</p><p>417年，大夏取长安，称帝。</p><p>420年，刘裕废晋恭帝自立，建国号“宋”，史称“南朝宋”或“刘宋”。<a href="http://114.xixik.com/chaodai/jin/">东晋</a>亡，进入“<a href="http://114.xixik.com/chaodai/nanbeichao/">南北朝</a>时期”。</p><p><strong><a href="http://114.xixik.com/chaodai/nanbeichao/">南北朝</a></strong></p><p>431年，夏主赫连定灭西秦；欲渡黄河击北凉遭吐谷浑袭击，兵败被俘，夏亡。</p><p>436年，北魏灭北燕。</p><p>439年，北魏灭北凉，统一北方。</p><p>477年，宋将军萧道成弑帝刘昱，拥立宋顺帝，独揽朝政。</p><p>479年，萧道成篡位，建国号“齐”，史称齐高帝，南朝宋亡。</p><p>485年，北魏孝文帝依汉人李安世之议，颁布均田令。</p><p>502年，齐宗室萧衍篡位，建国号“梁”，史称梁武帝，南朝齐亡。</p><p>510年，梁实施大明历。</p><p>534年，北魏孝武帝元修与权臣高欢关系决裂，逃到关中投奔宇文泰。高欢在邺城拥元善见为帝，是为东魏。其后宇文泰杀元修，在长安立元宝炬为帝，是为西魏。</p><p>548年，东魏降将侯景勾结梁京城守将萧正德，举兵谋反，史称“侯景之乱”。</p><p>550年，高欢的儿子高洋建立北齐，东魏亡。</p><p>551年，侯景自立为汉帝。</p><p>552年，陈霸先、王僧辩先后击败侯景，侯景为部下所杀。</p><p>553年，梁湘东王萧绎继位于江陵，为梁元帝。</p><p>554年，萧詧引西魏军攻陷江陵，杀害梁元帝。</p><p>555年，萧詧称帝，并对西魏称臣，史称“后梁”。</p><p>557年，梁权臣陈霸先篡位，建国“陈”，史称陈武帝，南朝梁亡。同年宇文泰的儿子宇文觉建立北周，西魏亡。</p><p>577年，北周军攻占邺城，高纬逃亡被擒，北齐亡。</p><p>580年，北周外戚杨坚自称大丞相。</p><p>581年，杨坚受禅代周称帝，改国号“隋”，史称隋文帝，北周亡。</p><p>584年，隋文帝命宇文恺兴建广通渠。</p><p>587年，隋灭后梁。</p><p>588年，隋起兵伐陈。</p><p>589年，隋军攻入建康，陈叔宝被俘，南朝陈亡。</p><p><strong>隋唐</strong></p><p><strong><a href="http://114.xixik.com/chaodai/sui/">隋朝</a></strong></p><p>581年，突厥沙钵略可汗举兵入侵<a href="http://114.xixik.com/chaodai/sui/">隋朝</a>。</p><p>583年，隋军分八路北伐突厥。</p><p>598年，高句丽袭击辽西，隋文帝派汉王杨谅迎战，败于高句丽。</p><p>599年，东突厥突利可汗战败降隋。</p><p>602年，隋征服越南前李朝，北越南地区纳入版图。</p><p>604年，隋炀帝派杨素、宇文恺于洛阳兴建东都。</p><p>605年，迁都洛阳。同年隋炀帝开凿通济渠。同年隋将韦云起率突厥兵大败契丹。</p><p>611年，西突厥处罗可汗降隋。</p><p>612年，隋炀帝发兵讨伐高句丽，大败。</p><p>613年，隋炀帝再次发兵征讨高句丽，因杨素子杨玄感谋反，退兵回国镇压。</p><p>614年，隋炀帝三度发兵征讨高句丽，婴阳王遣返杨玄感同党斛斯政，隋因而撤军。</p><p>618年，宇文化及等人发动兵变，弑炀帝。同年李渊受隋恭帝杨侑禅让，建立<a href="http://114.xixik.com/chaodai/tang/">唐朝</a>。</p><p>619年，王世充废他所拥立的另一位隋恭帝杨侗，隋亡。同年王世充自立为帝，建国号“郑”。</p><p><strong><a href="http://114.xixik.com/chaodai/tang/">唐朝</a></strong></p><p>620年，李世民击败入侵河东的刘武周、宋金刚。同年洛阳郑帝王世充与河北夏帝窦建德结盟抗唐。</p><p>622年，李世民击溃郑、夏联军，俘窦建德，王世充投降。</p><p>626年，李世民发动玄武门之变。李渊让位，成为太上皇。李世民继位，即唐太宗。</p><p>629年，唐将李靖率骑兵攻灭东突厥。</p><p>630年，北方各族入贡长安，诸民族尊称唐太宗为“天可汗”。</p><p>635年，唐将李靖攻占吐谷浑。</p><p>641年，唐派文成公主与吐蕃赞普松赞干布通婚。</p><p>648年，在东胡鲜卑后裔青牛白马之后住地设置松漠都督府，酋长任都督并赐李姓。</p><p>657年，唐将苏定方西征攻下西突厥汗国。</p><p>690年，武则天废睿宗，即帝位，改国号“周”，定都洛阳，史称“武周”。</p><p>705年，唐中宗复辟。</p><p>751年，唐将高仙芝于怛罗斯战役败于阿拔斯王朝与石国联军。</p><p>755年，安史之乱爆发。</p><p>762年，史朝义自缢，安史之乱平定。</p><p>874年，王仙芝在长垣起兵。</p><p>875年，黄巢在冤句起兵，响应王仙芝。</p><p>884年，黄巢连败于李克用、朱温，后为部下所杀。</p><p>893年，钱镠任镇海节度使。</p><p>902年，大迭烈府夷离堇（军事首领）领兵40万伐河东代北，下九郡。</p><p>903年，南取河东怀远军，略地蓟北（河北北部）。升于越，总知军国事，成为部落联盟的实际操纵者。</p><p>904年，朱全忠杀宰相崔胤，逼迫唐昭宗迁都洛阳。</p><p>905年，<a href="http://114.xixik.com/chaodai/tang/">唐朝</a>垂亡，他应晋王李克用之邀到云州（山西大同）相会，结为兄弟，约定共讨梁王朱温和卢龙节度使刘仁恭，但终因无利可图而没有践约。</p><p>906年，十二月，遥辇氏部落联盟首领痕德堇可汗去世，遗命推选阿保机为汗。</p><p>907年，朱温逼迫唐哀宗禅让，建国号“梁”，史称“后梁”。唐亡，进入<a href="http://114.xixik.com/chaodai/5dai10guo/">五代十国</a>时期。高季兴任荆南节度使。后梁封钱镠为吴越王。</p><p><strong><a href="http://114.xixik.com/chaodai/5dai10guo/">五代十国</a>/契丹（辽）</strong></p><p>916年，耶律阿保机登基称“大圣大明天<a href="http://114.xixik.com/chinese-emperors/">皇帝</a>”，定国号为“契丹”。</p><p>917年，南海王刘龑在番禺称帝，国号“大越”。</p><p>918年，大越改国号为“汉”，史称“南汉”。契丹定都临潢府（巴林左旗）。</p><p>920年：创契丹大字。</p><p>923年，李存勗在太原称帝，建国号“唐”，史称“后唐”庄宗。同年唐军攻入汴州，后梁亡。</p><p>924年，高季兴受封为南平王，成立割据政权，以荆州为首府，史称“南平”或“荆南”。</p><p>925年，后唐庄宗派郭崇韬、李继岌率军攻入成都，王衍投降，前蜀亡。</p><p>925年，东征渤海国，立东丹国以统治渤海遗民，册立皇太子耶律倍为东丹王。</p><p>930年，东丹王耶律倍南逃后唐。</p><p>932年，西川节度使孟知祥杀东川节度使董璋，取得东川，被后唐明宗封为蜀王。</p><p>934年，孟知祥在成都称帝，国号“蜀”，史称“后蜀”。</p><p>936年，契丹与石敬瑭联军攻入洛阳，后唐灭亡。石敬瑭称帝，国号“晋”，史称“后晋”，移都开封。</p><p>938年，石敬瑭割让燕云十六州予契丹。</p><p>946年，契丹派张彦泽率兵入开封，石重贵投降，后晋亡。契丹改国号为“大辽”。</p><p>947年，河东节度使刘知远于太原称帝，国号“汉”，史称“后汉”。</p><p>950年，郭威诛隐帝，建都汴，改国号“周”，史称“后周”。后汉亡。</p><p>951年，南唐将领边镐率军攻楚，占领长沙，楚灭亡。马殷旧将刘言起兵击败南唐军，继续据有楚地。</p><p>952年，王进逵杀刘言，控制楚地。</p><p>955年，部将潘叔嗣杀王进逵。潭州军府事周行逢进军朗州杀潘叔嗣，被后周任命为武平节度使，控制楚地。后周攻占后蜀之秦、阶、成、凤四州。</p><p>960年，殿前都点检赵匡胤谎报兵情，借口领兵到陈桥驿发动兵变，夺取后周帝位，建国号“宋”。</p><p><strong>宋辽金夏</strong></p><p><strong><a href="http://114.xixik.com/chaodai/song/">北宋</a>/辽/<a href="http://114.xixik.com/chaodai/xixia/">西夏</a></strong></p><p>962年，周行逢死，子周保权继位，部将张文表起兵反叛，兵败被杀。宋发兵攻占潭州。</p><p>963年，宋军攻占江陵，高继冲投降，荆南亡。宋军平定武平。</p><p>964年，宋太祖发兵攻后蜀。</p><p>965年，孟昶投降，后蜀亡。</p><p>970年，宋发兵讨伐南汉。</p><p>971年，刘鋹投降，南汉亡。</p><p>974年，宋发兵讨伐南唐。</p><p>975年，宋军攻陷金陵，李煜奉表投降，南唐亡。</p><p>978年，钱俶降宋，吴越亡。</p><p>979年，宋灭北汉。宋太宗起兵伐辽，败于高梁河之战。</p><p>980年，辽景宗耶律贤发兵伐宋，辽军攻占瓦桥关后退去。</p><p>983年，大辽改国号回“契丹”。</p><p>986年，宋发兵伐辽，败于岐沟关。</p><p>1004年，宋、辽订立澶渊之盟。</p><p>1038年，李元昊称帝，即夏景宗，定都兴州并改称为兴庆府，国号“大夏”，史称“<a href="http://114.xixik.com/chaodai/xixia/">西夏</a>”。</p><p>1042年，宋夏战争开始。</p><p>1043年，辽兴宗以国内西南部的党项叛附<a href="http://114.xixik.com/chaodai/xixia/">西夏</a>为由，于隔年冬率大军伐夏。<a href="http://114.xixik.com/chaodai/xixia/">西夏</a>求和不成，采取坚壁清野方式击溃辽军。</p><p>1044年，宋夏战争平息，双方签订庆历和议，<a href="http://114.xixik.com/chaodai/song/">宋朝</a>承认<a href="http://114.xixik.com/chaodai/xixia/">西夏</a>的割据地位。</p><p>1059年，夏毅宗参与政事，没藏讹庞密谋刺杀夏毅宗，后被夏帝诛杀全家。</p><p>1066年，契丹再改国号回“大辽”。</p><p>1069年，宋神宗任王安石为参知政事，推动变法。</p><p>1081年，<a href="http://114.xixik.com/chaodai/xixia/">西夏</a>内乱之际，宋以李宪为总指挥发动五路伐夏，夺下兰州。</p><p>1082年，宋军采取碉堡战术，派徐禧兴建永乐城，梁太后趁永乐城新建之初，率30万大军包围攻陷，宋军惨败，史称永乐城之战。</p><p>1099年，夏崇宗亲政后采取依附<a href="http://114.xixik.com/chaodai/liao/">辽朝</a>，与<a href="http://114.xixik.com/chaodai/song/">北宋</a>修和的策略，逐年减少战争。</p><p>1114年，女真族完颜阿骨打起兵反辽。</p><p>1115年，完颜阿骨打于会宁府建都立国，国号“大金”。</p><p>1119年，宋江聚众在梁山泊起事。</p><p>1120年，方腊率众在歙县七贤村起事。</p><p>1121年，宋军生擒方腊，送往汴京诛杀。宋江战败被俘。</p><p>1122年，宋军平定方腊余党。</p><p>1125年，辽天祚帝被俘，<a href="http://114.xixik.com/chaodai/liao/">辽国</a>亡。耶律大石率军西行，于西域建立西辽。金朝<a href="http://114.xixik.com/chaodai/xixia/">西夏</a>夹攻<a href="http://114.xixik.com/chaodai/song/">北宋</a>，<a href="http://114.xixik.com/chaodai/xixia/">西夏</a>占领天德军、云内等地。</p><p>1126年，宋地被金朝强占，并且被强索河东八馆之地。金朝为了补偿<a href="http://114.xixik.com/chaodai/xixia/">西夏</a>，同意占领陕西后将横山地区归还，但又违约。</p><p>1127年，金兵攻陷宋都汴京，掳走宋帝徽、钦二宗，史称“靖康之变”。金国立张邦昌为帝，国号“大楚”，32天后张邦昌自行退位。宋康王赵构在南京（今河南商丘）登基为帝，史称“<a href="http://114.xixik.com/chaodai/song/">南宋</a>”</p><p><strong><a href="http://114.xixik.com/chaodai/song/">南宋</a>/金/<a href="http://114.xixik.com/chaodai/xixia/">西夏</a></strong></p><p>1129年，完颜宗弼挥军南下，高宗南逃至杭州。完颜宗弼继续挥军南下，高宗乘船出海避难。宋将韩世忠率八千精兵，堵塞五万金军在黄天荡四十八天。史称黄天荡之战。</p><p>1130年，刘豫在金授意下即帝位，国号“大齐”，定都大名府，统治金所占黄河以南地区。</p><p>1137年，金废刘豫为蜀王，齐亡。</p><p>1138年，宋金初次协议，<a href="http://114.xixik.com/chaodai/song/">南宋</a>取回包含开封的河南、陕西之地。</p><p>1140年，金朝撕毁协议，金兵分三路南侵，重占开封与陕西等地，岳飞在郾城与金兵将领完颜宗弼会战，力挫金兵，进兵朱仙镇，收复了黄河以南一带。</p><p>1141年，宋、金签订“绍兴和议”，<a href="http://114.xixik.com/chaodai/song/">宋朝</a>称臣，并与金以淮河为界。</p><p>1161年，金主完颜亮起兵伐宋，败于釆石矶之役。</p><p>1206年，铁木真获得尊号“成吉思汗”，建国于漠北，国号“大蒙古国”。</p><p>1208年，韩侂胄被杀，双方议和，史称嘉定和议。</p><p>1214年，<a href="http://114.xixik.com/chaodai/song/">南宋</a>与蒙古协议联手击退金军，<a href="http://114.xixik.com/chaodai/song/">南宋</a>可获河南作回报。</p><p>1215年，蒙古攻取金朝首都中都。</p><p>1217年，蒙古将中都改名为燕京。</p><p>1218年，蒙古灭西辽。</p><p>1219年，蒙古第一次西征。</p><p>1220年，蒙古灭花剌子模。</p><p>1224年，孛鲁率军从东面攻入<a href="http://114.xixik.com/chaodai/xixia/">西夏</a>，攻陷银州，夏将塔海被俘。</p><p>1225年，蒙古第一次西征结束。</p><p>1227年，蒙古灭<a href="http://114.xixik.com/chaodai/xixia/">西夏</a>。</p><p>1234年，蒙古与宋联军攻陷蔡州，金哀宗自杀，金末帝死于乱军中，金亡。</p><p>1235年，蒙古建都和林。蒙古第二次西征。</p><p>1239年，宋军收复被蒙古军占领的襄阳和其他地区。</p><p>1240年，蒙古征服俄罗斯、乌克兰、白俄罗斯等地。</p><p>1241年，蒙古征服波兰王国、匈牙利王国。</p><p>1242年，蒙古第二次西征结束。</p><p>1245年，蒙古军越过淮河以南入侵宋。</p><p>1247年，蒙古凉州会盟，吐蕃归附。</p><p>1252年，蒙古第三次西征。</p><p>1253年，蒙古灭大理国。</p><p>1256年，蒙古灭木剌夷国。</p><p>1258年，蒙古灭阿拔斯王朝。</p><p>1259年，蒙哥大汗蒙哥亲征钓鱼城，被火炮击伤，后逝于温泉寺，蒙古军撤退。</p><p>1260年，蒙古击溃阿尤布王朝，征服叙利亚全境。忽必烈即帝位。阿里不哥起兵，和忽必烈争位。蒙古发行纸币中统元宝交钞。蒙古第三次西征结束。</p><p>1260年，蒙古迁都开平。</p><p>1263年，蒙古将开平改名为上都 。</p><p>1264年，阿里不哥兵败投降。蒙古将燕京改名中都。</p><p>1267年，蒙古迁都中都，修建皇城和宫城。</p><p>1271年，蒙古改国号为“大元”，蒙古文称为“大元大蒙古国”，史称“<a href="http://114.xixik.com/chaodai/yuan/">元朝</a>”。</p><p>1272年，元中都改名大都。</p><p>1273年，元颁布官修农书《农桑辑要》。</p><p>1274年，元第一次征日。</p><p>1275年，马可波罗到达中国。</p><p>1276年，元军入临安，俘5岁宋帝恭宗。</p><p>1279年，宋军于厓山海域败于元军，丞相陆秀夫负幼主赵昺跳海殉国，宋流亡政府亡。</p><p><strong>元明清</strong></p><p><strong><a href="http://114.xixik.com/chaodai/yuan/">元朝</a></strong></p><p>1281年，第二次征日</p><p>1287年，发行纸币至元通行宝钞</p><p>1291年，颁布法律《至元新格》</p><p>1292年，马可波罗离开中国</p><p>1303年，<a href="http://114.xixik.com/chaodai/yuan/">元朝</a>和窝阔台汗国、察合台汗国约和，四大汗国一致承认<a href="http://114.xixik.com/chaodai/yuan/">元朝</a><a href="http://114.xixik.com/chinese-emperors/">皇帝</a>的宗主地位</p><p>1304年，四大汗国彼此之间约和，蒙古帝国内战彻底结束</p><p>1307年，在王忽察都兴建中都</p><p>1309年，窝阔台汗国（1225－1309）灭亡</p><p>1313年，下诏恢复科举</p><p>1322年，《大元圣政国朝典章》（《元典章》）修成</p><p>1323年，颁布法律《大元通制》，《至元新格》停止使用</p><p>1331年，《经世大典》修成</p><p>1335年，废止科举</p><p>1340年，恢复科举</p><p>1344年，《辽史》、《金史》修成</p><p>1345年，《宋史》修成</p><p>1346年，颁布法律《至正条格》，《大元通制》停止使用</p><p>1351年，韩山童（?－1351）、刘福通（?－1363）红巾之乱（1351－1366）起</p><p>1359年，红巾军攻陷上都，焚毁宫殿后离去</p><p>1368年，朱元璋于南京称帝，国号“大明”。明军攻陷大都，元惠宗率宗室、臣僚逃回蒙古草原，国号仍为“大元”，迁都上都，不再统治中原，史称“北元”。</p><p><strong>明朝</strong></p><p>1369年，倭寇侵山东沿岸，倭寇之忧起。北元迁都应昌。</p><p>1370年，定科举法。北元迁都和林。</p><p>1373年，颁布大明律</p><p>1380年，丞相胡惟庸（ －1380）被处死，废止宰相</p><p>1381年，行里甲制</p><p>1382年，明军攻取云南，<a href="http://114.xixik.com/chaodai/yuan/">元朝</a>梁王把匝剌瓦尔密自杀。</p><p>1384年，再定科举取士制</p><p>1387年，《鱼鳞图册》问世。明军攻取东北，元军统帅纳哈出降明</p><p>1388年，天元帝内乱中被杀，此后北元去国号灭亡（《明史》说法为1402年），为鞑靼所取代，直到1635年额哲（林丹汗之子）将<a href="http://114.xixik.com/chaodai/yuan/">元朝</a>传国玉玺献给后金皇太极，鞑靼被后金灭亡</p><p>1398年，明太祖死，孙惠帝即位（1398－1402在位）</p><p>1402年，方孝孺（ －1402）被杀；燕王即位（1402－1424在位），是为明成祖</p><p>1405年，郑和（1371－1435）七次下西洋（ 1405－1433）始</p><p>1407年，《永乐大典》问世</p><p>1420年，北京设东厂</p><p>1421年，迁都北京</p><p>1435年，宦官专政开始</p><p>1449年，土木堡之变，英宗（1427－1464）被瓦剌军也先（ －1454）俘</p><p>1449年，瓦剌军也先（ －1454）攻北京</p><p>1502年，《大明会典》问世</p><p>1506年，王阳明（1472－1529）贬贵州</p><p>1550年，瓦剌军围北京</p><p>1562年，严嵩遭罢免</p><p>1557年，葡萄牙获澳门居住权</p><p>1563年，俞大猷（1504－1580），戚继光（1528－1587）于福建破倭寇</p><p>1566年，海瑞（1514－1587）非难世宗（1507－1566）入狱</p><p>1566年，葡萄牙人建设澳门</p><p>1570年，缔约承认蒙古对西藏宗主权</p><p>1572年，张居正（1525－1582）为首辅，高拱（1512－1578）遭罢免</p><p>1578年，李时珍（1518－1593）著《本草纲目》（Great Pharmacopoeia）问世</p><p>1580年，张居正（1525－1582）丈量田亩</p><p>1583年，申时行（1535－1614）任首辅</p><p>1592年，日本丰臣秀吉（1536－1598）出兵朝鲜</p><p>1596年，日本第二次出兵朝鲜</p><p>1601年，意大利耶稣教会传教士利玛窦（1552－1610）到北京</p><p>1602年，李贽（李卓吾，1527－1602）狱中自杀</p><p>1604年，顾宪成（1550－1612）重建东林书院</p><p>1615年，爱新觉罗努尔哈赤定八旗制</p><p>1616年，努尔哈赤即帝位，国号大金（后金），国都兴京</p><p>1620年，官宦之争起</p><p>1623年，魏忠贤（1568－1627）为东厂长官</p><p>1628年，崇祯西北大饥荒，李自成（1605－1645）乱起</p><p>1630年，袁崇焕（ －1630）遭磔刑</p><p>1636年，大金改国号“大清”，皇太极称帝，<a href="http://114.xixik.com/chaodai/qing/">清朝</a>建立</p><p>1637年，宋应星（1587－1666）著《天工开物》</p><p>1642年，洪承畴降清</p><p>1644年，李自成建国号“大顺”，攻陷北京，明亡。山海关总兵吴三桂引清兵入关，击败大顺军。清摄政王多尔衮与顺治帝入关，迁都北京，入主中原。明凤阳总督马士英等拥立福王朱由崧于南京即帝位，为弘光帝。</p><p><strong><a href="http://114.xixik.com/chaodai/qing/">清朝</a></strong></p><p>1645年，隆武绍宗（朱聿键，1602－1646）唐王即位福州。</p><p>1646年，绍武唐王（朱聿，1605－1647）即位于广州。永历桂王（朱由榔，1623－1662）即位肇庆。</p><p>1650年，郑成功（1624－1662）以金门、厦门为据点抗清。</p><p>1658年，郑成功封延平郡王。</p><p>1659年，桂王逃缅甸。朱舜水（1600－1682）归化日本，和水户学派往来。</p><p>1661年，郑成功攻台湾，驱荷兰人。</p><p>1662年，吴三桂（1612－1678）杀桂王。</p><p>1666年，德国耶稣教会传教士汤若望去世。</p><p>1673年，三藩之乱（1673－1681）起。</p><p>1683年，施琅攻台湾，郑克塽（1670－1707）投降。</p><p>1716年，《康熙字典》问世。</p><p>1721年，台湾朱一贵（1687－1721）举兵反清失败。</p><p>1723年，驱逐各地基督教传教士。</p><p>1725年，《古今图书集成》问世。</p><p>1735年，《明史》问世。</p><p>1740年，《大清一统志》问世。</p><p>1766年，《大清会典》问世。</p><p>1780年，《四库全书荟要》问世。</p><p>1782年，《四库全书》问世。</p><p>1787年，台湾天地会林爽文（1756－1788）反清。</p><p>1796年，白莲教起义（1796－1804）起。</p><p>1811年，禁止基督教传教。</p><p>1815年，禁鸦片。</p><p>1839年，林则徐（1785－1850）虎门销烟。第一次鸦片战争（1840－1842）。</p><p>1842年，中英签署《南京条约》，第一次鸦片战争结束。</p><p>1851年，洪秀全（1814－1864）成立太平天国。</p><p>1852年，曾国藩（1811－1872）组湘军。</p><p>1853年，淮北捻军（1853－1868）起。</p><p>1856年，英法联军，第二次鸦片战争（1856－1860）</p><p>1858年，清廷签署中俄、中美、中英、中法的《天津条约》。</p><p>1860年，英法联军攻入北京。清廷签署中英、中法、中俄的《北京条约》，第二次鸦片战争结束。</p><p>1861年，洋务运动开始。恭亲王奕訢（1832－1898）设立首个外交机构总理各国事务衙门（总理衙门）。慈禧（1835－1908）垂廉听政开始。</p><p>1862年，甘陕同治回乱（1862－1873）起。</p><p>1863年，石达开（1831－1863）被杀。</p><p>1864年，洪秀全病逝。天京被湘军所破。</p><p>1865年，李鸿章（1823－1901）立江南制造局。</p><p>1866年，左宗棠（1812－1885）设福州造船厂。</p><p>1872年，太平天国最后一支军队覆灭。</p><p>1876年，沈葆祯（1820－1879）聘法国工程师于台南建成亿载金城。左宗棠讨伐阿古柏，李鸿章反对无效。</p><p>1877年，左宗棠占和阗，收复除伊犁地区外的新疆全部领土。随即上疏建议新疆改设行省。</p><p>1879年，中俄伊犁交涉。1880年春左宗棠在新疆部署兵事。日本正式吞并琉球，废除其国王，将琉球改为冲绳县。</p><p>1881年，中俄《伊犁条约》签定。</p><p>1885年，刘铭传（1836－1895）任台湾省巡抚（1885－1891）。</p><p>1889年，光绪（1871－1908）亲政开始。张之洞（1837－1909）任湖广总督，推动洋务运动。</p><p>1894年，中日甲午战争（1894－1895）。唐景崧（1841－1902）任台湾省巡抚。</p><p>1895年，与日本签订《马关条约》，甲午战争结束。洋务运动失败收场。</p><p>1898年，谭嗣同（1865－1898）、康有为（1858－1927）戊戌变法。</p><p>1899年，道士王圆箓于敦煌石窟第17窟发现大量书画经卷。</p><p>1900年，义和团事变。八国联军攻入北京，庚子战争。</p><p>1901年，废八股，用策论。清廷签署《辛丑条约》。</p><p>1902年，鲁迅（周树人，1881－1936）留日。</p><p>1904年，日俄战争（1904－1905）。</p><p>1906年，废科举。</p><p>1907年，徐锡麟（1873－1907）、马宗汉（1884－1907）、秋瑾（1875－1907）被捕处死。</p><p>1911年，黄兴（1874－1916）广州起义，黄花岗事件。辛亥革命爆发，南方各省独立，<a href="http://114.xixik.com/chaodai/qing/">清朝</a>开始瓦解。</p><p>1912年，在袁世凯软硬兼施的逼迫下，清帝宣布退位，<a href="http://114.xixik.com/chaodai/qing/">清朝</a>正式灭亡。</p><p>转载自：<a href="http://www.xixik.com/content/4fb556fd7b53f8f6">http://www.xixik.com/content/4fb556fd7b53f8f6</a></p>]]></content>
      
      
      <categories>
          
          <category> 摘录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摘录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>历史为什么总是惊人的相似</title>
      <link href="/archives/fb5ea0d0.html"/>
      <url>/archives/fb5ea0d0.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://chegva.com/tag/%E5%8E%86%E5%8F%B2/">历史</a>为什么总是惊人的相似？这是个有意思的话题，想想也比较滑稽。个人感觉主要有这三点：</p><p>一是人类行为活动本身具有规律性；</p><p>二是没有反思、质变周期性地在怪圈里原地打转，甚至开倒车；</p><p>三是某些邪恶势力在“执古之道以御今之有”，刻意操纵。比如最近乔治亚石碑被拆毁了，还有什么共济会，gongcan国际，光明会，玫瑰十字会，骷髅会等等，再比如独裁者好用商鞅驭民五术来加强自身的集权统治，或者用xie教来控制思想行为。有人想当皇帝，有人想当上帝，总有些人的欲望永远无法满足。</p><p>由于人的弱点与缺陷，环境资源的局限，思维认知的局限，区域文化的局限，冲突与纷争随之而来，矛盾无法调和时，苦难便不期而至，直到系统不堪重负而崩塌毁灭重建或者消失。一方水土可以养一方人，也可以毁一方人；可以奴役一方人，也可以解放一方人。纵观历史长河，有些民族消失了，有些民族在苦难中反思进取得到进化，有些民族还在怪圈里互相残杀，相互压榨，承受着苦难。开拓新世界需要很多代人不断的努力尝试，牺牲奉献，反思改进，还需要勇气，责任，正义，取长补短不断融合才有可能产生质变，突破升华，回看历史这个太难了。</p><p>「总盯着过去，你会瞎掉一只眼；然而忘掉历史，你会双目失明。」– 索尔仁尼琴</p><p>历史是人类的血泪史，也是开拓史，但愿不会是毁灭史。</p>]]></content>
      
      
      <categories>
          
          <category> -摘录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摘录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>五千年华夏朝代灭亡兴衰史随想</title>
      <link href="/archives/96cec5b9.html"/>
      <url>/archives/96cec5b9.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="五千年中国各朝代灭亡兴衰史"><a href="#五千年中国各朝代灭亡兴衰史" class="headerlink" title="五千年中国各朝代灭亡兴衰史"></a>五千年中国各朝代灭亡兴衰史</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>中华民族，<a href="https://chegva.com/tag/%E5%8E%86%E5%8F%B2/">历史</a>悠长。是现存四大文明古国中唯一文化延续至今，唯一国家统一传承至今者，也是华夏人民不断的苦难史。自古朝代更迭受苦的总是劳苦大众，本文全面概括分析中国（夏、商、周、秦、汉、魏、晋、南北朝、隋、唐、五代、宋、元、明、清）各朝代灭亡的原因，让大家了解中国文化发展进程，吸取教训，寄予将来。兴、百姓苦；亡、百姓苦，然则何时能乐焉？</p><p>[◎<a href="https://www.youtube.com/watch?v=np2SOHeGpCA">油管] 中國歷史24個朝代，每個朝代滅亡原因是什麼？</a></p><span id="more"></span><h2 id="一、夏朝"><a href="#一、夏朝" class="headerlink" title="一、夏朝"></a>一、夏朝</h2><p><strong>夏王朝（约前21世纪—约前16世纪）</strong>是中国历史上第一个奴隶制王朝。夏朝共传十四代，十七后，延续约471年。夏王朝的建立，从禹开始。禹的父亲崇伯鲧，是雄据大河南岸位于嵩山中的有崇氏部落首领。有崇氏与在大河北岸太行山东麓的共工氏，都是富有治水经验的部落。在尧舜时期，为了争夺王权，鲧与共工先后对尧舜展开了激烈的斗争，都失败了后来，禹又继续联合共工氏以及其他众多的部落，在伊、洛、河、济一带，逐步展开治水的工作。</p><p>禹接任了鲧的职位，放弃了鲧“堵”的治水方略，改为以疏导为主，就是依据地势的高下，疏导高地的川流积水，使肥沃的平原能减少洪水泛滥的灾害。经过治理之后，原来大都集中在大平原边沿地势较高地区的居民，纷纷迁移到比较低平的原野中，开垦那些肥沃的土地。那些草木茂盛、禽兽繁殖的薮泽地，成为人们乐于定居的地方。社会生产力有了显著的提高，这就为奴隶制国家的建立提供了必要的经济基础。</p><p>灭亡原因：</p><p>1、内部生产力的衰退；</p><p>2、外部环境的长期不稳定；</p><p>3、夏王朝统治阶级的观念；</p><p>4、夏“桀”的个人因素（整日沉湎与声色犬马，大兴土木，亲近佞人）</p><h2 id="二、商朝"><a href="#二、商朝" class="headerlink" title="二、商朝"></a>二、商朝</h2><p><strong>商王朝（约前16世纪—前11世纪）</strong>是继夏朝之后，中国历史上第二个世袭制王朝时代。夏朝之诸侯国部落首领契因被封于商，所以他的后世子孙商汤率诸侯国于鸣条之战灭夏后，将自己建立的王朝称为“商”；至盘庚，又将国都迁往殷，所以商朝又称为“殷”。经历17代31王（共510年）后，末代君王商纣王于牧野之战被周武王击败而亡。</p><p>灭亡原因：</p><p>1、商朝后期，绝大多数奴隶主贵族的生活奢侈腐朽，而且对待奴隶十分残酷。如人祭和人殉等；</p><p>2、奴隶主贵族对平民和奴隶们的剥削和奴役日益加剧，阶级矛盾激化；</p><p>3、商朝统治者连年对外进行战争，大规模地对夷方用兵，国内的青壮年几乎都被征发，加剧了国内的矛盾；</p><p>4、战争俘获的奴隶太多，他没有处理好奴隶的安置，导致了大量的奴隶反水。</p><h2 id="三、周朝"><a href="#三、周朝" class="headerlink" title="三、周朝"></a>三、周朝</h2><p>其中东周时期又称“春秋战国”，分为“春秋”（春秋五霸：齐桓公、晋文公、秦穆公、楚庄王、吴王阖闾）及“战国”（战国七雄：齐、楚、燕、魏、韩、赵、秦）两部分<strong>。周王朝存在的时间从约前11世纪至前256年，共传30代37王，约为791年。</strong></p><p>灭亡原因：</p><p>1、地震、旱灾等自然灾害使人民的生命财产遭受极大损失，也让危机日重的西周王朝雪上加霜；</p><p>2、周厉王横征暴敛，加重了对劳动人民的剥削；传至周幽王又破坏宗法制度,”废后立妾,废嫡立庶”并“烽火戏诸侯”使诸侯们失去了对他的信任；</p><p>3、王室衰微，各诸侯国与周朝王权的关系渐渐疏远；</p><p>4、少数民族犬戎攻打镐京，西周灭亡；</p><p>5、分封制使得周天子的权力架空，加之周平王东迁后更加沦为傀儡；</p><p>6、周朝的宗法制遭到破坏，各地诸侯王的势力日渐增大；并利用王室这个旗号，“挟天子以令诸侯”，不断发展自己势力。</p><h2 id="四、秦朝"><a href="#四、秦朝" class="headerlink" title="四、秦朝"></a>四、秦朝</h2><p><strong>秦王朝（公元前221年－公元前206年）</strong>，是中国历史上第一个封建制王朝，由战国时代后期的秦国发展而来，它结束了自春秋起五百年来分裂割据的局面，成为中国历史上第一个以汉族为主体、多民族共融的统一的中央集权制国家。</p><p>秦原是周朝的一个诸侯国，其始祖伯益曾辅助大禹治水有功，被帝舜赐了嬴姓。伯益的后人非子曾为周孝王养马，凭着他的本事，马繁殖得很快。周孝王于是把秦谷（今甘肃省天水市西南面）一带分封给他，这就是“秦”的起源。前770年，秦襄公护送周平王东迁至雒邑有功，被封为诸侯，秦开始建国，占领东周王室在关中的领地。春秋时期秦穆公任用虞国的百里奚为相，辅佐其施德诸侯，树大国威，向西拓展称霸西戎；而秦孝公起用“商鞭变法”废井田、重农桑、奖军功、实行统一度量等富国强兵政策，使其为后来一统中国奠定了结实的基础，《史记》记载“行之十年，秦民大悦，道不拾遗，山无盗贼，家给人足。民勇于公战，怯于私斗，乡邑大治。”</p><p>后秦王嬴政灭掉了关东六国，完成国家统一，后北击匈奴，南服百越。首创了皇帝制度、以三公九卿为代表的中央官制，以及郡县制，彻底打破自西周以来的世卿世禄制度，维护国家的统一、强化中央对地方的控制。</p><p>灭亡原因：</p><p>1、统一后，没有给人民休养生息，徭役、兵役、赋税负担沉重；</p><p>2、政策律法没有做及时调整，和平治世下刑法依然残酷；</p><p>3、政府运作失效和地方武力的缺乏，像陈胜吴广这样的一群亡命之徒，也能攻下大泽乡；</p><p>4、原六国贵族后裔复辟势力过于强大，秦二世个人能力素质有限；</p><p>5、各地起义风起云涌时，而统治者仍忙于宫廷斗争；最终导致秦朝内部统治四分五裂，完全丧失平叛的主动权。</p><h2 id="五、汉朝"><a href="#五、汉朝" class="headerlink" title="五、汉朝"></a>五、汉朝</h2><p><strong>汉王朝（前202—公元220年）</strong>，汉高祖刘邦建立西汉（定都长安）和汉光武帝刘秀建立东汉（定都洛阳），是继秦朝之后强盛的大一统帝国。又因皇帝姓刘而称“刘汉”。</p><p>汉高祖刘邦至汉景帝刘启时期的汉朝，经济实力缓慢上升，成为世界第一大帝国，汉武帝时期，大汉王朝已经成为世界上最强大的王朝，霍去病越千里大漠大败匈奴，封狼居胥而还，最远达到今天的俄罗斯贝加尔湖附近，匈奴帝国战败而向西狼狈逃遁。中亚和西域各大国也都闻而惧之。张骞出西域首次开辟了著名的“丝绸之路”，降服中亚大国大宛，西域臣服，开拓了“北绝大漠、西逾葱岭、东越朝鲜、南至大海”的广袤国土，昭宣时期再次复兴。</p><p>公元九年，王莽篡夺政权，西汉结束。25年，刘秀称帝，建立东汉，定都洛阳。开创了光武中兴和明章之治，汉朝时期，许多人将汉朝和约略同时期欧洲的罗马帝国并列为当时世界上最先进的文明及强大帝国。其疆域鼎盛时期，正北至五原郡、朔方郡，南至日南郡，东至临屯郡，西至葱岭。西汉平帝时期（公元元年），全国人口达6000万左右，且文化的统一。两汉王朝有“文景之治”“汉武盛世”“昭宣中兴”“光武中兴”“明章之治”，为华夏民族两千年的社会发展奠定了基础，为中华文明的延续和挺立千秋做出了巨大贡献。华夏族因此逐渐被称为“汉族”。220年曹丕篡汉，东汉灭亡。</p><p>灭亡原因：</p><p>1、外戚、宦官势力膨胀，各自结成利益集团，无休止的争斗乱政；</p><p>2、娃娃皇帝太多（皇帝年幼，必然是太后临朝，依靠外戚掌权）；</p><p>3、土地兼并严重（私有化），大量农民失去土地；</p><p>4、地主豪势力强大，后期形成地方割据势力；</p><p>5、黄巾起义导致地方武装兴起，中央失去控制。</p><h2 id="六、魏晋"><a href="#六、魏晋" class="headerlink" title="六、魏晋"></a>六、魏晋</h2><p><strong>曹魏（220年—266年）</strong>天下大事，合久必分，分久必合。东汉末年，天下扰乱，群雄逐鹿，曹操在军阀混战中，势力逐渐增强，并且控制了东汉朝廷，为曹魏的建立奠定了基础。延康元年（220年），曹操逝于洛阳后，曹操之子曹丕逼汉献帝退位、篡夺汉室政权，在许昌称帝，迁都洛阳，建魏。至咸熙二年（265年），司马炎篡魏，改国号为晋，曹魏灭亡。</p><p>灭亡原因：</p><p>1、新魏主更换太快，后期太小，难以驾驭士族权臣；</p><p>2、宗室权力被过分削弱“煮豆燃豆萁”，外姓将领独大，夺权时曹魏皇室没有外援；</p><p>3、司马懿太长寿，强大的司马氏家族兴起无人制衡。</p><p><strong>晋朝（265—420年）</strong>，是中国历史上九个大一统朝代之一，分为西晋与东晋两个时期。它上承三国，下启南北朝，属于六朝（中国历史上三国至隋朝的南方的六个朝代）之一。265年司马炎自立为皇帝，国号晋（265年—316年），定都洛阳，史称西晋，280年灭东吴，完成统一。此后是绵延16年的“八王之乱”，永嘉之乱后,晋愍帝迁都长安,使少数民族乘虚而入，建立了十六个国家，3年后匈奴族首领刘渊攻克长安，俘晋愍帝，316年西晋灭，史称“五胡乱华”。</p><p>317年，晋室南渡，司马睿在建邺建立东晋（317年－420年），东晋曾多次北伐。383年东晋与前秦淝水之战后得到暂时巩固。两晋时期少数民族迁至中原，加强了民族融合，北人南迁，开发了江南地区。两晋总历时一百五十六年。420年，刘裕建立宋，东晋灭亡。</p><p>灭亡原因：</p><p>1、统治集团腐朽，政治制度落后，权力分散；</p><p>2、白痴晋惠帝无力控制全局，导致宫廷实权派内斗，以及八王之乱，耗竭了国力；</p><p>3、没有正确处理好民族矛盾，导致小数民族入侵（五胡乱华）。</p><h2 id="七、南北朝"><a href="#七、南北朝" class="headerlink" title="七、南北朝"></a>七、南北朝</h2><p><strong>南北朝（公元420年—公元589年）</strong>是中国历史上的一段分裂时期，由公元420年刘裕篡东晋建立南朝宋开始，至公元589年隋灭南朝陈为止。</p><p>该时期上承东晋、五胡十六国【五胡指匈奴、鲜卑、羯胡、氐、羌；十六国指前赵(匈奴)、后赵(羯)、前凉(汉)、后凉(氐)、南凉(鲜卑)、北凉(匈奴)、西凉(汉)、前秦(氐)、后秦(羌)、西秦(鲜卑)、前燕(鲜卑)、后燕(鲜卑)、南燕(鲜卑)、北燕(高句丽、汉)、胡夏(匈奴铁弗)、成汉(氐)】，下接隋朝，南北两势虽然各有朝代更迭，但长期维持对峙，所以称为南北朝。</p><p><strong>南朝（公元420年—公元589年）</strong>包含刘宋、南齐、萧梁、陈，四个政权的更迭，但这中间除梁元帝以江陵作都3年外，其余的时间，南方各朝的京城始终建在建康（今江苏南京）。刘宋（420－479年）是其中疆域最大、最强、统治年代最长的一个政权，历4代8帝，共60年。南齐（479－502年）国祚短暂，只有24年，但由于争杀频繁，竟历3代7帝，平均3年一帝，是中国历史上帝王更换极快的一朝。萧梁（502－557年）历3代4帝，共56年，其中武帝萧衍个人享国时间最久，几近半个世纪。陈（557－589年）首尾凡33年，历3代5帝。陈承衰梁之弊，是版图狭窄、人口孤弱、力量单薄的王朝，加之统治者又极度腐败，最终丧亡于北方强敌之手。</p><p><strong>北朝（公元439年—公元589年）</strong>则包含北魏、东魏、西魏、北齐和北周五朝。北朝是我国历史上与我国南朝同时代并存的北方王朝的总称，其中包括了北魏、东魏、西魏、北齐、北周等数个王朝。北魏、东魏、西魏及北周均由鲜卑族建立，北齐则由胡化汉人所建。</p><p>南北朝初期仍是世族政治，社会阶层分为世族、齐民编户、依附人及奴隶，对外交流也很兴旺，东到日本和朝鲜半岛，西到西域、中亚、西亚（埃兰沙赫尔），南到东南亚与印度。</p><p>灭亡原因：</p><p>（南朝）</p><p>1、门阀势力各自为政，门阀与皇权摩擦争斗不断；</p><p>2、受外来势力经常侵扰，经济受创，政权不是很牢固；</p><p>3、部分皇帝昏庸残暴，荒淫奢侈，激起地方将领叛乱；</p><p>（北朝）</p><p>1、六镇（北魏贵族将领）之乱，引起了各族人民激烈的斗争；</p><p>2、土地兼并严重引发社会矛盾，动摇国家（东魏、北齐）根基；</p><p>3、权臣势力过大，皇帝年幼（西魏、北周）难以驾驭。</p><h2 id="八、隋朝"><a href="#八、隋朝" class="headerlink" title="八、隋朝"></a>八、隋朝</h2><p><strong>隋王朝（581年－618年）</strong>是中国历史之中，上承南北朝、下启唐朝的一个重要的朝代，隋朝更是五胡乱华后，汉族在北方重新建立的大一统王朝，结束了自西晋末年以来长达近300年的分裂局面，史学家常把它和唐朝合称隋唐。隋朝源自581年隋文帝杨坚受禅于北周静帝建立隋朝，至619年隋恭帝杨侑禅让李渊，隋朝灭亡为止，国祚38年。581年北周静帝禅让给杨坚，北周亡，杨坚定国号为“隋”。</p><p>在政治制度方面，隋朝确立了三省六部制，制定出完整的科举制度，弱化世族垄断仕官的能力。另外还建立政事堂议事制度、监察制度、考绩制度，这些都强化了政府机制，深刻影响到唐朝与后世的政治制度。在军事上，继续推行和改革府兵制度；经济上，实行均田制和租庸调制减轻农民生产压力，另一方面采清差户口措施，以增加财政收入，这些政策成就了隋初的开皇之治。</p><p>为了巩固隋朝发展，隋文帝与隋炀帝兴建举世闻名的隋唐大运河以及驰道，建立京师大兴城（今西安）和东都（洛阳）。外交方面，隋朝的盛世也使得高昌、倭国、高句丽、新罗、百济与内属的东突厥等都受隋朝文化与典章制度影响，外交交流以日本的遣隋使最为著名。</p><p>灭亡原因：</p><p>1、大一统表面下的各种割据势力暗流涌动，统治基础很不稳固；</p><p>2、门阀对科举制度不满，与敌恶势力勾结，对抗皇权；</p><p>3、隋炀帝个人因素：好大喜功、穷兵黩武、穷奢极欲与滥用民力；但是，像搞科举、建东都、修驰道、凿运河、征高丽，都是苦在当代，功在千秋的。</p><h2 id="九、唐朝"><a href="#九、唐朝" class="headerlink" title="九、唐朝"></a>九、唐朝</h2><p><strong>唐王朝（618—907年）</strong>，是中国封建社会中统一时间最长，国力最强盛的朝代之一。618年由李渊建立，定都长安（今西安）。并且设有东都洛阳、北都太原等等陪都。627年，李世民登基后开创了“贞观之治”，唐高宗以后，武则天以周代唐，史称武周，705年神龙革命后恢复大唐国号。唐玄宗李隆基即位后，政治清明，经济雄厚，军事强盛，四夷宾服，万邦来朝，开创了全盛的“开元盛世”。</p><p>安史之乱后，国力日趋衰败。907年朱温篡唐，唐朝灭亡，从此中国进入了进入五代十国（五代是指后梁、后唐、后晋、后汉与后周，十国指的是前蜀、后蜀、吴、南唐、吴越、闽、楚、南汉、荆南、北汉）时期。</p><p>唐朝共历274年（包括武周是289年），20位皇帝。唐朝声誉远及海外，与南亚、西亚和欧洲国家均有往来。唐朝以后海外多称中国人为“唐人”。唐朝文化兼容并蓄，接纳各个民族与宗教，进行交流融合，成为了开放的国际文化。唐诗、科技、文化艺术极其繁盛，具有多元化的特点。</p><p>灭亡原因：</p><p>1、边患不断（如安史之乱、安南叛乱、外有吐蕃入侵等），藩镇割据；</p><p>2、宦官专权（如李辅国等），党争内耗（如牛李党争）；</p><p>3、长年战乱严重地削弱了唐朝的统治力量，阻碍了经济发展，引起农民起义与外族入侵。</p><h2 id="十、五代十国"><a href="#十、五代十国" class="headerlink" title="十、五代十国"></a>十、五代十国</h2><p><strong>五代十国（907年―979年）</strong>五代十国本质上是唐朝藩镇割据和唐朝后期政治的延续。唐朝灭亡后，各地藩镇纷纷自立为国，其中位在华北地区，军力强盛的藩镇国家即五代，其中有些是沙陀族所建立的。这五国虽然实力强大，但无力控制整个中国本土，只是藩镇型的朝廷。而其他割据一方的藩镇，有些自立为帝，有些奉五代为宗主国，其中十个国龄较长、国力较强的统称为十国。</p><p>本时期时常发生地方实力派叛变夺位的情况，使得战乱不止，统治者多重武轻文。中国的内乱，也带给契丹国南侵的机会，辽国得以建立。</p><p>五代十国是中国历史的重要时期，其间河西和交趾地区逐渐离心，交趾（越南）最终脱离中国独立。五代共有后梁、后唐、后晋、后汉与后周五个朝代。</p><p>公元907年汴州朱温篡唐建立后梁，这是五代十国的开始。太原李克用之子李存勖灭后梁，后唐建国。后唐之后五代君王均出自李克用的子孙与部属。后唐历经后唐明宗的扩张与整顿，国力强盛，但发生内乱后，被石敬瑭引契丹军攻灭，后晋建立。不久契晋关系恶化，契丹军南下灭后晋，建立辽朝。同时刘知远在太原建立后汉，收复中原。</p><p>郭威篡后汉建后周，后周世宗柴荣苦心经营，使后周隐隐有一统天下的希望，但柴荣在北伐燕云十六州时不幸病亡。后周随后被赵匡胤所篡，五代结束。在五代更迭中，中原地区之外存在过前蜀、后蜀、吴、南唐、吴越、闽、楚、南汉、荆南、北汉十个割据政权，合称十国。宋太祖赵匡胤建立北宋后，与其弟宋太宗赵光义相继消扫荡群雄，公元979年，赵光义灭北汉，实现统一。</p><p>灭亡原因：</p><p>1、藩镇势力依然强大，新生政权也无法控制，以致内乱战争不断；</p><p>2、不少君主昏庸淫乱、残暴蛮横，军务松弛，贪官暴吏欺压百姓；</p><p>3、权臣勾结外族作乱，以及外族反扑中原掳掠杀伐；</p><p>4、政权太多，赋敛苛重，战事频繁，社会秩序、经济基础破坏严重。</p><h2 id="十一、宋朝"><a href="#十一、宋朝" class="headerlink" title="十一、宋朝"></a>十一、宋朝</h2><p><strong>宋王朝（960—1279年）</strong>是中国历史上承五代十国、下启元朝的时代，分北宋和南宋。960年，后周大将赵匡胤黄袍加身，建立宋朝。宋真宗、宋仁宗时期步入了盛世，北宋为了避免唐代末朝以来藩镇割据和宦官乱政的现象，采取重文轻武的施政方针，一方面在军事上积弱，1127年徽、钦二帝受金人掳去，迫使宋室南迁。1127年靖康之耻，北宋灭亡。</p><p>靖康之变后宋高宗赵构在应天府南京（今商丘）仓促登基，继承皇位，后南迁定都在临安府（杭州），重建宋王朝，史称南宋。后期抗蒙战争连年，到1276年，元朝军队攻占临安，1279年，8岁的小皇帝赵昺被大臣陆秀夫背著跳海而死，厓山海战后，宋朝彻底灭亡。有学者认为宋朝灭亡是“崖山之后无中国”。</p><p>宋朝是中国古代历史上经济、文化教育与科学创新最繁荣的时代，宋朝时中国GDP占世界比重60%，为各朝代第一，期间出现了宋明理学，科技发展亦突飞猛进，政治也较开明廉洁。人口至大观四年（1110年）的1亿1275万。西方与日本史学界中认为宋朝是中国历史上的文艺复兴与经济革命的人不在少数。宋朝是中国历史上的黄金时期。</p><p>灭亡原因：</p><p>1、以文制武的方针，造成了军队内相互牵制，动辄掣肘，弊病丛生；</p><p>2、后晋石敬瑭割让的“燕云十六州”，使汉族江山的天然屏障失去，无法抵御外族骑兵；</p><p>3、联金抗辽、联蒙抗金决策失误，只看到了辽（金）的强大，没看到金（蒙）的危胁；</p><p>4、统治阶层对军事的无知、无能、不作为，导致了开封防御战的失利；</p><p>5、皇帝昏庸，朝政腐败，政治内斗严重，以及军费开支较大，百姓负担过重。</p><h2 id="十二、元朝"><a href="#十二、元朝" class="headerlink" title="十二、元朝"></a>十二、元朝</h2><p>**大元王朝（1271-1368)**由蒙古族建立，是中国历史上第一个由少数民族建立的大一统帝国。定都大都（今北京市）。1206年铁木真建立蒙古汗国。1260年忽必烈即位大汗并建元“中统”，1271年忽必烈取《易经》“大哉乾元”之意改国号为大元，1279年灭南宋，统一中国。</p><p>元朝的疆域空前广阔，北至北海、东到日本海，西藏和台湾第一次被纳入中国版图。元朝实行一省制，在中央设中书省，左右丞相和平章政事处理政务。造成了宰相专权和内乱频发。地方实行行省制度，开我国行省制度之先河。商品经济和海外贸易较繁荣。其间出现了元曲和散曲等文化形式。其整体生产力不如宋朝，后期因统治腐败和民族压迫，导致农民起义，1368年明军攻占大都，元朝在全国的统治结束，元政权退居漠称北元。1402年元臣鬼力赤篡位建国鞑靼，北元亡。</p><p>灭亡原因：</p><p>1、贵族生活糜烂，吏治腐败，政府信用破产，土地兼并严重；</p><p>2、不平等的民族等级制度，以及对人民压迫欺凌严重；</p><p>3、财政赤字高居不下，赋税过重，外加自然灾害严重；</p><p>4、管理者不注重学习，只会用武力打江山。</p><h2 id="十三、明朝"><a href="#十三、明朝" class="headerlink" title="十三、明朝"></a>十三、明朝</h2><p><strong>大明王朝（1368－1644年）</strong>是中国历史上最后一个由汉族建立的大一统封建王朝。历经十二世、十六位皇帝，国祚276年。南宋灭亡五十年后，元朝统治者日益残暴黑暗，终于爆发了元末农民起义。朱元璋参加了当时的濠州大帅郭子兴领导的红巾军分支，经过多年的南征北战，1364年，朱元璋自称吴王独霸一方，史称西吴政权。1368年，朱元璋称帝，以应天府（南京）为京师，国号大明，明初定都于应天府，1421年迁都至顺天府，而应天府改称为南京。</p><p>明前期，经过明太祖朱元璋的洪武之治，国力发展迅速，到明成祖时期，国力强盛，万邦来朝，史称永乐盛世。其后的明仁宗和明宣宗时期仍处于兴盛时期，史称仁宣之治，国力达到全盛，疆域辽阔。中后期由于与政治腐败导致国力下降。1644年，李自成攻入北京，明毅宗朱由检于煤山自缢，明亡。随后，满清入主中原，1662年永历帝朱由榔被杀，1683年清军占领台湾，明郑结束。</p><p>明朝商品经济发达，出现商业集镇和资本主义萌芽。文化艺术呈现世俗化趋势。明朝是中国继周朝、汉朝和唐朝之后的繁盛黄金时代，史称“治隆唐宋”、“远迈汉唐”。大明，无汉唐之和亲，无两宋之岁币，天子御国门，君主死社稷，为后世子孙所敬仰。</p><p>灭亡原因：</p><p>1、文官集团膨胀，权力过大，以及后期阉党专政危害统治；</p><p>2、外敌袭扰不断，政府添兵设饷，军费较大，造成财政经济危机；</p><p>3、资本主义萌芽，政府不注重工商业发展，大大限制商品货币的流通；</p><p>4、天灾人祸相继发生，造成流民数量大增，农民起义不断影响稳定；</p><p>5、吴三桂引清兵入关，自毁长城，帮助满清捡现成江山。</p><h2 id="十四、清朝"><a href="#十四、清朝" class="headerlink" title="十四、清朝"></a>十四、清朝</h2><p><strong>大清王朝（1644年—1912年）</strong>是中国历史上第二个由少数民族建立的统一政权，也是中国最后一个封建帝制国家。明万历四十四年（1616年），建州女真部首领努尔哈赤建国称汗，国号大金，史称“后金”。1636年（明崇祯九年，清崇德元年），清太宗皇太极称帝，改国号为大清。</p><p>1644年（明崇祯十七年、清顺治元年），李自成的大顺军攻占北京，明朝灭亡；驻守山海关的明将吴三桂降清，清摄政王多尔衮指挥清军入关，打败大顺农民军；同年清顺治帝迁都北京，从此清朝取代明朝成为全国的统治者。入关后20年时间里，清朝先后灭亡大顺、大西和南明等政权，基本统一全国。清朝前期，统一多民族国家得到巩固，基本上奠定了我国版图，同时君主专制发展到顶峰。</p><p>1840年鸦片战争后进入近代，清廷与侵略者分别缔结了大量不平等条约，割地赔款，开放通商口岸，中国的主权受到严重损害，逐步沦为半封建半殖民地社会，人民负担更为沉重，处于水深火热之中。1911年，辛亥革命爆发，清朝统治瓦解，从此结束了中国两千多年来的封建帝制。1912年2月12日，清帝被迫退位。清朝从后金建立开始算起，共有十二帝。</p><p>灭亡原因：</p><p>1、政治的黑暗腐朽，以及统治者本身腐化（慈喜）、无能（皇帝）；</p><p>2、闭关锁国政策下，导致思想、制度、科技落后；</p><p>3、清政府弱软无能，面对列强的入侵，只知一味的委曲求全、割地赔款；</p><p>4、军队的失控（陆军新军在国内的变乱中倒戈相向），及其职能的倒转（军队的职能只能对外而不是对内）；</p><p>5、财政赤字下，“永不加赋”的朝训被一破再破，各项加征摊派有增无减；</p><p>6、清末铁路的“国进民退”，进一步激起了民怨。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统知识点</title>
      <link href="/archives/38059bce.html"/>
      <url>/archives/38059bce.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="计算机结构"><a href="#计算机结构" class="headerlink" title="计算机结构"></a>计算机结构</h1><p>现代计算机模型是基于-<strong>冯诺依曼计算机模型</strong></p><p>计算机在运行时，先从内存中取出第一条指令，通过控制器的译码，按指令的要求，从存储器中取出数据进行指定的运算和逻辑操作等加工，然后再按地址把结果送到内存中去，接下来，再取出第二条指令，在控制器的指挥下完成规定操作，依此进行下去。直至遇到停止指令</p><p>程序与数据一样存贮，按程序编排的顺序，一步一步地取出指令，自动地完成指令规定的操作是计算机最基本的工作模型</p><p><strong>计算机五大核心组成部分</strong></p><p>控制器：是整个计算机的中枢神经，其功能是对程序规定的控制信息进行解释，根据其要求进行控制，调度程序、数据、地址，协调计算机各部分工作及内存与外设的访问等。</p><p>运算器：运算器的功能是对数据进行各种算术运算和逻辑运算，即对数据进行加工处理。</p><p>存储器：存储器的功能是存储程序、数据和各种信号、命令等信息，并在需要时提供这些信息。</p><p>输入：输入设备是计算机的重要组成部分，输入设备与输出设备合你为外部设备，简称外设，输入设备的作用是将程序、原始数据、文字、字符、控制命令或现场采集的数据等信息输入到计算机。</p><blockquote><p>常见的输入设备有键盘、鼠标器、光电输入机、磁带机、磁盘机、光盘机等。</p></blockquote><p>输出：输出设备与输入设备同样是计算机的重要组成部分，它把外算机的中间结果或最后结果、机内的各种数据符号及文字或各种控制信号等信息输出出来，微机常用的输出设备有显示终端CRT、打印机、激光印字机、绘图仪及磁带、光盘机等。</p><p><strong>计算机结构分成以下 5 个部分：</strong></p><p>输入设备；输出设备；内存；中央处理器；总线。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpkFYtYurwYD22yibbjd9PW8cw0yuoPU01TTsZ9T9fBRVjxg0ETRibLDWNjFUz7XiclPg7yRwwkZAv7nw/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>在冯诺依曼模型中，程序和数据被存储在一个被称作内存的线性排列存储区域。</p><p>存储的数据单位是一个二进制位，英文是 bit，最小的存储单位叫作字节，也就是 8 位，英文是 byte，每一个字节都对应一个内存地址。</p><p>内存地址由 0 开始编号，比如第 1 个地址是 0，第 2 个地址是 1， 然后自增排列，最后一个地址是内存中的字节数减 1。</p><p>我们通常说的内存都是随机存取器，也就是读取任何一个地址数据的速度是一样的，写入任何一个地址数据的速度也是一样的。</p><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><p>冯诺依曼模型中 CPU 负责控制和计算，为了方便计算较大的数值，CPU 每次可以计算多个字节的数据。</p><ul><li>如果 CPU 每次可以计算 4 个 byte，那么我们称作 32 位 CPU；</li><li>如果 CPU 每次可以计算 8 个 byte，那么我们称作 64 位 CPU。</li></ul><p>这里的 32 和 64，称作 CPU 的位宽。</p><p><strong>为什么 CPU 要这样设计呢？</strong></p><p>因为一个 byte 最大的表示范围就是 0~255。</p><p>比如要计算 <code>20000*50</code>，就超出了byte 最大的表示范围了。</p><p>因此，CPU 需要支持多个 byte 一起计算，当然，CPU 位数越大，可以计算的数值就越大，但是在现实生活中不一定需要计算这么大的数值，比如说 32 位 CPU 能计算的最大整数是 4294967295，这已经非常大了。</p><p><strong>控制单元和逻辑运算单元</strong></p><p>CPU 中有一个控制单元专门负责控制 CPU 工作；还有逻辑运算单元专门负责计算。</p><p><strong>寄存器</strong></p><p>CPU 要进行计算，比如最简单的加和两个数字时，因为 CPU 离内存太远，所以需要一种离自己近的存储来存储将要被计算的数字。</p><p>这种存储就是寄存器，寄存器就在 CPU 里，控制单元和逻辑运算单元非常近，因此速度很快。</p><p>常见的寄存器种类：</p><ul><li>通用寄存器，用来存放需要进行运算的数据，比如需要进行加和运算的两个数据。</li><li>程序计数器，用来存储 CPU 要执行下一条指令所在的内存地址，注意不是存储了下一条要执行的指令，此时指令还在内存中，程序计数器只是存储了下一条指令的地址。</li><li>指令寄存器，用来存放程序计数器指向的指令，也就是指令本身，指令被执行完成之前，指令都存储在这里。</li></ul><h3 id="多级缓存"><a href="#多级缓存" class="headerlink" title="多级缓存"></a>多级缓存</h3><p>现代CPU为了提升执行效率，减少CPU与内存的交互(交互影响CPU效率)，一般在CPU上集成了多级缓存架构</p><p><strong>CPU缓存</strong>即高速缓冲存储器，是位于CPU与主内存间的一种容量较小但速度很高的存储器</p><p>由于CPU的速度远高于主内存，CPU直接从内存中存取数据要等待一定时间周期，Cache中保存着CPU刚用过或循环使用的一部分数据，当CPU再次使用该部分数据时可从Cache中直接调用，减少CPU的等待时间，提高了系统的效率，具体包括以下几种：</p><p><strong>L1-Cache</strong></p><p>L1- 缓存在 CPU 中，相比寄存器，虽然它的位置距离 CPU 核心更远，但造价更低，通常 L1-Cache 大小在几十 Kb 到几百 Kb 不等，读写速度在 2~4 个 CPU 时钟周期。</p><p><strong>L2-Cache</strong></p><p>L2- 缓存也在 CPU 中，位置比 L1- 缓存距离 CPU 核心更远，它的大小比 L1-Cache 更大，具体大小要看 CPU 型号，有 2M 的，也有更小或者更大的，速度在 10~20 个 CPU 周期。</p><p><strong>L3-Cache</strong></p><p>L3- 缓存同样在 CPU 中，位置比 L2- 缓存距离 CPU 核心更远，大小通常比 L2-Cache 更大，读写速度在 20~60 个 CPU 周期。</p><p>L3 缓存大小也是看型号的，比如 i9 CPU 有 512KB L1 Cache；有 2MB L2 Cache；有16MB L3 Cache。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpkFYtYurwYD22yibbjd9PW8cAiaabc2ujbibgcpoPia4LNHyTxaf21kRiaIel5Lf6KXjjaQ9rzoCbKGI2g/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>当 CPU 需要内存中某个数据的时候，如果寄存器中有这个数据，我们可以直接使用；如果寄存器中没有这个数据，我们就要先查询 L1 缓存；L1 中没有，再查询 L2 缓存；L2 中没有再查询 L3 缓存；L3 中没有，再去内存中拿。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpkFYtYurwYD22yibbjd9PW8cmicntpVADaKNBWELzpMZwcHsZDzZMS5082WbVsic8ygIz1wia8hJDRibSA/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p><strong>总结：</strong></p><p>存储器存储空间大小：内存&gt;L3&gt;L2&gt;L1&gt;寄存器；</p><p>存储器速度快慢排序：寄存器&gt;L1&gt;L2&gt;L3&gt;内存；</p><h3 id="安全等级"><a href="#安全等级" class="headerlink" title="安全等级"></a>安全等级</h3><p><strong>CPU运行安全等级</strong></p><p>CPU有4个运行级别，分别为：</p><ul><li>ring0，ring1，ring2，ring3</li></ul><p>ring0只给操作系统用，ring3谁都能用。</p><p>ring0是指CPU的运行级别，是最高级别，ring1次之，ring2更次之……</p><p>系统（内核）的代码运行在最高运行级别ring0上，可以使用特权指令，控制中断、修改页表、访问设备等等。</p><p>应用程序的代码运行在最低运行级别上ring3上，不能做受控操作。</p><p>如果要做，比如要访问磁盘，写文件，那就要通过执行系统调用（函数），执行系统调用的时候，CPU的运行级别会发生从ring3到ring0的切换，并跳转到系统调用对应的内核代码位置执行，这样内核就为你完成了设备访问，完成之后再从ring0返回ring3。</p><p>这个过程也称作用户态和内核态的切换。</p><h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><p>在CPU访问存储设备时，无论是存取数据抑或存取指令，都趋于聚集在一片连续的区域中，这就被称为局部性原理</p><p><strong>时间局部性（Temporal Locality）：</strong></p><p>如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。</p><p>比如循环、递归、方法的反复调用等。</p><p><strong>空间局部性（Spatial Locality）：</strong></p><p>如果一个存储器的位置被引用，那么将来他附近的位置也会被引用。</p><p>比如顺序执行的代码、连续创建的两个对象、数组等。</p><h3 id="程序的执行过程"><a href="#程序的执行过程" class="headerlink" title="程序的执行过程"></a>程序的执行过程</h3><p>程序实际上是一条一条指令，所以程序的运行过程就是把每一条指令一步一步的执行起来，负责执行指令的就是 CPU 了。</p><p><strong>那 CPU 执行程序的过程如下：</strong></p><ul><li>第一步，CPU 读取程序计数器的值，这个值是指令的内存地址，然后 CPU 的控制单元操作地址总线指定需要访问的内存地址，接着通知内存设备准备数据，数据准备好后通过数据总线将指令数据传给 CPU，CPU 收到内存传来的数据后，将这个指令数据存入到指令寄存器。</li><li>第二步，CPU 分析指令寄存器中的指令，确定指令的类型和参数，如果是计算类型的指令，就把指令交给逻辑运算单元运算；如果是存储类型的指令，则交由控制单元执行；</li><li>第三步，CPU 执行完指令后，程序计数器的值自增，表示指向下一条指令。这个自增的大小，由 CPU 的位宽决定，比如 32 位的 CPU，指令是 4 个字节，需要 4 个内存地址存放，因此程序计数器的值会自增 4；</li></ul><p>简单总结一下就是，一个程序执行的时候，CPU 会根据程序计数器里的内存地址，从内存里面把需要执行的指令读取到指令寄存器里面执行，然后根据指令长度自增，开始顺序读取下一条指令。</p><p>CPU 从程序计数器读取指令、到执行、再到下一条指令，这个过程会不断循环，直到程序执行结束，这个不断循环的过程被称为 <strong>CPU 的指令周期</strong>。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpkFYtYurwYD22yibbjd9PW8cZgVGewVlnUGngt1tyb37icC3Ath6FTjw7r8DzmDa15FmkyBIUK691nA/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h2 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h2><p>CPU 和内存以及其他设备之间，也需要通信，因此我们用一种特殊的设备进行控制，就是总线。</p><ul><li>地址总线，用于指定 CPU 将要操作的内存地址；</li><li>数据总线，用于读写内存的数据；</li><li>控制总线，用于发送和接收信号，比如中断、设备复位等信号，CPU 收到信号后自然进行响应，这时也需要控制总线；</li></ul><p>当 CPU 要读写内存数据的时候，一般需要通过两个总线：</p><ul><li>首先要通过地址总线来指定内存的地址；</li><li>再通过数据总线来传输数据；</li></ul><h2 id="输入、输出设备"><a href="#输入、输出设备" class="headerlink" title="输入、输出设备"></a>输入、输出设备</h2><p>输入设备向计算机输入数据，计算机经过计算，将结果通过输出设备向外界传达。</p><p>如果输入设备、输出设备想要和 CPU 进行交互，比如说用户按键需要 CPU 响应，这时候就需要用到控制总线。</p><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p><strong>中断的类型</strong></p><ul><li>按照中断的触发方分成同步中断和异步中断；</li><li>根据中断是否强制触发分成可屏蔽中断和不可屏蔽中断。</li></ul><p>中断可以由 CPU 指令直接触发，这种主动触发的中断，叫作同步中断。</p><blockquote><p>同步中断有几种情况。</p></blockquote><ul><li>比如系统调用，需要从用户态切换内核态，这种情况需要程序触发一个中断，叫作陷阱（Trap），中断触发后需要继续执行系统调用。</li><li>还有一种同步中断情况是错误（Fault），通常是因为检测到某种错误，需要触发一个中断，中断响应结束后，会重新执行触发错误的地方，比如后面我们要学习的缺页中断。</li><li>最后还有一种情况是程序的异常，这种情况和 Trap 类似，用于实现程序抛出的异常。</li></ul><p>另一部分中断不是由 CPU 直接触发，是因为需要响应外部的通知，比如响应键盘、鼠标等设备而触发的中断，这种中断我们称为异步中断。</p><p>CPU 通常都支持设置一个中断屏蔽位（一个寄存器），设置为 1 之后 CPU 暂时就不再响应中断。</p><p>对于键盘鼠标输入，比如陷阱、错误、异常等情况，会被临时屏蔽。</p><p>但是对于一些特别重要的中断，比如 CPU 故障导致的掉电中断，还是会正常触发。</p><p><strong>可以被屏蔽的中断我们称为可屏蔽中断，多数中断都是可屏蔽中断。</strong></p><h2 id="内核态和用户态"><a href="#内核态和用户态" class="headerlink" title="内核态和用户态"></a>内核态和用户态</h2><p><strong>什么是用户态和内核态</strong></p><p>Kernel 运行在超级权限模式下，所以拥有很高的权限。</p><p>按照权限管理的原则，多数应用程序应该运行在最小权限下。</p><p>因此，很多操作系统，将内存分成了两个区域：</p><ul><li>内核空间（Kernal Space），这个空间只有内核程序可以访问；</li><li>用户空间（User Space），这部分内存专门给应用程序使用。</li></ul><p>用户空间中的代码被限制了只能使用一个局部的内存空间，我们说这些程序在用户态 执行。</p><p>内核空间中的代码可以访问所有内存，我们称这些程序在内核态 执行。</p><blockquote><p>按照级别分：</p></blockquote><p>当程序运行在0级特权级上时，就可以称之为运行在内核态</p><p>当程序运行在3级特权级上时，就可以称之为运行在用户态</p><p>运行在用户态下的程序不能直接访问操作系统内核数据结构和程序。</p><p>当我们在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态（比如操作硬件）</p><p><strong>这两种状态的主要差别</strong></p><p>处于用户态执行时，进程所能访问的内存空间和对象受到限制，其所处于占有的处理器是可被抢占的</p><p>处于内核态执行时，则能访问所有的内存空间和对象，且所占有的处理器是不允许被抢占的。</p><p><strong>为什么要有用户态和内核态</strong></p><p>由于需要限制不同的程序之间的访问能力，防止他们获取别的程序的内存数据，或者获取外围设备的数据，并发送到网络</p><p><strong>用户态与内核态的切换</strong></p><p>所有用户程序都是运行在用户态的，但是有时候程序确实需要做一些内核态的事情， 例如从硬盘读取数据，或者从键盘获取输入等，而唯一可以做这些事情的就是操作系统，所以此时程序就需要先操作系统请求以程序的名义来执行这些操作</p><p><strong>用户态和内核态的转换</strong></p><blockquote><p>系统调用</p></blockquote><p>用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如fork()实际上就是执行了一个创建新进程的系统调用</p><p>而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断</p><p><strong>举例：</strong></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpkFYtYurwYD22yibbjd9PW8czjRBHW72Q6oOCkT01jjviaZ7lLCsRrqBCeQs1qibpOHHiajDVfjCd2vNw/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>如上图所示：内核程序执行在内核态（Kernal Mode），用户程序执行在用户态（User Mode）。</p><p>当发生系统调用时，用户态的程序发起系统调用，因为系统调用中牵扯特权指令，用户态程序权限不足，因此会中断执行，也就是 Trap（Trap 是一种中断）。</p><p>发生中断后，当前 CPU 执行的程序会中断，跳转到中断处理程序，内核程序开始执行，也就是开始处理系统调用。</p><p>内核处理完成后，主动触发 Trap，这样会再次发生中断，切换回用户态工作。</p><blockquote><p>异常</p></blockquote><p>当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常</p><blockquote><p>外围设备的中断</p></blockquote><p>当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换</p><p>比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等</p><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>线程：系统分配处理器时间资源的基本单元，是程序执行的最小单位</p><p>线程可以看做轻量级的进程，共享内存空间，每个线程都有自己独立的运行栈和程序计数器，线程之间切换的开销小。</p><p>在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）</p><p>进程可以通过 API 创建用户态的线程，也可以通过系统调用创建内核态的线程。</p><h2 id="用户态线程"><a href="#用户态线程" class="headerlink" title="用户态线程"></a>用户态线程</h2><p>用户态线程也称作用户级线程，操作系统内核并不知道它的存在，它完全是在用户空间中创建。</p><p>用户级线程有很多优势，比如：</p><ul><li>管理开销小：创建、销毁不需要系统调用。</li><li>切换成本低：用户空间程序可以自己维护，不需要走操作系统调度。</li></ul><p>但是这种线程也有很多的缺点：</p><ul><li>与内核协作成本高：比如这种线程完全是用户空间程序在管理，当它进行 I/O 的时候，无法利用到内核的优势，需要频繁进行用户态到内核态的切换。</li><li>线程间协作成本高：设想两个线程需要通信，通信需要 I/O，I/O 需要系统调用，因此用户态线程需要额外的系统调用成本。</li><li>无法利用多核优势：比如操作系统调度的仍然是这个线程所属的进程，所以无论每次一个进程有多少用户态的线程，都只能并发执行一个线程，因此一个进程的多个线程无法利用多核的优势。</li></ul><p>操作系统无法针对线程调度进行优化：当一个进程的一个用户态线程阻塞（Block）了，操作系统无法及时发现和处理阻塞问题，它不会更换执行其他线程，从而造成资源浪费。</p><h2 id="内核态线程"><a href="#内核态线程" class="headerlink" title="内核态线程"></a>内核态线程</h2><p>内核态线程也称作内核级线程（Kernel Level Thread），这种线程执行在内核态，可以通过系统调用创造一个内核级线程。</p><p>内核级线程有很多优势：</p><ul><li>可以利用多核 CPU 优势：内核拥有较高权限，因此可以在多个 CPU 核心上执行内核线程。</li><li>操作系统级优化：内核中的线程操作 I/O 不需要进行系统调用；一个内核线程阻塞了，可以立即让另一个执行。</li></ul><p>当然内核线程也有一些缺点：</p><ul><li>创建成本高：创建的时候需要系统调用，也就是切换到内核态。</li><li>扩展性差：由一个内核程序管理，不可能数量太多。</li><li>切换成本较高：切换的时候，也同样存在需要内核操作，需要切换内核态。</li></ul><p><strong>用户态线程和内核态线程之间的映射关系</strong></p><p>如果有一个用户态的进程，它下面有多个线程，如果这个进程想要执行下面的某一个线程，应该如何做呢？</p><blockquote><p>这时，比较常见的一种方式，就是将需要执行的程序，让一个内核线程去执行。</p></blockquote><p>毕竟，内核线程是真正的线程，因为它会分配到 CPU 的执行资源。</p><p>如果一个进程所有的线程都要自己调度，相当于在进程的主线程中实现分时算法调度每一个线程，也就是所有线程都用操作系统分配给主线程的时间片段执行。</p><blockquote><p>这种做法，相当于操作系统调度进程的主线程；进程的主线程进行二级调度，调度自己内部的线程。</p></blockquote><p>这样操作劣势非常明显，比如无法利用多核优势，每个线程调度分配到的时间较少，而且这种线程在阻塞场景下会直接交出整个进程的执行权限。</p><p>由此可见，用户态线程创建成本低，问题明显，不可以利用多核。</p><p>内核态线程，创建成本高，可以利用多核，切换速度慢。</p><p>因此通常我们会在内核中预先创建一些线程，并反复利用这些线程。</p><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p><img src="https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpkFYtYurwYD22yibbjd9PW8cJXg5Z9YlmOA8IUnDNtKuAJGicF9kWdCALCy6GDANOVaxcy78c3RPvoQ/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>协程，是一种比线程更加轻量级的存在，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。</p><p>这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。</p><p><strong>子程序</strong></p><p>或者称为函数，在所有语言中都是层级调用，比如A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完毕返回，最后是A执行完毕。</p><p>所以子程序调用是通过栈实现的，一个线程就是执行一个子程序。</p><p>子程序调用总是一个入口，一次返回，调用顺序是明确的。</p><p><strong>协程的特点在于是一个线程执行，那和多线程比，协程有何优势？</strong></p><ul><li>极高的执行效率：因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显；</li><li>不需要多线程的锁机制：因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</li></ul><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。</p><p>如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。</p><h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>在系统中正在运行的一个应用程序；程序一旦运行就是进程；是资源分配的最小单位。</p><p>在操作系统中能同时运行多个进程；</p><p>开机的时候，磁盘的内核镜像被导入内存作为一个执行副本，成为内核进程。</p><p>进程可以分成<strong>用户态进程和内核态进程</strong>两类，用户态进程通常是应用程序的副本，内核态进程就是内核本身的进程。</p><p>如果用户态进程需要申请资源，比如内存，可以通过系统调用向内核申请。</p><p>每个进程都有独立的内存空间，存放代码和数据段等，程序之间的切换会有较大的开销；</p><p><strong>分时和调度</strong></p><p>每个进程在执行时都会获得操作系统分配的一个时间片段，如果超出这个时间，就会轮到下一个进程（线程）执行。</p><blockquote><p>注意，现代操作系统都是直接调度线程，不会调度进程。</p></blockquote><p><strong>分配时间片段</strong></p><p>如下图所示，进程 1 需要 2 个时间片段，进程 2 只有 1 个时间片段，进程 3 需要 3 个时间片段。</p><p>因此当进程 1 执行到一半时，会先挂起，然后进程 2 开始执行；进程 2 一次可以执行完，然后进程 3 开始执行，不过进程 3 一次执行不完，在执行了 1 个时间片段后，进程 1 开始执行；就这样如此周而复始，这个就是分时技术。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpkFYtYurwYD22yibbjd9PW8cmhw5XY1b16QvWnxII0DzFTIYurhm2RXysa7jwyjo5JzFwRwzeBKOoQ/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h2 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h2><p>用户想要创建一个进程，最直接的方法就是从命令行执行一个程序，或者双击打开一个应用，但对于程序员而言，显然需要更好的设计。</p><p>首先，应该有 API 打开应用，比如可以通过函数打开某个应用；</p><p>另一方面，如果程序员希望执行完一段代价昂贵的初始化过程后，将当前程序的状态复制好几份，变成一个个单独执行的进程，那么操作系统提供了 fork 指令。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpkFYtYurwYD22yibbjd9PW8ce5LdIJ4Lt7ZSuK1aKicLaNKLIFlYZnScE0VvgUuqtUCDb6HxjkUo2qA/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>也就是说，每次 fork 会多创造一个克隆的进程，这个克隆的进程，所有状态都和原来的进程一样，但是会有自己的地址空间。</p><p>如果要创造 2 个克隆进程，就要 fork 两次。</p><blockquote><p>那如果我就是想启动一个新的程序呢？</p></blockquote><p>操作系统提供了启动新程序的 API。</p><p>如果我就是想用一个新进程执行一小段程序，比如说每次服务端收到客户端的请求时，我都想用一个进程去处理这个请求。</p><p>如果是这种情况，建议你不要单独启动进程，而是使用线程。</p><p>因为进程的创建成本实在太高了，因此不建议用来做这样的事情：要创建条目、要分配内存，特别是还要在内存中形成一个个段，分成不同的区域。所以通常，我们更倾向于多创建线程。</p><p>不同程序语言会自己提供创建线程的 API，比如 Java 有 Thread 类；go 有 go-routine（注意不是协程，是线程）。</p><h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><p><img src="https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpkFYtYurwYD22yibbjd9PW8cGdAT0VDySJfO910FDDw10uUIibrliaVM9Jxp1gW9yN6YiclRzAcfat3bA/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p><strong>创建状态</strong></p><p>进程由创建而产生，创建进程是一个非常复杂的过程，一般需要通过多个步骤才能完成：如首先由进程申请一个空白的进程控制块(PCB)，并向PCB中填写用于控制和管理进程的信息；然后为该进程分配运行时所必须的资源；最后，把该进程转入就绪状态并插入到就绪队列中</p><p><strong>就绪状态</strong></p><p>这是指进程已经准备好运行的状态，即进程已分配到除CPU以外所有的必要资源后，只要再获得CPU，便可立即执行，如果系统中有许多处于就绪状态的进程，通常将它们按照一定的策略排成一个队列，该队列称为就绪队列，有执行资格，没有执行权的进程</p><p><strong>运行状态</strong></p><p>这里指进程已经获取CPU，其进程处于正在执行的状态。对任何一个时刻而言，在单处理机的系统中，只有一个进程处于执行状态而在多处理机系统中，有多个进程处于执行状态，既有执行资格，又有执行权的进程</p><p><strong>阻塞状态</strong></p><p>这里是指正在执行的进程由于发生某事件（如I/O请求、申请缓冲区失败等）暂时无法继续执行的状态，即进程执行受到阻塞，此时引起进程调度，操作系统把处理机分配给另外一个就绪的进程，而让受阻的进程处于暂停的状态，一般将这个暂停状态称为阻塞状态</p><p><strong>终止状态</strong></p><h2 id="进程间通信IPC"><a href="#进程间通信IPC" class="headerlink" title="进程间通信IPC"></a>进程间通信IPC</h2><p>每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信</p><p><strong>管道/匿名管道</strong></p><p>管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道。</p><ul><li>只能用于父子进程或者兄弟进程之间(具有亲缘关系的进程);</li><li>单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。</li><li>数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出，写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。</li></ul><p><strong>有名管道(FIFO)</strong></p><p>匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。</p><p>为了克服这个缺点，提出了有名管道(FIFO)。</p><p>有名管道不同于匿名管道之处在于它提供了一个路径名与之关联，以有名管道的文件形式存在于文件系统中，这样，即使与有名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过有名管道相互通信，因此，通过有名管道不相关的进程也能交换数据。</p><p><strong>信号</strong></p><p>信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。</p><p>如果该进程当前并未处于执行状态，则该信号就有内核保存起来，知道该进程回复执行并传递给它为止。</p><p>如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程。</p><p><strong>消息队列</strong></p><p>消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。</p><p>与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。</p><p>另外与管道不同的是，消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达</p><p><strong>共享内存</strong></p><p>使得多个进程可以直接读写同一块内存空间，是最快的可用IPC形式，是针对其他通信机制运行效率较低而设计的。</p><p>为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间，进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。</p><p>由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥。</p><p>共享内存示意图：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpkFYtYurwYD22yibbjd9PW8cOANFcOycXX7we4mOicnKOHrG4aj4MCMic6IbFlq0WRRN4Kk9b5K1gk7A/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>一旦这样的内存映射到共享它的进程的地址空间，这些进程间数据传递不再涉及到内核，换句话说是进程不再通过执行进入内核的系统调用来传递彼此的数据。</p><p><strong>信号量</strong></p><p>信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。</p><p>为了获得共享资源，进程需要执行下列操作：</p><ol><li>创建一个信号量：这要求调用者指定初始值，对于二值信号量来说，它通常是1，也可是0。</li><li>等待一个信号量：该操作会测试这个信号量的值，如果小于0，就阻塞，也称为P操作。</li><li>挂出一个信号量：该操作将信号量的值加1，也称为V操作。</li></ol><p><strong>套接字(Socket)</strong></p><p>套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。</p><h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>信号是进程间通信机制中唯一的异步通信机制，可以看作是异步通知，通知接收信号的进程有哪些事情发生了。</p><p>也可以简单理解为信号是某种形式上的软中断</p><p>可运行<code>kill -l</code>查看Linux支持的信号列表：</p><pre class="line-numbers language-none"><code class="language-none">kill -l 1) SIGHUP  2) SIGINT  3) SIGQUIT  4) SIGILL  5) SIGTRAP 6) SIGABRT  7) SIGBUS  8) SIGFPE  9) SIGKILL 10) SIGUSR111) SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15) SIGTERM16) SIGSTKFLT 17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20) SIGTSTP21) SIGTTIN 22) SIGTTOU 23) SIGURG 24) SIGXCPU 25) SIGXFSZ26) SIGVTALRM 27) SIGPROF 28) SIGWINCH 29) SIGIO 30) SIGPWR31) SIGSYS 34) SIGRTMIN 35) SIGRTMIN+1 36) SIGRTMIN+2 37) SIGRTMIN+338) SIGRTMIN+4 39) SIGRTMIN+5 40) SIGRTMIN+6 41) SIGRTMIN+7 42) SIGRTMIN+843) SIGRTMIN+9 44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+1348) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-1253) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9 56) SIGRTMAX-8 57) SIGRTMAX-758) SIGRTMAX-6 59) SIGRTMAX-5 60) SIGRTMAX-4 61) SIGRTMAX-3 62) SIGRTMAX-263) SIGRTMAX-1 64) SIGRTMAX<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>几个常用的信号：</strong></p><table><thead><tr><th align="left">信号</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">SIGHUP</td><td align="left">当用户退出终端时，由该终端开启的所有进程都会接收到这个信号，默认动作为终止进程。</td></tr><tr><td align="left">SIGINT</td><td align="left">程序终止(interrupt)信号, 在用户键入INTR字符(通常是<code>Ctrl+C</code>)时发出，用于通知前台进程组终止进程。</td></tr><tr><td align="left">SIGQUIT</td><td align="left">和<code>SIGINT</code>类似, 但由QUIT字符(通常是<code>Ctrl+\</code>)来控制，进程在因收到<code>SIGQUIT</code>退出时会产生<code>core</code>文件, 在这个意义上类似于一个程序错误信号。</td></tr><tr><td align="left">SIGKILL</td><td align="left">用来立即结束程序的运行，本信号不能被阻塞、处理和忽略。</td></tr><tr><td align="left">SIGTERM</td><td align="left">程序结束(terminate)信号, 与<code>SIGKILL</code>不同的是该信号可以被阻塞和处理。通常用来要求程序自己正常退出。</td></tr><tr><td align="left">SIGSTOP</td><td align="left">停止(stopped)进程的执行. 注意它和terminate以及interrupt的区别:该进程还未结束, 只是暂停执行，本信号不能被阻塞, 处理或忽略</td></tr></tbody></table><h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><p><strong>临界区</strong></p><p>通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问</p><p>优点：保证在某一时刻只有一个线程能访问数据的简便办法</p><p>缺点：虽然临界区同步速度很快，但却只能用来同步本进程内的线程，而不可用来同步多个进程中的线程</p><p><strong>互斥量</strong></p><p>为协调共同对一个共享资源的单独访问而设计的</p><p>互斥量跟临界区很相似，比临界区复杂，互斥对象只有一个，只有拥有互斥对象的线程才具有访问资源的权限</p><p>优点：使用互斥不仅仅能够在同一应用程序不同线程中实现资源的安全共享，而且可以在不同应用程序的线程之间实现对资源的安全共享</p><p><strong>信号量</strong></p><p>为控制一个具有有限数量用户资源而设计，它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目，互斥量是信号量的一种特殊情况，当信号量的最大资源数=1就是互斥量了</p><p>信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作</p><ul><li><strong>down</strong> : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；</li><li><strong>up</strong> ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。</li></ul><p>down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。</p><p>如果信号量的取值只能为 0 或者 1，那么就成为了 <strong>互斥量（Mutex）</strong> ，0 表示临界区已经加锁，1 表示临界区解锁。</p><p><strong>事件</strong></p><p>用来通知线程有一些事件已发生，从而启动后继任务的开始</p><p>优点：事件对象通过通知操作的方式来保持线程的同步，并且可以实现不同进程中的线程同步操作</p><p><strong>管程</strong></p><p>管程有一个重要特性：在一个时刻只能有一个进程使用管程。</p><p>进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。</p><p>管程引入了 <strong>条件变量</strong> 以及相关的操作：<strong>wait()</strong> 和 <strong>signal()</strong> 来实现同步操作。</p><p>对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。</p><p>signal() 操作用于唤醒被阻塞的进程。</p><p>使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。</p><h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>对于单核单线程CPU而言，在某一时刻只能执行一条CPU指令。</p><p>上下文切换(Context Switch)是一种将CPU资源从一个进程分配给另一个进程的机制。</p><p>从用户角度看，计算机能够并行运行多个进程，这恰恰是操作系统通过快速上下文切换造成的结果。</p><p><strong>在切换的过程中，操作系统需要先存储当前进程的状态(包括内存空间的指针，当前执行完的指令等等)，再读入下一个进程的状态，然后执行此进程。</strong></p><h2 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h2><p><strong>先来先服务调度算法</strong></p><p>该算法既可用于作业调度，也可用于进程调度，当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列</p><p><strong>短作业优先调度算法</strong></p><p>从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行</p><p><strong>时间片轮转法</strong></p><p>每次调度时，把CPU分配给队首进程，并令其执行一个时间片，时间片的大小从几ms到几百ms，当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾</p><p>然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片，这样就可以保证就绪队列中的所有进程在一给定的时间内均能获得一时间片的处理机执行时间</p><p><strong>最短剩余时间优先</strong></p><p>最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度，当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。</p><p>如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p><p><strong>多级反馈队列调度算法</strong>：</p><p>前面介绍的几种进程调度的算法都有一定的局限性，如<strong>短进程优先的调度算法，仅照顾了短进程而忽略了长进程</strong>，多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业迅速完成，因而它是目前<strong>被公认的一种较好的进程调度算法</strong>，UNIX 操作系统采取的便是这种调度算法。</p><blockquote><p>举例：</p></blockquote><p>多级队列，就是多个队列执行调度，先考虑最简单的两级模型</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpkFYtYurwYD22yibbjd9PW8cQoG1SGqtFVTaHuUmCv0t6qSLgjVnopdPafyoeWlQN5NlPJG2tOqWibA/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>上图中设计了两个优先级不同的队列，从下到上优先级上升，上层队列调度紧急任务，下层队列调度普通任务。</p><p>只要上层队列有任务，下层队列就会让出执行权限。</p><p>低优先级队列可以考虑抢占 + 优先级队列的方式实现，这样每次执行一个时间片段就可以判断一下高优先级的队列中是否有任务。</p><p>高优先级队列可以考虑用非抢占（每个任务执行完才执行下一个）+ 优先级队列实现，这样紧急任务优先级有个区分，如果遇到十万火急的情况，就可以优先处理这个任务。</p><p>上面这个模型虽然解决了任务间的优先级问题，但是还是没有解决短任务先行的问题，可以考虑再增加一些队列，让级别更多。</p><blockquote><p>比如下图这个模型：</p></blockquote><p><img src="https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpkFYtYurwYD22yibbjd9PW8cEAlGU8vZjmH8rNhrXYOBQ2a3xVCIqTHGQJdDzMaoxNhzV2WwB1iaiaHg/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>紧急任务仍然走高优队列，非抢占执行。</p><p>普通任务先放到优先级仅次于高优任务的队列中，并且只分配很小的时间片；如果没有执行完成，说明任务不是很短，就将任务下调一层。</p><p>下面一层，最低优先级的队列中时间片很大，长任务就有更大的时间片可以用。</p><p>通过这种方式，短任务会在更高优先级的队列中执行完成，长任务优先级会下调，也就类似实现了最短作业优先的问题。</p><p>实际操作中，可以有 n 层，一层层把大任务筛选出来，最长的任务，放到最闲的时间去执行，要知道，大部分时间 CPU 不是满负荷的。</p><p><strong>优先级调度</strong></p><p>为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推，具有相同优先级的进程以 FCFS 方式执行，可以根据内存要求，时间要求或任何其他资源要求来确定优先级。</p><h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h2><p>守护进程是脱离于终端并且在后台运行的进程，脱离终端是为了避免在执行的过程中的信息在终端上显示，并且进程也不会被任何终端所产生的终端信息所打断。</p><p>守护进程一般的生命周期是系统启动到系统停止运行。</p><p>Linux系统中有很多的守护进程，最典型的就是我们经常看到的服务进程。</p><p>当然，我们也经常会利用守护进程来完成很多的系统或者自动化任务。</p><h2 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h2><p>父进程早于子进程退出时候子进程还在运行，子进程会成为孤儿进程，Linux会对孤儿进程的处理，把孤儿进程的父进程设为进程号为1的进程，也就是由init进程来托管，init进程负责子进程退出后的善后清理工作</p><h2 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h2><p>子进程执行完毕时发现父进程未退出，会向父进程发送 SIGCHLD 信号，但父进程没有使用 wait/waitpid 或其他方式处理 SIGCHLD 信号来回收子进程，子进程变成为了对系统有害的僵尸进程</p><p>子进程退出后留下的进程信息没有被收集，会导致占用的进程控制块PCB不被释放，形成僵尸进程，进程已经死去，但是进程资源没有被释放掉</p><p><strong>问题及危害</strong></p><p>如果系统中存在大量的僵尸进程，他们的进程号就会一直被占用，但是系统所能使用的进程号是有限的，系统将因为没有可用的进程号而导致系统不能产生新的进程</p><p>任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理，这是每个子进程在结束时都要经过的阶段，如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是Z。</p><p>如果父进程能及时处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态</p><p>产生僵尸进程的元凶其实是他们的父进程，杀掉父进程，僵尸进程就变为了孤儿进程，便可以转交给 init 进程回收处理</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p><strong>产生原因</strong></p><p>系统资源的竞争：系统资源的竞争导致系统资源不足，以及资源分配不当，导致死锁。</p><p>进程运行推进顺序不合适：进程在运行过程中，请求和释放资源的顺序不当，会导致死锁。</p><p><strong>发生死锁的四个必要条件</strong></p><p>互斥条件：一个资源每次只能被一个进程使用，即在一段时间内某资源仅为一个进程所占有，此时若有其他进程请求该资源，则请求进程只能等待</p><p>请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求时，该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放</p><p>不可剥夺条件:进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)</p><p>循环等待条件: 若干进程间形成首尾相接循环等待资源的关系</p><p>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁</p><p><strong>只要我们破坏其中一个，就可以成功避免死锁的发生</strong></p><p>其中，互斥这个条件我们没有办法破坏，因为我们用锁为的就是互斥</p><ol><li>对于占用且等待这个条件，我们可以一次性申请所有的资源，这样就不存在等待了。</li><li>对于不可抢占这个条件，占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源，这样不可抢占这个条件就破坏掉了。</li><li>对于循环等待这个条件，可以靠按序申请资源来预防，所谓按序申请，是指资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化后自然就不存在循环了。</li></ol><p><strong>处理方法</strong></p><p>主要有以下四种方法：</p><ul><li>鸵鸟策略</li><li>死锁检测与死锁恢复</li><li>死锁预防，破坏4个必要条件</li><li>死锁避免，银行家算法</li></ul><p><strong>鸵鸟策略</strong></p><p>把头埋在沙子里，假装根本没发生问题。</p><p>因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。</p><p>当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。</p><p><strong>死锁检测</strong></p><p>不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。</p><ol><li>每种类型一个资源的死锁检测</li><li>每种类型多个资源的死锁检测</li></ol><p><strong>死锁恢复</strong></p><ul><li>利用抢占恢复</li><li>利用回滚恢复</li><li>通过杀死进程恢复</li></ul><h3 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h3><p>五个哲学家围着一张圆桌，每个哲学家面前放着食物。</p><p>哲学家的生活有两种交替活动：吃饭以及思考。</p><p>当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。</p><p>如果所有哲学家同时拿起左手边的筷子，那么所有哲学家都在等待其它哲学家吃完并释放自己手中的筷子，导致死锁。</p><p>哲学家进餐问题可看作是并发进程并发执行时处理共享资源的一个有代表性的问题。</p><p><strong>为了防止死锁的发生，可以设置两个条件：</strong></p><ul><li>必须同时拿起左右两根筷子；</li><li>只有在两个邻居都没有进餐的情况下才允许进餐。</li></ul><h3 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h3><p>银行家算法的命名是它可以用了银行系统，当不能满足所有客户的需求时，银行绝不会分配其资金。</p><p>当新进程进入系统时，它必须说明其可能需要的每种类型资源实例的最大数量这一数量不可以超过系统资源的总和。</p><p>当用户申请一组资源时，系统必须确定这些资源的分配是否处于安全状态，如何安全，则分配，如果不安全，那么进程必须等待指导某个其他进程释放足够资源为止。</p><p><strong>安全状态</strong></p><p>在避免死锁的方法中，允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次资源分配的安全性，若此次分配不会导致系统进入不安全状态，则将资源分配给进程；否则，令进程等待</p><p>因此，避免死锁的实质在于：系统在进行资源分配时，如何使系统不进入不安全状态</p><h2 id="Fork函数"><a href="#Fork函数" class="headerlink" title="Fork函数"></a>Fork函数</h2><p><code>fork</code>函数用于创建一个与当前进程一样的子进程，所创建的子进程将复制父进程的代码段、数据段、BSS段、堆、栈等所有用户空间信息，在内核中操作系统会重新为其申请一个子进程执行的位置。</p><p><code>fork</code>系统调用会通过复制一个现有进程来创建一个全新的进程，新进程被存放在一个叫做任务队列的双向循环链表中，链表中的每一项都是类型为<code>task_struct</code>的进程控制块<code>PCB</code>的结构。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpkFYtYurwYD22yibbjd9PW8c0zsuKd7ndDzmrHxnQXrwIcnXicFgpD8yrCqkW8AIrzicoOgOQCic3mw2Q/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>每个进程都由独特换不相同的进程标识符（PID），通过<code>getpid()</code>函数可获取当前进程的进程标识符，通过<code>getppid()</code>函数可获得父进程的进程标识符。</p><p>一个现有的进程可通过调用<code>fork</code>函数创建一个新进程，由<code>fork</code>创建的新进程称为子进程<code>child process</code>，<code>fork</code>函数被调用一次但返回两次，两次返回的唯一区别是子进程中返回0而父进程中返回子进程ID。</p><p><strong>为什么<code>fork</code>会返回两次呢？</strong></p><p>因为复制时会复制父进程的堆栈段，所以两个进程都停留在<code>fork</code>函数中等待返回，因此会返回两次，一个是在父进程中返回，一次是在子进程中返回，两次返回值是不一样的。</p><ul><li>在父进程中将返回新建子进程的进程ID</li><li>在子进程中将返回0</li><li>若出现错误则返回一个负数</li></ul><p>因此可以通过<code>fork</code>的返回值来判断当前进程是子进程还是父进程。</p><p><strong>fork执行执行流程</strong></p><p>当进程调用<code>fork</code>后控制转入内核，内核将会做4件事儿：</p><ol><li>分配新的内存块和内核数据结构给子进程</li><li>将父进程部分数据结构内容（数据空间、堆栈等）拷贝到子进程</li><li>添加子进程到系统进程列表中</li><li><code>fork</code>返回开始调度器调度</li></ol><p><strong>为什么<code>pid</code>在父子进程中不同呢？</strong></p><p>其实就相当于链表，进程形成了链表，父进程的<code>pid</code>指向子进程的进程ID，因此子进程没有子进程，所以PID为0，这里的<code>pid</code>相当于链表中的指针。</p><h1 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h1><h2 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h2><p>读写一个磁盘块的时间的影响因素有：</p><ul><li>旋转时间</li><li>寻道时间实际的数据传输时间</li></ul><p>其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。</p><blockquote><p>先来先服务 FCFS, First Come First Served</p></blockquote><p>按照磁盘请求的顺序进行调度，优点是公平和简单，缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。</p><blockquote><p>最短寻道时间优先，SSTF, Shortest Seek Time First</p></blockquote><p>优先调度与当前磁头所在磁道距离最近的磁道， 虽然平均寻道时间比较低，但是不够公平，如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的 磁道请求会一直等待下去，也就是出现饥饿现象，具体来说，两边的磁道请求更容易出现饥饿现象。</p><blockquote><p>电梯算法，SCAN</p></blockquote><p>电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向， 电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘 请求，然后改变方向，因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题</p><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p><strong>逻辑地址和物理地址</strong></p><p>我们编程一般只有可能和逻辑地址打交道，比如在 C 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定。</p><p>物理地址指的是真实物理内存中地址，更具体一点来说就是内存地址寄存器中的地址，物理地址是内存单元真正的地址。</p><p>编译时只需确定变量x存放的相对地址是100 ( 也就是说相对于进程在内存中的起始地址而言的地址)。</p><p>CPU想要找到x在内存中的实际存放位置，只需要用进程的起始地址+100即可。</p><p>相对地址又称逻辑地址，绝对地址又称物理地址。</p><p><strong>内存管理有哪几种方式</strong></p><ol><li><strong>块式管理</strong>：将内存分为几个固定大小的块，每个块中只包含一个进程，如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了，这些在每个块中未被利用的空间，我们称之为碎片。</li><li><strong>页式管理</strong>：把主存分为大小相等且固定的一页一页的形式，页较小，相对相比于块式管理的划分力度更大，提高了内存利用率，减少了碎片，页式管理通过页表对应逻辑地址和物理地址。</li></ol><p><img src="https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpkFYtYurwYD22yibbjd9PW8cEVIppLicOk5ps89mxu4N8XeZ98IPvq2oYicg8lFWxAlykuIAibXQWQhbA/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><ol><li><strong>段式管理</strong>：页式管理虽然提高了内存利用率，但是页式管理其中的页实际并无任何实际意义， 段式管理把主存分为一段段的，每一段的空间又要比一页的空间小很多 ，段式管理通过段表对应逻辑地址和物理地址。</li><li>**段页式管理机制：**段页式管理机制结合了段式管理和页式管理的优点，简单来说段页式管理机制就是把主存先分成若干段，每个段又分成若干页，也就是说**段页式管理机制**中段与段之间以及段的内部的都是离散的。</li></ol><p><img src="https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpkFYtYurwYD22yibbjd9PW8cMTgmVefF4eBS7lAlNibS4xIMVJzM9uv59dg6flEXdNQvia6G06HHryiag/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h2 id="虚拟地址"><a href="#虚拟地址" class="headerlink" title="虚拟地址"></a>虚拟地址</h2><p>现代处理器使用的是一种称为**虚拟寻址(Virtual Addressing)**的寻址方式</p><p><strong>使用虚拟寻址，CPU 需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。</strong></p><p>实际上完成虚拟地址转换为物理地址转换的硬件是 CPU 中含有一个被称为<strong>内存管理单元（Memory Management Unit, MMU）</strong>的硬件</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpkFYtYurwYD22yibbjd9PW8crlT2Fd97XP1Cxt74TCMPrrlAVEPdQw1ygkV69icOj3po80LJQiaXXyhQ/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p><strong>为什么要有虚拟地址空间</strong></p><p>没有虚拟地址空间的时候，<strong>程序都是直接访问和操作的都是物理内存</strong>。</p><p>但是这样有什么问题？</p><ol><li>用户程序可以访问任意内存，寻址内存的每个字节，这样就很容易破坏操作系统，造成操作系统崩溃。</li><li>想要同时运行多个程序特别困难，比如你想同时运行一个微信和一个 QQ 音乐都不行，为什么呢？举个简单的例子：微信在运行的时候给内存地址 1xxx 赋值后，QQ 音乐也同样给内存地址 1xxx 赋值，那么 QQ 音乐对内存的赋值就会覆盖微信之前所赋的值，这就造成了微信这个程序就会崩溃。</li></ol><p><strong>通过虚拟地址访问内存有以下优势：</strong></p><ul><li>程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区。</li><li>程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。</li><li>不同进程使用的虚拟地址彼此隔离，一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。</li></ul><p><strong>MMU如何把虚拟地址翻译成物理地址的</strong></p><p>对于每个程序，内存管理单元MMU都为其保存一个页表，该页表中存放的是虚拟页面到物理页面的映射。</p><p>每当为一个虚拟页面寻找到一个物理页面之后，就在页表里增加一条记录来保留该映射关系，当然，随着虚拟页面进出物理内存，页表的内容也会不断更新变化。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpkFYtYurwYD22yibbjd9PW8cF0frvqia4lficqVtWw3PnMRyblm47XDwM1yF8ol7WpKcfVoNiaSmGamnQ/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>很多时候我们使用点开了很多占内存的软件，这些软件占用的内存可能已经远远超出了我们电脑本身具有的物理内存</p><p>通过 <strong>虚拟内存</strong> 可以让程序可以拥有超过系统物理内存大小的可用内存空间。</p><p>另外，虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间），这样会更加有效地管理内存并减少出错。</p><p><strong>虚拟内存</strong>是计算机系统内存管理的一种技术，我们可以手动设置自己电脑的虚拟内存</p><p><strong>虚拟内存的重要意义是它定义了一个连续的虚拟地址空间</strong>，并且 <strong>把内存扩展到硬盘空间</strong></p><p><strong>虚拟内存的实现有以下三种方式：</strong></p><ol><li><strong>请求分页存储管理</strong> ：请求分页是目前最常用的一种实现虚拟存储器的方法，请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行，假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。</li><li><strong>请求分段存储管理</strong> ：请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。</li><li><strong>请求段页式存储管理</strong></li></ol><p>不管是上面那种实现方式，我们一般都需要：</p><blockquote><p>一定容量的内存和外存：在载入程序的时候，只需要将程序的一部分装入内存，而将其他部分留在外存，然后程序就可以执行了；</p></blockquote><p><img src="https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpkFYtYurwYD22yibbjd9PW8cjKECAx9F28Su1w7VCmib4Vdtz7E7IB1wKWUutD9M4f7fZXjuH9LWLpw/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h2 id="缺页中断"><a href="#缺页中断" class="headerlink" title="缺页中断"></a>缺页中断</h2><p>如果<strong>需执行的指令或访问的数据尚未在内存</strong>（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段<strong>调入到内存</strong>，然后继续执行程序；</p><p>在分页系统中，一个虚拟页面既有可能在物理内存，也有可能保存在磁盘上。</p><p>如果CPU发出的虚拟地址对应的页面不在物理内存，就将产生一个缺页中断，而缺页中断服务程序负责将需要的虚拟页面找到并加载到内存。</p><p>缺页中断的处理步骤如下，省略了中间很多的步骤，只保留最核心的几个步骤：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpkFYtYurwYD22yibbjd9PW8cqdKRvOUibF06eW8amA1DkSbvL0LVpOqtjDibX2fEIQ1hADTzfNohJicIg/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><p>当发生缺页中断时，如果当前内存中并没有空闲的页面，操作系统就必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。</p><p>用来选择淘汰哪一页的规则叫做页面置换算法，我们可以把页面置换算法看成是淘汰页面的规则</p><ul><li><strong>OPT 页面置换算法（最佳页面置换算法）</strong> ：该置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率，但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现，一般作为衡量其他置换算法的方法。</li><li><strong>FIFO（First In First Out） 页面置换算法（先进先出页面置换算法）</strong> : 总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。</li><li><strong>LRU （Least Currently Used）页面置换算法（最近最久未使用页面置换算法）</strong> ：LRU算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。</li><li><strong>LFU （Least Frequently Used）页面置换算法（最少使用页面置换算法）</strong> : 该置换算法选择在之前时期使用最少的页面作为淘汰页。</li></ul><h2 id="局部性原理-1"><a href="#局部性原理-1" class="headerlink" title="局部性原理"></a>局部性原理</h2><p>局部性原理是虚拟内存技术的基础，正是因为程序运行具有局部性原理，才可以只装入部分程序到内存就开始运行。</p><p>局部性原理表现在以下两个方面：</p><ol><li><strong>时间局部性</strong> ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问，产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。</li><li><strong>空间局部性</strong> ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。</li></ol><p>时间局部性是通过将近来使用的指令和数据保存到<strong>高速缓存存储器</strong>中，并使用高速缓存的层次结构实现。</p><p>空间局部性通常是使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。</p><h2 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h2><p>操作系统将虚拟内存分块，每个小块称为一个页（Page）；真实内存也需要分块，每个小块我们称为一个 Frame。</p><p>Page 到 Frame 的映射，需要一种叫作页表的结构。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpkFYtYurwYD22yibbjd9PW8cadmmorVgIJ9Njeu8VDESOzy9L76bH7qbrq6kCqxb6z1t8QTsNxXB9w/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>上图展示了 Page、Frame 和页表 （PageTable）三者之间的关系。</p><p>Page 大小和 Frame 大小通常相等，页表中记录的某个 Page 对应的 Frame 编号。</p><p>页表也需要存储空间，比如虚拟内存大小为 10G， Page 大小是 4K，那么需要 10G/4K = 2621440 个条目。</p><p>如果每个条目是 64bit，那么一共需要 20480K = 20M 页表，操作系统在内存中划分出小块区域给页表，并负责维护页表。</p><p><strong>页表维护了虚拟地址到真实地址的映射。</strong></p><p>每次程序使用内存时，需要把虚拟内存地址换算成物理内存地址，换算过程分为以下 3 个步骤：</p><ul><li>通过虚拟地址计算 Page 编号；</li><li>查页表，根据 Page 编号，找到 Frame 编号；</li><li>将虚拟地址换算成物理地址。</li></ul><h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><p>引入多级页表的主要目的是为了避免把全部页表一直放在内存中占用过多空间，特别是那些根本就不需要的页表就不需要保留在内存中</p><p><strong>一级页表：</strong></p><p>假如物理内存中一共有1048576个页，那么页表就需要总共就是<code>1048576 * 4B = 4M</code>。</p><p>也就是说我需要4M连续的内存来存放这个页表，也就是一级页表。</p><p>随着虚拟地址空间的增大，存放页表所需要的连续空间也会增大，在操作系统内存紧张或者内存碎片较多时，这无疑会带来额外的开销。</p><p>页表寻址是用寄存器来确定一级页表地址的，所以一级页表的地址必须指向确定的物理页，否则就会出现错误，所以如果用一级页表的话，就必须把全部的页表都加载进去。</p><p><strong>二级页表：</strong></p><p>而使用二级页表的话，只需要加载一个页目录表(一级页表)，大小为4K，可以管理1024个二级页表。</p><p>可能你会有疑问，这1024个二级页表也是需要内存空间的，这下反而需要4MB+4KB的内存，反而更多了。</p><p>其实二级页表并不是一定要存在内存中的，内存中只需要一个一级页表地址存在存器即可，二级页表可以使用缺页中断从外存移入内存。</p><p><strong>多级页表属于时间换空间的典型场景</strong></p><h2 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h2><p>为了解决虚拟地址到物理地址的转换速度，操作系统在<strong>页表方案</strong>基础之上引入了<strong>快表</strong>来加速虚拟地址到物理地址的转换</p><p>我们可以把快表理解为一种特殊的<strong>高速缓冲存储器（Cache）</strong>，其中的内容是页表的一部分或者全部内容，作为页表的 Cache，它的作用与页表相似，但是提高了访问速率，由于采用页表做地址转换，读写内存数据时 CPU 要访问两次主存，有了快表，有时只要访问一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。</p><p><strong>使用快表之后的地址转换流程是这样的：</strong></p><ol><li>根据虚拟地址中的页号查快表；</li><li>如果该页在快表中，直接从快表中读取相应的物理地址；</li><li>如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中；</li><li>当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。</li></ol><p><img src="https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpkFYtYurwYD22yibbjd9PW8casnLM5uFzjoU2c28VOqEABsJQXRQQD8MgJ2Mz1SjfYFw9Am6JrCGow/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h2 id="内存管理单元"><a href="#内存管理单元" class="headerlink" title="内存管理单元"></a>内存管理单元</h2><p>在 CPU 中一个小型的设备——内存管理单元（MMU）</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpkFYtYurwYD22yibbjd9PW8cAsxHoCrCELic1HQhf7sY7l5VSfs6RibkW6NYic06OYPLicTS6myPY2TGDQ/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"><img src="https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpkFYtYurwYD22yibbjd9PW8caKER6vx4iajHTAiaqxeL1crZsX347AZ3XicApTADTAK0r2YmPicS7n7jLQ/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>当 CPU 需要执行一条指令时，如果指令中涉及内存读写操作，CPU 会把虚拟地址给 MMU，MMU 自动完成虚拟地址到真实地址的计算；然后，MMU 连接了地址总线，帮助 CPU 操作真实地址。</p><p>在不同 CPU 的 MMU 可能是不同的，因此这里会遇到很多跨平台的问题。</p><p>解决跨平台问题不但有繁重的工作量，更需要高超的编程技巧。</p><h2 id="动态分区分配算法"><a href="#动态分区分配算法" class="headerlink" title="动态分区分配算法"></a>动态分区分配算法</h2><p>内存分配算法，大体来说分为：<strong>连续式分配 与 非连续式分配</strong></p><p>连续式分配就是把所以要执行的程序 <strong>完整的，有序的</strong> 存入内存，连续式分配又可以分为<strong>固定分区分配 和 动态分区分配</strong></p><p>非连续式分配就是把要执行的程序按照一定规则进行拆分，显然这样更有效率，现在的操作系统通常也都是采用这种方式分配内存</p><p>所谓动态分区分配，就是指<strong>内存在初始时不会划分区域，而是会在进程装入时，根据所要装入的进程大小动态地对内存空间进行划分，以提高内存空间利用率，降低碎片的大小</strong></p><p>动态分区分配算法有以下四种：</p><blockquote><p>首次适应算法（First Fit）</p></blockquote><p>空闲分区以地址递增的次序链接，分配内存时顺序查找，找到大小满足要求的第一个空闲分区就进行分配</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpkFYtYurwYD22yibbjd9PW8cRu80STSicy03crvKsOe8QHNzRIOxmQkYvxPAVkpRIR53zl3CAOVLUwA/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><blockquote><p>邻近适应算法（Next Fit）</p></blockquote><p>又称循环首次适应法，由首次适应法演变而成，不同之处是分配内存时从上一次查找结束的位置开始继续查找</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpkFYtYurwYD22yibbjd9PW8cWp10oWicLfTrsZg1zD8jm4JialpHyfyHcT5ebwjial3hocJXPUldDGSmg/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><blockquote><p>最佳适应算法（Best Fit）</p></blockquote><p>空闲分区按容量递增形成分区链，找到第一个能满足要求的空闲分区就进行分配</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpkFYtYurwYD22yibbjd9PW8cN3icE74nzybj4UdKia7icm2pNAtrQDntbKlVTylHC4BNh2UQT70SRsWKw/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><blockquote><p>最坏适应算法（Next Fit）</p></blockquote><p>又称最大适应算法，空闲分区以容量递减的次序链接，找到第一个能满足要求的空闲分区（也就是最大的分区）就进行分配</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpkFYtYurwYD22yibbjd9PW8cCCb1B9XY0B7FYV1vf6GN1oBl5hiaBRmVcawX7IOhiazjCmiaibdCMNDl3A/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p><strong>总结</strong></p><p>首次适应不仅最简单，通常也是最好最快，不过首次适应算法会使得内存低地址部分出现很多小的空闲分区，而每次查找都要经过这些分区，因此也增加了查找的开销。</p><p>邻近算法试图解决这个问题，但实际上，它常常会导致在内存的末尾分配空间分裂成小的碎片，它通常比首次适应算法结果要差。</p><p>最佳适应算法导致大量碎片，最坏适应算法导致没有大的空间。</p><h2 id="内存覆盖"><a href="#内存覆盖" class="headerlink" title="内存覆盖"></a>内存覆盖</h2><p>覆盖与交换技术是在程序用来扩充内存的两种方法。</p><p>早期的计算机系统中，主存容量很小，虽然主存中仅存放一道用户程序，但是存储空间放不下用户进程的现象也经常发生，这一矛盾可以用覆盖技术来解决。</p><p><strong>覆盖的基本思想是：</strong></p><p>由于程序运行时并非任何时候都要访问程序及数据的各个部分（尤其是大程序），因此可以把用户空间分成一个固定区和若干个覆盖区。</p><p>将经常活跃的部分放在固定区，其余部分按调用关系分段。</p><p>首先将那些即将要访问的段放入覆盖区，其他段放在外存中，在需要调用前，系统再将其调入覆盖区，替换覆盖区中原有的段。</p><p>覆盖技术的特点是打破了必须将一个进程的全部信息装入主存后才能运行的限制，但当同时运行程序的代码量大于主存时仍不能运行。</p><h2 id="内存交换"><a href="#内存交换" class="headerlink" title="内存交换"></a>内存交换</h2><p><strong>交换的基本思想</strong></p><p>把处于等待状态（或在CPU调度原则下被剥夺运行权利）的程序从内存移到辅存，把内存空间腾出来，这一过程又叫换出；</p><p>把准备好竞争CPU运行的程序从辅存移到内存，这一过程又称为换入。</p><blockquote><p>例如，有一个CPU釆用时间片轮转调度算法的多道程序环境。</p></blockquote><p>时间片到，内存管理器将刚刚执行过的进程换出，将另一进程换入到刚刚释放的内存空间中。</p><p>同时，CPU调度器可以将时间片分配给其他已在内存中的进程。</p><p>每个进程用完时间片都与另一进程交换。</p><p>理想情况下，内存管理器的交换过程速度足够快，总有进程在内存中可以执行。</p><blockquote><p>交换技术主要是在不同进程（或作业）之间进行，而覆盖则用于同一个程序或进程中。</p></blockquote><p>由于覆盖技术要求给出程序段之间的覆盖结构，使得其对用户和程序员不透明，所以对于主存无法存放用户程序的矛盾</p><p>现代操作系统是通过虚拟内存技术来解决的，覆盖技术则已成为历史；而交换技术在现代操作系统中仍具有较强的生命力。</p><h1 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h1><p><strong>进程、线程的区别</strong></p><p>操作系统会以进程为单位，分配系统资源（CPU时间片、内存等资源），进程是资源分配的最小单位。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpkFYtYurwYD22yibbjd9PW8cbnvmvXbqx7jLv1E9a4QBtW1xqV1SaeYxq2SXibHnicfLbjgvtgMSfGKw/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>调度：线程作为CPU调度和分配的基本单位，进程作为拥有资源的基本单位；</p><p>并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行；</p><blockquote><p>拥有资源：</p></blockquote><p>进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。</p><p>进程所维护的是程序所包含的资源（静态资源）， 如：地址空间，打开的文件句柄集，文件系统状态，信号处理handler等；</p><p>线程所维护的运行相关的资源（动态资源），如：运行栈，调度相关的控制信息，待处理的信号集等；</p><blockquote><p>系统开销：</p></blockquote><p>在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。</p><p>但是进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。</p><p>线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个进程死掉就等于所有的线程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。</p><p><strong>一个进程可以创建多少线程</strong></p><p>理论上，一个进程可用虚拟空间是2G，默认情况下，线程的栈的大小是1MB，所以理论上最多只能创建2048个线程。</p><p>如果要创建多于2048的话，必须修改编译器的设置。</p><p>在一般情况下，你不需要那么多的线程，过多的线程将会导致大量的时间浪费在线程切换上，给程序运行效率带来负面影响。</p><p><strong>外中断和异常有什么区别</strong></p><p>外中断是指由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求，此外还有时钟中断、控制台中断等。</p><p>而异常时由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。</p><p><strong>解决Hash冲突四种方法</strong></p><p>开放定址法</p><ul><li>开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。</li></ul><p>链地址法</p><ul><li>将哈希表的每个单元作为链表的头结点，所有哈希地址为i的元素构成一个同义词链表。即发生冲突时就把该关键字链在以该单元为头结点的链表的尾部。</li></ul><p>再哈希法</p><ul><li>当哈希地址发生冲突用其他的函数计算另一个哈希函数地址，直到冲突不再产生为止。</li></ul><p>建立公共溢出区</p><ul><li>将哈希表分为基本表和溢出表两部分，发生冲突的元素都放入溢出表中。</li></ul><p><strong>分页机制和分段机制有哪些共同点和区别</strong></p><p>共同点</p><ul><li>分页机制和分段机制都是为了提高内存利用率，较少内存碎片。</li><li>页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。</li></ul><p>区别</p><ul><li>页的大小是固定的，由操作系统决定；而段的大小不固定，取决于我们当前运行的程序。</li><li>分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满足用户的需要。</li><li>分页是一维地址空间，分段是二维的。</li></ul><p><strong>介绍一下几种典型的锁</strong></p><blockquote><p>读写锁</p></blockquote><ul><li>可以同时进行多个读</li><li>写者必须互斥（只允许一个写者写，也不能读者写者同时进行）</li><li>写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）</li></ul><blockquote><p>互斥锁</p></blockquote><p>一次只能一个线程拥有互斥锁，其他线程只有等待</p><p>互斥锁是在抢锁失败的情况下主动放弃CPU进入睡眠状态直到锁的状态改变时再唤醒，而操作系统负责线程调度，为了实现锁的状态发生改变时唤醒阻塞的线程或者进程，需要把锁交给操作系统管理，所以互斥锁在加锁操作时涉及上下文的切换。</p><p>互斥锁实际的效率还是可以让人接受的，加锁的时间大概100ns左右，而实际上互斥锁的一种可能的实现是先自旋一段时间，当自旋的时间超过阀值之后再将线程投入睡眠中，因此在并发运算中使用互斥锁（每次占用锁的时间很短）的效果可能不亚于使用自旋锁</p><blockquote><p>条件变量</p></blockquote><p>互斥锁一个明显的缺点是他只有两种状态：锁定和非锁定。</p><p>而条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，他常和互斥锁一起使用，以免出现竞态条件。</p><p>当条件不满足时，线程往往解开相应的互斥锁并阻塞线程然后等待条件发生变化。</p><p>一旦其他的某个线程改变了条件变量，他将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。</p><p>总的来说<strong>互斥锁是线程间互斥的机制，条件变量则是同步机制。</strong></p><blockquote><p>自旋锁</p></blockquote><p>如果进线程无法取得锁，进线程不会立刻放弃CPU时间片，而是一直循环尝试获取锁，直到获取为止。</p><p>如果别的线程长时期占有锁，那么自旋就是在浪费CPU做无用功，但是自旋锁一般应用于加锁时间很短的场景，这个时候效率比较高。</p><p>虽然它的效率比互斥锁高，但是它也有些不足之处：</p><ul><li>自旋锁一直占用CPU，在未获得锁的情况下，一直进行自旋，所以占用着CPU，如果不能在很短的时间内获得锁，无疑会使CPU效率降低。</li><li>在用自旋锁时有可能造成死锁，当递归调用时有可能造成死锁。</li></ul><p><strong>如何让进程后台运行</strong></p><p>1.命令后面加上&amp;即可，实际上，这样是将命令放入到一个作业队列中了</p><p>2.ctrl + z 挂起进程，使用jobs查看序号，在使用bg %序号后台运行进程</p><p>3.nohup + &amp;，将标准输出和标准错误缺省会被重定向到 <code>nohup.out</code> 文件中，忽略所有挂断（SIGHUP）信号</p><pre class="line-numbers language-none"><code class="language-none">nohup ping www.ibm.com &amp;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4.运行指令前面 + setsid，使其父进程变成init进程，不受SIGHUP信号的影响</p><pre class="line-numbers language-none"><code class="language-none">[root@pvcent107 ~]# setsid ping www.ibm.com[root@pvcent107 ~]# ps -ef |grep www.ibm.comroot     31094     1  0 07:28 ?        00:00:00 ping www.ibm.comroot     31102 29217  0 07:29 pts/4    00:00:00 grep www.ibm.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上例中我们的进程 ID(PID)为31094，而它的父 ID（PPID）为1（即为 init 进程 ID），并不是当前终端的进程 ID。</p><blockquote><p>5.将命令+ &amp;放在()括号中，也可以是进程不受HUP信号的影响</p></blockquote><pre class="line-numbers language-none"><code class="language-none">[root@pvcent107 ~]# (ping www.ibm.com &amp;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>异常和中断的区别</strong></p><blockquote><p>中断</p></blockquote><p>当我们在敲击键盘的同时就会产生中断，当硬盘读写完数据之后也会产生中断，所以，我们需要知道，中断是由硬件设备产生的，而它们从物理上说就是电信号，之后，它们通过中断控制器发送给CPU，接着CPU判断收到的中断来自于哪个硬件设备（这定义在内核中），最后，由CPU发送给内核，有内核处理中断。</p><p>下面这张图显示了中断处理的流程：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpkFYtYurwYD22yibbjd9PW8cmmhAATRFWKPa6mMuDMq5HPNsBZgIYqSnUajHm7EzYrJjSugGjgUPWg/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><blockquote><p>异常</p></blockquote><p>CPU处理程序的时候一旦程序不在内存中，会产生缺页异常；当运行除法程序时，当除数为0时，又会产生除0异常。</p><p><strong>异常是由CPU产生的，同时，它会发送给内核，要求内核处理这些异常</strong></p><p>下面这张图显示了异常处理的流程：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpkFYtYurwYD22yibbjd9PW8c5ObaEr28pmMxG9Dq5KAVzlL9ibuWdZGXGh1wFuWsrxdnPk4JWhqS6YA/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><blockquote><p>相同点</p></blockquote><ul><li>最后都是由CPU发送给内核，由内核去处理</li><li>处理程序的流程设计上是相似的</li></ul><blockquote><p>不同点</p></blockquote><ul><li>产生源不相同，异常是由CPU产生的，而中断是由硬件设备产生的</li><li>内核需要根据是异常还是中断调用不同的处理程序</li><li>中断不是时钟同步的，这意味着中断可能随时到来；异常由于是CPU产生的，所以它是时钟同步的</li><li>当处理中断时，处于中断上下文中；处理异常时，处于进程上下文中</li></ul><hr><p>怎么样？够硬核吧？</p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vuex学习</title>
      <link href="/archives/413c71da.html"/>
      <url>/archives/413c71da.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、-Vuex简介"><a href="#一、-Vuex简介" class="headerlink" title="一、 Vuex简介"></a><strong>一、 Vuex简介</strong></h2><h3 id="1-1-官方解释"><a href="#1-1-官方解释" class="headerlink" title="1.1 官方解释"></a>1.1 官方解释</h3><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用 集中式存储管理 应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p><p>Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。</p><hr><h3 id="1-2-状态管理到底是什么？"><a href="#1-2-状态管理到底是什么？" class="headerlink" title="1.2 状态管理到底是什么？"></a>1.2 状态管理到底是什么？</h3><ul><li><p>状态管理模式、集中式存储管理这些名词听起来就非常高大上，让人捉摸不透。</p></li><li><p>其实，你可以简单的将其看成把需要多个组件共享的变量全部存储在一个对象里面。</p></li><li><p>然后，将这个对象放在顶层的Vue实例中，让其他组件可以使用。</p></li><li><p>那么，多个组件是不是就可以共享这个对象中的所有变量属性了呢？</p><span id="more"></span></li></ul><hr><h3 id="1-3-Vuex状态管理图例"><a href="#1-3-Vuex状态管理图例" class="headerlink" title="1.3 Vuex状态管理图例"></a>1.3 Vuex状态管理图例</h3><p><img src="https://reclusew.github.io/2021/09/19/vuex-xiang-jie/1.png" alt="img"></p><hr><hr><h2 id="二、Vuex的基本使用"><a href="#二、Vuex的基本使用" class="headerlink" title="二、Vuex的基本使用"></a><strong>二、Vuex的基本使用</strong></h2><h3 id="2-1-Vuex五个核心概念总概"><a href="#2-1-Vuex五个核心概念总概" class="headerlink" title="2.1 Vuex五个核心概念总概"></a>2.1 Vuex五个核心概念总概</h3><ul><li><strong>state：</strong>Vuex的基本数据，用来存储变量</li><li><strong>getters：</strong>从基本数据(state)派生的数据，相当于state的计算属性</li><li><strong>mutation：</strong>提交更新数据的方法(里面是写方法的)，必须是同步的(如果需要异步使用action)。每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数，提交载荷作为第二个参数。</li><li><strong>actions：</strong>和mutation的功能大致相同，不同之处在于 ==》1. Action 提交的是 mutation，而不是直接变更状态。 2. Action 可以包含任意异步操作。</li><li><strong>modules：</strong>模块化Vuex，可以让每一个模块拥有自己的state、mutation、action、getters,使得结构非常清晰，方便管理。</li></ul><p>注意： 一般在项目的src文件夹中新建store文件夹，Vuex相关代码都写到里面</p><p><strong>案例：</strong></p><p><img src="https://reclusew.github.io/2021/09/19/vuex-xiang-jie/2.png" alt="img"></p><hr><h3 id="2-2-state单一状态树"><a href="#2-2-state单一状态树" class="headerlink" title="2.2 state单一状态树"></a>2.2 state单一状态树</h3><h4 id="2-2-1-单一状态树解释："><a href="#2-2-1-单一状态树解释：" class="headerlink" title="2.2.1 单一状态树解释："></a>2.2.1 单一状态树解释：</h4><ul><li>用一个对象（主干）就包含了全部的（分支）应用层级状态</li><li>每个应用将仅仅包含一个 store 实例对象（主干）</li></ul><p>单一状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。</p><h4 id="2-2-2-如何在-Vue-组件中展示状态呢？"><a href="#2-2-2-如何在-Vue-组件中展示状态呢？" class="headerlink" title="2.2.2 如何在 Vue 组件中展示状态呢？"></a>2.2.2 如何在 Vue 组件中展示状态呢？</h4><p>从store实例中读取状态最简单的方法就是在计算属性中返回某个状态。</p><p>示例：</p><p>例如我们在state中定义一个count属性，给它赋一个值为10，store.js文件内容如下所示：</p><p><img src="https://reclusew.github.io/2021/09/19/vuex-xiang-jie/3.png" alt="img"></p><p>然后创建一个 Counter组件，在组件中返回count，内容如下所示：</p><p><img src="https://reclusew.github.io/2021/09/19/vuex-xiang-jie/4.png" alt="img"></p><p>每当 store.state.count 变化的时候，都会重新求取count属性，并刷新界面。</p><p>这种模式依赖于全局的管理员 store，如果模块多了，那么每个模块或者页面只要用到了这个 state 里面的数据，都得把 store 引入进来，这样的操作确实有点难受。所以出现了下面这种解决办法。</p><p>Vuex 通过store 选项，提供了一种机制将状态从根组件 “注入” 到每一个子组件中：</p><p><img src="https://reclusew.github.io/2021/09/19/vuex-xiang-jie/5.png" alt="img"></p><p>在根实例中注册 store 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过this.$store 访问到，在组件中直接访问:this.$store.state.count</p><h4 id="2-2-3-mapState辅助函数"><a href="#2-2-3-mapState辅助函数" class="headerlink" title="2.2.3 mapState辅助函数"></a>2.2.3 mapState辅助函数</h4><p>当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性，让你少按几次键。</p><p>示例：</p><p>在使用mapState函数之前，需要先引入它：import { mapState } from ‘Vuex’</p><p>引入后才可以开始使用，它两种用法，可以接受一个对象或接受一个数组。</p><p>对象用法如下：</p><p><img src="https://reclusew.github.io/2021/09/19/vuex-xiang-jie/6.png" alt="img"></p><p>数组用法如下所示：</p><p><img src="https://reclusew.github.io/2021/09/19/vuex-xiang-jie/7.png" alt="img"></p><hr><h3 id="2-3-getters"><a href="#2-3-getters" class="headerlink" title="2.3 getters"></a>2.3 getters</h3><h4 id="2-3-1-前言"><a href="#2-3-1-前言" class="headerlink" title="2.3.1 前言"></a>2.3.1 前言</h4><p>Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</p><p>Getter 接受 state 作为其第一个参数：</p><p><img src="https://reclusew.github.io/2021/09/19/vuex-xiang-jie/8.png" alt="img"></p><h4 id="2-3-2-通过属性访问"><a href="#2-3-2-通过属性访问" class="headerlink" title="2.3.2 通过属性访问"></a><strong>2.3.2</strong> 通过属性访问</h4><p>Getter会暴露为 store.getters 对象，你可以以属性的形式访问这些值：</p><p><strong>store.getters.doneTodos // [{ id: 1, text: ‘…’, done: true }]</strong></p><p>Getter 也可以接受其他 getter 作为第二个参数：</p><p><img src="https://reclusew.github.io/2021/09/19/vuex-xiang-jie/9.png" alt="img"></p><p>我们可以很容易地在任何组件中使用它：</p><p><img src="https://reclusew.github.io/2021/09/19/vuex-xiang-jie/10.png" alt="img"></p><p>注意，getter 在通过属性访问时是作为 Vue 的响应式系统的一部分缓存其中的。</p><h4 id="2-3-3-通过方法访问"><a href="#2-3-3-通过方法访问" class="headerlink" title="2.3.3 通过方法访问"></a><strong>2.3.3</strong> 通过方法访问</h4><p>你也可以通过让 getter 返回一个函数，来实现给 getter 传参。在你对 store 里的数组进行查询时非常有用。</p><p><img src="https://reclusew.github.io/2021/09/19/vuex-xiang-jie/11.png" alt="img"></p><p>注意，getter 在通过方法访问时，每次都会去进行调用，而不会缓存结果。</p><h4 id="2-3-4-案例：获取学生年龄大于20的个数"><a href="#2-3-4-案例：获取学生年龄大于20的个数" class="headerlink" title="2.3.4 案例：获取学生年龄大于20的个数"></a>2.3.4 案例：获取学生年龄大于20的个数</h4><p><img src="https://reclusew.github.io/2021/09/19/vuex-xiang-jie/12.png" alt="img"></p><p>注意：getters默认是不能传递参数的, 如果希望传递参数, 那么只能让getters本身返回另一个函数.</p><hr><h3 id="2-4-mutations"><a href="#2-4-mutations" class="headerlink" title="2.4 mutations"></a>2.4 mutations</h3><h4 id="2-4-1-Mutation状态更新"><a href="#2-4-1-Mutation状态更新" class="headerlink" title="2.4.1 Mutation状态更新"></a>2.4.1 Mutation状态更新</h4><p>Vuex的store状态的更新唯一方式：提交Mutation</p><p>Mutation主要包括两部分：</p><ul><li>字符串的事件类型（type）</li><li>一个回调函数（handler）,该回调函数的第一个参数就是state</li></ul><p>mutation的定义方式：</p><p><img src="https://reclusew.github.io/2021/09/19/vuex-xiang-jie/13.png" alt="img"></p><p>通过mutation更新：</p><p><img src="https://reclusew.github.io/2021/09/19/vuex-xiang-jie/14.png" alt="img"></p><h4 id="2-4-2-Mutation传递参数"><a href="#2-4-2-Mutation传递参数" class="headerlink" title="2.4.2 Mutation传递参数"></a>2.4.2 Mutation传递参数</h4><p>在通过mutation更新数据的时候, 有可能我们希望携带一些额外的参数</p><ul><li>参数被称为是mutation的载荷(Payload)</li></ul><p>Mutation中的代码:</p><p><img src="https://reclusew.github.io/2021/09/19/vuex-xiang-jie/15.png" alt="img"></p><p>但是如果参数不是一个呢?</p><ul><li>比如我们有很多参数需要传递.</li><li>这个时候, 我们通常会以对象的形式传递, 也就是payload是一个对象.</li><li>这个时候可以再从对象中取出相关的信息.</li></ul><p><img src="https://reclusew.github.io/2021/09/19/vuex-xiang-jie/16.png" alt="img"></p><p><strong>案例：</strong>使+5按钮和+10按钮起效果，点击添加学生就给stu信息添加到数组中</p><p><img src="https://reclusew.github.io/2021/09/19/vuex-xiang-jie/17.png" alt="img"></p><h4 id="2-4-3-Mutation另一种提交风格"><a href="#2-4-3-Mutation另一种提交风格" class="headerlink" title="2.4.3 Mutation另一种提交风格"></a>2.4.3 Mutation另一种提交风格</h4><p>上面的通过commit进行提交是一种普通的方式,Vue还提供了另外一种风格, 它是一个包含type属性的对象</p><p><img src="https://reclusew.github.io/2021/09/19/vuex-xiang-jie/18.png" alt="img"></p><p>Mutation中的处理方式是将整个commit的对象作为payload使用, 所以代码没有改变, 依然如下:</p><p><img src="https://reclusew.github.io/2021/09/19/vuex-xiang-jie/19.png" alt="img"></p><h4 id="2-4-4-Mutation响应规则"><a href="#2-4-4-Mutation响应规则" class="headerlink" title="2.4.4 Mutation响应规则"></a>2.4.4 Mutation响应规则</h4><p>Vuex的store中的state是响应式的, 当state中的数据发生改变时, Vue组件会自动更新.</p><ul><li>state里面的内容属性都会被添加到响应式系统中，当系统监听到属性发生了变化，就会通知所有界面中用到该属性的地方进行更新，页面就会刷新</li></ul><p>这就要求我们必须遵守一些Vuex对应的规则：</p><ul><li>提前在store中初始化好所需的属性.</li><li>当给state中的对象添加新属性时, 使用下面的方式:</li><li><ul><li>方式一: 使用Vue.set(obj, ‘newProp’, 123)</li><li>方式二: 用新对象给旧对象重新赋值</li></ul></li></ul><p>我们来看一个例子:</p><ul><li>当我们点击更新信息时, 界面并没有发生对应改变.</li></ul><p><img src="https://reclusew.github.io/2021/09/19/vuex-xiang-jie/20.png" alt="img"></p><p>如何才能让它改变呢?</p><ul><li>查看下面代码的方式一和方式二</li><li>都可以让state中的属性是响应式的.</li></ul><p><img src="https://reclusew.github.io/2021/09/19/vuex-xiang-jie/21.png" alt="img"></p><h4 id="2-4-5-使用Mutation常量类型"><a href="#2-4-5-使用Mutation常量类型" class="headerlink" title="2.4.5 使用Mutation常量类型"></a>2.4.5 使用Mutation常量类型</h4><p>我们来考虑下面的问题:</p><ul><li>在mutation中, 我们定义了很多事件类型(也就是其中的方法名称).</li><li>当我们的项目增大时, Vuex管理的状态越来越多, 需要更新状态的情况越来越多, 那么意味着Mutation中的方法越来越多.</li><li>方法过多, 使用者需要花费大量的经历去记住这些方法, 甚至是多个文件间来回切换, 查看方法名称, 甚至如果不是复制的时候, 可能还会出现写错的情况.</li></ul><p>如何避免上述的问题呢?</p><ul><li>在各种Flux实现中, 一种很常见的方案就是使用常量替代Mutation事件的类型.</li><li>我们可以将这些常量放在一个单独的文件中, 方便管理以及让整个app所有的事件类型一目了然.</li></ul><p>具体怎么做呢?</p><ul><li>我们可以创建一个文件: mutation-types.js, 并且在其中定义我们的常量.</li><li>定义常量时, 我们可以使用ES2015中的风格, 使用一个常量来作为函数的名称.</li></ul><p><img src="https://reclusew.github.io/2021/09/19/vuex-xiang-jie/22.png" alt="img"></p><h4 id="2-4-6-Mutation同步函数"><a href="#2-4-6-Mutation同步函数" class="headerlink" title="2.4.6 Mutation同步函数"></a>2.4.6 Mutation同步函数</h4><p>通常情况下, Vuex要求我们<strong>Mutation中的方法必须是同步方法.</strong></p><ul><li>主要的原因是当我们使用devtools时, 可以devtools可以帮助我们捕捉mutation的快照.</li><li>但是如果是异步操作, 那么devtools将不能很好的追踪这个操作什么时候会被完成.</li></ul><p>比如我们之前的代码, 当执行更新时, devtools中会有如下信息: 图1</p><p><img src="https://reclusew.github.io/2021/09/19/vuex-xiang-jie/23.png" alt="img"></p><p>但是, 如果Vuex中的代码, 我们使用了异步函数(定时器): 图2</p><p><img src="https://reclusew.github.io/2021/09/19/vuex-xiang-jie/24.png" alt="img"></p><p>你会发现state中的info数据一直没有被改变, 因为他无法追踪到，所以通常情况下, 不要再mutation中进行异步的操作</p><hr><h3 id="2-5-actions"><a href="#2-5-actions" class="headerlink" title="2.5 actions"></a>2.5 actions</h3><h4 id="2-5-1-Action的基本定义"><a href="#2-5-1-Action的基本定义" class="headerlink" title="2.5.1 Action的基本定义"></a>2.5.1 Action的基本定义</h4><p>我们强调, 不要再Mutation中进行异步操作.</p><ul><li>但是某些情况, 我们确实希望在Vuex中进行一些异步操作, 比如网络请求, 必然是异步的. 这个时候怎么处理呢?</li><li><strong>Action类似于Mutation, 但是是用来代替Mutation进行异步操作的.</strong></li><li>Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用context.commit提交一个 mutation，或者通过context.state和context.getters来获取 state 和 getters。</li></ul><p>让我们来注册一个简单的 action：</p><p><img src="https://reclusew.github.io/2021/09/19/vuex-xiang-jie/25.png" alt="img"></p><p>context是什么?</p><ul><li>context是和store对象具有相同方法和属性的对象.</li><li>也就是说, 我们可以通过context去进行commit相关的操作, 也可以获取context.state等.</li><li>但是注意, 这里它们并不是同一个对象, 为什么呢? 我们后面学习Modules的时候, 再具体说.</li></ul><p>这样的代码是否多此一举呢?</p><ul><li>我们定义了actions, 然后又在actions中去进行commit, 这不是脱裤放屁吗?</li><li>事实上并不是这样, 如果在Vuex中有异步操作, 那么我们就可以在actions中完成了.</li></ul><h4 id="2-5-2-Action的分发"><a href="#2-5-2-Action的分发" class="headerlink" title="2.5.2 Action的分发"></a>2.5.2 Action的分发</h4><ul><li>在Vue组件中, 如果我们调用action中的方法, 那么就需要使用<strong>store.dispatch()</strong> 方法</li><li>同样的, 也是支持传递<strong>payload</strong></li></ul><p><img src="https://reclusew.github.io/2021/09/19/vuex-xiang-jie/26.png" alt="img"></p><h4 id="2-5-3-Action返回的Promise"><a href="#2-5-3-Action返回的Promise" class="headerlink" title="2.5.3 Action返回的Promise"></a>2.5.3 Action返回的Promise</h4><p>前面我们学习ES6语法的时候说过, Promise经常用于异步操作.</p><p>在Action中, 我们可以将异步操作放在一个Promise中, 并且在成功或者失败后, 调用对应的resolve或reject.</p><p><img src="https://reclusew.github.io/2021/09/19/vuex-xiang-jie/27.png" alt="img"></p><hr><h3 id="2-6-modules"><a href="#2-6-modules" class="headerlink" title="2.6 modules"></a>2.6 modules</h3><p>Module是模块的意思, 为什么在Vuex中我们要使用模块呢?</p><ul><li>Vue使用单一状态树,那么也意味着很多状态都会交给Vuex来管理.</li><li>当应用变得非常复杂时,store对象就有可能变得相当臃肿.</li><li>为了解决这个问题, Vuex允许我们将store分割成模块(Module), 而每个模块拥有自己的state、mutation、action、getters等</li></ul><p>上面的代码中, 我们已经有了整体的组织结构, 下面我们来看看具体的局部模块中的代码如何书写？</p><ul><li>我们在moduleA中添加state、mutations、getters</li><li>mutation和getters接收的第一个参数是局部状态对象</li></ul><p><img src="https://reclusew.github.io/2021/09/19/vuex-xiang-jie/28.png" alt="img"></p><p><strong>补充：</strong></p><p>modules里面action的写法: 局部状态通过 context.state 暴露出来，根节点状态则为context.rootState</p><p><img src="https://reclusew.github.io/2021/09/19/vuex-xiang-jie/29.png" alt="img"></p><p>modules里如果getters中也需要使用全局的状态, 可以接受更多的参数:</p><p><img src="https://reclusew.github.io/2021/09/19/vuex-xiang-jie/30.png" alt="img"></p><hr><hr><h2 id="三、结语"><a href="#三、结语" class="headerlink" title="三、结语"></a>三、结语</h2><p>这是本人在学习vuex时的笔记总结，对vuex进行了简单的概述，并附上了对应的案例，有什么问题希望大家指正！</p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客主题重建</title>
      <link href="/archives/31e5dc06.html"/>
      <url>/archives/31e5dc06.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>夜里心血来潮，回忆年前的此时此刻，费力搭建了一个静态博客，荒废实在可惜，加上国内网络审查日益严峻，许多笔记摘录无法上传国内生态，于是晚上肝起来修缮一下博客，用以记录点滴生活并摘录学习</p><span id="more"></span><h1 id="博客搭建过程（采用hexo框架-部署到github）"><a href="#博客搭建过程（采用hexo框架-部署到github）" class="headerlink" title="博客搭建过程（采用hexo框架+部署到github）"></a><strong>博客搭建过程（采用hexo框架+部署到github）</strong></h1><h2 id="1-前期准备"><a href="#1-前期准备" class="headerlink" title="1.前期准备"></a><strong>1.前期准备</strong></h2><h3 id="1-1-注意事项"><a href="#1-1-注意事项" class="headerlink" title="1.1 注意事项"></a><strong>1.1 注意事项</strong></h3><ul><li>很多命令既可以用Windows的cmd来完成，也可以使用git bash来完成，但是部分命令会有一些问题，为避免不必要的问题，建议全部使用git bash来执行</li><li>hexo不同版本差别比较大，网上很多文章的配置信息都是基于2.x的，所以注意不要被误导</li><li>hexo有2种_config.yml文件，一个是根目录下的全局的_config.yml，一个是各个theme下的</li></ul><h3 id="1-2-下载并安装node-js"><a href="#1-2-下载并安装node-js" class="headerlink" title="1.2 下载并安装node.js"></a><strong>1.2 下载并安装node.js</strong></h3><ul><li>官网下载：<a href="https://nodejs.org/en/">https://nodejs.org/en/</a></li><li>安装后验证：<strong>node -v</strong></li></ul><h3 id="1-3-下载并安装git"><a href="#1-3-下载并安装git" class="headerlink" title="1.3 下载并安装git"></a><strong>1.3 下载并安装git</strong></h3><ul><li>官网下载: <a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a></li><li>安装后验证：<strong>git -v</strong></li></ul><h3 id="1-4-命令行安装cnpm"><a href="#1-4-命令行安装cnpm" class="headerlink" title="1.4 命令行安装cnpm"></a><strong>1.4 命令行安装cnpm</strong></h3><ul><li>命令：<strong>npm install -g cnpm –registry==<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a></strong></li><li>安装后验证：<strong>cnpm -v</strong></li></ul><h3 id="1-5-命令行安装hexo"><a href="#1-5-命令行安装hexo" class="headerlink" title="1.5 命令行安装hexo"></a><strong>1.5 命令行安装hexo</strong></h3><ul><li>命令：<strong>cnpm install -g hexo-cli</strong></li><li>安装后验证：<strong>hexo -v</strong></li></ul><hr><h2 id="2-配置github"><a href="#2-配置github" class="headerlink" title="2.配置github"></a><strong>2.配置github</strong></h2><h3 id="2-1-在github上创建仓库"><a href="#2-1-在github上创建仓库" class="headerlink" title="2.1 在github上创建仓库"></a><strong>2.1 在github上创建仓库</strong></h3><p><strong>创建：</strong></p><ul><li>新建一个名为你的用户名.github.io的仓库</li><li>比如说，如果你的github用户名是test，那么你就新建test.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 <a href="http://test.github.io/">http://test.github.io</a> 了，是不是很方便？由此可见，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。</li></ul><p><strong>注意：</strong></p><ol><li>注册的邮箱一定要验证，否则不会成功；</li><li>仓库名字必须是：username.github.io，其中username是你的用户名；</li><li>仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟，或者更久；</li><li>创建页面如下：</li></ol><p><img src="https://reclusew.github.io/2021/08/12/blog-setup/1.png" alt="img"></p><p>创建成功后，默认会在你这个仓库里生成一些示例页面，以后你的网站所有代码都是放在这个仓库里啦。</p><h3 id="2-2-绑定域名（这步可省略）"><a href="#2-2-绑定域名（这步可省略）" class="headerlink" title="2.2 绑定域名（这步可省略）"></a><strong>2.2 绑定域名（这步可省略）</strong></h3><p>当然，你不绑定域名肯定也是可以的，就用默认的 xxx.github.io 来访问，如果你想更个性一点，想拥有一个属于自己的域名，那也是OK的。</p><p>首先你要注册一个域名，域名注册以前总是推荐去godaddy，现在觉得其实国内的阿里云也挺不错的，价格也不贵，毕竟是大公司，放心！</p><p>绑定域名分2种情况：带www和不带www的。</p><p>域名配置最常见有2种方式，CNAME和A记录，CNAME填写域名，A记录填写IP，由于不带www方式只能采用A记录，所以必须先ping一下你的用户名.github.io的IP，然后到你的域名DNS设置页，将A记录指向你ping出来的IP，将CNAME指向你的用户名.github.io，这样可以保证无论是否添加www都可以访问，如下：</p><p><img src="https://reclusew.github.io/2021/08/12/blog-setup/2.png" alt="img"></p><p>然后到你的github项目根目录新建一个名为CNAME的文件（无后缀），里面填写你的域名，加不加www看你自己喜好，因为经测试：</p><ul><li>如果你填写的是没有www的，比如 mygit.me，那么无论是访问 <a href="http://www.mygit.me/">http://www.mygit.me</a> 还是 <a href="http://mygit.me/">http://mygit.me</a> ，都会自动跳转到 <a href="http://mygit.me/">http://mygit.me</a></li><li>如果你填写的是带www的，比如 <a href="http://www.mygit.me/">www.mygit.me</a> ，那么无论是访问 <a href="http://www.mygit.me/">http://www.mygit.me</a> 还是 <a href="http://mygit.me/">http://mygit.me</a> ，都会自动跳转到 <a href="http://www.mygit.me/">http://www.mygit.me</a></li><li>如果你填写的是其它子域名，比如 abc.mygit.me，那么访问 <a href="http://abc.mygit.me/">http://abc.mygit.me</a> 没问题，但是访问 <a href="http://mygit.me/">http://mygit.me</a> ，不会自动跳转到 <a href="http://abc.mygit.me/">http://abc.mygit.me</a></li></ul><p>另外说一句，在你绑定了新域名之后，原来的你的用户名.github.io并没有失效，而是会自动跳转到你的新域名。</p><hr><h2 id="3-配置SSH免密登录"><a href="#3-配置SSH免密登录" class="headerlink" title="3. 配置SSH免密登录"></a><strong>3. 配置SSH免密登录</strong></h2><p>为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。</p><p><strong>操作步骤：</strong></p><p><strong>第一步：</strong>首先打开电脑文件夹，找到C:\Users\你的用户名.ssh文件夹并删除</p><p><strong>第二步：</strong>在C:\Users\你的用户名 文件夹下右键打开Git Bash Here<strong>输入命令：</strong>ssh-keygen -t rsa -C github邮件地址 生成.ssh秘钥，输入后连敲三次回车，出现下图情况代表成功</p><p><img src="https://reclusew.github.io/2021/08/12/blog-setup/3.png" alt="img"></p><p><strong>第三步：</strong>最终生成了一个新的 C:\Users\你的用户名.ssh文件夹，打开这个文件夹，找到.ssh\id_rsa.pub文件，记事本打开并复制里面的内容</p><p><strong>第四步：</strong>打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key，把复制的内容粘贴进去，title随便填，保存即可，我们的公钥就添加成功了，设置好如下图。</p><p><img src="https://reclusew.github.io/2021/08/12/blog-setup/4.png" alt="img"></p><p><strong>第五步：检测是否设置成功：</strong></p><p>输入命令： $ ssh -T <a href="mailto:git@github.com">git@github.com</a> # 注意邮箱地址不用改</p><p>如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到：</p><p>Hi liuxianan! You’ve successfully authenticated, but GitHub does not provide shell access.</p><p>看到这个信息说明SSH已配置成功！</p><p><strong>第六步：此时你还需要配置：</strong></p><p>$ git config –global user.name “liuxianan”// 你的github用户名，非昵称 $ git config –global user.email “<a href="mailto:xxx@qq.com">xxx@qq.com</a>“// 填写你的github注册邮箱</p><p>具体这个配置是干嘛的我没仔细深究。</p><hr><h2 id="4-使用-hexo-搭建博客"><a href="#4-使用-hexo-搭建博客" class="headerlink" title="4.使用 hexo 搭建博客"></a><strong>4.使用 hexo 搭建博客</strong></h2><h3 id="4-1-初始化"><a href="#4-1-初始化" class="headerlink" title="4.1 初始化"></a><strong>4.1 初始化</strong></h3><p><strong>第一步：</strong>在电脑的某个地方新建一个名为hexo的文件夹（名字可以随便取），比如我的是E:\xpzsData\hexocode，由于这个文件夹将来就作为你存放代码的地方，所以最好不要随便放</p><p><strong>第二步：</strong>在E:\xpzsData\hexocode文件夹下右键打开 Git Bash Here，输入hexo init 初始化</p><ul><li>hexo会自动下载一些文件到这个目录，包括node_modules，目录结构如下图：</li></ul><p><img src="https://reclusew.github.io/2021/08/12/blog-setup/5.png" alt="img"></p><p><strong>第三步：</strong>执行以下命令之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github去的：</p><p><img src="https://reclusew.github.io/2021/08/12/blog-setup/6.png" alt="img"></p><p><strong>第四步：</strong>hexo s 是开启本地预览服务，打开浏览器访问 <a href="http://localhost:4000/">http://localhost:4000</a> 即可看到内容，很多人会碰到浏览器一直在转圈但是就是加载不出来的问题，一般情况下是因为端口占用的缘故，因为4000这个端口太常见了，解决端口冲突问题请参考这篇文章<a href="https://www.runoob.com/w3cnote/windows-finds-port-usage.html">https://www.runoob.com/w3cnote/windows-finds-port-usage.html</a></p><ul><li>到这里初始化就完成了</li></ul><h3 id="4-2-将博客部署到-github-个人主页上"><a href="#4-2-将博客部署到-github-个人主页上" class="headerlink" title="4.2 将博客部署到 github 个人主页上"></a><strong>4.2 将博客部署到 github 个人主页上</strong></h3><p><strong>第一步：</strong>在E:\xpzsData\hexocode目录下安装 hexo-deployer-git 插件</p><ul><li><strong>安装命令：</strong> npm install hexo-deployer-git –save</li><li>必须安装，否则执行hexo d 的话会报如下错误：</li></ul><p><img src="https://reclusew.github.io/2021/08/12/blog-setup/7.png" alt="img"></p><p><strong>第二步：</strong>编辑E:\xpzsData\hexocode目录下的 _config.yml 文件, 在文件末尾添加如下内容：</p><p><img src="https://reclusew.github.io/2021/08/12/blog-setup/8.png" alt="img"></p><ul><li>注意：其中 repo 中的内容即为 github 个人主页链接地址，具体看下图：</li></ul><p><img src="https://reclusew.github.io/2021/08/12/blog-setup/9.png" alt="img"></p><p><strong>第三步：</strong>在E:\xpzsData\hexocode目录下, <strong>输入命令：hexo d</strong> 将本地 blog 推送到 github仓库, 也可能需要输入 username &amp; pwd。</p><ul><li>推送成功后, 在浏览器中输入对应域名, 即可访问 <a href="https://reclusew.github.io/">https://reclusew.github.io/</a></li></ul><hr><h2 id="5-更换主题"><a href="#5-更换主题" class="headerlink" title="5. 更换主题"></a><strong>5. 更换主题</strong></h2><h3 id="5-1-寻找主题"><a href="#5-1-寻找主题" class="headerlink" title="5.1 寻找主题"></a><strong>5.1 寻找主题</strong></h3><ul><li>既然默认主题很丑，那我们别的不做，首先来替换一个好看点的主题。</li><li>这是hexo官网：<a href="https://hexo.io/themes/%EF%BC%8C%E5%8F%AF%E5%9C%A8%E9%87%8C%E9%9D%A2%E4%B8%8B%E8%BD%BD%E4%B8%BB%E9%A2%98%EF%BC%8C%E7%82%B9%E5%87%BB%E4%B8%BB%E9%A2%98%E5%90%8D%E5%8D%B3%E5%8F%AF%E8%B7%B3%E8%BD%AC%E5%88%B0github%E4%B8%8A%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E5%9C%A8github%E4%B8%8A%E6%90%9C%E7%B4%A2%E4%B8%BB%E9%A2%98">https://hexo.io/themes/，可在里面下载主题，点击主题名即可跳转到github上，也可以直接在github上搜索主题</a></li><li>在这里我使用github上一个大佬的主题blinkfox/hexo-theme-matery</li></ul><p> 链接：<a href="https://github.com/blinkfox/hexo-theme-matery">https://github.com/blinkfox/hexo-theme-matery</a></p><h3 id="5-2-下载主题"><a href="#5-2-下载主题" class="headerlink" title="5.2 下载主题"></a><strong>5.2 下载主题</strong></h3><p><strong>第一步：</strong>Git Bash Here中先cd到E:\xpzsData\hexocode目录</p><p><strong>第二步：</strong>再输入命令 $ git clone 主题http链接 themes/主题名称</p><p><img src="https://reclusew.github.io/2021/08/12/blog-setup/10.png" alt="img"></p><p><strong>注意：</strong></p><ul><li>E:\xpzsData\hexocode目录下的 theme 文件夹下存放的就是博客的主题，主题是否下载成功可到该目录下查看：</li></ul><p><img src="https://reclusew.github.io/2021/08/12/blog-setup/11.png" alt="img"></p><h3 id="5-3-使用主题"><a href="#5-3-使用主题" class="headerlink" title="5.3 使用主题"></a><strong>5.3 使用主题</strong></h3><ul><li>打开E:\xpzsData\hexocode目录下的_config.yml文件，在里面找到theme: landscape改为theme: blinkfox （blinkfox为我们要使用的主题名）,然后重新执行hexo g来重新生成。</li><li>如果出现一些莫名其妙的问题，可以先执行hexo clean来清理一下public的内容，然后再执行hexo g 和 hexo s 重新生成和发布。</li><li>再次在浏览器中输入对应域名, 即可发现主题已更换</li></ul><p><img src="https://reclusew.github.io/2021/08/12/blog-setup/12.png" alt="img"></p><h3 id="5-4-修改主题内容"><a href="#5-4-修改主题内容" class="headerlink" title="5.4 修改主题内容"></a><strong>5.4 修改主题内容</strong></h3><p>在这里我使用的是blinkfox主题，后期相关修改参考这个主题文档</p><p><strong>文档链接：</strong><a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md">https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md</a></p><ul><li>注意：一些非md文件可以把他们放到source文件夹下，这里的所有文件都会原样复制（除了md文件）到public目录的</li><li>大致在下图的文件夹里面修改文件，记得修改后的文件需要关闭后，再在hexocode根目录右键打开Git Bash Here，输入两个命令：hexo g 重新生成，hexo s 开启本地预览服务,等修改的符合要求了，再输入 hexo d 推送到github仓库即可</li><li>这样就可以输入网址查看更改后的内容了</li></ul><p><img src="https://reclusew.github.io/2021/08/12/blog-setup/13.png" alt="img"></p><p><strong>文档上没有提及的修改：</strong></p><ul><li>返回按钮样式修改：在主题下面的 blinkfox\layout_partial 文件夹中的 back-top.esj 文件中修改</li></ul><p><strong>特别注意：</strong></p><ul><li><strong>修改生成的默认页面信息，要到主题下面的_config.yml文件里面去改，而不是根目录下的_config.yml文件</strong></li></ul><p><img src="https://reclusew.github.io/2021/08/12/blog-setup/14.png" alt="img"></p><ul><li><strong>要把根目录下的_config.yml文件中的这些信息替换成自己的和设置中文</strong></li></ul><p><img src="https://reclusew.github.io/2021/08/12/blog-setup/15.png" alt="img"></p><h3 id="5-5-blinkfox主题的相关配置问题"><a href="#5-5-blinkfox主题的相关配置问题" class="headerlink" title="5.5 blinkfox主题的相关配置问题"></a><strong>5.5 blinkfox主题的相关配置问题</strong></h3><p><strong>配置音乐播放器：</strong>使用网易云音乐id不行，这里用的是QQ音乐</p><p><strong>配置留言功能（利用Valine）：</strong></p><ul><li>我们的评论系统其实是放在Leancloud上的，因此首先需要去注册一个账号</li><li>注册完以后需要创建一个应用，名字可以随便起，然后 进入应用-&gt;设置-&gt;应用key，获取你的appid 和 appkey，复制到主题下面的 _config.yml 文件里面搜索 valine，填入appid 和 appkey</li><li>最后！记得在Leancloud -&gt; 设置 -&gt; 安全中心 -&gt; Web 安全域名 把你的域名加进去就可以了</li><li>主题页面显示的内容在主题下面的 layout 文件夹中的 contact.ejs 文件里面更改</li></ul><hr><h2 id="6-利用Typora软件来写博客"><a href="#6-利用Typora软件来写博客" class="headerlink" title="6.利用Typora软件来写博客"></a><strong>6.利用Typora软件来写博客</strong></h2><h3 id="6-1-Typora介绍"><a href="#6-1-Typora介绍" class="headerlink" title="6.1 Typora介绍"></a><strong>6.1 Typora介绍</strong></h3><ul><li>Typora–一款简单高效的Markdown编辑器，保存后直接为md格式，Markdown中点击导入就可以。</li><li>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式，其目标是实现易读易写，说人话就是删减版的HTML语言</li><li>Markdown教程：<a href="https://www.runoob.com/markdown/md-tutorial.html">https://www.runoob.com/markdown/md-tutorial.html</a></li></ul><h3 id="6-2-安装Typora"><a href="#6-2-安装Typora" class="headerlink" title="6.2 安装Typora"></a><strong>6.2 安装Typora</strong></h3><p><strong>官网：</strong><a href="https://www.typora.io/#windows">https://www.typora.io/#windows</a></p><h3 id="6-3-写博客的步骤"><a href="#6-3-写博客的步骤" class="headerlink" title="6.3 写博客的步骤"></a><strong>6.3 写博客的步骤</strong></h3><p><strong>第一步：创建.md文件</strong></p><ul><li><strong>方法1：</strong>定位到我们的hexo根目录，Git Bash Here 中执行命令： hexo new ‘my-first-blog’ hexo会帮我们在E:\xpzsData\hexocode\source_posts 下生成相关.md文件，用这个命令的好处是帮我们自动生成了时间，方法1默认生成如下内容：</li></ul><p><img src="https://reclusew.github.io/2021/08/12/blog-setup/16.png" alt="img"></p><h3 id="文章-Front-matter-介绍"><a href="#文章-Front-matter-介绍" class="headerlink" title="文章 Front-matter 介绍"></a>文章 Front-matter 介绍</h3><h4 id="Front-matter-选项详解"><a href="#Front-matter-选项详解" class="headerlink" title="Front-matter 选项详解"></a>Front-matter 选项详解</h4><p><code>Front-matter</code> 选项中的所有内容均为<strong>非必填</strong>的。但我仍然建议至少填写 <code>title</code> 和 <code>date</code> 的值。</p><table><thead><tr><th>配置选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td><code>Markdown</code> 的文件标题</td><td>文章标题，强烈建议填写此选项</td></tr><tr><td>date</td><td>文件创建时的日期时间</td><td>发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td>author</td><td>根 <code>_config.yml</code> 中的 <code>author</code></td><td>文章作者</td></tr><tr><td>img</td><td><code>featureImages</code> 中的某个值</td><td>文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <code>http://xxx.com/xxx.jpg</code></td></tr><tr><td>top</td><td><code>true</code></td><td>推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td></tr><tr><td>hide</td><td><code>false</code></td><td>隐藏文章，如果<code>hide</code>值为<code>true</code>，则文章不会在首页显示</td></tr><tr><td>cover</td><td><code>false</code></td><td><code>v1.0.2</code>版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td>coverImg</td><td>无</td><td><code>v1.0.2</code>版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td>password</td><td>无</td><td>文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td>toc</td><td><code>true</code></td><td>是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td></tr><tr><td>mathjax</td><td><code>false</code></td><td>是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td></tr><tr><td>summary</td><td>无</td><td>文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td>categories</td><td>无</td><td>文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td>tags</td><td>无</td><td>文章标签，一篇文章可以多个标签</td></tr><tr><td>keywords</td><td>文章标题</td><td>文章关键字，SEO 时需要</td></tr><tr><td>reprintPolicy</td><td>cc_by</td><td>文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个</td></tr></tbody></table><blockquote><p><strong>注意</strong>:</p><ol><li>如果 <code>img</code> 属性不填写的话，文章特色图会根据文章标题的 <code>hashcode</code> 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章的特色图<strong>各有特色</strong>。</li><li><code>date</code> 的值尽量保证每篇文章是唯一的，因为本主题中 <code>Gitalk</code> 和 <code>Gitment</code> 识别 <code>id</code> 是通过 <code>date</code> 的值来作为唯一标识的。</li><li>如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 <code>_config.yml</code> 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：<a href="http://tool.oschina.net/encrypt?type=2">开源中国在线工具</a>、<a href="http://encode.chahuo.com/">chahuo</a>、<a href="http://tool.chinaz.com/tools/hash.aspx">站长工具</a>。</li><li>您可以在文章md文件的 front-matter 中指定 reprintPolicy 来给单个文章配置转载规则</li></ol></blockquote><p>以下为文章的 <code>Front-matter</code> 示例。</p><h3 id="最简示例"><a href="#最简示例" class="headerlink" title="最简示例"></a>最简示例</h3><pre class="line-numbers language-none"><code class="language-none">---title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="最全示例"><a href="#最全示例" class="headerlink" title="最全示例"></a>最全示例</h3><pre class="line-numbers language-none"><code class="language-none">---title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00author: 赵奇img: /source/images/xxx.jpgtop: truehide: falsecover: truecoverImg: /images/1.jpgpassword: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92toc: falsemathjax: falsesummary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要categories: Markdowntags:  - Typora  - Markdown---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>方法2：</strong>当然你也可以直接自己打开E:\xpzsData\hexocode\source_posts 目录新建.md文件</li></ul><p><strong>第二步：编写并保存</strong></p><p>我们只需要用typora打开这个文件就可以开始写博客了，写完后Ctrl+S 保存关闭即可</p><p><strong>第三步：</strong>清理然后再生成一下，生成后推送到远程仓库即可，hexo根目录下右键Git Bash Here 中依次输入如下命令：</p><ol><li>hexo clean</li><li>hexo g</li><li>hexo d</li></ol><p><strong>补充：</strong>hexo new page ‘postName’命令和hexo new ‘postName’的区别？</p><ul><li>hexo new page ‘My-second-blog’最终部署时生成：hexo\public\my-second-blog\index.html，但是它不会作为文章出现在博文目录。</li></ul><h3 id="6-4-Typora快捷键"><a href="#6-4-Typora快捷键" class="headerlink" title="6.4 Typora快捷键"></a><strong>6.4 Typora快捷键</strong></h3><p>Typora中只要记住一些基本的快捷键就可以了，所有功能软件里面都有对应按钮，这点不用慌。</p><p><strong>快捷键文章：</strong><a href="https://blog.csdn.net/weixin_39533052/article/details/111115263">https://blog.csdn.net/weixin_39533052/article/details/111115263</a></p><h3 id="6-5-注意：所使用的主题的文章-Front-matter-语法"><a href="#6-5-注意：所使用的主题的文章-Front-matter-语法" class="headerlink" title="6.5 注意：所使用的主题的文章 Front-matter 语法"></a><strong>6.5 注意：所使用的主题的文章 Front-matter 语法</strong></h3><p>依据使用的不同主题，一些文章功能所使用的语法可能不一样，例如写博客时给文章添加标签的语法等等，这些都要看所使用的主题的文档，例如我们这里使用的是 <strong>blinkfox</strong> 主题，打开主题文档，往下翻找到<strong>”</strong> <strong>文章 Front-matter 介绍 “</strong>即可。</p><p><strong>blinkfox主题文档：</strong><a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md#%E6%96%87%E7%AB%A0-front-matter-%E4%BB%8B%E7%BB%8D">https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md#%E6%96%87%E7%AB%A0-front-matter-%E4%BB%8B%E7%BB%8D</a></p><p><img src="https://reclusew.github.io/2021/08/12/blog-setup/17.png" alt="img"></p><p><strong>示例：</strong></p><p><img src="https://reclusew.github.io/2021/08/12/blog-setup/18.png" alt="img"></p><h3 id="6-6-YAML语法（了解）"><a href="#6-6-YAML语法（了解）" class="headerlink" title="6.6 YAML语法（了解）"></a><strong>6.6 YAML语法（了解）</strong></h3><p>像在typora中添加tags时，可以直接用数组的写法，也可以使用YAML语法，如下：</p><p><img src="https://reclusew.github.io/2021/08/12/blog-setup/19.png" alt="img"></p><p><strong>YAML教程链接：</strong><a href="https://www.runoob.com/w3cnote/yaml-intro.html">https://www.runoob.com/w3cnote/yaml-intro.html</a></p><hr><h2 id="7-如何向hexo博客中插入图片"><a href="#7-如何向hexo博客中插入图片" class="headerlink" title="7.如何向hexo博客中插入图片"></a><strong>7.如何向hexo博客中插入图片</strong></h2><h3 id="7-1-使用相对路径的方式"><a href="#7-1-使用相对路径的方式" class="headerlink" title="7.1 使用相对路径的方式"></a><strong>7.1 使用相对路径的方式</strong></h3><p>众所周知，在md文件中插入图片的语法为!/。</p><p>其中<strong>方括号</strong>是图片描述，<strong>圆括号</strong>是图片路径。</p><p>一般来说有三种图片路径，分别是<strong>相对路径，绝对路径和网络路径</strong>。</p><p>所谓的网络路径就是直接引用网上的图片，直接复制图片地址，放在圆括号中就完事了。</p><p>这种方式十分的方便，但是也存在一定的问题：</p><ul><li>图片失效导致无法加载；</li><li>打开网页后要再请求加载图片；</li><li>原网站限制，如微信公众号的图片会变得不可见等。</li></ul><p>这种方式算是有利有弊。</p><p>绝对路径是图片在计算机中的绝对位置，相对路径是相对于当前文件的路径。</p><p>由于我们的博客是要部署在网站上，部署后会生成新的文件目录，所以我们选择使用相对路径的方式。</p><p>在hexo中使用<strong>文章资源文件夹</strong>需要在config.yaml文件中更改一下配置：</p><p>post_asset_folder: true</p><p>当该配置被应用后，使用hexo new命令创建新文章时，会生成相同名字的文件夹，也就是文章资源文件夹。</p><p><img src="https://reclusew.github.io/2021/08/12/blog-setup/replenish1.jpg" alt="img"></p><p>虽然可以正常引用图片了，但是这种引用图片的方式只有一句话能形容，wtf。</p><h3 id="7-2-hexo-renderer-marked插件的安装与配置"><a href="#7-2-hexo-renderer-marked插件的安装与配置" class="headerlink" title="7.2 hexo-renderer-marked插件的安装与配置"></a><strong>7.2 hexo-renderer-marked插件的安装与配置</strong></h3><p>插件<a href="https://github.com/hexojs/hexo-renderer-marked">hexo-renderer-marked</a>解决了这个问题</p><p><strong>安装：</strong> npm install hexo-renderer-marked –save ，之后在config.yaml中更改配置如下：</p><p><img src="https://reclusew.github.io/2021/08/12/blog-setup/20.png" alt="img"></p><p>之后就可以愉快的插入图片了</p><h3 id="7-3-hexo-renderer-marked插件与Typora的完美结合"><a href="#7-3-hexo-renderer-marked插件与Typora的完美结合" class="headerlink" title="7.3 hexo-renderer-marked插件与Typora的完美结合"></a><strong>7.3 hexo-renderer-marked插件与Typora的完美结合</strong></h3><p>如果图片数量众多的话，一张一张的放很影响效率。但是不用怕，我们有很方便的解决方法。</p><p><strong>Typora</strong>是我非常喜欢的Markdown文本编辑器，在之前的文章中也介绍过一点。</p><p>Typora对于插入图片的支持做得非常好，在文件-&gt;偏好设置或者直接&lt;C-,&gt;进入设置。</p><p><img src="https://reclusew.github.io/2021/08/12/blog-setup/21.png" alt="img"></p><p><strong>复制网络路径的图片：</strong></p><p>使用该配置后，可以直接复制网页中的图片地址，粘贴到Typora中后，会直接复制该图片到文章资源文件夹，同时自动更改路径。</p><p>如复制网络路径的图片https://…../image.jpg粘贴到Typora中叫文章名的文章后，图片会自动变为(文章名/image.jpg)。</p><p>但我们知道部署后，文件路径是不同的，所以当我们插入完所有的图片后，我们还需要删除每个图片路径中的文件名/。不慌，也很简单。</p><p>在Typora编辑器中，使用快捷键，将所有的文章名/替换为空即可删除。</p><p><img src="https://reclusew.github.io/2021/08/12/blog-setup/22.png" alt="img"></p><p>然后再将博客上传，图片就会随着文章一起打包。在网页中就可以看到正常显示的图片，大功告成</p><hr><h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8.总结"></a>8.总结</h2><p>这是本人熬夜搭建博客过程中遇到的一些问题和解决办法，按照我这个步骤基本就能搭建起来一个不错的博客了，文章里面省略了博客的SEO优化，比如让百度和谷歌搜索引擎收录我们的博客网站，这点大家可以去网上搜索，教程很多的，有什么问题欢迎在下方留言！</p><p>参考文献：</p><p>1：<a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md">https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md</a></p><p>2：<a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html">https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html</a></p><p>3：<a href="https://www.jianshu.com/p/f72aaad7b852">https://www.jianshu.com/p/f72aaad7b852</a></p>]]></content>
      
      
      <categories>
          
          <category> 经验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>切格瓦拉和自由精神</title>
      <link href="/archives/8a55ec57.html"/>
      <url>/archives/8a55ec57.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="✪-切·格瓦拉与自由精神"><a href="#✪-切·格瓦拉与自由精神" class="headerlink" title="✪ 切·格瓦拉与自由精神"></a>✪ 切·格瓦拉与自由精神</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在中国提到切格瓦拉，相信很少有人了解过，特别是像我这个年纪的一批人。在这个繁杂的年代，太多人像我一样都在毫无目的的向外驰骋，浮躁的内心却总不能平息，偶尔于电视媒体上匆匆的一瞥，似与他相识，而又擦肩而过。</p><p>但在几十年前，当中国正处于风起云涌的年代，在拉丁美洲那块遥远的土地上也有一群青年才俊者正在开始书写一段传奇 ，历史的年轮轰轰流转，留给世人只有无尽的唏嘘与寂寞，人们容易遗忘的是一种精神，而不是物质与空虚。</p><p>仅以此文献给切格瓦拉，献给还在为自由奋斗的人！</p><span id="more"></span><h2 id="切·格瓦拉"><a href="#切·格瓦拉" class="headerlink" title="切·格瓦拉"></a>切·格瓦拉</h2><blockquote><p>切·格瓦拉（西班牙语：Che Guevara，1928年6月14日－1967年10月9日），昵称切（El Che或Che），本名埃内斯托·格瓦拉（Ernesto Guevara），出生于阿根廷。他是古巴革命的核心人物之一，社会主义古巴、古巴革命武装力量和古巴共产党的主要缔造者及领导人，著名的国际马克思主义革命家、军事理论家、政治家、医生、作家、游击队领导人。古巴革命胜利后，他被授予古巴公民身份，担任古巴政府高级领导人，后辞去职务，离开古巴到刚果（金）、玻利维亚进行反对帝国主义的游击战争。他离开古巴的原因有不同的解释，主流看法称他是自愿离开古巴继续革命，也有资料显示他是被迫离开，因为卡斯特罗与切·格瓦拉在对中苏交恶的看法上存在分歧。自切·格瓦拉死后，他的肖像已成为反主流文化的普遍象征、全球流行文化的标志，同时他本人也成为了国际共产主义运动中的英雄和世界左翼运动的象征。</p></blockquote><p><a href="https://cdn.chegva.com/ueditor/php/upload/image/20181014/1539456229500188.jpg"><img src="https://cdn.chegva.com/ueditor/php/upload/image/20181014/1539456229500188.jpg" alt="✪ 切·格瓦拉与自由精神"></a></p><h2 id="了解他（一个悲伤浪漫的征人）"><a href="#了解他（一个悲伤浪漫的征人）" class="headerlink" title="了解他（一个悲伤浪漫的征人）"></a>了解他（一个悲伤浪漫的征人）</h2><blockquote><p> <a href="https://zh.wikipedia.org/wiki/%E5%88%87%C2%B7%E6%A0%BC%E7%93%A6%E6%8B%89">切·格瓦拉-维基百科</a></p><p>《切·格瓦拉传上下部》百度网盘高清分享：【<a href="http://pan.baidu.com/s/1pLPASJp">下载链接</a>】</p><p>《切·格瓦拉画传》 山东画报出版社 　【<a href="http://item.jd.com/10033133.html">购买地址</a>】</p></blockquote><p><a href="https://cdn.chegva.com/ueditor/php/upload/image/20181014/1539456259398970.jpg"><img src="https://cdn.chegva.com/ueditor/php/upload/image/20181014/1539456259398970.jpg" alt="✪ 切·格瓦拉与自由精神"></a></p><h2 id="●切·格瓦拉年谱●"><a href="#●切·格瓦拉年谱●" class="headerlink" title="●切·格瓦拉年谱●"></a>●切·格瓦拉年谱●</h2><ul><li>诞生阿根廷</li></ul><pre class="line-numbers language-none"><code class="language-none">１９２８年６月１４日生于阿根廷罗萨里奥市。父亲为马黛茶种植园主。 １９３０年５月，首次发哮喘病。 １９３６年西班牙内战爆发。由于舅舅科尔多瓦·伊图布鲁是《评论》日报的战地记者，埃内斯托·格瓦拉由此首次接触政治。 １９４５年进入布宜诺斯艾利斯国立大学医学系学习，并结识蒂塔·因方特。１９５１年１２月２９日，与阿尔贝托·格拉纳多共骑一辆摩托车漫游拉丁美洲，先后到达智利、玻利维亚和秘鲁，后来又乘木筏到达哥伦比亚，后又到委内瑞拉。 １９５２年８月３１日，结束漫游返回布宜诺斯艾利斯并参加大学期末考试。 １９５３年６月１２日，大学毕业并获医生证书。７月１２日，乘火车抵达玻利维亚。１２月２０日，途经哥斯达黎加抵达危地马拉，停留９个月，结识了秘鲁女青年伊尔达·卡代亚。后经她介绍认识了古巴"７月２６日运动"流亡人员尼科 ·洛佩斯，该人给他起了个外号叫"切"。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>相遇墨西哥</li></ul><pre class="line-numbers language-none"><code class="language-none">１９５４年在美国雇佣军推翻哈科沃·阿本斯政府之后，离开危地马拉赴墨西哥。 １９５５年７月，在墨西哥结识菲德尔·卡斯特罗，并决定参加卡斯特罗的起义军远征古巴。８月１８日，与伊尔达·卡代亚结婚。 １９５６年２月１５日，女儿小伊尔达出生。４月，与古巴人一起在墨西哥 参加军事训练。６月２４日，与卡斯特罗及其他古巴流亡者们一起，被墨西哥当局关进米格尔·苏尔兹监狱。７月３１日，与卡斯特罗等古巴流亡者一起出狱并继续参加军训。１１月２５日，作为８２名起义者中的一员，乘"格拉玛"号游艇从墨西哥出发前往古巴。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>激情澎湃的古巴</li></ul><pre class="line-numbers language-none"><code class="language-none">１９５７年１月１７日，率起义军攻占拉普拉达。５月２８日，攻占乌维罗。 ７月２１日，晋升为少校并任起义军第四纵队司令。８月３０日，攻占埃尔翁布里托。１１月，创办《古巴自由报》。 １９５８年１２月，与战友阿莱达·玛尔奇相识。１２月３１日，率部队攻占圣克拉腊。 １９５９年１月４日，率部队进入首都哈瓦那。１月２１日，伊尔达·卡代亚偕女儿小伊尔达抵达哈瓦那，两人决定离婚。２月７日，获得古巴国籍。３月， 参加《土地改革法》的起草工作。６月２日，与阿莱达·玛尔奇结婚。１０月８日，任全国土地改革委员会工业司司长。１１月２６日，任国家银行行长。 １９６０年４月，《论游击战》一书出版。８月８日，出席首届拉丁美洲青年代表大会。 １９６１年１月３日，美国宣布与古巴断绝外交关系。２月２３日，任工业部部长。４月１７日，美国雇佣军入侵猪湾。率部队驻守比纳尔德里奥。 １９６２年５月２０日，儿子卡米略出生。８月２６日，出访莫斯科和布拉格。８月３１日，在克里米亚与赫鲁晓夫共同签署在古巴建立核导弹基地的协议。 １０月，发生"导弹危机"，率部队驻守比纳尔德里奥。 １９６３年４月，母亲塞莉娅因宣传古巴的"罪名"遭阿根廷当局关押。６月１４日，女儿塞莉娅出生。 １９６４年３月，率代表团访问瑞士、法国、捷克和阿尔及利亚。１１月４日，出访莫斯科。１２月１１日，率代表团出席联合国大会。１２月１８日，出访 非洲各国。 １９６５年２月２日，出访中国、法国、阿尔及利亚、坦桑尼亚和埃及。２月２４日，儿子埃内斯托出生。２月２５日，在阿尔及尔大会上发言，批评苏联集团不帮助世界人民的解放斗争。会后顺访刚果、埃及和布拉格。 ３月３１日，交给卡斯特罗辞行信，信中宣布辞去在古巴的官衔和古巴公民资格。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>迷失在刚果</li></ul><pre class="line-numbers language-none"><code class="language-none">１９６５年４月１日，化名拉蒙·贝尼特斯斯离开古巴。４月２４日，与古巴志愿人员一起进入刚果。５月１９日，母亲塞莉娅病故。６月，在刚果的游击队开始活动。１０月，菲德尔·卡斯特罗在古巴共产党成立大会上公开宣读了格瓦拉的辞行信。１１月２２日，古巴游击小组撤出刚果。 １９６６年１月，阿莱达·玛尔奇赴坦桑尼亚探望格瓦拉。３月，秘密抵达布拉格。７月，从布拉格秘密返回古巴。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>玻利维亚受难曲</li></ul><pre class="line-numbers language-none"><code class="language-none">１９６６年１１月３日，以美洲国家组织观察员身份进入玻利维亚。１１月７日，由玻利维亚首都拉巴斯去年卡瓦苏游击队营地，并开始记日记。１１月３１日，与玻利维亚共产党总书记马里奥·蒙赫会晤，未得支持。 １９６７年３月１５日，两名玻利维亚游击队员开了小差，玻利维亚政府军获得游击队的可靠情报。３月１９日，返回年卡瓦苏营地。塔尼亚、雷吉斯·德布 雷和希罗·布斯托斯也到达营地。４月，游击队与政府军交火并获得较大胜利。哈瓦那公开发表格瓦拉致"三大洲"会议的贺信。４月３日，为躲避政府军的包围，将游击队分成两个分队，华金率领第二分队。４月２０日，政府军抓获雷吉斯·德布雷、希罗·布斯托斯和乔治·安德鲁·罗思。８月１４日，政府军入年卡瓦苏的游击队营地。８月３１日，华金率领的第二分队在瓦多德尔耶索遭政府军伏击，全体人员遇难。１０月８日，格瓦拉被政府军击伤并被捕。１０月９日，玻政府和中央情报局勾结，下令杀害了格瓦拉和另外两名被俘的游击队员。１０月１８日，１００万古巴人民在哈瓦那庄严哀悼格瓦拉。 １９９７年７月１２日，古巴法医小组终于在瓦耶格朗德合葬墓坑内找到了格瓦拉的遗骸，并于当天运回哈瓦那。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="我理解的自由精神"><a href="#我理解的自由精神" class="headerlink" title="我理解的自由精神"></a>我理解的自由精神</h2><blockquote><p>首先，自由不是自私，而是要尊重，理解他人。现在很多人都把自由当成了自私，以为我要怎样就怎样，我爱怎样就怎样，你管不着，其实这是一种很自私的表现，现在看新闻，时不时就有年轻人自杀，这是自由吗？这不过是极端自私的表现而已，自杀得不到所谓的解脱，反而给亲人带来了精神的枷锁，这是懦弱逃避的表现。为什么如今会有这么多乱象？因为很多人把目光都集中在了狭隘的自我中心上，只为满足自我的欲望，看到想要的就拼命抓取，看到排斥的就拼命逃避，更多时候表现的是一种昏昏沉沉自作聪明胆小怕事的状态，曾经的我也是如此，而如今的我却感到羞愧，为了获得身心的自由，我们必须做出反应与改变。自由和自私虽然只有一字之差，实则天壤之别。真正的自由是建立在自我反省，自我约束，自利利他的条件上的，它不是散乱，而是遵循着某种规则。自由每个人都可以无条件拥有，但需从自我改变做起，然后才能有能力向周围扩散，尊重自己也尊重他人，与周围环境始终保持一种调和的状态。在追求自由的过程中，始终保持一种明觉的状态，不侵害他人的自由，彼此独立而又相互尊重理解，这才是真正的个人自由。</p><p>其次，自由不是追求自我满足与享乐，而是要学会感恩与不断超越。某些人当物质自由、权力自由得到解放时，就开始耽于享乐，内心的欲望于是开始膨胀，拥有了很多东西却又不感到满足，这样的人是贫穷的，因为实际的物质根本填补不了空虚的内心，更何况妄想平息良心上受到的谴责呢。当一个人自我膨胀的时候，就容易堕落，喜欢给他人制定规则，借以展示自我的我是，我能，我慢，虚荣，然后用他所谓的自由去限制他人的自由，你们得按我设定的这样干，我就是权威。这种夜郎自大，固步自封的表现实则是把自己和他人圈在一个小圈子里，称王称霸与自由精神是毫不符合的，这是一种退化的表现，也是阻碍自我与他人发展的障碍。自由是一种去恶从善，不断超越进取的力量，当别人被压迫，奴役的时候，你能给他们带来自由，而不是为了权力，财富，一已之力去投机取巧，这样的人才是一个真正的革命者。当你成功了你也不会把功劳归根于自己，让他人来称赞你，膜拜你，以突显自我的伟大。一个人之所以成功是有很多外在因素促成的，天地父母养育了你，朋友爱人关心了你，同事工作帮助了你，社会环境培育了你，所以人要学会感恩，要存有敬畏之心，真诚之心，这样你的视野才不会局限，才不会被野心，欲望引入歧途。学会感恩你就会发现，你不再是孤独与自私的，你会改变自身不合理的现状，你也会改变周围不合理的现状，你会想着奉献自己仅有的光和热，你在自我提升的同时，也在和他人，社会一起不断超越进步。</p><p>自由，不是自私，只是为了改变不合理的现状。拒绝平庸，拒绝堕落，拒绝安于现状，以一种开创、进取的精神，在自我救赎的过程中完成对他人的救赎，以及对个人、社会、世界的改造，这是一种向前发展，向上提升的力量。这是我对自由的一点见解，也是了解切格瓦拉之后，从中领悟到的自由精神。</p><p>个人的自由是要以团队集体的自由为准的，因为人是群居动物，而团队的自由不能限制压迫个人的自由，只有个人自由和团队自由得到调和，才会和谐发展，才不会充满暴戾之气。极权、暴政、专治、都是灭绝自由的行为，也是灭绝人性的行为，这是一群人欲望与野心膨胀的结果，秦始王幻想一世、二世…以致万世，汉武帝平息边境动乱后以为从此汉朝基业可以永垂不朽，然而这都只是一厢情愿而已，做一件事前要问发心，是不是在为了满足自我的欲望，在玩弄，利用他人。奴役民众，奴役他人怎么会有好结果呢，能得民心是你给了民众美好的生活，给了他们自由发展的空间，给了他们对未来的憧憬与希望，然后他们心甘情愿为团队为集体创造价值，共同提升。一个家庭如此，一个公司也是如此，一个国家就更不用说了。家长要引导孩子走向自由，而不是自私，领导要引导员工踏实工作，努力创造，而不是投机取巧，坑蒙拐骗。所谓”朕躬有罪，无以万方；万方有罪，罪在朕躬”,出了错会找自身原因，会总结经验，然后好好带领团队前行，不会让跟着你的人往坏的方面发展，向下发展。这样的人才是一个合格的领导，才能领导大家前行。所谓天子，天生万物而忽撄之，就是说让你当天子，是天命所赋，让你像天一样好好照顾天下的子民，让他们好好生长，而不是压迫他们，让他们不得好活，否则天命一变，管你有多牛，就有一股摧枯拉朽的新生力量代替腐朽的力量，这不是危言耸听，这是历史的经验。天子者，有道则人推而为主，无道则人弃而不用，诚可畏也。故天子一硅步，皆关民命，不可忽也。权力越大，肩上的担子越重，不是有权了就可以胡作非为，而是人心似流水，上边一放纵，下边就随波逐流，然后彼此两极分化，不相交通，政令就不会好好的执行，因为大家已经对领导者失去了信任。人心一乱，团队就会乱成一锅粥，彼此设防，尔虞我诈，残暴乱象之事盛行。所以一个团队一个集体有变坏的趋势，就要下大力气扭转，社会充满纷争的时候，就要有大魄力者来解除纷争，”和其光，同其尘，挫其锐，解其纷“，一个团体是要有凝聚力的，而纷争与冲突是要调解的，而不是以暴治暴。</p><p>切格瓦拉不是一个伟人，也不是一个十分杰出的领导者政治家，但他所代表的是一种自由精神，一种不甘于享乐，不甘于现状，拒绝平庸与压迫的精神，当然这个世界本来就没有所谓的圣人，伟人，英雄，这些都是后人为了满足自我崇拜的虚荣心而幻想的梦幻泡影。在很多时候盲目的崇拜甚至让人异化了本来的可贵精神，释迦牟尼的学说是多么伟大，而现在很多不明事理的人每天拜来拜去又有什么意义，幻想一个超级大力神来帮助自已逃避现实逃避责任，而不是自我去反省，去修行，去调和，装神弄鬼于已于人何益。再看看现在社会所提倡的成功学，真不知道倡导这个又有什么意义，成功者的经历能复制吗？成功者的机遇你能逮到吗？成功学是留给那么守株待兔的幻想家，画的大饼又有多少变成了现实？人们更多观注的只是他们所代表的财富以及社会地位而已，很少有人会体会他们创业时的艰辛，媒体一味的提倡只是让人相互侵诈，幻想投机而已，又有几人真正成功了？钱多地位高权力大就代表成功吗?很多人现在都没有独立思考的能力了！</p><p>所以我们需要切格瓦拉的这种自由精神，要有知其不可而为之的勇气。这点孔子做到了，切格瓦拉做到了，释迦牟尼、耶稣基督等等都做到了，明明是一个礼崩乐坏的时代，孔子还是去六国游说自己的政治理想，以期为穷人争取利益；明明众生难渡，佛菩萨们还是不舍众生，慈航救世，帮世人解除身心的烦恼；耶稣的伟大在于他用自己的血证明自己只是个凡人，他在为世人赎罪；而切格瓦拉呢？他只是众多革命者中的一个，但他与众不同的是没有选择安于现状与平庸，更没有选择做恶，他全生命投入革命，最后选择用革命来终结自己的生命与理想，他只为证明革命是不朽的。所以这个世界并没有那么多的革命者，也没有那么多的救世主，也没有那么多的成功者，我们不要因为众人的盲目崇拜，而异化了他们，我们要继承的是这种可贵的精神，然后用它指引我们前行，这才是价值所在。</p></blockquote><pre class="line-numbers language-none"><code class="language-none">不了解切格瓦拉的人，崇拜他，了解他的人，爱他，让我们面对现实，让我们忠于理想，缅怀这位20世纪最后的征人。最后以一首切最喜欢的诗结尾吧！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><a href="https://cdn.chegva.com/ueditor/php/upload/image/20181014/1539456355838171.jpg"><img src="https://cdn.chegva.com/ueditor/php/upload/image/20181014/1539456355838171.jpg" alt="✪ 切·格瓦拉与自由精神"></a></p><p>沒有什麼東西可以把我們繫住</p><p>沒有什麼東西可以把我們綁在一起</p><p>我喜歡海員式的愛情</p><p>接個熱吻就匆匆離去</p><p>我要走</p><p>我心裡難受</p><p>可我心里總是難受</p><pre class="line-numbers language-none"><code class="language-none">--《聶魯達‧海員》<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote>]]></content>
      
      
      <categories>
          
          <category> 摘录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摘录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>比特币是什么</title>
      <link href="/archives/undefined.html"/>
      <url>/archives/undefined.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>比特币，金融界的一位新宠儿，它是基于区块链技术诞生出的一个具体应用，这篇文章我将以最通俗易懂的语言介绍它的原理</p><h3 id="比特币是什么？"><a href="#比特币是什么？" class="headerlink" title="比特币是什么？"></a>比特币是什么？</h3><p>比特币[<a href="https://coor.top/p/66.html#fn1">1]</a>是一种电子货币或者叫数字货币，它是基于密码学的货币，这种货币跟我们银行卡里的货币不太一样，它的出现算是一个传奇。2008年金融危机，同年11月1日一个网络极客化名中本聪，到目前为止我们也不知道他到底是谁，他在网络上发表了一篇《比特币:一种点对点的电子现金系统》的文章，我们现在也管他叫《区块链白皮书》</p><p>他在文章中提出了一种去中心化的电子记账系统的思想，相比于我们现在使用的货币的记账方式，现在货币是由银行记账，而比特币的思想是不由一个具体的人或机构去记账，而是公开账本让每个人都拿着账本记账，实现去中心化的效果</p><p>当两个用户间互相转账，将会把交易记录广播给其他用户，然后把一定量的记录打包，这就成了一个区块，后续再有区块加进来，会和之前的区块链接在一起，这就是区块链[<a href="https://coor.top/p/66.html#fn2">2]</a></p><h3 id="挖矿"><a href="#挖矿" class="headerlink" title="挖矿"></a>挖矿</h3><p>那么就出现了新的问题，广播出去的交易记录后别人为什么帮你记账？多条打包记录以谁为准呢？</p><p>因为网络存在延迟等因素，同一时刻广播出去的交易记录可能顺序就打乱了，并且还参杂着一部分假记录，那么就需要对这些记录进行审核验证才行。至于为什么别人愿意为你记账，是因为有一个奖励机制，记账成功者会获得记账奖励，这个奖励包含交易手续费和打包奖励,手续费奖励很少，收益主要来自打包区块给予的奖励</p><p>打包奖励规则，根据中本聪的文章里所写方案，系统会每10分钟自动打一个包，发行之初给予最先成功打包的人50个比特币，没过4年奖励减半，也就是4年后这个奖励为25个比特币，再过4年就是12.5个，所以根据这个数据计算可得，比特币一共有2100万个</p><p>中本聪提到，通过工作量证明的方式来确定以谁的打包为准，区块链会生成一道很难的数学题，难度到达不能以任何人脑进行计算，只能通过计算机大量重复的试错去获得最终的结果，这个过程我们称之为挖矿</p><h3 id="挖矿的原理"><a href="#挖矿的原理" class="headerlink" title="挖矿的原理"></a>挖矿的原理</h3><p>计算机密码学中有个叫哈希函数的东西，是专门用于加密字符串的，我们有时也叫它数字摘要或散列函数，这个算法有个特点就是正算比较容易而反算特别特别困难。其中有一种哈希算法叫SHA256，如果将一个任意字符串输入到这个SHA256里，将会得到一串256位的无规律二进制数，而且这个算法不管输入的是什么，得到的结果都无任何规律，哪怕输入值只变了一个标点符号</p><p>比特币区块链上的每个块会包含一个区块的头部部分和区块的具体信息部分，比特币交易会生成一大堆交易信息，而需要哈希加密的内容就是前一块区块的头部信息、当前已打包好的账单信息、时间戳和一串打包时生成的随机数等内容，当把这些信息进行两次SHA256加密算法加密以后，就得到当前包的哈希值</p><p>那么，每个人都可以生成这么一个区块，谁有资格将这个区块合并进主区块呢？这就是重点以及挖矿成功的难点，根据要求，我们要得到一串前n位为0的哈希值才算成功，要想改变这个结果，我们只能不停更换计算时里面添加的那串随机数</p><p>对于这个数学计算题的难度设置，就取决于需要获取的结果里0的个数，也就是那个n。中本聪的白皮书中规定，每十分钟要出一个新块，假设全世界挖矿的计算机有1万台在运行，每台矿机每秒一共进行 <code>1.4*10^13</code> 次运算，可计算所有矿机10分钟一共可计算 <code>1.4*10^13*10^4*600</code> ，大概是 <code>2^66</code> 次运算，那么n就是66，也就是要求谁先算出的哈希值前66位为0就算他挖矿成功了</p><p>你没有办法让这个题变得更简单，你能做的就是不断的运算，算出需要的那个结果，也正是因为这个原理，导致挖矿的人越多，需要的结果就越难，每个人就越不容易挖到矿，所以就导致了大量的矿老板不断的购入更多的机器，更高性能的硬件，更多的电力消耗，比特币也更稀有，价格一路高涨</p><h3 id="如何保证交易记录的真实？"><a href="#如何保证交易记录的真实？" class="headerlink" title="如何保证交易记录的真实？"></a>如何保证交易记录的真实？</h3><p>传统的身份认证方式有本人签名、指纹识别、人脸识别等，但是这些认证方式都不适合用于计算机系统，因为这些方式都可以进行拷贝</p><p>计算机所运用的方式是电子签名，电子签名的原理为</p><blockquote><p>随机数 -&gt; 私钥 -&gt; 公钥</p></blockquote><p>电子签名也是通过哈希加密算法计算的，所以通过公钥不能够反算出来私钥，私钥用于加密，公钥用于解密，这种加密方法我们称之为非对称加密，其中私钥要绝对保密，私钥丢失一切都没了，公钥是需要公开的。</p><p>比特币所用的是再将公钥转换成一串比特币地址，需要接收比特币时只需要告诉对方比特币地址就行，而发送比特币则需要公开公钥和比特币地址</p><p>假设用户A支付用户B十个比特币，那么用户A会先将这个交易记录通过SHA256算法加密成一串摘要，然后通过私钥进行加密成一串密码，再把这串密码、交易记录和公钥对外进行广播。其他用户会对这条交易记录进行哈希运算得出一个摘要1，然后使用公钥对密码进行解密出一个摘要2，最后将摘要1和摘要2进行对比，如果摘要1和摘要2是一样的，就说明电子签名的密码和你手上的私钥是对应的，那么就证明了这条交易信息是真实的</p><h3 id="如何避免双重支付问题"><a href="#如何避免双重支付问题" class="headerlink" title="如何避免双重支付问题"></a>如何避免双重支付问题</h3><p>首先其他人会对你的支付金额进行来源追溯，对已链接进区块的你的金额和余额进行对比，如果交易金额小于余额则允许交易，反之直接拒绝</p><p>如果用户A同时给用户B、用户C一起支付了10个比特币，那么用户A会将这两条支付记录会广播给其他部分用户，其他用户会对用户A余额追溯，证明了交易记录是被允许的，就会把交易记录打包进自己的区块，当某个用户成功挖到了矿，这条交易才算最终完成，别的挖矿者会放弃自己手上的区块，转而加入到新的区块链末端，这也是比特币交易会延迟到账的原因</p><h3 id="如何防止区块链被篡改"><a href="#如何防止区块链被篡改" class="headerlink" title="如何防止区块链被篡改"></a>如何防止区块链被篡改</h3><p>区块链有个最长链原则，如果区块链出现了分支，矿工会继续挖矿，直到哪条分支最长，短的一边会放弃自己的区块加入到对方区块中去，想要篡改区块链只能自己从历史某个区块开一条分支，将自己分支挖的比主分支更长，那么就篡改成功了</p><p>但是这几乎是不可能完成的事情，因为这就相当于你凭一己之力自己的矿机算力对抗全世界其他矿机算力的总和，一般大额交易会多等几个新区块生成就能确保万无一失</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>比特币和区块链作为一种前沿技术，是非常新颖和漂亮的，比特币没有中心发行机构，不用担心主权危机，比特币总量固定，不会存在滥发的风险，比特币天生具有防伪属性，可以追溯，比特币手续费非常低，由于有这么多优点，有人甚至提出让中本聪获得诺贝尔经济学奖，但由于比特币的匿名性，也被一些不法分子用于违法犯罪活动，被一些国家和政府打击，还有一些人把比特币当作一种投机手段，比特币的暴涨暴跌，造成了许多人一夜暴富，还有许多人倾家荡产，我们应该把比特币看作一种技术手段，如果要购买比特币也应该以投资而不是投机的角度，因为从长期来看，任何的投机行为都会使你倾家荡产，而只有投资才能让你稳定的获利</p><hr><ol><li>比特币官网：<a href="https://bitcoin.org/zh_CN">https://bitcoin.org/zh_CN</a> <a href="https://coor.top/p/66.html#fnref1">↩︎</a></li><li>区块链爆块查询：<a href="https://www.btc.com/btc/pool/55">https://www.btc.com/btc/pool/55</a> <a href="https://coor.top/p/66.html#fnref2">↩︎</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot框架原理分析？</title>
      <link href="/archives/undefined.html"/>
      <url>/archives/undefined.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>目录</strong></p><p><a href="https://onestar.newstar.net.cn/blog/29#%E4%B8%80%E3%80%81%E8%B5%B7%E6%AD%A5%E4%BE%9D%E8%B5%96%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90">一、起步依赖原理分析</a></p><p><a href="https://onestar.newstar.net.cn/blog/29#1%E3%80%81spring-boot-starter-parent">1、spring-boot-starter-parent</a></p><p><a href="https://onestar.newstar.net.cn/blog/29#2%E3%80%81spring-boot-starter-web">2、spring-boot-starter-web</a></p><p><a href="https://onestar.newstar.net.cn/blog/29#%E4%BA%8C%E3%80%81%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90">二、自动配置原理解析</a></p><p><a href="https://onestar.newstar.net.cn/blog/29#1%E3%80%81%40SpringBootApplication%E6%B3%A8%E8%A7%A3">1、@SpringBootApplication注解</a></p><p>[【1】@SpringBootConfiguration 注解](<a href="https://onestar.newstar.net.cn/blog/29#%E3%80%901%E3%80%91%40SpringBootConfiguration">https://onestar.newstar.net.cn/blog/29#【1】%40SpringBootConfiguration</a> 注解)</p><p>[【2】@EnableAutoConfiguration 注解](<a href="https://onestar.newstar.net.cn/blog/29#%E3%80%902%E3%80%91%40EnableAutoConfiguration">https://onestar.newstar.net.cn/blog/29#【2】%40EnableAutoConfiguration</a> 注解)</p><p>[【3】@ComponentScan 注解](<a href="https://onestar.newstar.net.cn/blog/29#%E3%80%903%E3%80%91%40ComponentScan">https://onestar.newstar.net.cn/blog/29#【3】%40ComponentScan</a> 注解)</p><span id="more"></span><hr><h1 id="一、起步依赖原理分析"><a href="#一、起步依赖原理分析" class="headerlink" title="一、起步依赖原理分析"></a>一、起步依赖原理分析</h1><p>在搭建SpringBoot环境的时候（SpringBoot入门：<a href="https://blog.csdn.net/One_L_Star/article/details/103033571%EF%BC%89%EF%BC%8C%E5%9C%A8pom.xml%E4%B8%AD%E6%B7%BB%E5%8A%A0%E4%BA%86%E4%B8%A4%E4%B8%AA%E4%BE%9D%E8%B5%96%EF%BC%8C%E5%AF%B9%E8%BF%99%E4%B8%A4%E4%B8%AA%E4%BE%9D%E8%B5%96%E8%BF%9B%E8%A1%8C%E5%88%86%E6%9E%90%EF%BC%8C%E5%88%86%E5%88%AB%E6%98%AF%EF%BC%9A">https://blog.csdn.net/One_L_Star/article/details/103033571），在pom.xml中添加了两个依赖，对这两个依赖进行分析，分别是：</a></p><ul><li><p>SpringBoot的起步依赖：spring-boot-starter-parent</p></li><li><p>web的起步依赖：spring-boot-starter-web</p></li></ul><h2 id="1、spring-boot-starter-parent"><a href="#1、spring-boot-starter-parent" class="headerlink" title="1、spring-boot-starter-parent"></a>1、spring-boot-starter-parent</h2><p>spring-boot-starter-parent 是Spring Boot的父级依赖，是一个特殊的starter，它用来提供相关的Maven默认依赖。使用它之后，常用的包依赖可以省去version标签。</p><p>咱们可以直接对源码进行分析，来看看源码，就拿上篇博文中搭建 SpringBoot 环境的代码，使用 idea 按住 Ctrl 点击 pom.xml 中的spring-boot-starter-parent</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>2.0.1.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>relativePath</span><span class="token punctuation">&gt;</span></span>../../spring-boot-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>relativePath</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>截取了部分源码，在这里，可以看到SpringBoot的继承关系：</p><ul><li>SpringBoot 继承 spring-boot-starter-parent</li><li>spring-boot-starter-parent 继承 spring-boot-dependencies</li></ul><p>【1】咱们可以进入 spring-boot-dependencies 看一看，按住 Ctrl 点击 spring-boot-dependencies，截取部分代码：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>activemq.version</span><span class="token punctuation">&gt;</span></span>5.15.3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>activemq.version</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>antlr2.version</span><span class="token punctuation">&gt;</span></span>2.7.7<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>antlr2.version</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appengine-sdk.version</span><span class="token punctuation">&gt;</span></span>1.9.63<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>appengine-sdk.version</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artemis.version</span><span class="token punctuation">&gt;</span></span>2.4.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artemis.version</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>aspectj.version</span><span class="token punctuation">&gt;</span></span>1.8.13<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>aspectj.version</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>assertj.version</span><span class="token punctuation">&gt;</span></span>3.9.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>assertj.version</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>atomikos.version</span><span class="token punctuation">&gt;</span></span>4.0.6<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>atomikos.version</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bitronix.version</span><span class="token punctuation">&gt;</span></span>2.1.4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bitronix.version</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build-helper-maven-plugin.version</span><span class="token punctuation">&gt;</span></span>3.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build-helper-maven-plugin.version</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>byte-buddy.version</span><span class="token punctuation">&gt;</span></span>1.7.11<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>byte-buddy.version</span><span class="token punctuation">&gt;</span></span>  ... ... ...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencyManagement</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>2.0.1.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>2.0.1.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>      ... ... ...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencyManagement</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pluginManagement</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.jetbrains.kotlin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>kotlin-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>${kotlin.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.jooq<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>jooq-codegen-maven<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>${jooq.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>2.0.1.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">&gt;</span></span>          ... ... ...    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>pluginManagement</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这些配置里面主要是定义一些坐标的版本、依赖管理、插件管理，这里会根据我们在spring-boot-starter-parent定义的版本来提供相应版本的匹配，这就很好的解决了Spring导入版本依赖冲突的问题，所以我们的 SpringBoot 工程继承 spring-boot-starter-parent 后已经具备版本锁定等配置了。</p><p>可以看出起步依赖的作用就是进行依赖的传递。</p><p>【2】在 spring-boot-starter-parent 中，还有一个地方咱们可以看一下，那就是资源引入：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resource</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filtering</span><span class="token punctuation">&gt;</span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filtering</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>directory</span><span class="token punctuation">&gt;</span></span>${basedir}/src/main/resources<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>directory</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>includes</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span><span class="token punctuation">&gt;</span></span>**/application*.yml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>include</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span><span class="token punctuation">&gt;</span></span>**/application*.yaml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>include</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span><span class="token punctuation">&gt;</span></span>**/application*.properties<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>include</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>includes</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resource</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，${basedir}/src/main/resources 表示资源的加载文件，资源文件包括下面三种格式的，也就是说，咱们在配置SpringBoot资源文件的时候都是以 application*.yml、application*.yaml、application*.properties文件格式</p><h2 id="2、spring-boot-starter-web"><a href="#2、spring-boot-starter-web" class="headerlink" title="2、spring-boot-starter-web"></a>2、spring-boot-starter-web</h2><p> spring-boot-starter-web 是web功能的起步依赖，导入了web功能的起步依赖后，可以不用导入Spring和SpringMVC的坐标，是因为starter-web 将坐标打包了，同样，可以来看看源码，按住 Ctrl 点击 spring-boot-starter-web，截取部分代码</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">&gt;</span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starters<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>2.0.1.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>2.0.1.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">&gt;</span></span>Spring Boot Web Starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>2.0.1.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">&gt;</span></span>compile<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-json<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>2.0.1.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">&gt;</span></span>compile<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-tomcat<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>2.0.1.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">&gt;</span></span>compile<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.hibernate.validator<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>hibernate-validator<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>6.0.9.Final<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">&gt;</span></span>compile<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>5.0.5.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">&gt;</span></span>compile<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-webmvc<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>5.0.5.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">&gt;</span></span>compile<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，spring-boot-starter-web就是将web开发要使用的spring-web、spring-webmvc等坐标进行了“打包”，这样我们的工程只要引入spring-boot-starter-web起步依赖的坐标就可以进行web开发了，同样体现了依赖传递的作用。  </p><h1 id="二、自动配置原理解析"><a href="#二、自动配置原理解析" class="headerlink" title="二、自动配置原理解析"></a>二、自动配置原理解析</h1><p>自动配置其实就是将默认的配置自动加载进去，不需要我们去手动进行配置，在这里，我们还是以我的上一篇博客的环境搭建程序为例（<a href="https://blog.csdn.net/One_L_Star/article/details/103033571%EF%BC%89%EF%BC%8C%E4%BE%9D%E7%84%B6%E6%98%AF%E5%AF%B9%E6%BA%90%E7%A0%81%E8%BF%9B%E8%A1%8C%E5%88%86%E6%9E%90%EF%BC%8C%E4%BB%8EmySpringBootApplication%E5%BC%95%E5%AF%BC%E7%B1%BB%E5%BC%80%E5%A7%8B%EF%BC%9A">https://blog.csdn.net/One_L_Star/article/details/103033571），依然是对源码进行分析，从mySpringBootApplication引导类开始：</a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> mySpringBootApplication <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//将字节码引导参数传递给run方法</span>        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>mySpringBootApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1、-SpringBootApplication注解"><a href="#1、-SpringBootApplication注解" class="headerlink" title="1、@SpringBootApplication注解"></a>1、@SpringBootApplication注解</h2><p>首先是@SpringBootApplication注解，咱们按住 Ctrl 点击 SpringBootApplication，进入 SpringBootApplication 注解源码瞧一瞧：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span>TYPE<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Inherited</span><span class="token annotation punctuation">@SpringBootConfiguration</span><span class="token annotation punctuation">@EnableAutoConfiguration</span><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span>    excludeFilters <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token annotation punctuation">@Filter</span><span class="token punctuation">(</span>    type <span class="token operator">=</span> <span class="token class-name">FilterType</span><span class="token punctuation">.</span>CUSTOM<span class="token punctuation">,</span>    classes <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token class-name">TypeExcludeFilter</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token annotation punctuation">@Filter</span><span class="token punctuation">(</span>    type <span class="token operator">=</span> <span class="token class-name">FilterType</span><span class="token punctuation">.</span>CUSTOM<span class="token punctuation">,</span>    classes <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token class-name">AutoConfigurationExcludeFilter</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">SpringBootApplication</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@AliasFor</span><span class="token punctuation">(</span>        annotation <span class="token operator">=</span> <span class="token class-name">EnableAutoConfiguration</span><span class="token punctuation">.</span><span class="token keyword">class</span>    <span class="token punctuation">)</span>    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">exclude</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>     <span class="token annotation punctuation">@AliasFor</span><span class="token punctuation">(</span>        annotation <span class="token operator">=</span> <span class="token class-name">EnableAutoConfiguration</span><span class="token punctuation">.</span><span class="token keyword">class</span>    <span class="token punctuation">)</span>    <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">excludeName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>     <span class="token annotation punctuation">@AliasFor</span><span class="token punctuation">(</span>        annotation <span class="token operator">=</span> <span class="token class-name">ComponentScan</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span>        attribute <span class="token operator">=</span> <span class="token string">"basePackages"</span>    <span class="token punctuation">)</span>    <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">scanBasePackages</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>     <span class="token annotation punctuation">@AliasFor</span><span class="token punctuation">(</span>        annotation <span class="token operator">=</span> <span class="token class-name">ComponentScan</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span>        attribute <span class="token operator">=</span> <span class="token string">"basePackageClasses"</span>    <span class="token punctuation">)</span>    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">scanBasePackageClasses</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里我们可以看到，有一些其他的注解，咱们挑一些重要的注解来进行分析：</p><h3 id="【1】-SpringBootConfiguration-注解"><a href="#【1】-SpringBootConfiguration-注解" class="headerlink" title="【1】@SpringBootConfiguration 注解"></a>【1】@SpringBootConfiguration 注解</h3><p>咱们可以按住 Ctrl 点进去看</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span>TYPE<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">SpringBootConfiguration</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到 @SpringBootConfiguration 注解上面有一个@Configuration 注解，既标注该类是 Spring 的一个配置类 ，其实，@SpringBootConfiguration 注解就相当于Configuration注解，用于标注该类是 Spring 的一个配置类，和 Spring 中的@Configuration 注解是一个意思</p><h3 id="【2】-EnableAutoConfiguration-注解"><a href="#【2】-EnableAutoConfiguration-注解" class="headerlink" title="【2】@EnableAutoConfiguration 注解"></a>【2】@EnableAutoConfiguration 注解</h3><p>@EnableAutoConfiguration 注解是 SpringBoot 自动配置功能开启 ，同样，咱们可以按住 Ctrl 点进去瞧瞧</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span>TYPE<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Inherited</span><span class="token annotation punctuation">@AutoConfigurationPackage</span><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token class-name">AutoConfigurationImportSelector</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">EnableAutoConfiguration</span> <span class="token punctuation">{</span>    <span class="token class-name">String</span> ENABLED_OVERRIDE_PROPERTY <span class="token operator">=</span> <span class="token string">"spring.boot.enableautoconfiguration"</span><span class="token punctuation">;</span>     <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">exclude</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>     <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">excludeName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，在上面有一个 @Import({AutoConfigurationImportSelector.class}) 注解配置，这是导入了AutoConfigurationImportSelector类，意思是自动配置导入选择器，咱们可以点进AutoConfigurationImportSelector类看看，截取部分源码：</p><p><img src="https://img-blog.csdnimg.cn/20191115143158162.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L09uZV9MX1N0YXI=,size_16,color_FFFFFF,t_70" alt="img"></p><p>图中框出来的表示加载某些配置，点进源码看一看：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">getCandidateConfigurations</span><span class="token punctuation">(</span><span class="token class-name">AnnotationMetadata</span> metadata<span class="token punctuation">,</span> <span class="token class-name">AnnotationAttributes</span> attributes<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> configurations <span class="token operator">=</span> <span class="token class-name">SpringFactoriesLoader</span><span class="token punctuation">.</span><span class="token function">loadFactoryNames</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getSpringFactoriesLoaderFactoryClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getBeanClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token function">notEmpty</span><span class="token punctuation">(</span>configurations<span class="token punctuation">,</span> <span class="token string">"No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> configurations<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，SpringFactoriesLoader.loadFactoryNames 方法的作用就是从META-INF/spring.factories文件中读取指定类对应的类名称列表，而这个文件就在当前类的包下面，咱们可以找到看一看：</p><p><img src="https://img-blog.csdnimg.cn/20191115153837971.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L09uZV9MX1N0YXI=,size_16,color_FFFFFF,t_70" alt="img"></p><p>点进spring.factories文件，里面有关自动配置的配置信息：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">... ... ... org.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration,\org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration,\org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration,\org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration,\org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration,\org.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration,\ ... ... ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面配置文件存在大量的以 Configuration 为结尾的类名称，这些类就是存有自动配置信息的类，而 SpringApplication 在获取这些类名后再加载 ，我们以ServletWebServerFactoryAutoConfiguration为例来分析源码，找到 ServletWebServerFactoryAutoConfiguration 点进去看看：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@AutoConfigureOrder</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">2147483648</span><span class="token punctuation">)</span><span class="token annotation punctuation">@ConditionalOnClass</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token class-name">ServletRequest</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@ConditionalOnWebApplication</span><span class="token punctuation">(</span>    type <span class="token operator">=</span> <span class="token class-name">Type</span><span class="token punctuation">.</span>SERVLET<span class="token punctuation">)</span><span class="token annotation punctuation">@EnableConfigurationProperties</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token class-name">ServerProperties</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token class-name">ServletWebServerFactoryAutoConfiguration<span class="token punctuation">.</span>BeanPostProcessorsRegistrar</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token class-name">EmbeddedTomcat</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token class-name">EmbeddedJetty</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token class-name">EmbeddedUndertow</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServletWebServerFactoryAutoConfiguration</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里，@EnableConfigurationProperties(ServerProperties.class) 代表加载 ServerProperties 服务器配置属性类，咱们可以进入ServerProperties.class 看源码（截取部分源码）：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span>    prefix <span class="token operator">=</span> <span class="token string">"server"</span><span class="token punctuation">,</span>    ignoreUnknownFields <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServerProperties</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> port<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">InetAddress</span> address<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里，prefix = “server” 表示SpringBoot配置文件中的前缀，SpringBoot会将配置文件中以server开始的属性映射到该类的字段中。可以通过这个类完成相应配置加载，而加载的内容在包下面的 spring-configuration-metadata.json 文件中</p><p><img src="https://img-blog.csdnimg.cn/2019111515325295.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L09uZV9MX1N0YXI=,size_16,color_FFFFFF,t_70" alt="img"></p><p>点进去可以看到很多默认的配置，咱们以 server.port 配置为例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">{</span>  <span class="token string">"sourceType"</span><span class="token operator">:</span> <span class="token string">"org.springframework.boot.autoconfigure.web.ServerProperties"</span><span class="token punctuation">,</span>  <span class="token string">"defaultValue"</span><span class="token operator">:</span> <span class="token number">8080</span><span class="token punctuation">,</span>  <span class="token string">"name"</span><span class="token operator">:</span> <span class="token string">"server.port"</span><span class="token punctuation">,</span>  <span class="token string">"description"</span><span class="token operator">:</span> <span class="token string">"Server HTTP port."</span><span class="token punctuation">,</span>  <span class="token string">"type"</span><span class="token operator">:</span> <span class="token string">"java.lang.Integer"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个配置表示 Tomcat 启动时的默认端口，在这里配好之后，通过 ServerProperties 进行加载，然后通过@EnableConfigurationProperties标签引入，最终在 getCandidateConfigurations 类中进行加载。这就是整个默认配置的过程，当然，我们可以通过修改我们自己的 application*.properties 配置文件来覆盖默认配置</p><h3 id="【3】-ComponentScan-注解"><a href="#【3】-ComponentScan-注解" class="headerlink" title="【3】@ComponentScan 注解"></a>【3】@ComponentScan 注解</h3><p>@ComponentScan 注解是用于组件扫描，默认扫描当前引导类所在的包下的索引</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大圣，此去何为？</title>
      <link href="/archives/f9741c98.html"/>
      <url>/archives/f9741c98.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>原文链接：<a href="https://www.jianshu.com/p/0b60dd03e163">https://www.jianshu.com/p/0b60dd03e163</a></p></blockquote><p>后人解读《西游记》时，说孙悟空死在了“真假美猴王”那一节，原因是后来的孙悟空，再没有反抗过。</p><p>是这样吗？也许，是吧。</p><p>偶尔也会想到，真正的美猴王，是不是在大闹天宫之后，就已经不在了？</p><p>是的，那之后，世间少了一个桀骜不驯的美猴王，多了一个斩妖除魔的孙行者。但我分明记得，他以前是万妖之王，曾率群魔，对抗天庭。</p><p>我分明记得。</p><p>那一年他擎起金箍棒，起落之间，天地改色。</p><p>“大圣，此去欲何?”</p><p>“踏南天，碎凌霄。”</p><p>“若一去不回……”</p><p>“便一去不回”</p><p>没想到“一去不回”四个字，就这样应验了，那一战之后，他被压在了五行山下，五百年后西游，斗，战，胜，佛。从此，江湖，只留下了他的传说。</p><p>佛家讲“魔以心生，亦以心摄”，有人用这来解释孙悟空的心性由放纵不羁到修炼成佛的过程。这听起来似乎有点道理，但什么是魔，什么是仙，什么是正统，什么又是叛逆？</p><p>这世间的规则，是谁定的？我不知道。</p><p>这么多年，我只知道，让我感动的，是孙悟空占山为王，身披金甲衣，脚踏七彩云，棒指南天时的威风八面。</p><p>我迎风而颂。</p><p>金猴奋起千钧棒，玉宇澄清万里埃。</p><p><img src="https://note.youdao.com/yws/api/personal/file/3E59F7A5C0284865AB50CEA66ED810A2?method=download&amp;shareKey=3e8264eaaeae10c11f6701b3f3a902e6" alt="img"></p><span id="more"></span><p>电影《大圣归来》上映时，我和弟弟去看了，旁边小朋友问他母亲：“妈妈，这是一部动画片，为什么这么多大人来看？”</p><p>“因为他们都在等大圣归来啊！”</p><p>是的，我们等了整个童年，等待着心中那个唯一的超级英雄，再一次披上战甲，昂首向天。</p><p>满天诸佛，又能耐他如何？</p><p>当年你说：“若天压我，劈开那天，若地拘我，踏碎那地，我等生来是自由身，谁敢高高在上？”</p><p>我在等你回来，因为我一直不信，你那样桀骜不驯的一个人，怎么可能被金箍束缚？</p><p>我一直不信西游路上的那个俯首听话的孙行者是你，因为你当年是那样倔强，宁愿死，也不肯输。</p><p>我喜欢你，因为你，从来就和别人不一样。</p><p><img src="https://note.youdao.com/yws/api/personal/file/17F1A08652124A2DA6189086463F1C14?method=download&amp;shareKey=9c98bdafc31d7df8d683b73af37dce63" alt="img"></p><p>当年看完《西游记》时，我疯了似的满世界寻找你，好在，让我在《大话西游》里，又一次看到了你。</p><p>如今，这部电影我已经看了无数遍了，里面有你的成长与挣扎，但更重要的，是你的情。</p><p>从古到今，爱情一直是热门话题。</p><p>情字何解，情字，从来就无解。</p><p>原来这世间，根本就没有什么所谓的爱情大师，有的，只是历经千帆之后的看透，与强装看透。</p><p>戴上金箍，没法爱你；放下金箍，没法保护你。我知道上天不会给我第二次机会，曾经我们说好的永远，原来也仅仅只有，十二画，而已。</p><p>一路走来才发现，没有什么永远不变。</p><p>我们才终于懂得，曾经离我们一步之遥的人，一旦错过之后，即使化身绝世英雄，身披金甲圣衣，脚踏七彩祥云，也未必追的回来。</p><p>你把金箍棒扛在肩上，孤独远去时，我知道，我心里的那个美猴王，不会再回来了。</p><p>从此。</p><p>月溅星河 长路漫漫</p><p>风烟残尽 独影阑珊</p><p>到后来。</p><p>肝肠寸断。</p><p>有人和我说他看不懂《悟空传》，觉得里面都是无厘头的东西，我笑了：“那你肯定，也看不懂《大话西游》。”</p><p>其实这本就不是给小孩子看的，看不透，是因为阅历不够。</p><p>也许你喜欢的是“我要这天，再遮不住我眼，要这地，再埋不了我心，要这众生，都明白我意，要那诸佛，都烟消云散！”</p><p>而我喜欢的，是“你跳不出这个世界，是因为你不知道这个世界有多大，一旦你知道了，你就超出了它。”</p><p>其实这也是我近来亲身体验到的一个感悟：眼界很重要，往上走的时候，一步一重天。</p><p>我喜欢书里写出的悟空精神，那是对自由的向往，是对梦想的执着。有时候我也觉得，那里面的所有挣扎与无奈，才是悟空真正的心路历程。</p><p>他真的喜欢取经吗？他真的喜欢斩妖除魔吗？亦或者，他真的喜欢成佛吗？</p><p>没有人问他，也没有人真正关心他。</p><p>就像偶尔你也会扪心自问：我真的喜欢现在的生活吗？喜欢别人的干涉吗？喜欢亲戚朋友给安排的这段姻缘吗？</p><p>你喜欢或者不喜欢，但最后你还是接受了。</p><p>因为你怕。</p><p>你怕别人说你错，怕没人理你，怕人笑你，怕别人说你怕。</p><p>原来你也喜欢《悟空传》，回忆里面的热血，间接性的感动。我明白了，这是一个无能为力的人，在回忆他儿时的梦想。</p><p>小白龙的宝剑在颈上抹过时，有了一瞬间的念头：“原来一生一世那么短暂，原来当你发现所爱的，就应该不顾一切地去追求。因为生命随时都会终止，命运是大海，当你能够畅游时，你就要纵情游向你的所爱，因为你不知道狂流会什么时候到来，卷走一切希望与梦想。”</p><p>其实很多时候，我们都是有机会的，最后真正放弃的，是我们自己。</p><p>因为怂，因为怕，因为怕人说。</p><p>而现在，只能追忆。</p><p>只能羡慕。</p><p>其实我们每个人年少时，都是桀骜不驯的美猴王。</p><p>现在的你，是死在了大闹天宫时，还是一直在热泪盈眶着？</p><p>我也得和你说一句，偶尔，你也问问自己：</p><p>“大圣，此去欲何？”</p>]]></content>
      
      
      <categories>
          
          <category> 摘录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摘录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无友不如己者</title>
      <link href="/archives/undefined.html"/>
      <url>/archives/undefined.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://cdn.pixabay.com/photo/2014/10/15/15/20/the-thinker-489753_960_720.jpg" alt="img"></p><span id="more"></span><p>我正好前一阵看到某网友的几句话，正好把它转过来回复朋友：</p><blockquote><ol><li>你思考的90%的社会问题，至少1000年前，先哲们都给了答案。</li><li>剩下的10%，300年前的哲学家，思想家一定给出了答案。</li><li>绝对不存在你思考的问题，历史上的思想家没有给出答案。<br>所以，大多数时候，没看书之前，你的思考，是徒劳的。</li></ol></blockquote><p>我不太认同我们看书之前的思考是徒劳的，但“多读好书”我是认可的。</p><p>阿里的肖利华博士曾在《高质量深度学习体验拓展人生宽度高度深度》提出：学习成长的主要方法和路径有哪些？他总结道：</p><blockquote><ol><li>读万卷书</li><li>行万里路</li><li>识万种人</li><li>名师指导</li><li>自己感悟</li></ol></blockquote><p>这其中就有“读书”和“思考”两项。</p><p>我还认为应该找优秀的人多交流，每个人都有自己的短项，优秀的人可能有现自己短项互补的地方，正如达利欧在《原则》一书中所言：</p><blockquote><p>找到与我观点不同的最聪明的人，以便自己能够努力理解他们的推理。</p><p>找到其他的独立思考者，他们与我肩负共同的使命，但对问题的看法与我不同。通过以一种经过深思熟虑的辩论方式与他们交流，我就能理解他们的推理，并让他们对我的推理进行压力测试。我们都可以通过这种方式降低自己犯错的可能性。</p></blockquote><p>这样可以将<strong>思维定式从认为“我是对的”变成了问自己“我怎么知道我是对的”。</strong></p><p>也难怪《论语》里都说：</p><blockquote><p>无友不如己者。</p></blockquote><p>总结起来，就是多读好书，多独立思考，同时也要多与优秀朋友交流请教。</p><p>摘录自—<a href="https://tumutanzi.com/archives/16901">多读好书多思考，多与优秀做交流 – 土木坛子 (tumutanzi.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 摘录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摘录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“放开”</title>
      <link href="/archives/undefined.html"/>
      <url>/archives/undefined.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://steemitimages.com/640x0/https://cdn.pixabay.com/photo/2020/01/29/05/48/mouth-guard-4801623_1280.jpg" alt="img"></p><span id="more"></span><p>10月初时，我在日志<a href="https://tumutanzi.com/archives/16925">《管中窥豹、见微知著》</a>中提到，国内的疫情管控可能会有变化。我的直觉是再这样子持续不下去了。</p><p>记得有一次和两位领导散步，我当时说疫情一定会放开，我反问：就像当年的大跃进，难道毛主席那么聪明的人不知道亩产万斤是不可能的？当年的灭四害，也是一样的道理，灭了三年，可是哪一害到如今不存在于这个地球上——当年作为四害的麻雀更是冤枉到家？与常识作斗争，人类斗得过吗？</p><p>新冠疫情也一样，想把病毒彻底消灭，不惜一切代价消灭，那代价就是人类消灭自己，何况现在的变种毒性已经弱多了，毕竟发达国家早已和病毒共存——2022世界杯的观众席没有任何口罩就刺激了我们的常识神经。</p><p>再到后来注意到各大城市大学生们群情激动（白纸运动），于是今年的全国大部分高校提前准放假，各回各家、各找各妈，都回到家中，理由当然是疫情防控。全国中小学生和大学生相反，他们恢复线下上课，可能是未成年人不像有些大学生们会向老人们呐喊：不要欺负年轻人。</p><p>再到11月末，全国的疫情防控突然来一个U型转弯，从之前的动态清零到全国直接放开——有些地方政府可能没有领会上面的意思而未能及时放开。有广州的朋友和我抱怨，上午市政府还说要严控，下午就直接解封。转变之快，令人咋舌。只能感叹效率之高了。无论封控还是放开，<a href="https://tumutanzi.com/archives/16930">老板是不会有错的</a>。老子说：治大国若烹小鲜。这面煎糊了，换另一面煎。古人诚不我欺？</p><p>于是全国人们集中时间“感冒发烧”，实现我们当年嘲笑英国首相提出的“群体免疫”躺平策略。我因知道北京人民提前经受新冠感染高峰期，按照某知名网友的意见，于是叫孩子妈买了一盒泰诺，于是上周因孩子从学校带来病毒导致全家感染，我们用了5颗泰诺药丸，就把这个新冠感染扛过去了，烧退了，痛镇住了，比平时的感冒要难受得多，但疫情管控放松后，也只能接受这样的结果（英国的新冠奥密克戎感染后的死亡率是10万分之35）。</p><p>前两天的新闻证实了境外的传言，从2023年1月8日开始，中国将新冠疫情调整为乙类乙管疾病，过去那些超常规的管控手段就更没有依据了。终于可以回到比较正常的状态了。三年疫情，在整整三年后，就这样结束了，比想象中的样子结束得早一些，希望以后这样的日子不要再来。</p><p>回首这三年，对个人的经验教训也是有的。那些疫情期间本来德高望重的医学专家们，并不能坚持说真话，甚至连不说假话都没有做到，再一次让“专家”这个词的信用扫地。就像当年的钱老，应是写出文章证明“亩产万斤”可能的文章，导致后来真的全国各地产量也放卫星，导致多少人饿死，就不得而知了。</p><p>如果科学家们都昧着良心说假话，真不知道他们还对得住“科学家”这称号，其中还不乏院士、首席科学家，实在想不出来他们还缺什么？金钱？名誉？他们都早已拥有。最后将一世名誉毁在了自己手中，更不知道造成了多少生命的损失。也许有人会说，他们也是没有办法，疫情已经不是一个科学问题，他们不过是帮人站台背书——<a href="https://tumutanzi.com/archives/16930">老板是不会有错的</a>。但我觉得，说不了真话，那就至少做到闭嘴不说假话。</p><p>与专家对应，在疫情封控期间，各居委会似乎是得了尚方宝剑一般，保安以为自己变成了警察，一些小区物业公司也从中渔利，不让外面物流进入小区，只能购买他们提供的商品。一些身穿防护服的“大白”们在疫情期间对人们人格尊严和自由的践踏，法治在他们眼中如同儿戏。部分人们反应过来，原来欧美那些“傻子”争取不接种疫苗、不做核酸检测的自由也是一种自由。权力得不到制约，就走向了另一个极端变成害人的东西，上一次类似事情的主角是上世纪60年代的红卫兵。</p><p>虽然如今的网络是如此发达，但整个疫情期间，我们的消息渠道却没有变得好起来，往往有非官方小道消息，刚开始被官方认为是谣言，然后又变成是真的，尤其是境外的小道消息，更像是我们的行动指南。而官方消息，自己也前后矛盾，再加上不良自媒体的混合发酵，经常让我不知道该不该相信。</p><p>曾经以为的历史离我们已经远去，但一场疫情，将这些历史事件又一件件搬回到眼前，提醒着我们，历史一直在转着圈儿，并没有离去，疫情之初我曾说过：<a href="https://tumutanzi.com/archives/16702">大疫情下的2020年春节是块试金石</a>，没想到这块试金石试了三年，试出了更多的假恶丑。</p><p>但愿这是专家所说的螺旋式前进吧。在不要忘记过去历史的同时，保持一点对未来美好的期待，希望这次疫情是真的结束了，官方已经将“新型冠状病毒肺炎”更名为“新型冠状病毒感染”，我们再说它没有结束，可能就有一种领导夹菜你转桌的感觉了。</p><p>祝愿世界和平，祝愿各位朋友冬安。</p><p>摘录自—<a href="https://tumutanzi.com/archives/16962">新冠疫情终于结束了？ – 土木坛子 (tumutanzi.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摘录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“专家”</title>
      <link href="/archives/undefined.html"/>
      <url>/archives/undefined.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://source.unsplash.com/640x480/?prediction" alt="img"></p><p>又到一年伊始，不少机构和智库就开始放出一年预测，毕竟人们总是很喜欢往前看，而把过去的事情忘记，也很少有人回顾过去一年那些曾经作出的预测。</p><p>看到有人分享中金2022年所作预测的复盘结果：10个预测错了9个。随口预测明天下雨的概率都有50%，他们这些分析师的预测成功率，简直就是非常成功的“反指”（反向指标）。</p><p>我感慨：看着精英群体，实则草台班子。这几年，我也越来越对这些专家、精英的水平不敢恭维，具体一点就是这两年的的经济和医学领域，一次次拙劣的表现，让他们逐渐丧失了公信力。</p><span id="more"></span><p>诚然，预测未来是很难的，很多预测模型都是“垃圾进、垃圾出”（Rubbish in, rubbish out）。谁都没有上帝的视角，未来受到的干扰因素又很多，哪怕是对于过去的数据和信息，预测者也掌握不够。</p><p>针对2008年全球经济危机，听说英国女王写信质问经济学家们：你们怎么就没有预测到这样的危机？经济学家们说，我们平时搞的模型没有全球这么大。</p><p>在《灭火》一书中，身为时任美联储主席的作者伯南克也指出，大部分经济学家和政客们没有察觉到系统性风险，就更难预测未来的走向。这些经济学家们也确实不掌握政府全局层面的核心数据，预测的基础条件都不具备。</p><p>在某些地方，对未来的公开预测还受政治影响，专家们哪怕是真实的想法，也要考虑到政治因素，但客观规律未必会受政治影响，从而导致专家们的预测与未来的事实大相径庭，到头来受害的还是相信预测的人们。</p><p>我们应该尊重知识和客观规律，预测也不是不可以做，毕竟凡事预则立，只是面对那些草台班子一样的精英专家们所做的预测，不必那么认真对待，他们完全可能是错的，迷信他们，不经过自己的思考分析，被收割了也就不必怨天尤人了。</p>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>万历三十年读后感</title>
      <link href="/archives/af091701.html"/>
      <url>/archives/af091701.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>这一帝国既无崇尚武功的趋向，也没有改造社会、提高生活程度的宏愿，它的宗旨，只是在于使大批人民不为饥荒所窘迫，即在“四书”所谓“黎民不饥不寒”的低标准下以维持长治久安。这种宗旨如何推行？直接与农民合作是不可能的，他们是被统治者，不读书，不明理，缺乏共同的语言。和各地绅士合作，也不会收到很大的效果，因为他们的分布地区过广，局部利害不同，即使用文字为联系的工具，其接触也极为有限。剩下唯一可行的就是与全体文官的合作，如果没有取得他们的同意，办任何事情都将此路不通。</p><p>－－选自《万历十五年》</p></blockquote><span id="more"></span><p>这是第三次读《万历十五年》，第一次记得是2007年左右读的，印刷版，<a href="https://tumutanzi.com/archives/6937">第二次</a>忘记了在哪里和什么方式阅读。这次则是在Kindle上阅读，作书摘就方便多了。随着年月的增长，一而再、再而三地阅读同一本书，对它的理解也不一样。另一方面，我不断地阅读它，足见我对它的欣赏程度。</p><blockquote><p>这时，刑部尚书趋步向前，站定，然后大声朗读各个俘虏触犯天地、危害人类的罪行。读毕他又宣布，这些罪人法无可逭，请皇上批准依律押赴市曹斩首示众。皇帝答复说：“拿去！”他的天语纶音为近旁的高级武官二人传达下来，二人传四人，而后八人、十六人、三十二人相次联声传喝，最后大汉将军三百二十人以最大的肺活量齐声高喝“拿去”，声震屋瓦，旁观者无不为之动容。</p><p>－－选自《万历十五年》</p></blockquote><p>本书中文版成书于上世界80年代，到现在已经有近半个世纪之久，作者黄仁宇教授也不幸于2000年左右仙逝。我很佩服历史学家黄仁宇先生能把历史写得既严谨又风趣，读起来很有享受的感觉。作者单单从1587年入手，将明朝的历史分析了一整遍，所谓“叙事不妨细致，但是结论却要看远不顾近”。从七位人物入手，书中涉及到文化、政治、经济、权术、心理各方各面，既有对史料全面和细微的介绍，又有作者从古今中外大历史观的角度对各种事情的分析见解，我真是遗憾自己无法将博士论文写得如此有趣。</p><blockquote><p>三日之内，四品以上的官员及其夫人分批整队前去慈宁宫举行礼仪上的号哭，号哭十五次，全部人员的动作协调，一哭皆哭，一止皆止，有如交响曲。</p><p>－－选自《万历十五年》</p></blockquote><p>虽然写的是明朝历史，但我的感觉是，整部作品是理解我们国家的文化和社会的重要资料，书中的绝大部分观点，对于我们理解和认识现处的这个社会依然有用，不同的是我们现在有了火车，有了手机，有了电脑……我不方便在这里展开讨论，更重要的是，只有亲自阅读原著才会更能体会到作者想要表达的内容。</p><blockquote><p>至于开发民智这一类概念，在他们心目中更不占有任何地位。在我们这个古老的礼义之邦里，绝大多数的农民实际上早被列为顽民愚氓，不在文化教养之内，即使在模范官员海瑞的笔下，这些乡民也似乎只是一群动物，既浑浑噩噩，又狠毒狡诈，易于冲动。</p><p>－－选自《万历十五年》</p></blockquote><p>因此，从对现实的认识理解这一点来说，这部作品再一次给了我一种更加悲凉的悲观感。我们绝大多数人不过是历史长河中的一名匆匆过客，不会有什么能力改变什么，然而，多知道一点东西，减少一些心中的疑惑，总比什么都不知道要好。</p><blockquote><p>凡是发生事故，中枢之是否能作深入的调查研究已无关宏旨，上级总可以归罪于下级地方官。周密的调查既费周折，而如果受罚者又提出证据为自己辩护，如所出事情，在他到任之前滋生，或者其差错在于邻府邻县，或者由于上级指示错误，则法庭也无法结案。案悬不结，责任不明，必将破坏全部文官机构的规律，失去以后赏罚的标准。 因之我们的政事，注重体制的安定，而不计较对一人一事的绝对公允。牺牲少数人，正是维持大局的办法。人事考察条例，也就从这里着眼。</p><p>－－选自《万历十五年》</p></blockquote><p>以下是全部书摘：</p><p>公元年1587年，在中国为明万历十五年，论干支则为丁亥，属猪。当日四海升平，全年并无大事可叙，纵是气候有点反常，夏季北京缺雨，五六月间时疫流行，旱情延及山东，南直隶却又因降雨过多而患水，入秋之后山西又有地震，但这种小灾小患，以我国幅员之大，似乎年年在所不免。只要小事未曾酿成大灾，也就无关宏旨。总之，在历史上，万历十五年实为平平淡淡的一年。</p><p>1587年，在西欧历史上为西班牙舰队全部出动征英的前一年。当年，在我国的朝廷上发生了若干为历史学家所易于忽视的事件。这些事件，表面看来虽似末端小节，但实质上却是以前发生大事的症结，也是将在以后掀起波澜的机缘。其间关系因果，恰为历史的重点。 由于表面看来是末端小节，我们的论述也无妨从小事开始。</p><p>本朝官俸微薄，京城中高级官员的豪华生活，决非区区法定的俸银所能维持。如各部尚书的官阶为正二品，全年的俸银只有一百五十二两。他们的收入主要依靠地方官的馈赠，各省的总督巡抚所送的礼金或礼品，往往一次即可相当于十倍的年俸。这种情况自然早在圣明的洞鉴之中，传旨罚俸，或许正是考虑到此辈并不赖官俸为生而以示薄惩。但对多数低级官员来说，被罚俸两月，就会感到拮据，甚至付不出必要的家庭开支了。</p><p>按照传统观念，皇帝的意旨总是绝对公允的，圣旨既下，就不再允许有任何的非议。这一事件，也难怪万历皇帝圣心震怒。从皇帝到臣僚都彼此心照，朝廷上的政事千头万绪，而其要点则不出于礼仪和人事两项。仅以礼仪而言，它体现了尊卑等级并维护了国家体制。我们的帝国，以文人管理为数至千万、万万的农民，如果对全部实际问题都要在朝廷上和盘托出，拿来检讨分析，自然是办不到的。所以我们的祖先就抓住了礼仪这个要点，要求大小官员按部就班，上下有序，以此作为全国的榜样。现在全体京官自相惊扰，狼奔豕突，实在是不成体统。</p><p>这时，刑部尚书趋步向前，站定，然后大声朗读各个俘虏触犯天地、危害人类的罪行。读毕他又宣布，这些罪人法无可逭，请皇上批准依律押赴市曹斩首示众。皇帝答复说：“拿去！”他的天语纶音为近旁的高级武官二人传达下来，二人传四人，而后八人、十六人、三十二人相次联声传喝，最后大汉将军三百二十人以最大的肺活量齐声高喝“拿去”，声震屋瓦，旁观者无不为之动容。</p><p>这种珠帘是一种有趣的道具，它们在皇帝的眼前脑后来回晃动，使他极不舒服，其目的就在于提醒他必须具有端庄的仪态，不能轻浮造次。和冕相配的服装是饰有豪华刺绣的黑色上衣和黄色下裙，裙前有织锦一片，悬于腰带之上而垂于两腿之间，靴袜则均为红色。</p><p>皇家的开支可以不受限制，官员们却只能在极度节俭的原则下生活，更不必说这些宦官宫女。所以，本朝的官员、宦官的法定薪给都十分微薄。 这种不公平的现象当然不能持久。到十六世纪初，大部分的高级官员和宦官都已经过着十分奢侈的生活。尤其是高级宦官更为人所艳羡，他们不但在皇城内筑有精美的住宅，而且根据传统习惯，他们也有相好的宫女，同居如同夫妇。他们没有子女，但不乏大批干儿、侄子、外甥的趋奉，因而也颇不寂寞。至于招权纳贿，则更是题内的应有文章。</p><p>万历登极之初批阅本章，只是按照大伴冯保的指导，把张先生或其他大学士的“票拟”改用朱笔批写就算完成了职责。其中有些本章的批示极为简易，例如“如拟”、“知道了”，简直和练习书法一样。而且按照惯例，皇帝仅仅亲自批写几本，其他的批写，就由司礼监秉笔太监用朱笔代劳。这朱笔所代表的是皇帝的权威，如果没有皇帝的许可而擅用朱笔，就是“矫诏”，依律应判处死刑。</p><p>但即使是这些例行的批语，不到十岁的万历皇帝恐怕还是无法理解它的全部含义的。例如“知道了”，实际的意义是对本章内的建议并未接受，但也不必对建议者给予斥责。这些深微奥妙之处也只有随着他年龄的增长而逐渐加深理解。</p><p>这时张居正显示了他的宽容。他恳请对犯官免加体罚，改为流放到边远省份，受当地官吏的监视。这种雅量使万历极为感动，无端遭受别人的攻击，还要代这个人说情，可见他确实是不计个人恩怨，有古大臣之风。然而万历所不会理解的是，权倾朝野的张居正，他的作威作福已经达到了这样的程度：凡是他所不满的人，已经用不着他亲自出面而自有其他的内外官员对此人投井下石，以此来讨好首辅。果然，在几年之后，万历皇帝获悉当日免受杖刑的这位官员，竟在流放的地方死去，其死情极端可疑。</p><p>但所谓伯爵，不过是军队中的一个名誉军官，除了朝廷举行各项礼仪时位居前列以外，并没有任何特殊的权利，而且俸给甚低，甚至不敷家用。李伟在京城中大做揽纳物资于仓库的经纪，原因之一即在于此。他还有一个儿子，即慈圣太后的弟弟，身分却是宦官。</p><p>翰林院中负责记述本朝历史的各位编修均深感自身具有重大的责任，因为他们的职责就是要在记述中体现本朝按照圣经贤传的教导办事的精神，如果没有这种精神，朝廷就一定不能管理好天下的苍生赤子。统治我们这个庞大帝国，专靠严刑峻法是不可能的，其秘诀在于运用伦理道德的力量使卑下者服从尊上，女人听男人的吩咐，而未受教育的愚民则以读书识字的人作为楷模。而这一切都需要朝廷以自身的行动为天下作出表率。很多翰林来自民间，他们知道法治的力量有一定的限度，但一个人只要懂得忠孝大节，他就自然地会正直而守法。现在要是皇帝的老师不能遵守这些原则，把三年的父母之丧看成无足轻重，这如何能使亿万小民心悦诚服？</p><p>皇室的情谊不同于世俗，它不具有世俗友谊的那种由于互相关怀而产生的永久性。</p><p>这时，他感到空虚和烦躁。宫廷固然伟大，但是单调。即使有宫室的画栋雕梁和其他豪华装饰，紫禁城也无非是同一模式的再三再四的重复。每至一定的节令，成百成千的宦官宫女，把身上的皮裘换成绸缎，又换成轻纱；又按照时间表把花卉从暖房中取出，或者是把落叶打扫，御沟疏通，这一切都不能改变精神世界中的空虚和寂寞。在按着固定节奏流逝的时光之中，既缺乏动人心魄的事件，也缺乏令人企羡的奇遇。这种冷酷的气氛笼罩一切，即使贵为天子，也很难有所改变。</p><p>这些女孩子的年龄在九岁至十四岁之间，她们的容貌和生活经常成为骚人墨客笔下的题材。其实以容貌而论，一般来说仅仅端正，惊人的美丽并不是选择的标准。至于她们的生活，那确实是值得同情的。皇宫里真正的男人只有皇帝一个，得到皇帝垂青因而风云际会，像慈圣太后的经历一样，这种机会不是没有，但毕竟是极为罕见的。绝大多数的宫女在使婢生涯中度过了青春，中年以后也许配给某个宦官作伴，即所谓“答应”，也可能送到紫禁城的西北部养老打杂。经历过这可悲可感的一生，最后老病而死，还不许家属领取尸体。她们的尸体经过火化后，埋葬在没有标记的坟墓里。</p><p>郑氏之所以能赢得万岁的欢心，并不是具有闭月羞花的美貌，而是由于聪明机警，意志坚决，喜欢读书，因而符合皇帝感情上的需要。如果专恃色相，则宠爱决不能如此地历久不衰。</p><p>可以说，她是在最适当的时机来到了他的生活里，填补了他精神上的缺陷。凭着机智和聪明，她很快就理解了命运为她所作的安排，因而抓住现实，发挥了最大的能动性，从而达到自己预期的目的。她看透了他虽然贵为天子，富有四海，但在实质上却既柔且弱，也没有人给他同情和保障。即使是他的母亲，也常常有意无意地把他看成一具执行任务的机械，而忽视了他毕竟是一个有血有肉、既会冲动又会感伤的“人”。基于这种了解，她就能透彻地认清了作为一个妻子所能够起到的作用。别的妃嫔对皇帝百依百顺，但是心灵深处却保持着距离和警惕，惟独她毫无顾忌，敢于挑逗和嘲笑皇帝，同时又倾听皇帝的诉苦，鼓励皇帝增加信心。在名分上，她属于姬妾，但是在精神上，她已经常常不把自己当作姬妾看待，而万历也真正感到了这种精神交流的力量。据宦官们私下谈论，皇上和娘娘曾经俪影双双，在西内的寺院拜谒神佛，有时还一起作佛前的祈祷。她对万历优柔寡断的性格感到不快，并且敢于用一种撒娇讥讽的态度对他说：“陛下，您真是一位老太太！”</p><p>反张的运动由此揭开了序幕。大批严格办理丈量的官员被参劾，他们都直接或间接与故太师张居正有关。他们劣迹多端，而细加推究，其所以胆大妄为，后边盖有张居正的支持。这一运动慢慢地、但是有进无退地蔓延开去，而参与者也清楚地知道现在和当年劝谏夺情的时候，政治形势已经大不相同，他们揭发事实，制造舆论，使张居正的形象逐步变得虚伪和毒辣。到年年底，张居正去世仅仅半年，他已经被盖棺论定，罪状有欺君毒民、接受贿赂、卖官鬻爵、任用私人、放纵奴仆凌辱缙绅，等等，归结到最后，就是结党营私，妄图把持朝廷大权，居心叵测云云。</p><p>这一切使年轻的皇帝感到他对张居正的信任是一种不幸的历史错误。张先生言行不一，他满口节俭，但事实证明他的私生活极其奢侈。他积聚了许多珠玉玩好和书画名迹，还蓄养了许多绝色佳人，这些都是由趋奉他的佞幸呈送的。得悉了此项新闻，万历又感到十分伤心。这十年来，他身居九五之尊，但是被限制到没有钱赏赐宫女，以致不得不记录在册子上等待有钱以后再行兑现；他的外祖父因为收入不足，被迫以揽纳公家物品牟利而被当众申饬。但是，这位节俭的倡导者、以圣贤自居的张居正，竟如此口是心非地占尽了实利！</p><p>在这以后，在万历皇帝对张先生回忆之中，连勉强保留下来的一部分敬爱也化为乌有。他发现，他和他的母后曾误信张居正的所作所为是出于保障皇位的忠诚，而现在看来，张居正不过是出于卑鄙的动机而卖友求荣，纯粹是一个玩弄阴谋与权术的人。</p><p>元辅张居正死后被清算，大伴冯保被驱逐出京，皇帝至此已经实际掌握了政府的大权。但是不久以后，他就会发觉他摆脱了张、冯之后所得到的自主之权仍然受到种种约束，即使贵为天子，也不过是一种制度所需要的产物。他逐渐明白，倒掉张居正，真正的受益者并不是他自己。在倒张的人物中可以分为两类。一类人物强硬而坚决，同时又顽固而拘泥。张居正的案件一经结束，他们立即把攻击的目标转向皇帝。在劝谏的名义下，他们批评皇帝奢侈懒惰，个人享乐至上，宠爱德妃郑氏而冷落恭妃王氏，如此等等。总而言之，他们要把他强迫纳入他们所设置的规范，而不让他的个性自由发展。另一类人物则干脆是为了争权夺利。他们利用道德上的辞藻作为装饰，声称只有他们才能具有如此的眼光及力量来暴露张冯集团的本质。而张冯被劾之后在朝廷上空出来的大批职务，他们就当仁不让，安排亲友。</p><p>这种繁文缛节乃是当日国家中一种重要制度。经筵的着眼点在发挥经传的精义，指出历史的鉴戒，但仍然经常归结到现实，以期古为今用。称职的讲官务必完成这一任务，如果只据章句敷衍塞责或以佞辞逢迎恭维，无疑均属失职，过去好几个讲官就曾因此而被罢免。</p><p>施用于实际问题，或者说把实际问题抽象化。例如经过皇帝批准，人事有所任免，文渊阁公布其原因，总是用道德的名义去掩饰实际的利害，因为本朝法令缺乏对具体问题评断是非的准则，即令有时对争执加以裁处，也只能引用经典中抽象道德的名目作为依据。</p><p>本朝治理天下，礼仪所起巨大的作用，已略如前述。皇帝以一人而君临天下，具有最高的权威，实因天意之所归。天意必须通过亿万臣民的信念而体现出来。皇帝和他的大臣，经常以庄严美观的形式举行各式各样的礼仪，又为巩固这种信念不可或缺。无数次的磕头加强了皇帝神圣不可侵犯的意义；而他亲自主持各种礼仪，更表明他也同样受上天的节制，即受传统的道德所节制。儒家经典的教条愈简单平淡，就愈要加强学习，接二连三地听来讲去，借此加强我们理智的主宰。越是地冻天寒，溽暑蒸人，我们的早朝也更可以收到锻炼身心之效。就是皇帝的亲耕，看来有很明显的象征成分，但象征不一定就是虚伪。如果所有参加典礼的人都相信这种象征，而决心以行动促其成为现实，这又是何等壮大的力量！一月三次的经筵，其目的更直接了当，它表现了皇帝和大臣们坚决地在经典和史籍中寻觅最有效的方法，以达到大同之治。</p><p>难道一个人熟读经史，文笔华美，就具备了在御前为皇帝作顾问的条件？难道学术上造诣深厚，就能成为大政治家？二十五年前，翰林院修撰徐时行（当时他尚未姓申，仍袭用外祖徐姓）也曾对这些问题发生疑惑。但是今天的大学士申时行对此早已涣然冰释，理解了其中的精微奥妙，因为我们的帝国在体制上实施中央集权，其精神上的支柱为道德，管理的方法则依靠文牍。</p><p>翰林院的官员替皇帝撰写诰敕，诰敕的接受者总是孝子贤孙，同时也是眼光远大的父母或是能够周济邻里、领导地方的正人君子。执掌文墨与教育的官员也向皇帝反复说明，为人君的职责是在使人民在丰年得以温饱，凶年不致填于沟壑。他们也要阐明三代以来的王道至今依然适用，即一个良好的政府务必选贤任能，同时在社会上提倡诚信与和谐。总而言之，道德至高无上，它不仅可以指导行政，而且可以代替行政。至于具体的技术问题，例如一个蛮夷酋长当抚当剿的得失，使黄河水道南移或北迁的利弊，边区茶马交易折换率的调整，等等，自然也很重要，但这是属于各地总督巡抚的范围，他们理应提出建议。按本朝传统，所有的建议仍当奏请皇帝批准。然则用人适当，各地总督巡抚都是众望所归，他们的建议，也必为上策佳计，所有奏请，必然会得到批准。所以归根结底，技术问题仍与道德问题不可分离。</p><p>他的老成来自长期处理各种人事经验；这种经验，使他深知我们这个帝国有一个特点：一项政策能否付诸实施，实施后或成或败，全靠看它与所有文官的共同习惯是否相安无扰，否则理论上的完美，仍不过是空中楼阁。这一帝国既无崇尚武功的趋向，也没有改造社会、提高生活程度的宏愿，它的宗旨，只是在于使大批人民不为饥荒所窘迫，即在“四书”所谓“黎民不饥不寒”的低标准下以维持长治久安。这种宗旨如何推行？直接与农民合作是不可能的，他们是被统治者，不读书，不明理，缺乏共同的语言。和各地绅士合作，也不会收到很大的效果，因为他们的分布地区过广，局部利害不同，即使用文字为联系的工具，其接触也极为有限。剩下唯一可行的就是与全体文官的合作，如果没有取得他们的同意，办任何事情都将此路不通。例如就在这年，山东省的三千农民，由于饥荒铤而走险，丛聚为盗；各地白莲教的信徒也大有增加。</p><p>所以说来说去，施政的要诀，仍不外以抽象的方针为主，以道德为一切事业的根基。朝廷最大的任务是促进文官之间的互相信赖与和谐。此亦即鼓舞士气，发挥精神上的力量。</p><p>如果各部院寺的文官几个月都见不到皇帝一面，他们就很难维持信心，认为皇帝陛下对各种事情仍能充分掌握。此念一开，他们即会怀疑他对是非善恶可能已经置之度外。信念既失，疑窦即生，他们就很难再尽忠竭力。这也就是“四书”劈头所述的“诚意”至此已经不能维持。这种情况，就是所谓“上下否鬲，中外睽携”，如果继续下去，铤而走险的农民决不会止于三千，白莲教徒也一定会越来越多了。</p><p>科举制度的重要性又在社会风气中得到反映。一个读书人如果不入仕途，则极少有机会表现他的特长，发挥他的创造能力；也极少有机会带给一家、一族以荣誉。所以一个人的进学中举，表面上似乎只是个人的聪明和努力的结果，实则父祖的节衣缩食，寡母的自我牺牲，贤妻的茹苦含辛，经常是这些成功的背景。无数的祭文和墓碑，可为例证。这些文章多有出自儿子或丈夫的手笔，其中歌颂母亲或妻子给他们的赞助扶持，文句悱侧动人，情节也真实可信。皇帝赐给臣下的诰命，也针对这种感情上的需要，恩赐荣典，大多包括妻子以及祖宗三代。此外还有规定：本人可以辞去诰命而转封他们的妻子和祖宗三代。</p><p>首辅申时行虽然提倡诚意，他对理想与事实的脱节，却有一番深切的认识。他把人们口头上公认的理想称为“阳”，而把人们不能告人的私欲称为“阴”。调和阴阳是一件复杂的工作，所以他公开表示，他所期望的不外是“不肖者犹知忌惮，而贤者有所依归”。达到这个低标准，已经需要一番奋斗，如果把目标定得更高，那就不是实事求是了。</p><p>地方官综揽民政与财政，致富的机会至多。至于官员本身，向这种社会风气投降的程度则各有不同。大多数人觉得在似合法又似非法之间取得一部分额外收入，补助官俸的不足，以保持他们士大夫阶级的生活水准，于清操无损。另有相当数量的官员，则声名狼籍，其搜刮自肥的劣迹令人愤慨。再有一部分极端人物，则属清高自负，一介不苟取于人；这绝对的道德观念，可以由古怪的南京都御史海瑞作为代表。这三者的差别，也就是文官之间不能和谐的一大原因。</p><p>中枢的管理又被官僚习气所掣肘，这是中央集权很难避免的结果。中央对很多边远县份的实际情形无法直接获知，只能依赖地方官的报告。这种文书从地方送达中枢就常常需要一个月。执笔者铺陈情事，动辄使用自古以来最为华丽的辞藻，可是他们却足不出户，所引用的统计资料也许已经一百年没有修订过。中枢的大厦坐落在无数含糊暧昧所叠砌的基础之上，于是就必须找出自己的行政管理办法。</p><p>凡是发生事故，中枢之是否能作深入的调查研究已无关宏旨，上级总可以归罪于下级地方官。周密的调查既费周折，而如果受罚者又提出证据为自己辩护，如所出事情，在他到任之前滋生，或者其差错在于邻府邻县，或者由于上级指示错误，则法庭也无法结案。案悬不结，责任不明，必将破坏全部文官机构的规律，失去以后赏罚的标准。 因之我们的政事，注重体制的安定，而不计较对一人一事的绝对公允。牺牲少数人，正是维持大局的办法。人事考察条例，也就从这里着眼。按照规定，四品以下的地方官三年任满应当入京朝觐述职，由皇帝及有关部门核定他们政绩的优劣。但是全国有一千一百多个县，任何精明强干的人事官员也无法详细知道他们的具体成绩，而只能在大节目上斟酌一二。如果一个地方官所统辖的地区安静无事，税收没有多大亏欠，该地区的民风就是“淳厚”而并非“刁顽”，这一位地方官必为好官而非“浮躁”或“才力不及”。京官六年一考核，名为“京察”，考察也很难根据实际能力和成绩，而大抵是视其人事应付能否得宜而有其上下高低。</p><p>个人的私心会随时随地变迁，只有伦理道德永恒不变。古代的圣贤写作“四书”的时候如此，朱熹注解“四书”的时候如此，今日仍然如此。正因为如此，它才可以在经筵上被讲解者发挥，也可以在墓志上被镌刻，以为后人的典范。</p><p>张居正的根本错误在自信过度，不能谦虚谨慎，不肯对事实作必要的让步。申时行生平不愿宣扬别人的缺点，对于提拔自己的人，更不会妄加批判。他只是从这悲剧的内幕中得到了教益。</p><p>他们经常批评万历皇帝，其用心也未必真是“沽名卖直”，而是他们深知自我牺牲，必须得到皇帝的肯定和合作，才能使亿万百姓沾惠受益。他们之所以攻击张居正，也正因为在他们心目中，张居正的措施放弃了古圣先贤的宗旨，而是急功好利，企图以世俗的行政效率来代替这种伟大的精神，最终必然窒碍难行，落一个引用私人的下场。</p><p>从客观条件来看，张居正之引用私人，是无法避免的。以我国幅员之大，交通通信又极落后，任何有能力的内阁，也不能对各种地方官有周密的了解和实际的控制。张居正一心改弦更张，十年“专政”之后，各地税额并没有调整；地方政府仍然无法管理农村，官吏薪给之低，依然如故。总之，这种维新不过是局部的整顿，而非体制上的变革。张居正本人认真办事，一丝不苟，他亲自审核政府的账目，查究边防人马的数额，下令逮捕犯法的官吏，甚至设计各种报表的格式，规定报告的限期。他所派遣的总督和任命的尚书个个精明能干，然而他们的诚信仍有问题，因为撇开他们本身不说，他们属下的低级机构，依然处于各种各样不合理条件之下；离开了权术，这些高级官员也无精明能干之可言，而权术又总是和诚信背道而驰的。</p><p>他所派遣的总督和任命的尚书个个精明能干，然而他们的诚信仍有问题，因为撇开他们本身不说，他们属下的低级机构，依然处于各种各样不合理条件之下；离开了权术，这些高级官员也无精明能干之可言，而权术又总是和诚信背道而驰的。</p><p>才人见忌，自古已然。吴干越钩，轻用必折；匣而藏之，其精乃全。</p><p>在他执政的时代，在名义上说，文官还是人民的公仆，实际上则已包罗了本朝的出色人物，成为权力的源泉，也是这一大帝国的实际主人。张居正按照过去的眼光仍然把文官集团当作行政工具，对其中最孚众望的人物不加尊敬，就使自己陷于孤立的地位。直到危机四伏之际，他才发现了这一点，并且引用佛家经义，作为自己精神上的解脱，说是：“如入火聚，得清凉门。”</p><p>首辅或是在政策上遭到多数人的反对，或是个性太强而引起嫉妒和仇视。技术上的争端，一经发展，就可以升级扩大而成道德问题，胜利者及失败者也就相应地被认为至善或极恶。</p><p>利用这些小事可以促使公众注意，引起文官参加，假以时日，使小事积累而成大事，细微末节的局部问题转化而成为整个道德问题。在程序上讲，发展中的步伐则须前后衔接，第一步没有收到效果之前决不轻率采取第二步。而且出场交锋的人物起先总是无名小卒，直到时机成熟才有大将出马。这种方式，大凡久在政治圈子里的人物，都已看透，他们可以从青萍之末，预测大风暴的来临。</p><p>这一攻击既阴险又毒辣，因为它正中了皇帝心理上的要害。攻击者预料，高启愚为申时行提拔，在这严重罪状面前，申必然要出面为高辩护，于是就可以顺水推舟地搞垮申时行。</p><p>为什么张居正这样令人痛恨？原因在于他把所有的文官摆在他个人的严格监视之下，并且凭个人的标准加以升迁或贬黜，因此严重地威胁了他们的安全感。这些官员之间关系复杂，各有他们的后台老板以及提拔的后进。他们又无一不有千丝万缕的家族与社会关系，因之得罪了一个人，就得罪了一批人；得罪了一批人，也就得罪了全国。这正如他同年王世贞所说，张居正一套偏激的办法，是和全国的读书人作对。</p><p>张居正又错误地使用了獬豸这一动物。监察官是征集舆论、平衡阴阳、在公益和私利中找到折衷的工具，元辅张先生却用它来推动自己的政策。御史和给事中只检举对他不利的人物，不纠察他的行政，这种情况使他们与特务警察无异。因之张居正虽没有独裁者的权位，却有了独裁者的神通。要是在他执政之日没有这种普遍被压抑的恐惧和怨恨，以后的反张运动就不会引起这么多的同情，动员这么多的力量，产生这么多的枝节。</p><p>为了有效地管制全国各府县，这一考成法规定各科给事中按年月记载各地方官的政绩，其标准为欠税是否能够追缴，盗匪是否能够擒获。官员前案未结，就不许升迁离职，甚至有些已经退休或正在养病的官员还要被传询答复问题。现任首辅申时行认为这种方法有欠公允，因为税收能否如额征足，有其多方面的原因，而不完全决定于县令府尹的能力和办事精神；匪盗就擒或漏网，更多出于偶然的机会，如果上官不顾困难，一味逼迫下属，下属又逼迫兵丁捕快，就会促成许多嫌疑犯屈打成招，这也不是清明宽厚的本朝所宜有。万历听罢首肯。这样，张居正时代惟一有组织性的条例也就此撤销。</p><p>与他前任年的原则相反，申时行力主人事上的稳定。随即消息传来，政府让大小官员各安其位，于是众心欣慰。京察的结果，凡由进士出身的职官只有三十三人降级或罢免，而且这三十三人，没有一个出于吏部、都察院或翰林院这些传统上最富敏感的机关。这种恕道稳定了文官集团的情绪，也稳定了首辅自己的地位，他被众口交誉为老成持重，有古君子之风。</p><p>另外一个原因，则是他在张居正事件以后，他明白了别人也和他一样，一身而具有“阴”、“阳”的两重性。有“阳”则有“阴”，既有道德伦理，就有私心贪欲。这种“阴”也决非人世间的力量所能加以消灭的。于是，他既不强迫臣僚接受他的主张，也不反对臣僚的意见，而是对这一切漠然置之。他的这种消极怠工自然没有公然以圣旨的形式宣布，但在别人看来则已洞若观火。</p><p>而像我们这样庞大而历史悠久的帝国，即使在不利的条件之下，仅凭惯性的作用也可以使这个王朝继续存在若干年月。</p><p>这前后不同之处尽管在形式上含蓄，实质上却毫不含糊。原因是开国之君主创建了本朝，同时也设立了作为行政工具的文官制度，而今天的文官却早已成熟，他们所需要的只是一个个性平淡的君主作为天命的代表，其任务就是在他们的争端无法解决时作出强制性的仲裁。他们要求这位守成之主与日常的生活隔绝，在仲裁争端中不挟带个人的嗜好和偏爱以引起更多的纠纷。坦率地说，就是皇帝最好毫无主见，因此更足以代表天命。这种关系，已经由万历的曾叔祖弘治作出了榜样。弘治皇帝愈是谦抑温和，听凭文臣们的摆布，文臣们就愈是称颂他为有道明君。</p><p>皇帝没有办法抵御这种力量，因为他的权威产生于百官的俯伏跪拜之中，他实际上所能控制的则至为微薄。名义上他是天子，实际上他受制于廷臣。万历皇帝以他的聪明接触到了事情的真相，明白了自己立常洵的计划不能成功，就心灰意懒，对这个操纵实际的官僚集团日益疏远，采取了长期怠工的消极对抗。</p><p>当张居正出任首辅的时候，本朝已经有了两百年的历史。开国时的理想和所提倡的风气与今天的实际距离已经愈来愈远了。很多问题，按理说应该运用组织上的原则予以解决，但事实上无法办到，只能代之以局部的人事调整。</p><p>一个必然的后果，即政府对民间的经济发展或衰退，往往感到隔膜，因之税收和预算不能随之而增加或减缩。</p><p>财政上死板、混乱与缺乏控制，给予官员的俸禄又微薄到不合实际，官员们要求取得额外收入也就是不可避免的了。上面说过的地方官的“常例”是一种普遍的不成文制度，亦即在规定的税额以外抽取附加税：征收白银，每两附加几分几厘，称为“火耗”；征收实物，也要加征几匹几斗，称为“耗米”、“样绢”。除此之外，一个地方官例如县令，其家中的生活费用、招待客人的酒食、馈送上司的礼物，也都在地方上摊派。</p><p>一个具有高度行政效率的政府，具备体制上技术上的周密，则不致接二连三地在紧急情况下依赖于道德观念作救命的符箓。说得严重一点，后者已不是一种好现象，而是组织机构违反时代，不能在复杂的社会中推陈出新的结果。</p><p>在北京的两千多名文官中间，存在着对伦理道德和对现实生活的不同态度，互相顾忌而又互相蔑视。有的人出身寒微，把做官看作发财致富的机会；有的人家境丰饶，用不着靠做官的收入维持生活，自然就不会同意和允许其他人这样做。“四书”中的原则，有的人仅仅视为具文，拿来做职业上的口头禅，有些人却一丝不苟，身体力行。另外有一些人彷徨于上述两者之间；也有一些人由于人事的牵涉参与了对立的阵营。</p><p>一个人可以把他旁边的另一个人看成毫无人格，他的对方也同样认为他是在装腔作势地用圣贤之道掩饰他的无能。而眼前更为重要的是，立储一事绝不是抽象的原则，而是关系到文官们荣辱生死的现实问题：因为，凡是皇帝的继承权发生争执并通过一场残酷的冲突以后，胜利者登上皇帝的宝座，接着而来的就是指斥对方伪造先帝的旨意或是暴戾无道；因为九五之尊必有天命和道德做背景。如果不经过这一番左右舆论的工作，自己的胜利就不能名正言顺。而他手下的拥戴者，也总是要请求新皇帝以各种凶狠的手段加之于他们的对方，才能顺逆分明；自己流芳百世，政敌则遗臭万年，各有分晓。这种情形，在本朝的历史上至少已经发生过两次。</p><p>凡是皇帝的继承权发生争执并通过一场残酷的冲突以后，胜利者登上皇帝的宝座，接着而来的就是指斥对方伪造先帝的旨意或是暴戾无道；因为九五之尊必有天命和道德做背景。如果不经过这一番左右舆论的工作，自己的胜利就不能名正言顺。而他手下的拥戴者，也总是要请求新皇帝以各种凶狠的手段加之于他们的对方，才能顺逆分明；自己流芳百世，政敌则遗臭万年，各有分晓。这种情形，在本朝的历史上至少已经发生过两次。</p><p>身为天子的万历，在另一种意义上讲，他不过是紫禁城中的一名囚徒。他的权力大多带有被动性。他可以把他不喜欢的官员革职查办，但是很难升迁拔擢他所喜欢的官员，以致没有一个人足以成为他的心腹。他对大臣们的奏折作出决断，可以超出法律的规定，但是他没有制定法律的力量。官僚之间发生冲突，理所当然地由他加以裁夺，但是他不能改造制度以避免冲突的发生，而且他裁夺的权威性正在日益微弱，因为他被臣下视为燕安怠惰。各边区的军事问题必须奏报皇帝，但是皇帝自己不能统率兵将，在平日也没有整顿军备的可能。他很难跨出宫门一步，自然更谈不上离开京城巡视各省。连这一点选择的自由都没有，居于九五之尊还有什么趣味？</p><p>皇位是一种社会制度，他朱翊钧却是一个有血有肉的个人。一登皇位，他的全部言行都要符合道德的规范，但是道德规范的解释却分属于文官。他不被允许能和他的臣僚一样，在阳之外另外存在着阴。他之被拘束是无限的，任何个性的表露都有可能被指责为逾越道德规范。</p><p>三日之内，四品以上的官员及其夫人分批整队前去慈宁宫举行礼仪上的号哭，号哭十五次，全部人员的动作协调，一哭皆哭，一止皆止，有如交响曲。</p><p>人们看得很清楚，慈圣太后之被隆重追悼，并不是因为她个人引起了如此广泛而深沉的哀思。她不过是一个形式上的代表，她的丧仪象征了全国臣民怀念慈母的养育之恩，也表现了他们对皇室的忠悃。不难想象，这些官员和夫人在号哭完毕以后回到家里，由于为这隆重的丧仪所感染，势必要对长者更为孝敬，而全国的风俗乃能更为淳厚。然而万历皇帝却早已丧失了这样的信心。他已经把一切看透，仪式典礼只会产生更多的仪式典礼，作为全国的表率，他又必须在每一种仪式中使用全部精力去表现他的诚意。他在过去的生活里付出的精力已经太多了，他已经不再有周旋应付的兴趣，所以他以近日偶患湿毒、敷药未愈、行走不便作为理由，免除了自己应该在众目睽睽之下参加的繁文缛节。</p><p>换言之，皇帝的处置纵然不能事事合理，但只要百官都能俯首虚心地接受，则不合理也就成为合理。正德皇帝不去培养这种神秘力量，反而偏要去表现自己的将才帅略，岂不是破坏了臣僚们对他绝对服从的大前提？</p><p>万历皇帝缺乏他叔祖的勇气、积极性和寻找快乐的情趣。他从小开始就没有一天体会到自由的意义，也不是凭借自己的能力而获得臣下的尊敬，所以就难怪乎他不能向臣下提出明确的主张了。他读过有关他叔祖的记录，深知文臣集团只要意见一致，就是一种很强大的力量。既然缺乏坚强的毅力，这个孤立无援的皇帝只好一再向臣下屈服。然而他又不是一个胸襟开阔足以容物、并以恕道待人的皇帝，他的自尊心受到损伤，他就设法报复。报复的目的不是在于恢复皇帝的权威，而纯系发泄。发泄的对象也不一定是冒犯他的人，而是无辜的第三者。积多年之经验，他发现了最有效的武器乃是消极抵抗，即老子所谓“无为”。</p><p>检举张鲸的奏章中指斥他与某些文官勾结，并且接受贿赂。其所列举的罪状看来都凿凿有据，只是当时勾结为奸、纳贿贪财的一段罪状也可以加之于许多高级廷臣身上，写奏呈的人似乎全未计及。张鲸事后感慨，由于他的嘴巴说话太多，所以才招致了那么多的攻击，不能算是事出无因。只是根本的原因还是在于机构本身，其职务与文臣的利害相违。万历一朝的冲突，文臣占优势，与天启朝厂卫跋扈、缇骑气焰冲天的情形恰为尖刻的对照。</p><p>他本来已经对早朝和经筵感到极度厌倦，至此他拿定主意，今后再也不愿意公开接见这些不诚实的、口是心非的臣僚了。他隐居在深宫里，惟一能和他呼吸相通、忧患与共的就是贵妃郑氏。</p><p>他欣赏自己“从中调剂，就事匡维”这一处世和执政的原则，对待皇帝的办法则是“显谏者不若潜移为妙”，因为这种办法既对皇帝的权威无损，而臣下的目的又可以达到，这比之于臣下在奏章上奚落昏庸的皇帝，而皇帝用荆条痛打犯上的群臣总要高明得多。申时行所始料未及的，就是万历皇帝比他申先生又更高一手，已经看透了这种斗争的真情实相，知道自己生气都属无效，莫若用“无为”的办法，对付所有的纠缠，因之消极也越来越彻底了。</p><p>他虽然被人仰慕，但没有人按照他的榜样办事。他的一生体现了一个有教养的读书人服务于公众而牺牲自我的精神，但这种精神的实际作用却至为微薄。他可以和舞台上的英雄人物一样，在情绪上激动大多数的观众；但是，当人们评论他的政治措施，却不仅会意见分歧，而且分歧的程度极大。在各种争执之中最容易找出的一个共通的结论，就是他的所作所为无法被接受为全体文官们办事的准则。</p><p>以熟读诗书的文人治理农民，他们不可能改进这个司法制度，更谈不上保障人权。法律的解释和执行离不开传统的伦理，组织上也没有对付复杂的因素和多元关系的能力。</p><p>皇帝的情绪显得很矛盾，他有时把海瑞比做古代的忠臣比干，有时又痛骂他为“那个咒骂我的畜物”。有时他责打宫女，宫女就会在背后偷偷地说：“他自己给海瑞骂了，就找咱们出气！”</p><p>他的声望已为整个帝国所公认。他当然是极端地廉洁，极端地诚实，然而从另外一个角度来看，也可能就是极端地粗线条，极端地喜欢吹毛求疵。这样的人不会相信为人处世应该有阴阳的分别，他肯定会用他自己古怪的标准要求部下和上司。对他应该怎么分派呢？看来比较稳妥的办法是让他升官而不让他负实际的责任。于是，在不长的时期内，他历任尚宝司丞、大理寺右寺丞、左寺丞、南京通政司右通政，官至正四品。</p><p>洪武皇帝所推行的农村政策及一整套的措施，对本朝今后的历史，影响至为深远。其最显著的后果是，在全国的广大农村中遏止了法制的成长发育，而以抽象的道德取代了法律。上自官僚下至村民，其判断是非的标准是“善”和“恶”，而不是“合法”或“非法”。</p><p>但是他和洪武皇帝都没有想到，政府不用技术和经济的力量扶植民众，而单纯依靠政治上的压力和道德上的宣传，结果只能是事与愿违。政府的绝大部分收入出自农民，而在海瑞出任巡抚的时候，大部分农民又都身受高利贷的压迫和威胁。政府缺乏资金，农民无法从政府机构获得低利率的贷款。</p><p>洪武时代的八千官员，现在已经扩大为两万人。当年不准下乡的禁令早已废止，但事实上他们也极少再有下乡的需要，因为很多的人对民生疾苦早已视而不见，而是更多地关心于保持职位以取得合法与非法的收入。</p><p>何况商业的发展，如照资本主义的产权法，必须承认私人财产的绝对性。这绝对性超过传统的道德观念。就这一点，即与“四书”所倡导的宗旨相背。海瑞在判决疑案时所持的“与其屈兄，宁屈其弟”等等标准，也显示了他轻视私人财产的绝对性，而坚持维系伦理纲常的前提。</p><p>换言之，这种设施也仍不离以道德代替法律的途径。其方便之处则是一个地方官虽然缺乏法律上的专门训练，但是在幕僚和吏员的协助下仍然可以应付裕如地兼任司法官。司法从属于行政，则政府的统治得以保持一元化而使文官集团的思想行动趋于一致。</p><p>至于开发民智这一类概念，在他们心目中更不占有任何地位。在我们这个古老的礼义之邦里，绝大多数的农民实际上早被列为顽民愚氓，不在文化教养之内，即使在模范官员海瑞的笔下，这些乡民也似乎只是一群动物，既浑浑噩噩，又狠毒狡诈，易于冲动。日常生活中为小事而发生口角已属司空见惯，打架斗殴以致死伤也时有发生。纠纷的一方有时还愤而自杀以倾陷仇家；即或由于病死，家属也总要千方百计归之于被殴打致死。海瑞在做县令的时候，有一次下乡验尸，发现村民竟以颜料涂在死者的身上来冒充血迹。这些残酷的做法，除了泄愤以外，还因为诉讼一旦获胜，死者的家属就可以取得一部分仇家的产业。</p><p>在君子的精神世界里，出仕做官仅仅是取得了为国家尽忠、为百姓办事的机会。一个人如果出于牟利，他可以选择别的职业，或为农，或为工，或为商。如果为士做官，则应当排除一切利己的动机。在这一点上，海瑞和创建本朝的洪武皇帝的看法完全一致。</p><p>接近年年底亦即万历十五年丁亥的岁暮，海瑞的死讯传出，无疑使北京负责人事的官员大大地松了一口气，因为他们再也用不着去为这位大众心目中的英雄——到处惹是生非的人物去操心作安排了。</p><p>本朝治理农民的根本方针是保持他们的淳朴无知，一个士兵退伍还乡，就等于增加一个无业游民，因为他在军队里所学到的技术和养成的起居习惯，已经难于再度适应农村的生活，事情的复杂性就会因之而增加。军官退伍以后所引起的问题更为严重。在别的国家里，一个退伍军官通常都受到应有的尊敬，如果担任民政职务，他的管理经验也能保证他胜任愉快。然而事情适得其反，我们的军官在长期训练中所培养的严格和精确，退伍以后竟毫无用武之地。他会发现在军队以外，人们所重视的是安详的仪表、华丽的文辞、口若悬河的辩才以及圆通无碍的机智。——总而言之，和他已经取得的能力恰恰相反。</p><p>这种军事体制的设计，显而易见，其重点不在于对付敌国的全面入侵，同时也不打算全面进攻敌国。发生在年号称“土木之变”的战役，正统皇帝为瓦剌所俘虏，已经暴露了军事体制中致命的弱点。然而这样震惊全国的事件仍然没有能够引起应有的重视与改革。武备继续废弛，军事组织不断衰退。文官们只要在他们的任期中保持平静无事，则一切有关军队改造的计划大可束之高阁。一直到十六世纪中叶，倭寇的势力大张，不仅屡次攻破了被视为固若金汤的东南海防，而且长驱直入，视守军为无物，这才使中枢的文官惊醒，发现这低能的军事制度将要危及整个帝国以及他们个人的安全。穷则思变，改革已成为势所必然，而改革的初步，仍在于选择有创造精神的高级将领，他必须在战略上深谋远虑，而又精通各种战术。</p><p>然而这样震惊全国的事件仍然没有能够引起应有的重视与改革。武备继续废弛，军事组织不断衰退。文官们只要在他们的任期中保持平静无事，则一切有关军队改造的计划大可束之高阁。一直到十六世纪中叶，倭寇的势力大张，不仅屡次攻破了被视为固若金汤的东南海防，而且长驱直入，视守军为无物，这才使中枢的文官惊醒，发现这低能的军事制度将要危及整个帝国以及他们个人的安全。穷则思变，改革已成为势所必然，而改革的初步，仍在于选择有创造精神的高级将领，他必须在战略上深谋远虑，而又精通各种战术。</p><p>海盗大多是乌合之众，只要抄掠财物的目的一经达到，随即呼啸而去。而倭寇则不然。他们登陆以后通常要建立根据地，有时还围攻城池。其中的成员也并非全部来自日本，而常常混有不少的中国人。在一般情况下，中国人还在其中占有多数，而且可以担任高级头目。</p><p>颇为特异的是，他们的指挥信号乃是班排长手中的折扇。当双方开始接触，班长排长把折扇往上一挥，他们的部下就以刀锋向上。当对方的注意力为这种动作所吸引，他们就突然倒转刀锋迎头砍下。这种双刀的长度不过五尺，但在一个熟练的使用者手中挥舞，一片刀光，使“上下四方尽白，不见其人”，可以在一丈八尺的方圆之内杀伤对方。其他常见的武器还有弓箭和标枪。据记载，“倭竹弓长八尺，以弓蹈其弰，立而发矢。……镞宽二寸……近身而发，无不中者”，所掷的标枪“不露竿，突忽而掷，故不测”。至于火器，似乎并没有为他们所重视。虽然戚继光说过鸟铳由日本传来，但在记录上却看不到倭寇曾有效地使用这种武器。他们偶尔使用的火炮，看来也是在中国俘获的战利品。</p><p>再往下推求，俞大猷要求建立现代化的海军以拒敌于国门之外，作战的目的，则在消灭国际贸易，也和世界历史趋势相反。</p><p>戚继光的募兵原则是只收农民，而不收城市居民。他认为来自市井的人都属于狡猾无赖之徒。这种观点，虽然有它的片面性，但揆诸实际，在城市中有固定职业的人是极少自愿从军的。士兵为社会所普遍轻视，其军饷也相当微薄，城市中的应募者绝大多数只是把兵营当作解决食宿的救济所，一有机会就想另谋高就。这样的士兵如何能指望其奋勇杀敌以致效死疆场？所以戚继光订立了一条甄别应募者的奇特标准，凡属脸色白晰、眼神轻灵、动作轻快的人一概摈诸门外，因为这种人几乎全是来自城市的无业游民，实属害群之马，一旦交锋，不仅自己会临阵脱逃，还会唆使周围的人一起逃跑，以便一旦受到审判时可以嫁祸于这些言辞钝拙的伙伴。在这个标准下招收来的兵员，都属于淳朴可靠的青年农民，而“鸳鸯阵”的战术，也是针对这些士兵的特点而设计的。他曾明确地指出，两个手持狼筅的士兵不需要特别的技术，膂力过人就足以胜任。而这种狼筅除了扫倒敌人以外，还有隐蔽的作用而可以使士兵壮胆。</p><p>帝国的官僚政治已经发展到登峰造极，成千成万的官僚，在维护成宪的名义下保持各方面的平衡，掩盖自己不可告人的私利。要公然宣布改组军事制度，就等于邀请别人对自己攻击。因此张居正不得不采取这种迂回的方式。反正皇帝站在他这一边，不论别人是否识破真相，只要举不出违背成宪的理由，则公开的攻讦和私下的流言都可以不在话下。</p><p>中国的古典诗歌，如果用冲淡自然的语言表现出深切或激动的情绪，就谓之含蓄；如果用棱角分明的粗线条勾画出不受拘束的气概，则谓之豪放。戚继光的诗歌达不到这样的境界，带给读者的感觉只是拘束和平庸。好在也没有人用上述的标准来权量诗人戚继光。一般看来，出身于武举的将领，大半生都在戎马倥偬之中，能够写出这样的作品也就是出类拔萃。即在当代高级将领之中，除了“少好读书”的俞大猷之外，戚继光的文章造诣已无与伦比。在平常的谈话中，他可以随口引用儒家的经典和史书上的教训，以此，文官们对他刮目相看，认为他不是樊哙式的武人。等到他的官阶越来越高，就有更多的文官把他引为同类，在一起饮酒赋诗，往来酬对。当时的文苑班头王世贞和戚继光的交情就非同泛泛，在他的文集中有两篇赠送给戚帅的寿序，并且还为《纪效新书》和《止止堂集》作序。</p><p>但是用视而不见的态度抹去这些事实，就是不忠实于历史；对一个英雄人物隐恶扬善，也并不是真正的推崇。戚继光的复杂来自环境的复杂，如果指望他简单得如同海瑞，无疑是不近情理。写历史的人既知道戚继光是一代卓越的将领，一位极端刚毅果敢的军人，也是一位第一流的经理、组织家、工程建筑师和操典的作者，则自然应当联想到假如他不精通政治间的奥妙，就决不可能同时做好这么多的事情。戚继光所生活的时代，落后陈旧的卫所和军户制度早应该全盘放弃，而代之以先进的募兵制度；零碎的补给，也早就应该集中管理。然而我们的帝国不允许也没有能力作全面的改革，只好寻找出一种妥协的办法来作部分的修补。戚继光的天才，在于他看准了妥协之无法避免；而他的成功，也在于他善于在技术上调和各式各样的矛盾。妥协的原则，是让先进的部门后退，使之与落后的部门不至相距过远。在组织制度上没有办法，就在私人关系上寻找出路。具体来说，没有文渊阁和张居正的全力支持，就没有强有力的蓟州军区和戚继光。他的部队和他本人充满了矛盾，在火器已经在欧洲普遍使用的时候，他动员大批士兵修建碉堡；在他的混成旅里面，枪炮手和藤牌手并肩作战。他一方面是这样精细，仔细计算日出日没的时间；一方面又这样野蛮，把违反军纪的士兵割去耳朵。这些极端矛盾的事实，在其他国家内，可能彼此相隔几个世纪，而我们的帝国则在一个军区内同时出现。</p><p>李贽的悲观不仅属于个人，也属于他所生活的时代。传统的政治已经凝固，类似宗教改革或者文艺复兴的新生命无法在这样的环境中孕育。社会环境把个人理智上的自由压缩在极小的限度之内，人的廉洁和诚信，也只能长为灌木，不能形成丛林。都御史耿定向是李贽的朋友、居停和论辩的对手，李贽曾屡屡对他作过不留情面的抨击，批评他缺乏诚信。然而，李贽还以同样不留情面的态度解剖自己，指责自己缺乏诚信：“志在温饱，而自谓伯夷叔齐；质本齐人，而自谓饱道饫德。分明一介不与，而以有莘借口；分明毫毛不拔，而谓杨朱贼仁。动与物迕，口与心违。”他还怀疑自己用佛门的袈裟遮掩了“商贾之行之心”，“以欺世盗名”。</p><p>这种似合法又似非法的收入并没有使李贽感到不安。他并不像海瑞一样，以为官俸定额以外的一丝一毫收入都属于贪污。他以特行卓识而见称于当代和后世，但在这个问题上却和常人有相同的看法，即做官的目的本来就是名利。他的诚实在于能够坦白承认这一目的，而不打出去绝私欲、为国为民等等高尚的幌子。这就接触到了一个更为根本的问题：我们是否应该让每个人公开承认自己的私心，也就是自己的个人打算，以免口是心非而阴阳淆混？</p><p>李贽的一意孤行，一定要和两千年来根深蒂固的家族观念联系起来观察，才能使人理解，因为按照当时的习惯，他一旦回到泉州，他所需要照顾的决不能仅止于自己的家庭。他是族中有名望的人物，又做过知府，那就一定会陷入无数的邀劝纠缠之中而不可自拔。</p><p>一个人的品质高尚，就因为他的志趣和行为得到别人的赞赏；他的识见深远，就因为他分析理解其他事物的正确。所以人的生活目的，就不能不是合作互助与共同享有。但是，在现实中，为什么所有的人身上都存在或多或少的自私？这个问题使读书明理之人为之不安，而高级官员由于负有治国平天下的重任，其不安尤为严重。按理说，他们所受到的教养，都要求发扬为公众服务的精神；然而一旦接触实际，这种精神常常只是海上神山，或者干脆销声匿迹。有时他们身上的自私苟且，还远过于不识字的愚氓。这种不安，或者由此发展而来的内心交战，需要有一种适当的方式来缓解排除。志趣相投的研究讨论，可以触发彼此的灵感，深入探索人生的真谛，俾使内心的不安涣然冰释。所以他们来往密切，集会商谈之余，还互相通信，刊印文集。李贽落发为僧以后，仍然经常外出旅行，参加这些活动。在当时，还谈不上旅费必须报销，或者演讲应当收入费用，这些问题，都可以根据习惯，在往来交际之间安排妥帖。以李贽的名望，加上化缘和尚的姿态，他已经用不着再为经济问题而踌躇。</p><p>但是涉及面虽然广泛，却并不等于具有多方面的精深造诣。他写作的历史，对史实没有精确的考辨，也没有自成体系的征象。大段文章照史书抄录，所不同的只是按照自己的意见改换章节，编排次序，再加进若干评论。在接触小说的时候，他所着眼的不是作品的艺术价值和创作方法，也就是说，他不去注意作品的主题意义以及故事结构、人物描写、铺陈穿插等等技巧。他离开了文学创作的特点，而专门研究小说中的人物道德是否高尚，行事是否恰当，如同评论真人实事。再则，即使是阐述哲学理论，也往往只从片段下手，写成类似小品文，而缺乏有系统的推敲，作结构谨严的长篇大论。惟其如此，当日的士人，对于“李氏《藏书》、《焚书》人挟一册，以为奇货”。</p><p>既然由于对官僚政治不满而绝意仕进，那就理当息机忘世，以文墨自娱；可是写来写去，还总是和官僚政治有关，加之名望越来越大，“祸逐名起”，这就无怪乎招致杀身之祸了。</p><p>李贽自然无法理解，用中央集权的方式，以为数众多的官僚治理亿万农民，就要求整齐划一、按部就班，不能鼓励特殊分子或特殊成分发展新的技术或创造新的法则。在他所处的时代，文官集团业已丧失了发展技术的可能，也没有对付新的历史问题的能力。社会物质文明（即李贽所谓“文”）往前发展，而国家的法律和组织机构不能随之而改进，势必发生动乱。受到时代的限制，李贽认为历史循环之无法避免，乃是命运的安排，几乎带有神秘的力量，所以也不必再白费心力去寻找任何新的解决方案。这样来看，李贽的唯心论并不彻底，因为他承认了客观的真实性，治乱兴亡并不决定于人的主观，当然更不承认，所谓人心不在，治乱就不成其为治乱这样的理论了。</p><p>在道德的旌旗下，拘谨和雷同被视为高尚的教养，虚伪和欺诈成为官僚生活中不可分离的组成部分，无怪乎李贽要慨乎言之：“其流弊至于今日，阳为道学，阴为富贵！”</p><p>治理如此庞大的帝国，不依靠公正而周详的法律，就势必依靠道德的信条。而当信条僵化而越来越失去它的实用价值，沦于半瘫痪状态中的法律也当然无法填补这种缺陷。</p><p>对官僚绅士自己来说，行为不检，甚至涉及淫乱，本来是所在多有，毫不足怪。如果他们本人不事声张，旁人也可以心照不宣。李贽究竟无邪，还是有邪，可以放在一边不管，关键在于他那毫无忌惮的态度。他公然把这些可以惹是生非的情节著为文字，而且刊刻流传，这就等于对社会公开挑战，其遭到还击也为必然。而且，他的声名愈大，挑战性就愈强烈，地方官和绅士也愈不能容忍，对他进行惩罚已属责无旁贷。这些人雇佣地痞打手焚烧芝佛院，行为可谓卑劣怯弱，但在他们自己看来，则属于卫道。</p><p>李贽之所以罪有应得，则在于张问达的奏疏具有煽动的力量，而他使用的“罗织”方法，也把一些单独看来不成其为罪状的过失贯穿一气，使人觉得头头是道。何况把可能的后果作为现实的罪行，也是本朝司法中由来已久的习惯。而全部问题，说到底，还在于它牵涉到了道德的根本。</p><p>当一个人口众多的国家，各人行动全凭儒家简单粗浅而又无法固定的原则所限制，而法律又缺乏创造性，则其社会发展的程度，必然受到限制。即便是宗旨善良，也不能补助技术之不及。1587年，是为万历十五年，岁次丁亥，表面上似乎是四海升平，无事可记，实际上我们的大明帝国却已经走到了它发展的尽头。在这个时候，皇帝的励精图治或者宴安耽乐，首辅的独裁或者调和，高级将领的富于创造或者习于苟安，文官的廉洁奉公或者贪污舞弊，思想家的极端进步或者绝对保守，最后的结果，都是无分善恶，统统不能在事业上取得有意义的发展，有的身败，有的名裂，还有的人则身败而兼名裂。 因此我们的故事只好在这里作悲剧性的结束。万历丁亥年的年鉴，是为历史上一部失败的总记录。</p><p>以下是书籍附录里的书摘内容：</p><p>所以叙事不妨细致，但是结论却要看远不顾近，例如郑贵妃是否掩袖工谗，她到底是否国家妖孽，和今人的关系至微。明代人之所以要在这些地方做文章，可见他们道德的观念过于窄狭，技术无法开展。我的书也已给欧美学生作教本，那些教师，当然不会在考试时要求学生在试卷上说明明代衰亡乃因泰昌皇帝朱常洛并非郑妃所生，而系恭妃王氏所出。</p><p>而其中最大的差别，则是现代先进的国家以商业的法律作高层机构及低层机构的联系，落后的国家以旧式农村的习惯及结构作为行政的基础。</p><p>但是“一国两制”不是没有危险的，美国开国时以保障人权为前提，却又因为联邦制在南方姑息奴隶制度，终发生内战。日本在十九世纪尽量学西欧，对农民生活则不顾及，也可以算作一国两制，而引起滔天战祸的悲剧。一国两制的精神需要彼此将眼光看远，在长久的历史，找到合作的逻辑，而且今后也只有使两方更为接近，不致越来越远。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读后感 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>佛并不能把痛苦从你身上拿走</title>
      <link href="/archives/undefined.html"/>
      <url>/archives/undefined.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>比如，你在昏暗的房间，看到一根麻绳，以为是蛇，吓得半死。</p><p>这时，一个人走进房间并打开灯。有了亮光，你清楚的看到那是麻绳而非蛇，于是不再害怕。</p><p>这个人并没有把蛇拿走，因为它并存在。</p><p>同样，佛并不能把痛苦从你身上拿走，因为它不存在。佛只能告诉你，痛苦并不是真实存在的，而只是你自己的理解、甚至是幻象。要从痛苦中走出来，只能靠自己。</p><p>摘录自—<a href="http://atjason.com/daily/2023-01-07.html">http://atjason.com/daily/2023-01-07.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 摘录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>车流与经济</title>
      <link href="/archives/undefined.html"/>
      <url>/archives/undefined.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>高架上行车，</p><ul><li>如果前面的车比后面的车快，哪怕只快一丢丢，就会越来越通畅。</li><li>如果前面的车比后面的车慢，哪怕只怕一丢丢，也会越来越拥堵。</li><li>如果前面的车突然刹车大减速，后面的车会接连撞上去，引发连环车祸。</li></ul><p>这个车流，可以对比理解经济。</p><ul><li>如果经济在增长，你好我好喜欢大家好；</li><li>如果经济慢慢减速、软着陆，大家开始难受，但还可以忍受；</li><li>如果大减速、硬着陆，那就会引发一系列严重后果，甚至崩溃。</li></ul><p>并且，经济一旦失速，再想起来，就不只是踩油门这么简单。有可能，已经出现连环车祸。车都损坏了，还怎么踩油门。等拖车处理事故现场，也要好一会。第一车加速之后，要等很久，最后一辆车的速度才能提起来。</p>]]></content>
      
      
      <categories>
          
          <category> 摘录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“2010天涯神贴摘录”</title>
      <link href="/archives/undefined.html"/>
      <url>/archives/undefined.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>文章摘录之一：</p><p>博古才能通今，不了解历史无法治理国家，不了解历史也无法对事务有一个清楚的认识。</p><p>我们的今天本来就是历史的延续，前人经验和智慧的总结，不是一句话就可以抹杀的。</p><p>因为秦以后漫长帝国时代的大一统，才会把中央集权延续到现在。</p><p>而西方封建时代延续到地理大发现，诸侯割据王国、公国、侯国林立为现代的西方提供了民主制度的可能。</p><p>在制度上完全的不可比性，使向国际接轨成为了笑话。</p><p>我们看到的结果就是，物价上涨与西方接轨，甚至堂而皇之的超过西方，体制外的工资则与非洲结果，也算是国际化了。</p><ul><li>调控降房价是刚需的一厢情愿<ul><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#1%E4%BA%BA%E4%BA%BA%E9%83%BD%E6%9C%89%E5%B1%85%E4%BD%8F%E6%9D%83%E6%88%BF%E5%AD%90%E6%98%AF%E7%94%A8%E6%9D%A5%E4%BD%8F%E7%9A%84%E4%B8%8D%E6%98%AF%E7%94%A8%E6%9D%A5%E7%82%92%E7%9A%84">1、人人都有居住权。房子是用来住的，不是用来炒的。</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#2%E6%88%BF%E5%AD%90%E5%A4%AA%E8%B4%B5%E4%BA%86%E7%A7%9F%E5%94%AE%E6%AF%94%E4%B8%A5%E9%87%8D%E4%B8%8D%E5%90%88%E7%90%86%E7%A9%BA%E7%BD%AE%E7%8E%87%E5%A4%AA%E9%AB%98%E4%BA%BA%E5%9D%87%E6%94%B6%E5%85%A5%E5%A4%AA%E4%BD%8E%E6%97%A9%E6%99%9A%E8%A6%81%E5%B4%A9%E7%9B%98">2、房子太贵了，租售比严重不合理，空置率太高，人均收入太低，早晚要崩盘。</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#3%E6%88%BF%E4%BB%B7%E4%B8%8A%E6%B6%A8%E9%80%A0%E6%88%90%E7%89%A9%E4%BB%B7%E4%B8%8A%E6%B6%A8%E4%BA%BA%E6%B0%91%E7%94%9F%E6%B4%BB%E5%8F%98%E5%BE%97%E5%9B%B0%E9%9A%BE">3、房价上涨造成物价上涨，人民生活变得困难</a></li></ul></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E8%B0%83%E6%8E%A7%E7%9A%84%E7%9C%9F%E6%AD%A3%E7%9B%AE%E7%9A%84%E9%98%B2%E8%8C%83%E9%87%91%E8%9E%8D%E9%A3%8E%E9%99%A9--%E9%80%9A%E8%BF%87%E5%9E%84%E6%96%AD%E5%AE%9E%E7%8E%B0gj%E5%88%A9%E7%9B%8A%E6%9C%80%E5%A4%A7%E5%8C%96">调控的真正目的：防范金融风险 &amp; 通过垄断实现gj利益最大化</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%AE%98%E6%96%B9%E5%85%AC%E5%B8%83%E7%9A%84%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE%E5%8F%AA%E8%A6%81%E5%85%B3%E7%B3%BB%E5%88%B0%E6%9F%90%E4%B8%AA%E7%BE%A4%E4%BD%93%E7%9A%84%E5%88%A9%E7%9B%8A%E5%B0%B1%E4%B8%80%E5%AE%9A%E4%BC%9A%E8%A2%AB%E4%BF%AE%E9%A5%B0%E5%AF%BC%E8%87%B4%E5%A4%B1%E7%9C%9F">官方公布的统计数据，只要关系到某个群体的利益，就一定会被修饰导致失真</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E7%A8%8E%E6%94%B6%E4%BB%8E%E6%9D%A5%E9%83%BD%E6%98%AF%E5%90%91%E4%B8%8B%E6%B8%B8%E8%BD%AC%E5%AB%81%E7%9A%84--%E6%88%BF%E4%BA%A7%E7%A8%8E%E8%BF%9F%E8%BF%9F%E4%B8%8D%E5%87%BA%E5%8F%B0%E7%9A%84%E7%9C%9F%E6%AD%A3%E5%8E%9F%E5%9B%A0">税收从来都是向下游转嫁的 &amp; 房产税迟迟不出台的真正原因</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E6%88%BF%E5%9C%B0%E4%BA%A7%E7%9A%84%E7%8E%B0%E7%8A%B6">房地产的现状</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E6%88%BF%E4%BB%B7%E6%8C%81%E7%BB%AD%E4%B8%8A%E6%B6%A8%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E7%A8%80%E7%BC%BA%E6%80%A7%E8%AE%A9%E5%A5%BD%E6%88%BF%E5%AD%90%E6%88%90%E4%B8%BA%E8%B5%84%E9%87%91%E6%9C%80%E5%A5%BD%E7%9A%84%E5%8E%BB%E5%A4%84">房价持续上涨的本质是稀缺性让好房子成为资金最好的去处</a></li><li>关于垄断<ul><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#1%E5%9E%84%E6%96%AD%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%E6%B2%A1%E6%9C%89%E9%A3%8E%E9%99%A9">1、垄断的好处是没有风险</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#2%E5%9E%84%E6%96%AD%E5%8F%AF%E4%BB%A5%E8%A7%A3%E5%86%B3%E7%A4%BE%E4%BC%9A%E7%A8%B3%E5%AE%9A">2、垄断可以解决社会稳定</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#3%E6%88%BF%E5%B1%8B%E5%9E%84%E6%96%AD%E5%8F%AA%E4%BC%9A%E6%84%88%E6%BC%94%E6%84%88%E7%83%88%E5%BA%95%E5%B1%82%E4%BA%BA%E6%B0%91%E6%83%B3%E8%A6%81%E6%8B%A5%E6%9C%89%E4%B8%80%E5%A5%97%E6%88%BF%E5%AD%90%E7%9A%84%E9%9A%BE%E5%BA%A6%E5%8F%AA%E4%BC%9A%E8%B6%8A%E6%9D%A5%E8%B6%8A%E9%9A%BE">3、房屋垄断只会愈演愈烈，底层人民想要拥有一套房子的难度只会越来越难</a></li></ul></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E6%B0%91%E7%94%9F%E9%97%AE%E9%A2%98">民生问题</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E6%88%BF%E4%BA%A7%E7%A8%8E%E7%9A%84%E5%88%B6%E5%AE%9A%E5%8E%9F%E5%88%99">房产税的制定原则</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E7%BB%B4%E7%A8%B3%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E4%BA%BA%E6%B0%91%E8%83%BD%E5%90%83%E9%A5%B1%E9%A5%AD">维稳的本质是人民能吃饱饭</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%85%AC%E7%A7%9F%E6%88%BF%E6%98%AF%E4%B8%BA%E4%BD%93%E5%88%B6%E5%86%85%E6%9C%8D%E5%8A%A1%E7%9A%84">公租房是为体制内服务的</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E6%88%BF%E4%BA%A7%E7%A8%8E%E4%B8%80%E5%AE%9A%E4%BC%9A%E8%BD%AC%E5%AB%81%E7%BB%99%E7%A7%9F%E6%88%BF%E4%BA%BA">房产税一定会转嫁给租房人</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%B7%A8%E5%A4%A7%E7%9A%84%E7%A8%8E%E6%94%B6%E6%B6%88%E8%80%97%E4%B9%9F%E5%86%B3%E5%AE%9A%E4%BA%86GDP%E5%BF%85%E9%A1%BB%E5%BF%AB%E9%80%9F%E5%A2%9E%E9%95%BF">巨大的税收消耗也决定了GDP必须快速增长</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E8%B0%83%E6%8E%A7%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%E8%AE%A9zf%E5%88%A9%E7%9B%8A%E6%9C%80%E5%A4%A7%E5%8C%96&amp;%E9%98%B2%E8%8C%83%E9%87%91%E8%9E%8D%E9%A3%8E%E9%99%A9">调控的好处是让zf利益最大化&amp;防范金融风险</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%9E%84%E6%96%AD%E5%8F%AF%E4%BB%A5%E6%8E%A7%E5%88%B6%E4%BB%B7%E6%A0%BC%E7%BB%B4%E6%8C%81%E7%A8%B3%E5%AE%9A">垄断可以控制价格，维持稳定</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E4%BD%93%E5%88%B6%E5%86%85%E7%9A%84%E4%BD%8F%E6%88%BF%E9%97%AE%E9%A2%98%E6%9C%89%E5%9B%BD%E5%AE%B6%E4%BF%9D%E9%A9%BE%E6%8A%A4%E8%88%AA">体制内的住房问题有国家保驾护航</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E4%BE%9D%E9%9D%A0%E4%BD%86%E5%8F%88%E4%B8%8D%E8%83%BD%E5%AE%8C%E5%85%A8%E4%BE%9D%E9%9D%A0%E5%BC%80%E5%8F%91%E5%95%86%E5%BB%BA%E5%85%AC%E7%A7%9F%E6%88%BF">依靠但又不能完全依靠开发商建公租房</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E4%BD%93%E5%88%B6%E5%86%85%E7%9A%84%E4%BD%8F%E6%88%BF%E9%97%AE%E9%A2%98%E4%B8%8D%E9%9A%BE%E8%A7%A3%E5%86%B3">体制内的住房问题不难解决</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E8%A7%A3%E5%86%B3%E4%BD%93%E5%88%B6%E5%A4%96%E7%9A%84%E4%BD%8F%E6%88%BF%E9%97%AE%E9%A2%98%E5%9B%BD%E5%AE%B6%E5%9E%84%E6%96%AD%E7%BB%86%E6%B0%B4%E9%95%BF%E6%B5%81%E6%94%B6%E7%A7%9F">解决体制外的住房问题：国家垄断，细水长流收租</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E6%99%AE%E9%80%9A%E4%BA%BA%E4%B9%B0%E5%BE%97%E8%B5%B7%E4%BC%98%E8%B4%A8%E5%95%86%E5%93%81%E6%88%BF%E5%B0%B1%E5%B0%BD%E6%97%A9%E4%B9%B0%E6%8A%8A">普通人买得起「优质商品房」就尽早买把</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%95%86%E5%93%81%E6%88%BF%E5%92%8C%E5%85%AC%E7%A7%9F%E6%88%BF%E7%9A%84%E5%8C%BA%E5%88%AB">商品房和公租房的区别</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E6%8F%90%E8%AE%AE%E9%80%9A%E8%BF%87%E5%BE%81%E6%99%AE%E7%A8%8E%E8%B0%83%E8%8A%82%E8%B4%AB%E5%AF%8C%E5%B7%AE%E8%B7%9D%E4%B8%8D%E6%98%AF%E5%82%BB%E5%B0%B1%E6%98%AF%E5%9D%8F%E5%88%B6%E5%AE%9A%E6%94%BF%E7%AD%96%E7%9A%84%E4%BA%BA%E4%B8%8D%E4%BC%9A%E8%AE%A9%E6%94%BF%E7%AD%96%E9%92%88%E5%AF%B9%E8%87%AA%E5%B7%B1%E9%82%A3%E4%B9%88%E6%94%BF%E7%AD%96%E9%83%BD%E6%98%AF%E8%B0%81%E5%88%B6%E5%AE%9A%E7%9A%84%E5%91%A2">提议通过征普税调节贫富差距，不是傻，就是坏（制定政策的人不会让政策针对自己，那么政策都是谁制定的呢）</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E8%B0%83%E6%8E%A7%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%BD%B1%E5%93%8D">调控带来的影响</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%86%9C%E4%BA%A7%E5%93%81%E7%9A%84%E4%BB%B7%E6%A0%BC%E5%85%B3%E7%B3%BB%E5%88%B0%E5%BD%B1%E5%93%8D%E7%A8%B3%E5%AE%9A%E7%9A%84%E5%90%83%E9%A5%AD%E9%97%AE%E9%A2%98">农产品的价格关系到影响稳定的吃饭问题</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%86%9C%E4%BA%A7%E5%93%81%E4%BB%B7%E6%A0%BC%E7%9A%84%E6%8A%AC%E5%A4%B4%E4%BC%9A%E5%AF%BC%E8%87%B4%E7%89%A9%E4%BB%B7%E5%85%A8%E9%9D%A2%E4%B8%8A%E6%B6%A8%EF%BC%8C%E4%BD%86%E5%9B%BD%E5%AE%B6%E4%B8%8D%E4%BC%9A%E5%9D%90%E8%A7%86%E4%B8%8D%E7%AE%A1%E4%B8%94%E6%9C%89%E8%83%BD%E5%8A%9B%E7%AE%A1">农产品价格的抬头会导致物价全面上涨，但国家不会坐视不管且有能力管</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E8%B5%84%E9%87%91%E4%BC%9A%E5%9C%A8%E4%BC%98%E8%B4%A8%E8%B5%84%E4%BA%A7%E4%B9%8B%E9%97%B4%E6%B5%81%E5%8A%A8%EF%BC%8C%E8%80%8C%E5%86%B3%E5%AE%9A%E4%BC%98%E8%B4%A8%E8%B5%84%E4%BA%A7%E4%BB%B7%E6%A0%BC%E7%9A%84%E6%98%AF%E7%B2%BE%E8%8B%B1%E9%98%B6%E5%B1%82%E7%9A%84%E8%B4%AD%E4%B9%B0%E5%8A%9B">资金会在优质资产之间流动，而决定优质资产价格的是精英阶层的购买力</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E8%B5%84%E9%87%91%E6%B5%81%E5%90%91%E8%A7%84%E5%BE%8B%E5%86%B3%E5%AE%9A%E4%BA%86%E5%86%9C%E4%BA%A7%E5%93%81%E5%92%8C%E8%B5%84%E4%BA%A7%E4%BB%B7%E6%A0%BC%E6%80%BB%E6%9C%89%E4%B8%80%E4%B8%AA%E8%A6%81%E6%B6%A8%E4%BA%BA%E4%B8%BA%E5%8E%8B%E5%88%B6%E4%B8%80%E5%AE%9A%E4%BC%9A%E6%8C%89%E4%B8%8B%E8%91%AB%E8%8A%A6%E6%B5%AE%E8%B5%B7%E7%93%A2">资金流向规律决定了农产品和资产价格总有一个要涨，人为压制，一定会按下葫芦浮起瓢</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E8%B5%84%E9%87%91%E6%B5%81%E5%90%91%E8%A7%84%E5%BE%8B%E5%86%B3%E5%AE%9A%E4%BA%86%E6%B4%BC%E5%9C%B0%E4%B8%8D%E4%BC%9A%E4%B8%80%E7%9B%B4%E6%98%AF%E6%B4%BC%E5%9C%B0">资金流向规律决定了洼地不会一直是洼地</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%A4%A7%E5%9F%8E%E5%B8%82%E5%AF%B9%E8%BF%91%E8%B7%9D%E7%A6%BB%E7%9A%84%E5%B0%8F%E5%9F%8E%E5%B8%82%E6%9C%89%E8%99%B9%E5%90%B8%E6%95%88%E5%BA%94">大城市对近距离的小城市有虹吸效应</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%86%B3%E5%AE%9A%E6%88%BF%E4%BB%B7%E7%9A%84%E5%9B%A0%E7%B4%A0%E6%9C%89%E5%BE%88%E5%A4%9A%EF%BC%8C%E5%85%B7%E4%BD%93%E6%83%85%E5%86%B5%E5%85%B7%E4%BD%93%E5%88%86%E6%9E%90">决定房价的因素有很多，具体情况具体分析</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E6%88%BF%E4%BB%B7%E6%9A%B4%E6%B6%A8%E6%98%AF%E7%9B%B8%E5%AF%B9%E4%BA%8E%E9%92%B1%E8%80%8C%E8%A8%80%E7%9A%84%E4%B8%8D%E6%98%AF%E7%9B%B8%E5%AF%B9%E4%BA%8E%E5%AE%9E%E9%99%85%E8%B4%AD%E4%B9%B0%E5%8A%9B%E8%80%8C%E8%A8%80%E7%9A%84">房价暴涨是相对于钱而言的，不是相对于实际购买力而言的</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%9C%9F%E5%9C%B0%E4%B8%8D%E7%A8%80%E7%BC%BA%E4%BC%98%E8%B4%A8%E5%9C%9F%E5%9C%B0%E7%A8%80%E7%BC%BA">土地不稀缺，优质土地稀缺</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E9%9B%86%E4%B8%AD%E5%8F%91%E5%B1%95%E5%A4%A7%E5%9F%8E%E5%B8%82%E6%98%AF%E5%AF%BC%E8%87%B4%E4%BC%98%E8%B4%A8%E5%9C%9F%E5%9C%B0%E7%A8%80%E7%BC%BA%E7%9A%84%E5%8E%9F%E5%9B%A0">集中发展大城市是导致优质土地稀缺的原因</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E4%B8%BA%E4%BA%BA%E6%B0%91%E6%9C%8D%E5%8A%A1%E6%98%AF%E8%AF%B4%E7%BB%99%E4%BA%BA%E6%B0%91%E5%90%AC%E7%9A%84">为人民服务是说给人民听的</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%8E%86%E5%8F%B2%E6%98%AF%E4%B8%80%E9%9D%A2%E9%95%9C%E5%AD%90%E4%B8%8D%E5%90%8C%E7%9A%84%E5%9B%BD%E6%83%85%E5%86%B3%E5%AE%9A%E4%BA%86%E9%87%87%E5%8F%96%E5%90%8C%E6%A0%B7%E7%9A%84%E6%94%BF%E7%AD%96%E7%BB%93%E6%9E%9C%E5%8F%AF%E8%83%BD%E6%98%AF%E5%8D%97%E8%BE%95%E5%8C%97%E8%BE%99">历史是一面镜子，不同的国情决定了采取同样的政策结果可能是南辕北辙</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#zf%E9%99%90%E5%88%B6%E6%94%BF%E7%AD%96%E6%88%BF%E7%9A%84%E5%88%A9%E6%B6%A6%E9%82%A3kfs%E5%B0%B1%E4%B8%80%E5%AE%9A%E4%BC%9A%E5%81%B7%E5%B7%A5%E5%87%8F%E6%96%99">zf限制政策房的利润，那kfs就一定会偷工减料</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%B1%81%E8%82%A1%E5%86%B3%E5%AE%9A%E8%84%91%E8%A2%8B%E4%BA%BA%E6%B0%91%E4%B8%8D%E7%9F%A5%E5%8E%89%E5%AE%B3%E5%85%B3%E7%B3%BB%E9%80%89%E6%88%BF%E5%AD%90zf%E9%80%89%E5%86%9C%E4%BA%A7%E5%93%81">屁股决定脑袋，人民不知厉害关系选房子，zf选农产品</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%90%84%E4%B8%AA%E9%98%B6%E5%B1%82%E7%9A%84%E4%BD%8F%E6%88%BF%E9%97%AE%E9%A2%98%E9%83%BD%E5%AE%89%E6%8E%92%E7%9A%84%E5%A6%A5%E5%A6%A5%E7%9A%84">各个阶层的住房问题都安排的妥妥的</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E9%A1%B6%E5%B1%82%E7%9A%84%E5%B2%81%E6%9C%88%E9%9D%99%E5%A5%BD%E6%9D%A5%E8%87%AA%E4%BA%8E%E5%BA%95%E5%B1%82%E7%9A%84%E8%B4%9F%E9%87%8D%E5%89%8D%E8%A1%8C">顶层的岁月静好来自于底层的负重前行</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%BA%95%E5%B1%82%E6%8C%87%E7%9A%84%E6%98%AF%E4%BD%93%E5%88%B6%E5%A4%96%E5%BA%95%E8%96%AA%E7%99%BD%E9%A2%86">底层指的是体制外底薪白领</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E8%B5%84%E9%87%91%E7%BB%88%E4%BC%9A%E6%B5%81%E5%90%91%E5%85%B7%E6%9C%89%E7%A8%80%E7%BC%BA%E6%80%A7%E7%9A%84%E8%B5%84%E4%BA%A7">资金终会流向具有稀缺性的资产</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%9C%9F%E5%9C%B0%E7%9A%84%E7%A8%80%E7%BC%BA%E5%86%B3%E5%AE%9A%E4%BA%86%E5%A4%A7%E5%A4%9A%E6%95%B0%E4%BA%BA%E6%B0%B8%E8%BF%9C%E4%B9%B0%E4%B8%8D%E8%B5%B7%E6%83%B3%E4%B9%B0%E7%9A%84%E6%88%BF%E5%AD%90">土地的稀缺决定了大多数人永远买不起想买的房子</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E4%B8%8D%E5%90%8C%E9%98%B6%E5%B1%82%E7%9A%84%E4%BA%BA%E5%AF%B9%E6%94%B6%E5%85%A5%E9%AB%98%E4%BD%8E%E6%9C%89%E4%B8%8D%E5%90%8C%E7%9A%84%E7%90%86%E8%A7%A3">不同阶层的人对收入高低有不同的理解</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E4%B8%80%E4%BA%8C%E7%BA%BF%E4%B9%B0%E6%88%BF%E5%8F%AA%E4%BC%9A%E8%B6%8A%E6%9D%A5%E8%B6%8A%E9%9A%BE%EF%BC%8C%E6%9C%80%E7%BB%88%E7%A7%9F%E6%88%BF%E4%BC%9A%E6%88%90%E4%B8%BA%E4%B8%BB%E6%B5%81">一二线买房只会越来越难，最终租房会成为主流</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E4%BA%BA%E9%9C%80%E8%A6%81%E4%B8%80%E4%B8%AA%E5%AE%89%E8%BA%AB%E4%B9%8B%E6%89%80%E8%83%BD%E4%B9%B0%E6%97%A9%E4%B9%B0%E6%AF%94%E6%99%9A%E4%B9%B0%E5%A5%BD">人需要一个安身之所，能买早买比晚买好</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E8%82%A1%E5%B8%82">股市</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%A6%82%E6%9E%9C%E6%88%BF%E4%BB%B7%E4%B8%8D%E6%B6%A8%E9%82%A3%E5%85%B6%E4%BB%96%E4%BA%A7%E5%93%81%E4%BC%9A%E6%80%8E%E4%B9%88%E6%B6%A8">如果房价不涨，那其他产品会怎么涨</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#zf%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E5%85%AC%E7%A7%9F%E6%88%BF%E6%8E%A7%E5%88%B6%E7%A7%9F%E6%88%BF%E5%B8%82%E5%9C%BA">zf如何利用公租房控制租房市场</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%9F%8E%E4%B8%AD%E6%9D%91%E4%B8%8D%E4%BC%9A%E9%95%BF%E6%9C%9F%E5%AD%98%E5%9C%A8">城中村不会长期存在</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E4%B8%89%E5%9B%9B%E7%BA%BF%E5%9F%8E%E5%B8%82%E7%9A%84%E6%9C%AA%E6%9D%A5">三四线城市的未来</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E6%88%BF%E7%A7%9F%E4%BB%B7%E6%A0%BC%E6%B6%A8%E4%B8%8D%E4%B8%8A%E5%8E%BB%EF%BC%8C%E6%9C%AC%E8%B4%A8%E6%98%AF%E4%B9%B0%E6%88%BF%E8%BF%98%E7%9C%8B%E8%B5%B7%E6%9D%A5%E6%9C%89%E5%B8%8C%E6%9C%9B">房租价格涨不上去，本质是买房还看起来有希望</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E7%A8%80%E7%BC%BA%E6%88%BF%E7%9A%84%E4%BB%B7%E6%A0%BC%E6%B0%B8%E8%BF%9C%E6%B6%A8">稀缺房的价格永远涨</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E7%B2%AE%E9%A3%9F%E5%92%8C%E6%88%BF%E5%AD%90%E7%9A%84%E4%B8%8D%E5%90%8C%E6%98%AF%E6%88%BF%E5%AD%90%E6%97%A0%E6%B3%95%E5%92%8C%E5%9C%9F%E5%9C%B0%E5%89%A5%E7%A6%BB">粮食和房子的不同是，房子无法和土地剥离</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E8%B4%AD%E4%B9%B0%E6%88%BF%E4%BB%B7%E5%9F%BA%E6%95%B0%E4%BD%8E%E7%9A%84%E7%9C%81%E4%BC%9A%E5%9F%8E%E5%B8%82%E6%80%8E%E4%B9%88%E9%83%BD%E4%B8%8D%E4%BC%9A%E4%BA%8F%E7%9A%84">购买房价基数低的省会城市，怎么都不会亏的</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E6%88%BF%E5%9C%B0%E4%BA%A7%E6%98%AF%E8%B5%84%E6%9C%AC%E5%B8%82%E5%9C%BA%E8%BF%98%E6%98%AF%E5%AE%9E%E4%BD%93%E7%BB%8F%E6%B5%8E">房地产是资本市场还是实体经济？</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E4%BB%80%E4%B9%88%E6%98%AF%E5%82%BB%E7%A9%BA">什么是傻空</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E4%BB%80%E4%B9%88%E6%98%AF%E7%9C%9F%E4%B9%B0%E4%B8%8D%E8%B5%B7%E6%88%BF">什么是真买不起房</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%85%B7%E4%BD%93%E6%83%85%E5%86%B5%E5%85%B7%E4%BD%93%E5%88%86%E6%9E%90%E5%A6%82%E6%9E%9C%E7%9C%8B%E4%B8%8D%E6%87%82%E4%B8%80%E5%AE%9A%E6%98%AF%E6%B2%A1%E6%9C%89%E6%8A%93%E4%BD%8F%E9%97%AE%E9%A2%98%E6%9C%AC%E8%B4%A8">具体情况具体分析，如果看不懂，一定是没有抓住问题本质</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E6%A1%82%E6%9E%97-vs-%E5%8D%97%E5%AE%81">桂林 vs 南宁</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%85%AC%E7%A7%9F%E6%88%BF%E7%9A%84%E9%87%8F%E7%BA%A7%E4%B8%8D%E4%BC%9A%E5%86%B2%E5%87%BB%E5%88%B0%E5%95%86%E5%93%81%E6%88%BF%E5%B8%82%E5%9C%BA">公租房的量级不会冲击到商品房市场</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E8%B4%B5%E9%98%B3%E8%B5%84%E6%BA%90%E7%9A%84%E7%A8%80%E7%BC%BA%E5%AF%BC%E8%87%B4%E6%9D%83%E8%B4%B5%E6%9B%B4%E5%AE%B9%E6%98%93%E5%9E%84%E6%96%AD%E9%80%9A%E8%BF%87%E4%BD%8E%E6%94%B6%E5%85%A5%E9%AB%98%E7%89%A9%E4%BB%B7%E7%9A%84%E6%96%B9%E5%BC%8F%E5%89%A5%E5%89%8A%E5%BA%95%E5%B1%82%E7%BE%A4%E4%BD%93">贵阳，资源的稀缺导致权贵更容易垄断，通过低收入高物价的方式剥削底层群体</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E9%87%8D%E5%BA%86%E9%AB%98%E5%B1%82%E5%92%8C%E5%88%AB%E5%A2%85%E6%80%8E%E4%B9%88%E9%80%89">重庆：高层和别墅怎么选？</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E8%B4%A7%E5%B8%81%E8%B4%AC%E5%80%BC">货币贬值</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BE%8E%E5%9B%BD%E4%BA%BA%E5%B7%A5%E9%AB%98%E4%BA%8E%E4%B8%AD%E5%9B%BD%E4%BD%86%E5%A4%A7%E5%A4%9A%E6%95%B0%E5%95%86%E5%93%81%E7%9A%84%E7%89%A9%E4%BB%B7%E5%8D%B4%E4%BD%8E%E4%BA%8E%E4%B8%AD%E5%9B%BD">为什么美国人工高于中国，但大多数商品的物价却低于中国</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E8%BF%98%E8%83%BD%E4%B8%8A%E8%BD%A6%E7%9A%84%E8%B5%B6%E7%B4%A7%E4%B8%8A%E8%BD%A6">还能上车的赶紧上车</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E6%AD%A6%E6%B1%89%E5%9F%8E%E5%B8%82%E5%8F%91%E5%B1%95%E7%A9%BA%E9%97%B4%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%BE%80%E5%BE%80%E5%92%8C%E6%88%BF%E4%BB%B7%E7%9A%84%E5%8D%87%E5%80%BC%E7%A9%BA%E9%97%B4%E6%88%90%E6%AD%A3%E6%AF%94">武汉：城市发展空间的大小，往往和房价的升值空间成正比</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E6%9D%83%E5%88%A9%E8%AE%A9%E9%9D%A9%E6%97%8F%E6%88%90%E4%B8%BA%E8%8B%97%E6%97%8F%E7%9A%84%E4%B8%80%E6%94%AF">权利让革族成为苗族的一支</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E6%88%BF%E4%BB%B7%E6%98%AF%E5%90%A6%E4%BC%9A%E8%B7%8C%E5%A6%82%E6%9E%9C%E4%BC%9A%E4%BC%9A%E6%80%8E%E4%B9%88%E8%B7%8C">房价是否会跌，如果会，会怎么跌</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E9%80%9A%E8%B4%A7%E8%86%A8%E8%83%80%E6%98%AF%E5%87%8F%E7%BC%93%E7%81%AD%E4%BA%A1%E6%9C%80%E5%A5%BD%E7%9A%84%E8%89%AF%E8%8D%AF">通货膨胀是减缓灭亡最好的良药</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E8%B4%A7%E5%B8%81%E4%BE%9B%E5%BA%94%E4%B8%8D%E8%B6%B3%E6%98%AF%E6%98%8E%E6%9C%9D%E7%9A%84%E7%9C%9F%E6%AD%A3%E5%8E%9F%E5%9B%A0">货币供应不足是明朝的真正原因</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E7%BB%8F%E6%B5%8E%E9%97%AE%E9%A2%98%E6%98%AF%E5%AF%BC%E8%87%B4%E6%B8%85%E6%9C%9D%E7%81%AD%E4%BA%A1">经济问题是导致清朝灭亡</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E6%88%BF%E4%BA%A7%E6%8A%95%E8%B5%84%E7%9A%84%E5%87%A0%E7%82%B9%E5%BB%BA%E8%AE%AE">房产投资的几点建议</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E4%BA%BA%E6%B0%91%E5%B8%81%E5%AF%B9%E5%A4%96%E5%8D%87%E5%80%BC%E5%AF%B9%E5%86%85%E8%B4%AC%E5%80%BC">人民币对外升值，对内贬值</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%8D%97%E5%AE%81%E4%B9%B0%E6%88%BF%E5%BB%BA%E8%AE%AE">南宁买房建议</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E7%BB%8F%E6%B5%8E%E9%80%82%E7%94%A8%E6%88%BF%E9%83%BD%E6%98%AF%E5%86%85%E9%83%A8%E5%88%86%E9%85%8D%E7%9A%84">经济适用房都是内部分配的</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E6%99%AE%E9%80%9A%E4%BA%BA%E6%80%8E%E4%B9%88%E5%8A%9E%E5%B0%BD%E6%97%A9%E4%B9%B0%E6%88%BF%E5%8A%AA%E5%8A%9B%E6%8C%A3%E9%92%B1%E6%8A%B5%E5%BE%A1%E9%80%9A%E8%83%80">普通人怎么办：尽早买房，努力挣钱抵御通胀</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E6%88%BF%E4%BB%B7%E4%BC%9A%E5%87%BA%E7%8E%B0%E5%BE%88%E5%A4%9A%E4%B8%8A%E4%B8%8B%E6%B3%A2%E5%8A%A8">房价会出现很多上下波动</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E4%B9%B0%E6%88%BF%E6%97%B6%E6%9C%BA%E7%9A%84%E9%80%89%E6%8B%A9%E7%9C%9FTM%E5%8E%89%E5%AE%B3%E8%BF%99%E7%AB%9F%E7%84%B6%E6%98%AF2010%E5%B9%B4%E7%9A%84%E5%BB%BA%E8%AE%AE%E5%8F%AF%E6%81%A8%E7%9A%84%E6%98%AF2020%E5%B9%B4%E6%89%8D%E7%9C%8B%E5%88%B0">买房时机的选择（真TM厉害，这竟然是2010年的建议，可恨的是2020年才看到）</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E6%94%B6%E5%85%A5%E5%88%86%E9%85%8D%E6%94%B9%E9%9D%A9%E8%B7%9F%E4%BD%93%E5%88%B6%E5%A4%96%E7%9A%84%E4%BA%BA%E6%B2%A1%E5%85%B3%E7%B3%BB">收入分配改革跟体制外的人没关系</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E4%BD%93%E5%88%B6%E5%A4%96%E7%9A%84%E4%BA%BA%E8%A6%81%E6%97%A9%E6%97%A9%E8%80%83%E8%99%91%E5%85%BB%E8%80%81%E9%97%AE%E9%A2%98">体制外的人要早早考虑养老问题</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E6%B0%B8%E8%BF%9C%E4%B8%8D%E8%A6%81%E5%92%8C%E7%99%BD%E7%97%B4%E4%BA%89%E8%BE%A9%E5%9B%A0%E4%B8%BA%E4%BB%96%E4%BC%9A%E6%8A%8A%E4%BD%A0%E7%9A%84%E6%99%BA%E5%95%86%E6%8B%89%E5%88%B0%E5%92%8C%E4%BB%96%E5%90%8C%E4%B8%80%E6%B0%B4%E5%B9%B3%E7%84%B6%E5%90%8E%E7%94%A8%E4%B8%B0%E5%AF%8C%E7%9A%84%E7%BB%8F%E9%AA%8C%E6%89%93%E8%B4%A5%E4%BD%A0">永远不要和白痴争辩，因为他会把你的智商拉到和他同一水平，然后用丰富的经验打败你</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%BD%93%E4%B8%AA%E5%86%9C%E6%B0%91%E4%B9%9F%E8%A6%81%E6%87%82%E6%94%BF%E7%AD%96%E8%A6%81%E9%A1%BA%E6%94%BF%E7%AD%96%E8%80%8C%E4%B8%BA">当个农民也要懂政策，要顺政策而为</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%AD%98%E9%92%B1%E4%B8%8D%E5%A6%82%E5%AD%98%E8%B5%84%E4%BA%A7%E9%92%B1%E4%BC%9A%E8%B4%AC%E5%80%BC%E8%B5%84%E4%BA%A7%E4%BC%9A%E5%8D%87%E5%80%BC">存钱不如存资产，钱会贬值，资产会升值</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E6%88%BF%E5%AD%90%E8%B6%8A%E6%97%A9%E4%B9%B0%E8%B6%8A%E5%A5%BDzf%E6%83%B3%E9%92%B1%E6%83%B3%E7%96%AF%E4%BA%86">房子越早买越好，zf想钱想疯了</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%88%A9%E7%9B%8A%E6%89%8D%E6%98%AFzf%E8%A1%8C%E4%B8%BA%E7%9A%84%E6%8C%87%E6%8C%A5%E6%A3%92">利益才是zf行为的指挥棒</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%BB%BA%E8%AE%AE%E4%B8%80%E5%AE%9A%E6%98%AF%E5%BB%BA%E7%AB%8B%E5%9C%A8%E4%B8%A5%E8%82%83%E8%80%83%E5%AF%9F%E7%9A%84%E5%9F%BA%E7%A1%80%E4%B8%8A">建议一定是建立在严肃考察的基础上</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E7%9F%B3%E5%AE%B6%E5%BA%84">石家庄</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E6%8A%95%E8%B5%84%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84%E6%98%AF%E7%A8%80%E7%BC%BA%E6%80%A7%E4%B9%B0%E6%88%BF%E9%A6%96%E9%80%89%E5%85%AC%E5%8A%A1%E5%91%98%E5%B0%8F%E5%8C%BA">投资最重要的是稀缺性，买房首选公务员小区</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E8%BF%9C%E7%A6%BB%E5%9E%83%E5%9C%BE%E4%BA%BA">远离垃圾人</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E9%AB%98%E6%88%BF%E4%BB%B7%E6%88%96%E8%AE%B8%E6%9C%89%E5%A4%A9%E4%BC%9A%E5%B4%A9%E7%9B%98%E4%BD%86%E4%BD%A0%E7%AD%89%E4%B8%8D%E5%88%B0%E9%82%A3%E4%B8%80%E5%A4%A9">高房价或许有天会崩盘，但你等不到那一天</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E6%88%BF%E5%AD%90%E4%B8%8D%E4%BB%85%E8%A6%81%E6%97%A9%E4%B9%B0%E8%80%8C%E4%B8%94%E6%9C%89%E8%83%BD%E5%8A%9B%E7%9A%84%E8%AF%9D%E4%B8%8D%E8%A6%81%E6%80%95%E5%8E%8B%E5%8A%9B%E4%BA%89%E5%8F%96%E4%B8%80%E6%AD%A5%E5%88%B0%E4%BD%8D">房子不仅要早买，而且有能力的话不要怕压力，争取一步到位</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E9%87%91%E8%9E%8D%E6%9D%A0%E6%9D%86%E6%98%AF%E7%82%92%E6%88%BF%E8%B5%9A%E9%92%B1%E7%9A%84%E6%94%BE%E5%A4%A7%E5%99%A8">金融杠杆是炒房赚钱的放大器</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E8%A6%81%E7%94%A8%E5%8F%91%E5%B1%95%E7%9A%84%E7%9C%BC%E5%85%89%E7%9C%8B%E9%97%AE%E9%A2%98%E5%8F%AA%E8%A6%81%E5%8A%AA%E5%8A%9B%E5%8F%AA%E4%BC%9A%E8%B6%8A%E6%9D%A5%E8%B6%8A%E5%A5%BD%E8%B6%8A%E6%9D%A5%E8%B6%8A%E8%BD%BB%E6%9D%BE">要用发展的眼光看问题，只要努力，只会越来越好，越来越轻松</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E6%80%A7%E6%A0%BC%E5%86%B3%E5%AE%9A%E5%91%BD%E8%BF%90">性格决定命运</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#2012%E5%B9%B4%E4%B8%8D%E5%8F%96%E6%B6%88%E8%B0%83%E6%8E%A7%E8%BF%98%E6%9C%89%E6%88%BF%E4%BB%B7%E7%BB%B4%E7%A8%B3%E9%A1%BA%E5%88%A9%E6%8D%A2%E5%B1%8A%E8%80%83%E8%99%91">2012年不取消调控，还有房价维稳顺利换届考虑</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E6%B4%BC%E5%9C%B0%E6%9C%80%E7%BB%88%E9%83%BD%E4%BC%9A%E8%A2%AB%E5%A1%AB%E5%B9%B3%E5%A4%9A%E6%95%B0%E5%9F%8E%E5%B8%82%E6%98%AF%E6%97%A9%E4%B9%B0%E8%83%9C%E4%BA%8E%E6%99%9A%E4%B9%B0">洼地最终都会被填平，多数城市是早买胜于晚买</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E8%A5%BF%E9%83%A8">西部</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E7%9F%AD%E6%9C%9F%E6%B3%A2%E5%8A%A8%E5%B1%9E%E4%BA%8E%E6%AD%A3%E5%B8%B8%E7%8E%B0%E8%B1%A1%E9%9C%80%E8%A6%81%E5%85%B3%E6%B3%A8%E7%9A%84%E6%98%AF%E9%95%BF%E6%9C%9F%E8%B6%8B%E5%8A%BF">短期波动属于正常现象，需要关注的是长期趋势</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E9%A2%86%E5%AF%BC%E4%BA%BA%E7%9A%84%E6%99%BA%E6%85%A7%E5%92%8C%E6%89%8D%E5%B9%B2%E5%86%B3%E5%AE%9A%E4%BA%86%E5%9B%BD%E5%AE%B6%E7%9A%84%E5%91%BD%E8%BF%90%E7%BB%9F%E5%B8%85%E7%9A%84%E6%99%BA%E6%85%A7%E5%92%8C%E6%89%8D%E5%B9%B2%E5%86%B3%E5%AE%9A%E4%BA%86%E5%86%9B%E9%98%9F%E7%9A%84%E5%91%BD%E8%BF%90%E8%80%8C%E4%B8%AA%E4%BA%BA%E7%9A%84%E6%99%BA%E6%85%A7%E5%92%8C%E6%89%8D%E5%B9%B2%E5%86%B3%E5%AE%9A%E4%BA%86%E4%B8%AA%E4%BA%BA%E7%9A%84%E5%91%BD%E8%BF%90">领导人的智慧和才干决定了国家的命运，统帅的智慧和才干决定了军队的命运，而个人的智慧和才干决定了个人的命运</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%AF%B9%E4%BA%8E%E5%85%B7%E5%A4%87%E6%8A%95%E8%B5%84%E5%B1%9E%E6%80%A7%E7%9A%84%E5%95%86%E5%93%81%E4%BE%9B%E6%B1%82%E5%85%B3%E7%B3%BB%E6%98%AF%E6%8C%87%E8%B4%A7%E5%B8%81%E4%B8%8E%E5%95%86%E5%93%81%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB">对于具备投资属性的商品，供求关系是指货币与商品之间的关系</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E6%97%A9%E4%B9%B0%E7%9A%84%E9%A3%8E%E9%99%A9%E5%B0%8F%E4%BA%8E%E6%99%9A%E4%B9%B0">早买的风险小于晚买</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%B0%8F%E5%BC%80%E5%8F%91%E5%95%86%E7%9A%84%E6%88%BF%E5%AD%90%E8%83%BD%E4%B8%8D%E8%83%BD%E4%B9%B0">小开发商的房子能不能买？</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%A4%A7%E5%85%B4%E5%9C%9F%E6%9C%A8%E6%90%9E%E5%BB%BA%E8%AE%BE%E7%9A%84%E5%9F%8E%E5%B8%82%E6%88%BF%E4%BB%B7%E9%83%BD%E5%BA%95%E4%B8%8D%E4%BA%86">大兴土木搞建设的城市，房价都底不了</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%8C%97%E4%BA%AC%E8%80%81%E5%BC%8F%E7%A0%96%E6%B7%B7%E6%9D%BF%E6%A5%BC%E7%9A%84%E6%9C%80%E7%BB%88%E5%91%BD%E8%BF%90">北京老式砖混板楼的最终命运？</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E6%8A%8A%E6%88%BF%E4%B9%B0%E5%9C%A8zf%E8%BE%B9%E5%B7%AE%E4%B8%8D%E4%BA%86">把房买在zf边，差不了</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%A4%A9%E5%AD%90%E8%84%9A%E4%B8%8B%E4%BA%8C%E6%89%8B%E8%80%81%E6%88%BF%E4%B9%B0%E5%BE%97%E5%A5%BD%E6%8B%86%E8%BF%81%E8%A1%A5%E5%81%BF%E5%B0%91%E4%B8%8D%E4%BA%86">天子脚下：二手老房买得好，拆迁补偿少不了</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#3%E4%B8%87%E5%85%A5%E6%89%8B%E5%8C%97%E4%BA%AC%E5%9B%9B%E7%8E%AF%E4%BD%A0%E4%B9%9F%E6%98%AF%E5%B9%B8%E8%BF%90%E7%9A%84">3万入手北京四环，你也是幸运的</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%90%9B%E4%B8%BA%E8%B4%B5%E5%95%86%E4%BA%BA%E6%8A%80%E5%B7%A5%E6%AC%A1%E4%B9%8B%E5%86%9C%E6%B0%91%E4%B8%BA%E8%BD%BB%E6%89%93%E5%B7%A5%E4%BA%BA%E4%B8%BA%E5%BA%95">君为贵，商人、技工次之，农民为轻，打工人为底</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#10%E5%B9%B4%E7%9A%84%E8%B0%83%E6%8E%A7%E5%92%8C08%E5%B9%B4%E8%B0%83%E6%8E%A7%E7%9A%84%E5%8C%BA%E5%88%AB%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%BD%B1%E5%93%8D%E6%9C%BA%E4%BC%9A">10年的调控和08年调控的区别、带来的影响、机会</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%8E%86%E5%8F%B2%E6%80%BB%E6%98%AF%E6%83%8A%E4%BA%BA%E7%9A%84%E7%9B%B8%E4%BC%BC">历史总是惊人的相似</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%85%B3%E4%BA%8E%E6%88%BF%E8%B4%B7">关于房贷</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E4%B9%B0%E5%8D%96%E5%95%86%E5%93%81%E6%88%BF%E4%BC%9A%E9%80%90%E6%B8%90%E5%8F%98%E6%88%90%E5%AF%8C%E4%BA%BA%E7%9A%84%E6%B8%B8%E6%88%8F">买卖商品房会逐渐变成富人的游戏</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#zf%E8%BF%98%E6%98%AF%E6%9B%B4%E5%9C%A8%E6%84%8F%E5%86%9C%E6%B0%91%E9%97%AE%E9%A2%98">zf还是更在意农民问题</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E6%B2%BB%E5%9B%BD%E9%9C%80%E8%A6%81%E7%94%A8%E8%B4%AA%E5%AE%98%E5%8F%8D%E8%B4%AA%E5%AE%98">治国需要用贪官、反贪官</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E4%BA%8C%E7%BA%BF%E5%9F%8E%E5%B8%82%E5%85%B8%E5%9E%8B%E4%BB%A3%E8%A1%A8">二线城市典型代表</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%85%B3%E4%BA%8E%E5%95%86%E9%93%BA%E5%92%8C%E4%BD%8F%E5%AE%85%E6%8A%95%E8%B5%84">关于商铺和住宅投资</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%85%B3%E4%BA%8E%E6%88%BF%E4%BA%A7%E8%B0%83%E6%8E%A7">关于房产调控</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%85%B3%E4%BA%8E%E6%88%BF%E4%BA%A7%E7%A8%8E">关于房产税</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E8%80%81%E5%85%AC%E6%88%BF%E7%9A%84%E6%8B%86%E8%BF%81%E9%97%AE%E9%A2%98">老公房的拆迁问题</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E6%8A%95%E8%B5%84%E6%96%B0%E6%88%BF%E8%BF%98%E6%98%AF%E8%80%81%E5%85%AC%E6%88%BF">投资新房还是老公房</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E9%AB%98%E7%AB%AF%E7%9B%98%E6%9C%89%E6%88%BF%E4%BB%B7%E5%B8%A6%E5%8A%A8%E4%BD%9C%E7%94%A8">高端盘有房价带动作用</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E4%B9%B0%E6%88%BF%E5%92%8C%E6%B2%A1%E4%B9%B0%E6%88%BF%E7%9A%84%E5%B7%AE%E8%B7%9D">买房和没买房的差距</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E6%88%BF%E4%BA%A7%E4%BA%A4%E6%98%93%E5%8E%86%E5%8F%B2">房产交易历史</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%A5%91%E7%A8%8E%E7%9A%84%E5%8E%86%E5%8F%B2">契税的历史</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%BB%89%E7%A7%9F%E6%88%BF%E7%9A%84%E5%8E%86%E5%8F%B2">廉租房的历史</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%8E%86%E5%8F%B2%E4%B8%8A%E4%B9%B0%E6%88%BF%E6%9C%80%E5%A5%BD%E7%9A%84%E6%9C%9D%E4%BB%A3">历史上买房最好的朝代</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E6%9C%AA%E6%9D%A5%E6%88%BF%E5%9C%B0%E4%BA%A7%E5%B8%82%E5%9C%BA%E7%9A%84%E5%8F%91%E5%B1%95">未来房地产市场的发展</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E6%88%BF%E4%BA%A7%E5%88%B0%E6%9C%9F">房产到期</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E4%B9%B0%E5%AD%A6%E5%8C%BA%E6%88%BF%E9%97%AE%E9%A2%98">买学区房问题</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%8E%86%E5%8F%B2%E7%9A%84%E7%BB%93%E5%B1%80">历史的结局</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E4%BA%BA%E5%8F%A3%E6%99%AE%E6%9F%A5">人口普查</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E6%98%86%E5%B1%B1%E6%88%BF%E4%BB%B7%E5%88%86%E6%9E%90%E4%B8%8E%E4%B9%B0%E6%88%BF">昆山房价分析与买房</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%8E%B0%E5%9C%A8%E7%A7%9F%E5%94%AE%E6%AF%94%E8%BF%99%E4%B9%88%E4%BD%8E%E2%80%94%E5%90%8C%E5%B0%8F%E5%8C%BA%E4%B9%B0%E4%B8%80%E5%A5%97%E5%A4%A7%E8%BF%98%E6%98%AF%E4%B8%A4%E5%A5%97%E5%B0%8F">为什么现在租售比这么低 &amp; 同小区买一套大还是两套小</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E4%B9%B0%E6%88%BF%E9%9A%BE%E4%B9%8B%E5%9B%9E%E4%B8%8D%E5%8E%BB%E7%9A%84%E4%B9%A1%E2%80%94%E6%8B%89%E7%BE%8E%E4%BA%BA%E8%BF%87%E5%BE%97%E6%AF%94%E4%BD%A0%E6%83%B3%E8%B1%A1%E7%9A%84%E5%A5%BD">买房难之回不去的乡 &amp; 拉美人过得比你想象的好</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E7%A7%9F%E6%88%BF%E7%9A%84%E8%8B%A6">租房的苦</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%8C%97%E4%BA%AC%E8%A5%BF%E4%B8%89%E6%97%97">北京西三旗</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E4%B9%B0%E6%88%BF%E4%BA%89%E5%8F%96%E4%B8%80%E6%AD%A5%E5%88%B0%E4%BD%8D">买房争取一步到位</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E6%94%B6%E5%85%A5%E7%A8%B3%E5%AE%9A%E7%9A%84%E5%AE%B6%E5%BA%AD%E5%A6%82%E4%BD%95%E4%B9%B0%E6%88%BF">收入稳定的家庭如何买房</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%8C%97%E4%BA%AC%E5%9B%9E%E9%BE%99%E8%A7%82">北京回龙观</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E8%B4%B7%E6%AC%BE%E8%BF%98%E6%98%AF%E5%85%A8%E6%AC%BE">贷款还是全款</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#00%E5%90%8E%E7%9A%84%E4%B9%B0%E6%88%BF%E9%9C%80%E6%B1%82%E4%BB%8E%E4%BD%95%E8%80%8C%E6%9D%A5">00后的买房需求从何而来</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E6%84%8F%E5%A4%A7%E5%88%A9%E7%9A%84%E4%BD%8F%E6%88%BF%E6%A8%A1%E5%BC%8F">意大利的住房模式</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E4%B8%AD%E5%9B%BD%E7%9A%84%E5%AD%A6%E6%9C%AF">中国的学术</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%8C%97%E4%BA%AC%E8%BF%9C%E6%B4%8B%E5%B1%B1%E6%B0%B4">北京远洋山水</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E7%B2%BE%E8%8B%B1%E7%9A%84%E8%B5%84%E4%BA%A7">精英的资产</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%8C%97%E4%BA%AC%E4%B8%89%E7%8E%AF%E5%A1%94%E6%A5%BC">北京三环塔楼</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E6%99%AE%E9%80%9A%E4%BA%BA%E4%B9%B0%E6%88%BF%E7%9A%84%E6%9C%AA%E6%9D%A5">普通人买房的未来</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%8C%97%E4%BA%AC%E6%88%BF%E4%BB%B7%E8%B6%85%E9%A6%99%E6%B8%AF">北京房价超香港</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E4%B8%AD%E5%9B%BD%E7%9A%84%E6%96%B0%E9%97%BB%E4%B8%8D%E5%8F%AF%E4%BF%A1%E7%B2%BE%E8%8B%B1%E7%9A%84%E6%9C%89%E9%92%B1%E6%98%AF%E4%BD%A0%E6%83%B3%E8%B1%A1%E4%B8%8D%E5%88%B0%E7%9A%84">中国的新闻不可信，精英的有钱是你想象不到的</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#40%E5%B9%B4%E7%9A%84%E5%95%86%E4%BD%8F%E6%88%BF%E6%B2%A1%E6%9C%8970%E5%B9%B4%E7%9A%84%E4%BD%8F%E5%AE%85%E6%9C%89%E6%8A%95%E8%B5%84%E4%BB%B7%E5%80%BC">40年的商住房没有70年的住宅有投资价值</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E9%99%90%E8%B4%B7%E5%AF%B9%E7%B2%BE%E8%8B%B1%E6%B2%A1%E7%94%A8">限贷对精英没用</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%A4%96%E6%B1%87%E7%AE%A1%E5%88%B6%E5%86%B3%E5%AE%9A%E4%BA%86%E5%A4%A7%E9%83%A8%E5%88%86%E6%9C%89%E9%92%B1%E4%BA%BA%E5%8F%AA%E8%83%BD%E5%9C%A8%E5%9B%BD%E5%86%85%E6%8A%95%E8%B5%84">外汇管制决定了大部分有钱人只能在国内投资</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%A4%96%E5%9B%BD%E5%9B%BD%E7%B1%8D%E5%9C%A8%E4%B8%AD%E5%9B%BD%E7%94%9F%E6%B4%BB%E6%98%AF%E6%9B%B4%E5%A5%BD%E7%9A%84%E9%80%89%E6%8B%A9">外国国籍在中国生活是更好的选择</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%88%86%E6%9C%9F%E4%BB%98%E6%AC%BE%E4%B9%B0%E6%88%BF%E5%A6%82%E6%9E%9C%E6%88%BF%E4%BB%B7%E4%B8%8A%E6%B6%A8%E5%BE%88%E5%AE%B9%E6%98%93%E6%AF%81%E7%BA%A6--%E8%87%AA%E4%BD%8F%E8%A6%81%E9%80%89%E5%A4%A7%E5%93%81%E7%89%8C%E5%BC%80%E5%8F%91%E5%95%86">分期付款买房，如果房价上涨，很容易毁约 &amp; 自住要选大品牌开发商</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E9%80%9A%E8%B4%A7%E8%86%A8%E8%83%80%E5%92%8C%E6%88%BF%E4%BB%B7%E7%9A%84%E5%85%B3%E7%B3%BB">通货膨胀和房价的关系</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%8D%97%E4%BA%AC%E4%B9%B0%E6%88%BF%E5%88%86%E6%9E%90--%E4%B9%B0%E6%88%BF%E8%A6%81%E5%81%9A%E5%A5%BD%E8%B0%83%E6%9F%A5%E5%88%86%E6%9E%90%E5%B7%A5%E4%BD%9C">南京买房分析 &amp; 买房要做好调查分析工作</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%8C%97%E4%BA%AC%E5%8D%8E%E6%B8%85%E5%98%89%E5%9B%AD">北京华清嘉园</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E4%B8%AD%E5%9B%BD%E7%9A%84%E6%9C%9D%E4%BB%A3%E6%9B%B4%E6%9B%BF">中国的朝代更替</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E4%B8%AD%E5%9B%BD%E5%8F%AF%E4%BB%A5%E6%97%A0%E9%99%90%E5%8D%B0%E9%92%9E%E5%90%97">中国可以无限印钞吗</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E8%AF%BB%E5%8F%B2%E8%AF%BB%E7%9A%84%E4%B8%8D%E6%98%AF%E6%95%85%E4%BA%8B%E8%BF%98%E6%98%AF%E6%89%BE%E5%8E%86%E5%8F%B2%E8%A7%84%E5%BE%8B%E4%BB%A5%E5%8F%A4%E9%89%B4%E4%BB%8A">读史读的不是故事，还是找历史规律，以古鉴今</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E6%AF%9B%E5%A4%AA%E9%98%B3%E5%BE%80%E4%BA%8B">毛太阳往事</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%8C%97%E4%BA%AC%E5%A4%A7%E5%85%B4">北京大兴</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E8%B4%B5%E9%98%B3">贵阳</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%AF%8C%E4%BA%BA%E8%B6%8A%E5%AF%8C%E7%A9%B7%E4%BA%BA%E8%B6%8A%E7%A9%B7">富人越富、穷人越穷</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E9%80%9A%E8%B4%A7%E8%86%A8%E8%83%80%E7%9A%84%E5%BD%A2%E6%88%90%E5%8E%9F%E5%9B%A0">通货膨胀的形成原因</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E6%B7%B1%E5%9C%B3--%E6%98%86%E6%98%8E%E4%BB%87%E4%B9%A6%E8%AE%B0%E2%80%94-%E9%80%9A%E8%B4%A7%E8%86%A8%E8%83%80%E4%BD%93%E5%88%B6%E5%86%85%E9%AB%98%E6%9E%95%E6%97%A0%E5%BF%A7%E4%BD%93%E5%88%B6%E5%A4%96%E8%87%AA%E6%B1%82%E5%A4%9A%E7%A6%8F">深圳 &amp; 昆明仇书记 &amp; 通货膨胀体制内高枕无忧、体制外自求多福</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E9%95%BF%E6%98%A5">长春</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E4%BD%9B%E5%B1%B1">佛山</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E9%A6%96%E4%BB%98%E6%8F%90%E9%AB%98%E7%9A%84%E9%80%BB%E8%BE%91">首付提高的逻辑</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%9B%9B%E7%BA%BF%E5%9F%8E%E5%B8%82">四线城市</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E8%8B%8F%E5%B7%9E%E5%B7%A5%E4%B8%9A%E5%9B%AD">苏州工业园</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E4%BD%8F%E6%88%BF%E5%85%AC%E7%A7%AF%E9%87%91%E5%88%A9%E7%8E%87">住房公积金利率</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E6%B5%8E%E5%8D%97--%E5%A4%A7%E8%A7%84%E5%BE%8B%E6%8B%86%E8%BF%81%E7%9A%84%E5%9F%8E%E5%B8%82%E6%88%BF%E4%BB%B7%E4%B8%8D%E4%BC%9A%E4%B8%8B%E9%99%8D">济南 &amp; 大规律拆迁的城市房价不会下降</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%85%AC%E5%8A%A1%E5%91%98%E5%B0%8F%E5%8C%BA%E7%89%9B%E9%80%BC">公务员小区牛逼</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E6%88%BF%E5%B1%8B%E6%9C%9D%E5%90%91%E5%8F%AA%E8%A6%81%E4%B8%8D%E6%98%AF%E7%BA%AF%E5%8C%97%E8%A5%BF%E5%B0%B1%E8%A1%8C--%E4%B9%B0%E6%88%BF%E9%A6%96%E9%80%89%E5%B8%82%E4%B8%AD%E5%BF%83%E5%85%AC%E5%9B%AD%E5%9C%B0%E4%BA%A7">房屋朝向只要不是纯北西就行 &amp; 买房首选市中心、公园地产</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#zf%E6%90%AC%E8%BF%81">zf搬迁</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E4%BF%84%E7%BD%97%E6%96%AF">俄罗斯</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E7%8F%A0%E6%B5%B7--%E5%94%AF%E4%B8%80%E8%87%AA%E4%BD%8F%E6%88%BF%E4%B8%8D%E5%8F%AA%E6%98%AF%E6%8A%95%E8%B5%84--%E8%B0%83%E6%8E%A7%E6%98%AF%E6%9C%80%E4%BD%B3%E7%9A%84%E9%80%89%E6%88%BF%E6%97%B6%E6%9C%BA">珠海 &amp; 唯一自住房不只是投资 &amp; 调控是最佳的选房时机</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E7%BB%8F%E6%B5%8E%E5%B4%A9%E6%BA%83%E6%9C%80%E5%90%8E%E6%8E%A5%E7%9B%98%E7%9A%84%E6%98%AF%E8%80%81%E7%99%BE%E5%A7%93">经济崩溃，最后接盘的是老百姓</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%91%BD%E8%BF%90%E4%B9%8B%E7%9F%9B">命运之矛</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E9%99%A4%E9%9D%9E%E5%A4%96%E6%97%8F%E5%85%A5%E4%BE%B5%E6%88%96%E5%85%A8%E5%9B%BD%E5%A4%A7%E9%A5%A5%E8%8D%92%EF%BC%8C%E5%90%A6%E5%88%99%E5%8F%8C%E8%BD%A8%E5%88%B6%E5%86%B3%E5%AE%9A%E4%BA%86%E6%88%BF%E4%BB%B7%E4%B8%8D%E4%BC%9A%E5%B4%A9%E7%9B%98">除非外族入侵或全国大饥荒，否则双轨制决定了房价不会崩盘</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#kkndme%E8%81%8A%E5%8C%97%E5%AE%8B%E5%94%90%E6%9C%9D">kkndme聊北宋、唐朝</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%AE%8B%E4%BB%A3%E6%88%BF%E5%A5%B4">宋代房奴</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#ZG%E6%B0%91%E4%B8%BB">ZG民主</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E7%8E%8B%E5%AE%89%E7%9F%B3%E7%9A%84%E9%9D%92%E8%8B%97%E6%B3%95%E4%B9%8B%E5%9B%BD%E5%AE%B6%E5%87%BA%E6%94%BF%E7%AD%96%E7%9A%84%E5%8A%A8%E6%9C%BA">王安石的青苗法之国家出政策的动机</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E4%BB%80%E4%B9%88%E6%98%AF%E7%A4%BE%E4%BC%9A%E5%85%AC%E5%B9%B3">什么是社会公平</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E8%BF%98%E6%98%AF%E6%9C%89%E5%BE%88%E5%A4%9A%E6%9C%89%E9%92%B1%E4%BA%BA">还是有很多有钱人</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%8F%8C%E8%BD%A8%E5%88%B6%E4%B9%8B%E4%BD%93%E5%88%B6%E5%86%85%E7%9A%84%E7%A6%8F%E5%88%A9">双轨制之体制内的福利</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%BC%80%E5%8F%91%E5%95%86%E6%80%9D%E7%BB%B4">开发商思维</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%86%9C%E6%B0%91%E6%94%BF%E6%9D%83%E7%9A%84%E7%BC%BA%E7%82%B9">农民政权的缺点</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E9%83%91%E5%B7%9E%E6%9C%89%E5%89%8D%E6%99%AF">郑州有前景</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%85%AC%E5%9B%AD%E5%9C%B0%E4%BA%A7%E6%98%AF%E7%A8%80%E7%BC%BA%E8%B5%84%E6%BA%90">公园地产是稀缺资源</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%BC%A0%E7%8C%AE%E5%BF%A0%E5%B1%A0%E5%B7%9D">张献忠屠川</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E6%B4%AA%E7%A7%80%E5%85%A8%E9%BB%84%E5%B7%A2%E6%9D%8E%E8%87%AA%E6%88%90">洪秀全、黄巢、李自成</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E6%9C%B1%E5%85%83%E7%92%8B">朱元璋</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E6%9B%B9%E5%8F%82%E6%B2%BB%E5%9B%BD">曹参治国</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E6%99%81%E9%94%99">晁错</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E6%B0%91%E8%90%A5%E5%B0%8F%E4%BC%81%E4%B8%9A%E7%9A%84%E8%80%81%E6%9D%BF%E5%92%8C%E6%89%93%E5%B7%A5%E8%80%85">民营小企业的老板和打工者</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E9%83%AD%E8%A7%A3">郭解</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#2010%E5%B9%B4%E7%9A%84%E4%B8%AD%E5%9B%BD%E6%88%BF%E5%9C%B0%E4%BA%A7">2010年的中国房地产</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E6%88%BF%E5%A5%B4%E7%AE%97%E4%B8%8D%E4%B8%8A%E4%B8%8D%E5%B9%B8%E7%9B%B8%E5%BD%93%E5%BD%93%E4%B8%8D%E4%BA%86%E6%89%8D%E7%AE%97">房奴算不上不幸，相当当不了才算</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E7%B2%BE%E8%8B%B1%E4%BA%BA%E7%BE%A4%E7%9A%84%E5%B9%B3%E5%9D%87%E6%94%B6%E5%85%A5%E5%86%B3%E5%AE%9A%E6%88%BF%E4%BB%B7">精英人群的平均收入决定房价</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%86%85%E5%9C%B0%E4%B8%8D%E6%98%AF%E9%A6%99%E6%B8%AF%E6%B5%B7%E5%8D%97">内地不是香港、海南</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%8E%86%E5%8F%B2%E6%98%AF%E4%B8%80%E9%9D%A2%E9%95%9C%E5%AD%90">历史是一面镜子</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E4%B9%B0%E6%88%BF%E4%B8%80%E6%AC%A1%E6%80%A7%E5%88%B0%E4%BD%8D%E6%AF%94%E8%BE%83%E5%A5%BD">买房一次性到位比较好</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%A4%96%E6%B1%87%E7%AE%A1%E5%88%B6">外汇管制</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E4%B8%80%E7%BA%BF%E5%92%8C%E4%BA%8C%E7%BA%BF">一线和二线</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%90%95%E5%90%8E%E7%AF%A1%E6%9D%83">吕后篡权</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%B0%8F%E4%BA%A7%E6%9D%83%E6%88%BF">小产权房</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%95%86%E9%93%BA%E5%92%8C%E4%BD%8F%E5%AE%85">商铺和住宅</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E4%BD%93%E5%88%B6%E5%86%85%E5%A4%96">体制内外</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#2010%E5%B9%B4%E7%9A%84%E4%B8%8A%E6%B5%B7">2010年的上海</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E4%B9%B0%E6%88%BF%E7%89%A9%E4%B8%9A%E4%B8%8E%E6%88%BF%E8%B4%B7">买房：物业与房贷</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E6%94%B6%E7%B4%A7%E4%BD%8F%E6%88%BF%E8%B4%B7%E6%AC%BE">收紧住房贷款</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E4%B9%B0%E6%88%BF%E7%89%A9%E4%B8%9A%E4%B8%8E%E6%88%BF%E8%B4%B7">买房：物业与房贷</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%A5%B8%E8%87%A3%E8%94%A1%E4%BA%AC">奸臣蔡京</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E4%BD%93%E5%88%B6%E5%86%85%E7%9A%8428%E5%8E%9F%E5%88%99">体制内的28原则</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E8%B4%BE%E8%B0%8A">贾谊</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#kkndme-%E6%8E%A8%E8%8D%90%E7%9A%84%E5%8E%86%E5%8F%B2%E4%B9%A6">kkndme 推荐的历史书</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%B9%B4%E8%BD%BB%E4%BA%BA%E8%A6%81%E6%97%A9%E4%B9%B0%E6%88%BF">年轻人要早买房</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E4%B8%8D%E8%A6%81%E4%BD%8E%E4%BC%B0%E9%80%9A%E8%B4%A7%E8%86%A8%E8%83%80">不要低估通货膨胀</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E4%BA%8C%E4%B8%89%E7%BA%BF%E5%9F%8E%E5%B8%82%E4%B8%8E%E9%87%8D%E5%BA%86">二三线城市与重庆</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%9F%8E%E5%8C%BA%E5%92%8C%E9%83%8A%E5%8C%BA">城区和郊区</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%AE%88%E7%9D%80%E9%87%91%E7%A2%97%E8%A6%81%E9%A5%AD%E5%90%83">守着金碗要饭吃</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E4%BA%BA%E5%88%B6%E7%9A%84%E7%A4%BE%E4%BC%9A%E4%BA%BA%E5%B0%B1%E6%98%AF%E5%88%B6%E5%BA%A6">人制的社会，人就是制度</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%87%86%E5%85%AC%E5%8A%A1%E5%91%98%E7%9A%84%E5%A5%BD%E5%A4%84">准公务员的好处</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%B0%8F%E5%9F%8E%E5%B8%82%E6%88%BF%E4%BB%B7%E4%BC%9A%E5%9B%A0%E4%B8%BA%E4%BA%BA%E6%B0%91%E5%B8%81%E8%B4%AC%E5%80%BC%E6%B6%A8%E4%BB%B7%E4%BD%86%E4%BE%9D%E7%84%B6%E9%9A%BE%E5%8F%98%E7%8E%B0">小城市房价会因为人民币贬值涨价，但依然难变现</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E4%B8%80%E7%BA%BF%E6%9D%AD%E5%B7%9E">一线杭州</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E4%BA%8C%E4%B8%89%E7%BA%BF%E5%9F%8E%E5%B8%82%E7%9A%84%E5%8F%91%E5%B1%95%E9%9D%A0%E6%8B%86%E8%BF%81">二三线城市的发展靠拆迁</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E8%BD%AC%E7%AF%87%E6%96%87%E7%AB%A0%E4%B8%80%E4%B8%AA%E5%BF%BD%E6%82%A0%E4%BA%86%E5%87%A0%E4%BA%BF%E4%B8%AD%E5%9B%BD%E4%BA%BA%E7%9A%84%E4%BC%AA%E6%A6%82%E5%BF%B5%E6%89%80%E8%B0%93%E4%B8%AD%E5%9B%BD%E6%88%BF%E5%9C%B0%E4%BA%A7%E6%B3%A1%E6%B2%AB">转篇文章：一个忽悠了几亿中国人的伪概念：所谓“中国房地产泡沫”</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E6%8B%86%E8%BF%81%E8%A1%A5%E5%81%BF">拆迁补偿</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%9F%8E%E5%B8%82%E5%BA%95%E5%B1%82">城市底层</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%9E%84%E6%96%AD%E4%BC%81%E4%B8%9A">垄断企业</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%86%9C%E6%9D%91%E8%87%AA%E6%9D%A5%E6%B0%B4">农村自来水</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E8%A2%81%E7%9B%8E">袁盎</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E4%BA%8C%E4%B8%89%E7%BA%BF%E5%9F%8E%E5%B8%82%E9%80%89%E6%96%B0%E5%9F%8E%E8%BF%98%E6%98%AF%E8%80%81%E5%9F%8E">二三线城市，选新城还是老城</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E5%9C%A8%E4%B8%AD%E5%9B%BD%E6%99%AE%E9%80%9A%E4%BA%BA%E6%89%8B%E4%B8%8A%E9%97%B2%E9%92%B1%E4%B8%8D%E5%A4%9A%E7%9A%84%E4%BA%BA%E8%A2%AB%E5%89%A5%E5%89%8A">在中国，普通人手上闲钱不多的人被剥削</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E4%B8%89%E5%88%86%E5%A4%A9%E6%B3%A8%E5%AE%9A%E4%B8%83%E5%88%86%E9%9D%A0%E6%89%93%E6%8B%BC">三分天注定七分靠打拼</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E4%BA%BA%E7%9A%84%E5%89%8D%E7%A8%8B%E6%9C%89%E7%9A%84%E6%97%B6%E5%80%99%E4%B8%8D%E6%8E%8C%E6%8F%A1%E5%9C%A8%E8%87%AA%E5%B7%B1%E6%89%8B%E9%87%8C">人的前程有的时候不掌握在自己手里</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E6%B2%B3%E5%8D%97%E9%83%91%E5%B7%9E%E4%B8%8E%E6%B4%9B%E9%98%B3">河南郑州与洛阳</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E6%9D%AD%E5%B7%9E">杭州</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E8%A5%BF%E5%AE%89-%E4%B8%8E-%E9%87%8D%E5%BA%86">西安与重庆</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E8%B0%A2%E5%9B%BD%E4%B8%AD%E7%A9%BA%E7%BD%AE%E7%8E%87">谢国中「空置率」</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E6%89%93%E5%B7%A5%E4%B8%8D%E5%A6%82%E6%9C%89%E4%B8%80%E6%8A%80%E4%B9%8B%E9%95%BF%E7%9A%84%E5%B0%8F%E8%80%81%E6%9D%BF">打工不如有一技之长的小老板</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E4%B8%80%E7%BA%BF%E4%BA%8C%E7%BA%BF%E7%9A%84%E7%94%9F%E6%B4%BB">一线、二线的生活</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E8%AE%B2%E6%95%85%E4%BA%8B%E5%90%AB%E6%B2%99%E5%B0%84%E5%BD%B1ZG%E4%B9%8B%E6%88%BF%E5%AD%90%E4%B8%8D%E5%B1%9E%E4%BA%8E%E5%B8%82%E5%9C%BA%E7%BB%8F%E6%B5%8E">讲故事含沙射影ZG之房子不属于市场经济</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A5%BD%E7%9A%84%E6%94%BF%E7%AD%96">什么是好的政策</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E6%9D%8E%E5%95%86%E9%9A%90%E6%B8%A3%E7%94%B7%E7%A5%96%E5%B8%88%E7%88%B7">李商隐「渣男」祖师爷</a></li><li><a href="https://github.com/shengcaishizhan/kkndme_tianya#%E8%A5%BF%E4%BA%94%E7%8E%AF%E5%86%85%E7%9A%84%E5%88%AB%E5%A2%85%E6%98%AF%E7%9B%B8%E5%BD%93%E7%A8%80%E7%BC%BA%E7%9A%84%E8%B5%84%E6%BA%90">西五环内的别墅，是相当稀缺的资源</a></li></ul><span id="more"></span><h2 id="调控降房价是刚需的一厢情愿"><a href="#调控降房价是刚需的一厢情愿" class="headerlink" title="调控降房价是刚需的一厢情愿"></a>调控降房价是刚需的一厢情愿</h2><p>2010年的房地产调控，让很多人看到了希望：让房价降得再猛烈些吧。还有人更是幸灾乐祸似的呼喊：让房地产赶紧崩盘吧。让没房子的好好看看有房子的笑话，是人生的一大快事。</p><p>但是我们是不是要仔细想想，为什么调控？调控期望得到什么样的效果？</p><ol><li>是如千千万万想买房子的人期望的那样，让人人买的起房吗？</li><li>是如千千万万的流氓无产者期望的那样，让房地产崩盘，开发商上吊，dfzf不再靠卖地实现gdp吗？</li></ol><p>2010年房价下跌已经变成了人民最急切的期望，已经高过了解决超贫困家庭的温饱问题，已经超过了子女教育，医疗和养老。并且为房地产必须下降提出了若干义正言辞理由，总结下来无外乎三条：</p><ol><li>人人都有居住权。房子是用来住的，不是用来炒的。</li><li>房子太贵了，租售比严重不合理，空置率太高，人均收入太低，早晚要崩盘。</li><li>房价上涨造成物价上涨，人民生活变得困难。</li></ol><p>的确，当经济过热，房价过高，会对经济运行和社会安定带来较高的风险。这也是国家所担忧的。防范金融风险，一切维稳才是zy考虑的重中之中。</p><p>而民间所总结的三条，应该和调控的原因和目的基本不沾边。让我们一条一条的分析一下：</p><h3 id="1、人人都有居住权。房子是用来住的，不是用来炒的"><a href="#1、人人都有居住权。房子是用来住的，不是用来炒的" class="headerlink" title="1、人人都有居住权。房子是用来住的，不是用来炒的"></a>1、人人都有居住权。房子是用来住的，不是用来炒的</h3><p>其实这是一个伪命题。房子包括房屋及房屋所属的土地两个部分。房屋本身只有居住价值；而土地所具备稀缺性，决定了土地的投资价值。房地产贵的不是房屋，而是房屋下面那块地皮。所以商品房具备了投资与自住双重属性。</p><p>任志强说的并没有错，居者有其屋并不等于人人享有商品房的产权。居住的房屋也不等于商品房。</p><blockquote><p><strong>liougehooa：</strong></p><p>“任志强说的并没有错，居者有其屋并不等于人人享有商品房的产权。居住的房屋也不等于商品房。” 任志强这句话绝对没说炒房价，房子在他眼里还是住的。 难道你用byt是你老er比较稀缺才买？那也没看见byt暴涨到5W一个。 ”而土地所具备稀缺性？“任志强也说了，拿出全国耕地的1%也够老百姓住了！现在是啥科技了，舍掉1%耕地对农作物有什么影响？</p><p><strong>kkndme：</strong></p><p>华北平原从河北到山东有大片的盐碱地，你都可以用于盖房，而且会非常便宜，也没有人跟你竞价。但是你在那里盖了房子并不能保证你天天按时在北京城区上班。</p></blockquote><h3 id="2、房子太贵了，租售比严重不合理，空置率太高，人均收入太低，早晚要崩盘"><a href="#2、房子太贵了，租售比严重不合理，空置率太高，人均收入太低，早晚要崩盘" class="headerlink" title="2、房子太贵了，租售比严重不合理，空置率太高，人均收入太低，早晚要崩盘"></a>2、房子太贵了，租售比严重不合理，空置率太高，人均收入太低，早晚要崩盘</h3><p>这个问题比较大。房价是不是太贵了？有没有泡沫？</p><p>我们首先从国民的收入结构来分析</p><p>一个遵从“丛林法则”的精英社会决定了国民收入的金字塔结构。</p><p>既然是金字塔，底端的中低收入者占据了金子塔的最大比例，但是大家要知道金字塔的顶端既使只有10%人口，那也将是一个1亿多的绝对庞大的数字，远远超过了绝大多数西方国家的人口总和。</p><p>而北上广深以及三十多个省会，这些个靠掠夺全国或者一省资源，以牺牲大多数人口的利益为代价发展壮大起来的超大型及大型城市，需要容纳全国1亿多的精英人群，是否能得出房地产严重泡沫，空置率过高的结论？</p><p>当低收入者们努力挥洒汗水期望着自己年薪能够超过5万，8万，10万。。。的时候，他们可能做梦也想不出精英阶层手中究竟拥有多少财富。</p><p>精英们会象流氓无产者们一厢情愿认为的那样：因为一个区区房产税而恐慌性抛弃手中的大量房产吗？</p><blockquote><p><strong>liougehooa：</strong></p><p>”因为一个区区房产税而恐慌性抛弃手中的大量房产吗？“ 现在不说哪个富豪不是靠偷税漏税爆发的，我就举个例子，一套房不收税，二套房也不收税，三套房收300%税，你龟儿子还敢买三套房？</p><p><strong>kkndme：</strong></p><p>你说的事情在历史上已有发生，大明律明令禁止超标准建房，如果违禁，不仅仅是收税的问题，而是打板子下大狱，没收充公的，比房产税可要狠多了。但是终究没能执行下去，原因在于官员太腐败，不符合官员地主阶层的利益，最后名存实亡了。光是梗着脖子叫唤是没有用的，利益驱动着社会的发展，违背统治阶层利益的事情即使出台也难以执行，最后的下场都是不了了之。</p></blockquote><p>答案显然是否定的。</p><p>可以确认的是，房价不是由统计局的平均收入决定的。而是精英的平均收入决定的。</p><p>为了便于分析，我们剥离掉商品房（注意：只是商品房，而不是房屋）的社会属性，先把它看做商品。是商品就有他的内在规律。</p><p>什么决定商品的价格，价值？对不起，我只能说你上学上傻了。</p><p>是供求关系，只有供求关系。</p><p>我们判断一个核心城市市区内的商品房是具备足够稀缺性的。</p><p>如果你在北京海淀区上班，即使你在山海关拥有1000平方米的住宅也不能替代你住在北京市近郊区以内的愿望。而无论你是租房，分房还是买房，只要你还在海淀区上班，你就必须住在北京市近郊区以内。</p><p>假设你挣得钱不足够多，你需要租一套房子解决你的上班问题，上班距离的远近及居住的质量，取决于你愿意支付的租金。</p><p>假设你的钱够买房子，我相信你更愿意买房，因为你可以拥有房屋的产权和房产增值的收益。而买房子的大小，品质，离你上班的远近，取决于你手中的资金和你对未来收入的预期。</p><p>买房问题很象是中国的上学问题，而且简直是异曲同工。</p><p>假设你家附近有个重点中学，教学质量很好，考大学几率很高，而其他的学校你觉得不理想，你肯定希望无论如何自家小孩也要上这个重点中学。</p><p>上重点中学凭什么？我们简单的剥离掉其他社会因素的影响，可以认为想上重点中学就要凭好成绩，小孩努力考到前多少名，就可以上重点中学。这与努力赚钱买房是一个道理，有钱的出高价就能买到好位置好环境的房子。</p><p>我们再加入社会因素的影响，比如某大人物看到这个中学很抢手，很可以赚一笔，于是就设计了加分项，谁给自己送的钱多，就给谁加分，于是小孩要上重点中学不但要考高分，还要送钱加分。</p><p>同理，当好位置的商品房成为稀缺资源，各类炒房客的出现是必然的。</p><p>如果说炒房客加高价给最终住户的行为会产生泡沫，那么重点小学和公立幼儿园高昂的择校费应不应该也叫做泡沫？</p><blockquote><p><strong>liougehooa：</strong></p><p>”如果说炒房客加高价给最终住户的行为会产生泡沫，那么重点小学和公立幼儿园高昂的择校费应不应该也叫做泡沫？“ 你拿一个错误的现象，说这个现象是正确的来证明你错误的房价观念是正确的，可笑！</p><p><strong>kkndme：</strong></p><p>事情不能简单用正确还是错误来评价，一件事物发生一定有发生的原因。你说皇帝统治老百姓，想杀谁杀谁是正确还是错误？如果是错的，但是却在中国延续了几千年。</p></blockquote><p>尽管炒房和公立幼儿园加价成为普遍的社会现象是令人痛心的，但它们不以刚需人群的意志为转移的存在着，且与泡沫无关。</p><p>最被提及与泡沫有关的是以下两点：</p><p>第一，中国的房价甚至高于某些发达国家的房价。</p><p>其实，众所周知的是：不光房价高于某些发达国家，石油，高速，教育，医疗，税收等费用都远远高于某些发达国家。</p><p>而且中国的精英人群尽管所占比例不大，但是绝对数量足够大，而且精英平均收入甚至远远高于某些发达国家的收入水平。</p><p>第二：租售比问题</p><p>这个问题不用过多解释，使租售比更合理的方法不是只有降低房价一种，还有一种更靠谱的：房租大幅度上涨。而且已经在行动中。房租长期保持低价就像1990年以前的和田玉长期保持低价一样不可能。</p><h3 id="3、房价上涨造成物价上涨，人民生活变得困难"><a href="#3、房价上涨造成物价上涨，人民生活变得困难" class="headerlink" title="3、房价上涨造成物价上涨，人民生活变得困难"></a>3、房价上涨造成物价上涨，人民生活变得困难</h3><p>这个问题其实也不用多解释，懂经济学的该明白自然会明白，不会轻易被忽悠，不懂的解释半天也不会明白。</p><p>简单的可以这样说，物价上涨是经济过热，钞票印多了的后果。而房地产因为稀缺性和易保存比较吸金，所以吸收了大量的钞票，以至于大家光看到了房地产的飞涨。</p><blockquote><p><strong>liougehooa：</strong></p><p>”而房地产因为稀缺性和易保存比较吸金，所以吸收了大量的钞票，以至于大家光看到了房地产的飞涨。“</p><p>房价高涨，你要发的钞票必须要多，不然怎么去买房子？你发的钞票越多，钞票不是你发下来去买房子就死掉了不流通了，它只要流到人的口袋或者银行的口袋，这钱立马回出现流动，能不造成通货膨胀吗？除非这笔钱收到后限制房东使用。 为了支持高房价，国家必须发大量货币，这也是去年房价高涨的原因。</p><p><strong>kkndme：</strong></p><p>请先了解一下中国的货币发行制度，人可以无知，但不可以乱说。让人笑话。</p></blockquote><p>其实如果房地产交易量下降，不再具有吸金功能，那么农产品等生活必须品以及房屋租金等等就会大幅上涨。这是因为多出来的大量钞票总要有个流向，如果不被房地产吸收，就会被大蒜，绿豆，姜，及全部生活必须品的上涨来吸收</p><p>事实也证明确实如此。2010年房产调控后，物价上涨的势头非常迅猛。</p><h2 id="调控的真正目的：防范金融风险-amp-通过垄断实现gj利益最大化"><a href="#调控的真正目的：防范金融风险-amp-通过垄断实现gj利益最大化" class="headerlink" title="调控的真正目的：防范金融风险 &amp; 通过垄断实现gj利益最大化"></a>调控的真正目的：防范金融风险 &amp; 通过垄断实现gj利益最大化</h2><p>那麽是不是房地产就没有泡沫呢？</p><p>这个问题谁也不知道，因为到现在zf拿不出一份权威的数据来说明房地产到底有无泡沫。</p><p>但是房价高了就有风险，zf从感性上还是有清楚认识的。</p><p>注意，我们前面啰嗦了很多，现在才开始接近这次调控的真实意图。</p><p>防范金融风险？不错，你说的很对，但是没这么简单。</p><p>辨别利益是看透一切事物真相的武器。</p><p>高房价谁是受益者？</p><p>房地产游戏的模式三个环节：dfzf卖地、银行贷款、开发商在二级市场销售</p><p>dfzf卖地之后，剩余的风险和收益都归银行和开发商</p><p>dfzf卖地的款则用于地方广场，地铁，公路之类的建设和权贵的挥霍。</p><p>dfzf只负责卖地，是无风险的买卖。</p><p>只要房价不断上涨，加杠杆的炒房客就会赚到盆满钵满</p><p>这么分析下来，最受益的地方政府、开发商、炒房客。</p><p>独独缺了zy。</p><p>这时你是否猜到zy为什么要调控？如果还猜不到没关系，听我道来。</p><p>纵观古今，上位者最不能容忍的是别人受益，自己被黑锅。</p><p>大kfs，小kfs，大炒房客，小炒房客，dfzf都是收益者，但是风险却由zy来抗。这是一笔很不划算的买卖。</p><p>而房地产混战的局面，造成了国家队央企成员只有凭财大气粗高价拿地的份，钱花的最多，风险却抗的最大。</p><p>zy深深的感觉到要想国家队受益，要想控制风险只有做到两个字：垄断。</p><p>提高资金门槛，让小kfs，小炒房客，有点钱的小老百姓推出这个游戏。房地产很好玩，但不是小人物应该玩的。</p><p>先让市场冷静，彻底整顿，踢出那些个跳梁小丑，然后国家队出马，绝对垄断的市场，才能够统一定价，才能够控制风险，才能够利润最大化。</p><p>既然油价高于美国是合理的，那麽房价高于美国一定也是合理的，关键在于垄断。</p><p>不仅仅是房价的垄断，因为过高的垄断定价将会使交易量下降，国家队也需要资金周转。</p><p>真正厉害的，还是房租的垄断。公租房的推出是房租垄断进程的里程碑。</p><p>至于苦等廉租房的同志，不要抱太大的希望。城市要建设，地铁，广场，政府大楼都要上马，钱从哪里来？不会无缘无故凭空出来。</p><p>想想小学就近上学，但是重点小学真的就近就能上吗？小学名额可以寻租，经适房，廉租房也是一个道理。</p><blockquote><p><strong>tjOOSAN：</strong></p><p>真扯啊~~~ 油价跟房价去比？？</p><p>这位kkndme ，你就别忽悠了！~~</p><p>汽车对于百姓而言，可有可无，油价涨到是美国的一百倍，中国百姓才高兴了。</p><p>大哥！房子是必须品。ok？那么既然你也认为政府的钱大多从地产来。</p><p>那么这种发展正常嘛？会持续吗？？没有实体经济，能行吗？</p><p>招你的法子说，炒楼才是中国的前途？</p><p><strong>kkndme：</strong></p><p>这位兄弟，您比那些希望钱钱去炒大米的还不靠谱。</p><p>石油影响的不仅仅是开车的人花费多了。疯狂上涨的运输成本会导致民不聊生的。</p><p>假设一斤蔬菜从广西的农民地里收购是0.5元一斤，但是由于油价的像你说的上百倍的涨，运到北京，这斤蔬菜要卖300块一斤。</p><p>社会就瘫痪了</p><p><strong>tjOOSAN：</strong></p><p>那么这种发展正常嘛？会持续吗？？没有实体经济，能行吗？</p><p><strong>kkndme：</strong></p><p>实体经济的发展不是简单的钱不去投资房产，就会去投资实体经济，实体经济就发展起来了。估计媒体洗脑洗的比较厉害，你中毒了。</p><p>资本是趋利的。无论是哪个国家，哪个社会，只要存在市场经济，这个道理就一定不会错。</p><p>为什么资金进入房地产及其他资本市场而逃离实体经济？是因为实体经济环境不好，不赚钱。</p><p>一是税赋太高，二是各种需要打点孝敬的部门、管理人员、工作人员太多，比税赋还高，不能承受之重。三是国家队在各个重要领域的垄断，使国企变成了变相税务局的职能，垄断企业的暴利定价，又是压在本应该蓬勃发展的实体经济上的又一座大山。</p><p>现在央企基本是不垄断的行业不做，把产能过剩，充分竞争的产业交给民间资本，并且还要给这些资本压上高昂的负担.</p><p>有可能垄断的行业包括房地产都会收到国家队手里，以后更是将发展成为一个高度垄断的社会。</p><p>资本不是傻子，一定会趋利，所以资本放弃了操心受累不挣钱的实体经济，转而投向房地产。房地产的调控，让资本又进入了黄金、农产品领域参与爆炒，反正就是不进实体经济。因为国家不给实体经济的环境做任何的改善。</p><p>如果实体经济有一个好的环境，有一个好的获利空间，大量的资金就不会撤出实体经济，没有资金潮涌般的投入房地产市场，中国的房地产将会是一个平稳的上涨趋势。</p><p>但是体制决定了资金的去向，不以人的意志为转移。</p><p>高税赋、暗箱成本及垄断不但造成巨大的贫富差距，而且将会导致生活成本的大幅提高，生活负担日益沉重。</p><p>一方面百姓生活负担的加重，导致一些非生活必须品严重产能过剩，将会出现大量亏损倒闭的内需企业。</p><p>另一方面精英阶层快速聚集大量财富，使奢侈品供不应求。古董，字画，玉器，豪车，顶级服装的消费比重也将越来越大。</p><p>但是能够容纳大量资金的只有两个领域：农产品领域（满足老百姓的肚子）和商品房领域（居住权要满足老百姓的需求，产权要满足精英阶层的需求）。</p><p>资金的流向只能疏导不能强堵，zf很明白这个道理。两者危害取其轻，你认为zf会选择哪个领域？</p></blockquote><blockquote><p><strong>tjOOSAN：</strong></p><p>真扯啊~~~ 油价跟房价去比？？</p><p>这位kkndme ，你就别忽悠了！~~</p><p>汽车对于百姓而言，可有可无，油价涨到是美国的一百倍，中国百姓才高兴了。</p><p><strong>vavan2010：</strong></p><p>这种人肯定最后就是蠢死的。你没车，不用汽油，你可知道生活中有多少东西是需要用汽油的？无知才最可悲！</p><p><strong>kkndme：</strong></p><p>我们为确实买不起房的低收入群体，只能感到无奈</p><p>但有些本来能买房却嫌这嫌那而不买房的傻空通知，我们只能说你买不起房，完全是自己的原因，连油价上涨意味着什么都搞不懂，贫穷真的不能怨别人。</p></blockquote><h2 id="官方公布的统计数据，只要关系到某个群体的利益，就一定会被修饰导致失真"><a href="#官方公布的统计数据，只要关系到某个群体的利益，就一定会被修饰导致失真" class="headerlink" title="官方公布的统计数据，只要关系到某个群体的利益，就一定会被修饰导致失真"></a>官方公布的统计数据，只要关系到某个群体的利益，就一定会被修饰导致失真</h2><p>说到房产泡沫的问题，就不得说说官方的统计数据。</p><p>官方的统计数据从来是可以很雷，但不可以很真。</p><p>我们的统计原则基本就是：村骗乡，乡骗县，一骗骗到国务院。</p><p>不知道有人去市、县、乡、村进行过社会调查没有？</p><p>社会调查是怎么一回事？</p><p>我来告诉你，所有的关于人口、收入、田地、贫困户的数据都是官方统一编写，统一口径，如果胆敢有哪个小民对调查人员乱说，那是吃不了兜着走的。</p><p>你问了数据编来编去的意义在哪里呢？</p><p>意义很大，起码跟向上申请拨款是关系非常密切的。数据不假，钱从哪来？</p><p>统计数据无所谓是否真实并不重要，重要的是它是获取利益的重要手段。</p><p>假设官方想证明房地产不存在泡沫，那么一定拿的出不存在泡沫的统计数据作证。</p><p>反之，也一样。</p><p>好比,CCAV为了证明高空置率的结论，派出记者专门找偏远且刚刚完工的楼盘，进行了一次纯粹为了证明内部已事先得出结论的毫无科学依据的调研。</p><p>而dfzf，为了证明刚需多么强劲，也立刻拿出了选择性失明的统计数据来进行回击。</p><p>无论是左还是右，同样都是不科学，都是现有结论，再有证据。</p><p>我们到底应该信谁</p><blockquote><p><strong>cdw1：</strong></p><p>商品房本来名字中就有商品二字不准投资岂不是笑话？真正不准投资的那叫公房，这才是保证老百姓有房住的关键，商品房诞生的时候就很明确是改善居民居住条件的，现在政府怪商品房价格过高造成老百姓没房住本来就是颠倒黑白，政府不造保障老百姓居住的公房，而让老百姓去购买改善居住条件的商品房来解决本该政府解决的居住问题，政府不作为才是造成老百姓出现居住问题的罪魁祸首。我不期望人人有房，我只希望每一个在城市里找到工作的人通过努力工作勤俭持家能在生活城市里有希望拥有一套安稳的房子来容身，不管这房子的性质是商品房、经适房、廉租房或者其他什么房子。</p><p><strong>kkndme：</strong></p><p>你说的正是根源所在啊，zf的职责应该向无房者提供的保障房，建成经适房、两限房，被权贵占有牟利，而非要把商品房赋予稳定社会的职能。zf不是不知道问题的根源，而是不愿意放弃巨大的利益。</p></blockquote><h2 id="税收从来都是向下游转嫁的-amp-房产税迟迟不出台的真正原因"><a href="#税收从来都是向下游转嫁的-amp-房产税迟迟不出台的真正原因" class="headerlink" title="税收从来都是向下游转嫁的 &amp; 房产税迟迟不出台的真正原因"></a>税收从来都是向下游转嫁的 &amp; 房产税迟迟不出台的真正原因</h2><p>闲扯了一下统计数据</p><p>还是回到这次调控中来</p><p>房地产游戏的模式三个环节：dfzf卖地、银行贷款、开发商在二级市场销售</p><p>dfzf卖地之后，剩余的风险和收益都归银行和开发商</p><p>dfzf卖地的款则用于地方广场，地铁，公路之类的建设和权贵的挥霍。</p><p>dfzf只负责卖地，是无风险的买卖。当然还有人企图利用流氓无产者和无知群众的群情激奋来进一步收取房产税来提高dfzf收入。</p><p>税收从来都是向下游转嫁的，zf多收出来的钱一定是通过最下游的房租来体现。</p><p>当然，也有很多明白人士大声疾呼反对房产税。</p><p>自古而今，即使最辉煌的朝代，最被广大群众津津乐道的太平盛世，普通群众也仅仅只是解决了温饱而已，包括贞观、文景、康乾。</p><p>国家的富庶都是以老百姓勒紧裤腰带为代价的。</p><p>所以，zf是不会理会部分明白人反对房产税的呼声的。</p><p>真正对房产税的顾及来自于dfzf对土地出卖前途的担忧，真是鱼与熊掌不可兼得。</p><p>尽管流氓无产者和无知群众的呼声很高，然而房产税征收一旦实际操作起来，就会变的不得人心，征收难度非常之大，实际效果难以预知。也就是说zf没有底。而如果房产税征收效果不佳，dfzf卖地收入再受到巨大影响，那就真正是得不偿失了。</p><p>就会变成赔了夫人又折兵。</p><p>这样的买卖，zf是不会轻易做的</p><h2 id="房地产的现状"><a href="#房地产的现状" class="headerlink" title="房地产的现状"></a>房地产的现状</h2><p>房地产的现状是，商品房二级市场是由各种类型的开发商自由竞争的，一手房开发商之间的竞争，二手房投资客之间的的竞争。</p><h2 id="房价持续上涨的本质是稀缺性让好房子成为资金最好的去处"><a href="#房价持续上涨的本质是稀缺性让好房子成为资金最好的去处" class="headerlink" title="房价持续上涨的本质是稀缺性让好房子成为资金最好的去处"></a>房价持续上涨的本质是稀缺性让好房子成为资金最好的去处</h2><p>房价为什麽在一个自由竞争的市场上能够持续上涨？因为稀缺性。不是房屋的稀缺性，而是房屋所必须占用的土地的稀缺性。</p><p>有些群情激奋的群众立刻以6500万套房子空置的事情提出质疑，还有ccav的报道，那是要多煽情又多煽情。</p><p>我们无需说6500万套的真实性（明白人都知道非常离谱）和空置我心的科学性。为什么不说，因为这种稀缺性跟空置率就完全没有关系。商品房的稀缺性是相对人民币而言的。人民币印多了，资金没地方去，商品房就涨价了。</p><h2 id="关于垄断"><a href="#关于垄断" class="headerlink" title="关于垄断"></a>关于垄断</h2><h3 id="1、垄断的好处是没有风险"><a href="#1、垄断的好处是没有风险" class="headerlink" title="1、垄断的好处是没有风险"></a>1、垄断的好处是没有风险</h3><p>垄断的市场是没有风险的，土地是完全垄断的，所以dfzf完全没有风险。</p><p>而商品房是自由竞争的市场，是具备风险属性的，尽管由于大量印钞造成了商品房的飞涨，但随着房价的高涨，风险也在积聚。</p><p>dfzf土地垄断没有风险，完全可以置身事外。</p><p>可是银行呢？属于国家的银行。</p><p>银行正在承担自由竞争市场房价高涨积聚的风险。</p><p>这是zy不允许看到的，dfzf受益，而风险全部甩给zy。</p><p>既然垄断的市场是没有风险的，那还是让房屋和土地一起垄断好了。</p><h3 id="2、垄断可以解决社会稳定"><a href="#2、垄断可以解决社会稳定" class="headerlink" title="2、垄断可以解决社会稳定"></a>2、垄断可以解决社会稳定</h3><p>垄断还可以解决一个问题：社会稳定。</p><p>常被媒体和群情激奋群众所提及的一个重要问题就是：房价收入比。</p><p>大量印刷的人民币促成了房价高企（因为商品房实在是具备了大资金需要的所有投资品属性），可是那些个巨额的资金普通老百姓并没有见到。</p><p>路人甲：我们一个月就挣2000多块钱，干一辈子买不起房啊。</p><p>路人乙：我一个月上万都买不起房。</p><p>媒体：一个家庭不吃不喝22年买一套房</p><p>大量的疯狂印刷的人民币在哪里呢？</p><p>在精英手里。</p><p>我们在回顾一下开篇，我们奉行的是精英社会，丛林法则，金字塔式收入结构。</p><p>人民币再多，也不可能流到金字塔的底端。</p><p>dfzf垄断卖地也就让百姓们发发牢骚。</p><p>而炒房客，kfs赚的盆满钵满就让生活在中下层的老百姓眼红和不能容忍。</p><p>不患寡而患不均啊。</p><p>垄断，国家队的垄断，可以解决眼红问题，也就是社会稳定问题。</p><h3 id="3、房屋垄断只会愈演愈烈，底层人民想要拥有一套房子的难度只会越来越难"><a href="#3、房屋垄断只会愈演愈烈，底层人民想要拥有一套房子的难度只会越来越难" class="headerlink" title="3、房屋垄断只会愈演愈烈，底层人民想要拥有一套房子的难度只会越来越难"></a>3、房屋垄断只会愈演愈烈，底层人民想要拥有一套房子的难度只会越来越难</h3><p>还有一个最重要的问题：银行和民营开发商之间，是官与民之间的问题。</p><p>而银行和国家队央企，是左兜和右兜的问题。</p><p>土地是垄断的</p><p>然而房屋垄断并不是一件容易的事情。</p><p>因为民间百姓手里是存在大量二手房的，当然这也是为什么调控的板子只打在二套房、投资客、炒房客身上的原因。</p><p>同样，房租的垄断也并不是一件容易的事情，因为民间百姓手中的大量二手房都具备出租的特性。</p><p>俗话说，问渠哪得清如许，唯有源头活水来。</p><p>要垄断，必须抓住源头。</p><p>源头在哪里？</p><p>在一级市场，而不是二级市场。</p><p>房地产的垄断就是要国家队从一级市场做起，从一级市场开发着手完成对商品房开发的垄断。</p><p>一级市场，那是一个高高的门槛，民间资金，就让他该干嘛干嘛吧，房地产不是你玩的。</p><p>一级市场包括的内容是一般开发商无法参与的：</p><p>城市规划，城中村改造，旧房拆迁，城市综合体开发。</p><p>可以说从规划、改造拆迁、开发、到二级市场销售，一条龙服务。</p><p>一级市场开发的最大特点就是可以创造需求：你不是有房子吗？我拆掉你的房子，看你有没有刚需。</p><p>国家垄断控制风险的意义还在于：需求可以拆出来。</p><p>以后的路，民营开发商的日子将变得越发艰难。</p><p>土地是dfzf的，商品房开发是央企和国企的。</p><p>处于金字塔下层的40%家庭，如果还没有一套自己的房子，那么买一套自己的房子就越发的变得不可能。</p><p>商品房将逐渐往金字塔的上层积聚。</p><p>处于金字塔下层40%的无房家庭将只能以租房来解决居住问题。</p><p>租金的快速上涨期即将到来，zf已经盯上了房租这块巨大的蛋糕。因为房租的收益比房产税更靠谱，更具有操作性。</p><p>公租房，呼之欲出</p><h2 id="民生问题"><a href="#民生问题" class="headerlink" title="民生问题"></a>民生问题</h2><blockquote><p><strong>sunxinmfc：</strong></p><p>政府无需考虑民生问题么，本次号称史上最严厉的打压政策再起不到一点效果，ZF威信力将进一步下降，需要仔细考量</p><p><strong>kkndme：</strong></p><p>自古以来，民生问题的底线就是不要出现陈胜吴广的极端情况。所以zf更在意的是农民问题。</p><p>因为历史的改朝换代都是大饥荒引起的，无论是汉末、唐末、隋末、还是明末。农产品价格上涨的对zf的震动要远远大于房价的上涨。</p><p>农民具备最原始的力量，而他们关心的并不是三线以上城市的房价，而是能否填饱肚子。</p><p>而关心自己能否拥有一套产权房的都市白领，除了呻吟一下意外，几乎是没有什么有效反抗的可能的。</p><p><strong>sunxinmfc：</strong></p><p>秀才造反，三年不成，自古已然。</p><p>但我们还没有谈到所谓“造反”的地步，只是说房价如你所述，暴涨，中国的中产和以上人士将进一步携款合法外流（在房价暴涨的09年，中国外流人口达到历史峰值）。这一部分人利益如何保证？您觉得zf不需要考虑对么？</p><p><strong>kkndme：</strong></p><p>现在社会跟几百年前最大的不同是，世界是开放的，这得益于地理大发现和世界经济一体化，即使缅甸朝鲜这样封闭的国家也免不了受到来自世界范围的影响。大一统的集权社会融入了西方民主的思想，同时互联网的出现也让人们对过去的思维进行了再思考。</p><p>尽管底层百姓出国还是一个梦想，但对于精英人群，基本上是在世界范围自由流动的。</p><p>中国自古以来，商人都是没有地位的，商人的财产可以随时被官员没收，自古如此，至今如此，即使是今天也并没有出现私人财产神圣不可侵犯的宣言。即使出现了，也没有任何可以操作的可能。</p><p>明朝以后大量的商人移居海外成了华侨，现今的商人为了安全移居海外也不是什么新鲜事，不过是步明朝华侨的后尘罢了，zf会真的放在心上吗？朱元璋没有放在心上，朱棣没有放在心上，现在同样也不会放在心上。</p><p>真正可怕的是官员一方面谋取私利一方面把亲属和存款送到国外，这其实是一种国家背叛。在国内榨干老百姓的血汗，得到的金钱却在国外挥霍。什么叫卖国，不过如此。</p><p><strong>connstr：</strong></p><p>假如商人可以移居海外，官员自然也可以。官商能分家吗？</p><p><strong>kkndme：</strong></p><p>商人还是要分的吧：红顶商人就是官商，统治阶级，那是上位者。</p><p>普通商人，比如开个袜子厂赚个辛苦钱，最后袜子厂不挣钱了，官员还天天找他，让他孝敬，他就只好移民了。</p><p>普通商人在中国也是海量的，有点钱，但是没一点地位。</p></blockquote><p>中国自古以来都不是人人都能有属于自己的房子，大量的丫鬟、仆妇、管家、小厮寄养在权贵人家，身体都是不自由的，何谈拥有自己的房子。</p><p>自古以来，最多的就是失去土地的农民，住在地主家做长工，又何谈属于自己的房子。</p><p>只要是有贫富差距的社会，只要存在阶级，只要存在统治和被统治，这个社会就会不以人的意志为转移的出现大量的底层居民，没有这些底层居民。权贵就不能很好的生活。</p><p>为了权贵生活的更好，就要维持大量的底层群众。</p><p>权贵必须保证大量底层群众的基本生活，才能够让自己过得更舒服，仅此而已。这就是民生</p><blockquote><p><strong>sunxinmfc：</strong></p><p>删掉了一大段，不得不说，你说的很对。</p><p>（呻吟一下）。君不见，天涯上多少盼着被美军解放的铁杆准汉奸，政府楼被炸七成网民不是替死者默哀，而是一片欢呼。为什么会有这样的民意，参考前苏联，ZF确实应三思</p><p><strong>kkndme：</strong></p><p>爱国是与中华的历史分不开的，自秦统一以来，中国由封建时代转变为帝国时代，只有在项羽焚烧咸阳后，对诸侯进行了一次分封，但时间非常短暂，刘邦重新统一了天下，帝国时代经历了漫长的汉、唐、宋、元、明、清。天下一统的爱国情结是根深蒂固的。</p><p>而在秦以前，与中世纪的欧洲是极为相似的，齐国人可以到秦国做宰相，赵国人可以到燕国做将军。中世纪法国的诺曼底公爵可以到英格兰继承王位，瑞典的贵族可以到基普做大公，封建时代的国家概念并不是明显。欧洲经历了漫长的封建时代，国家观念很淡薄，能够抛弃国家货币成立欧盟就是明证。这对于漫长帝国时代，天下一统的国家是很难想象的。</p><p>爱国只跟历史文化传统有关。</p><p>1978年越南入侵红色高棉，当时的红色高棉对内实行红色恐怖，以gongchanzhuyi的名义对全国700万人口进行奴役和屠杀，总共屠杀了100万人。当越南军入侵时，受到了广大柬埔寨群众的热烈欢迎，称越南军解放柬埔寨是解放人类的战争。</p><p>红色高棉失去了民心，必然败亡。</p><p>那时，为了支援红色高棉，中越战争打响。有我国的强力支持，红色高棉仍然走向败亡。</p></blockquote><h2 id="房产税的制定原则"><a href="#房产税的制定原则" class="headerlink" title="房产税的制定原则"></a>房产税的制定原则</h2><blockquote><p><strong>中年不惑吗：</strong></p><p>不过从政府要分租房市场的蛋糕而言，我有不同的看法</p><p>政府的公租房要想租出好价格，有两种方式</p><p>1）减少市场可出租房源（北京就这样干了，拆迁廉价城中村）</p><p>2）提高竞争房源的成本。（所以我认为推出房产税是大概率的事情，因为政府的公租房是不需要交房产税的）</p><p>于是竞争房源的房租暴涨，政府的公租房也就可以羞羞答答的打个9则来</p><p>安抚一些底层了，反正所有的黑锅都有竞争房源的房东背了</p><p><strong>kkndme：</strong></p><p>房产税的问题我觉得zf还是慎重的</p><p>1、如果采用不公平法则：</p><p>公务员，垄断企业，事业单位的福利房不上税，权贵与利益集团购买囤积的大量商品房不上税，只有普通百姓上税，会加剧社会矛盾，而房产税会大幅提升租金，在公租房没有大量建起来之前，对稳定不利，维稳才是第一要务。</p><p>2、如果实行公平法则</p><p>小产权房，福利房，权贵囤积房都要上税，执行难度太大，可操作性不强，阻力几乎难以逾越。</p><p>如果真的收房产税，采用不公平法则的可能性最大，普通的无房百姓生活将变得非常艰难。</p></blockquote><h2 id="维稳的本质是人民能吃饱饭"><a href="#维稳的本质是人民能吃饱饭" class="headerlink" title="维稳的本质是人民能吃饱饭"></a>维稳的本质是人民能吃饱饭</h2><p>维稳问题其实最终还是吃饭问题。</p><p>房价上涨可以不买，如果房租价格不能控制，农产品价格不能控制。一旦大批群众吃饭出现了问题，维稳就无从谈起了。这个底线，还是要严守的</p><h2 id="公租房是为体制内服务的"><a href="#公租房是为体制内服务的" class="headerlink" title="公租房是为体制内服务的"></a>公租房是为体制内服务的</h2><p>说到公租房问题</p><p>首先还是要提到我们实行的双轨制</p><p>从某一方面可以简单的理解为统治阶级内和统治阶级外。  也就是我们常说的体制内，体制外。</p><p>体制内：公务员、垄断企业及医院高校科研院所等事业单位。</p><p>体制外：外资、私企打工者，个体工商户，农民，这里面也应当包括高层的老板和最底层的长期无业人员。</p><p>我们感受最深的就是涨工资的问题，一旦政府涨工资，那就一定是体制内涨工资，跟体制外完全没有关系。在金融危机的08年，大批企业关门，减薪，裁员，美国欧洲因为钱紧不得不降低公务员薪水。而这时，我们神奇的国家在干一件事：公务员普遍加薪，是为了全国百姓着想—刺激消费。</p><p>还有保障房问题，这个也是我们感受最深的：保障房=公务员及垄断企业住房；解决住房问题变成了如何让领导干部住更多更大的房子，如何让体制内员工拥有足够舒适住房的问题。</p><p>体制外的群众，那是别想得到一点好处的。谁让你是被统治阶级呢。</p><p>公租房的推出，也要解决两个问题：</p><p>1、体制内的最下层（最下层也是统治阶级，也就是是古代官吏中的吏）员工的基本住房问题</p><p>2、向体制外被统治的小民稳定收钱的问题。</p><h2 id="房产税一定会转嫁给租房人"><a href="#房产税一定会转嫁给租房人" class="headerlink" title="房产税一定会转嫁给租房人"></a>房产税一定会转嫁给租房人</h2><blockquote><p><strong>中年不惑吗：</strong></p><p>对公租房的问题受教了</p><p>不过当前从来不存在什么公平正义</p><p>税收向来是穷人多交，富人不交或少交</p><p>不过我很感兴趣的是假如推出了房产税</p><p>政府采取何种方式收</p><p>难道是如同鬼子进村了，挨家挨户的收？</p><p>但鬼子本身就是房产税的征收对象（不然也当不了鬼子）</p><p>他们自己都抵制，难道还指望他们向屁民收</p><p>遇到那种要钱没有，要命有一条的主</p><p>难道政府还开拖拉机来收？</p><p>5年前就叫嚣对房租收个人所得税</p><p>到现在也没有个影了</p><p>操作性实在太差</p></blockquote><p>房产税无论是持有环节征收，还是交易环节征收都是要向最终租房人转嫁的。</p><p>好比鸡饲料上涨没有可能鸡肉不涨价，但是养鸡的并没有赚更多钱。</p><h2 id="巨大的税收消耗也决定了GDP必须快速增长-amp-公务员越精减越多"><a href="#巨大的税收消耗也决定了GDP必须快速增长-amp-公务员越精减越多" class="headerlink" title="巨大的税收消耗也决定了GDP必须快速增长 &amp; 公务员越精减越多"></a>巨大的税收消耗也决定了GDP必须快速增长 &amp; 公务员越精减越多</h2><p>降低百姓租房困难的唯一国际通行办法就是减税。但是减税，在我国是很难行的通的。一个高增长高通胀的国家，高昂的腐败成本和巨大的浪费将导致国家必须维持高税收才能维持运转，gdp保8实际上是必须的也是迫不得已的。维持正常的运转，维持庞大的消耗税收而不是创造税收的公务员队伍，没有gdp快速的增长怎么可能呢。</p><blockquote><p><strong>feiying：</strong></p><p>这种看法很有道理，但保8毕竟会有个尽头，一旦走到头了那怎么去做呢</p><p><strong>kkndme：</strong></p><p>对于小富即安的我等小老百姓来说，希望此生不要见到这一天的到来。</p><p>对于流氓无产者来说，盼望着这一天的到来。届时新的英雄将从流氓无产者中产生。如同威武的 同志。</p><p><strong>艾馨999：</strong></p><p>我也觉得应精减公务员，也许减掉三分之二房价就见效了，呵呵。中国确实存在很多不应有的机构。</p><p><strong>kkndme：</strong></p><p>千万不能精减，越精减越多。 一般裁减公务员都是专门裁那些没背景，没关系，不会拍马屁，傻干活的。而留下的就是有背景有关系，会拍马而不干活的。 当傻干活的公务员被裁掉以后，剩下的不干活的公务员照样不干活。 于是政府发现没人干活了，人不够用了，再大批量招人，所以越精简人越多。 这就叫精减膨胀</p><p>特别是把熟悉业务的熟手减下来后，不得不招3个新手才能顶的住。等新手熟练了，人又富裕出来了。 精减膨胀这是不可更改的。 千万别精减，谁提出精减跟谁急，到时人民更没活路了。</p><p><strong>跳坑的青蛙：</strong></p><p>楼主关于精简膨胀的见解很精辟~ 很多事情看起来、听起来很美，也仅仅是看起来、听起来而已， 有丰富生活经验的人仔细思考一下、观察一下就不是那么回事了~</p><p><strong>kkndme：</strong></p><p>是啊，很多空空们扯着脖子呼喊这个政策那个政策，殊不知执行下来，最倒霉的还是自己。管老爷利用空空们鸡冻的心情趁机敛财，赚个盆满钵满。等空空们明白过来，也没办法了。 好比许多人最欢迎的费改税，结果税增加了，费却一点没见少。</p></blockquote><h2 id="调控的好处是让zf利益最大化-amp-防范金融风险"><a href="#调控的好处是让zf利益最大化-amp-防范金融风险" class="headerlink" title="调控的好处是让zf利益最大化&amp;防范金融风险"></a>调控的好处是让zf利益最大化&amp;防范金融风险</h2><blockquote><p><strong>骑自行车买别墅：</strong></p><p>就说政府为什么要调控？</p><p>难道就为了给你说的P民面子？？</p><p>如果房价一直暴涨，不更符合食利阶层的利益？房价低价一起彪～</p><p><strong>kkndme：</strong></p><p>真不知道你仔细看了没有。我通篇也没下过调控是为了给P民面子的结论。</p><p>调控的根本原因还是zy在房地产的游戏中没有得到好处。调控是为了让zy的国家队参与进来，成为主体。</p></blockquote><h2 id="垄断可以控制价格，维持稳定"><a href="#垄断可以控制价格，维持稳定" class="headerlink" title="垄断可以控制价格，维持稳定"></a>垄断可以控制价格，维持稳定</h2><p>垄断的目的还在于能够控制价格，为了维稳，zy是不希望暴涨的，但也不希望不涨。</p><h2 id="体制内的住房问题有国家保驾护航"><a href="#体制内的住房问题有国家保驾护航" class="headerlink" title="体制内的住房问题有国家保驾护航"></a>体制内的住房问题有国家保驾护航</h2><p>回头还说公租房</p><p>在私企打过工的都知道，毫无归属感可言，老板脑袋一发热，随时让员工卷铺盖卷走人。那是要多没保障有多没保障。原因是社会关系，关键客户，都掌握在老板一个人手里，员工就是打个下手，一不爽了，就换人呗。</p><p>统治者可知道不能这么用人的。一个庞大的国家机器要想正常运转，必须得让手下的和自己的利益一致。如果自己吃肉，手下的连汤都没得喝，这个机器就转不动了。</p><p>因此，在房价高涨的时代，保障房才成为zy默认的公务员房、垄断企业房。  公租房首要解决的就是手下里面最底层人士的住房问题。  我认为针对于体制内来说，无论是公务员，事业单位，还是国有企业的初级员工，都可以通过所在单位申请公租房，公租房的租金会略低于市场，主要是单位一定会提供补贴。  体制外对公租房的申请就没有那么幸运了。</p><h2 id="依靠但又不能完全依靠开发商建公租房"><a href="#依靠但又不能完全依靠开发商建公租房" class="headerlink" title="依靠但又不能完全依靠开发商建公租房"></a>依靠但又不能完全依靠开发商建公租房</h2><p>钱的问题，dfzf也想到了解决的办法。</p><p>在卖地时就要求开发商配套建设一定比例的经适房、廉租房或公租房。  然而，羊毛出在羊身上，开发商不可能做赔本的买卖。经适房好说，反正是卖个住户，大不了利润很低，顶多挣得少点。而廉租房和公租房就纯粹是只见投入不见产出的（开发商可没资金没耐心收租子）。廉租房和公租房的建设成本必须加到所建的商品房身上，这肯定会抬高房价。  关键是拿地成本逐年上涨，孝敬的资金也在逐年上涨，在加上多出来的廉租房和公租房建设成本，房价不可能无限抬高的。开发商也需要资金回笼周转。房价越高风险越大只是无论zf，开发商，炒房客和买房群众都有的共识。只是房价多高才是高，不同的人理解是不同的。</p><p>显然，把大量廉租房和公租房的建设寄托在开发商配套身上是完全行不通的，不仅不能解决住房问题，还让本来就高企的房价更加雪上加霜。</p><h2 id="体制内的住房问题不难解决"><a href="#体制内的住房问题不难解决" class="headerlink" title="体制内的住房问题不难解决"></a>体制内的住房问题不难解决</h2><p>体制内公务员、垄断企业和事业单位的员工住房问题是不难解决的，因为有zf行为的强制意志在里面。</p><p>1、df划拨土地，征集开发商建经适房、公租房</p><p>2、dfzf强制要求开发商建配套经适房、公租房，建设成本就转嫁给购买商品房的冤大头吧。</p><p>3、体制内单位自有土地，集资建房。</p><p>多管齐下，体制内人员的住房不难解决，甚至体制内人员每人住好房子大房子多套房子的问题都不难解决。处于金字塔的中上层，他们俯瞰着芸芸众生。</p><h2 id="解决体制外的住房问题：国家垄断，细水长流收租"><a href="#解决体制外的住房问题：国家垄断，细水长流收租" class="headerlink" title="解决体制外的住房问题：国家垄断，细水长流收租"></a>解决体制外的住房问题：国家垄断，细水长流收租</h2><p>处于金字塔下层的体制外的广大群众怎么办？</p><p>体制内员工的住房舒适性和投资获利是首要保证的，不然光让干活不给好处，怎么能让手下听话呢？</p><p>体制外广大群众的住房问题也要解决，这关系到社会稳定。</p><p>能不能拿出一个办法，即解决了群众住房问题，又可以从群众手里长期获取收益？</p><p>细水长流收租子的事情开发商做不了，但zf可以做。</p><p>公租房，如果解决了钱的问题，面向广大群众的公租房的推出，将会取得双赢的局面。</p><p>既然房地产开发最肥的肉留给了国家队，国家队也应该投身到公租房的建设中来。</p><p>国家队全面进场之前，大鱼小鱼虾米泥鳅，皆可得利。</p><p>不把小鱼虾米泥鳅赶出池塘，市场无法控制，风险无法控制，公租房建设也无从谈起。</p><p>二套房首付提高到50%，第三套房停止贷款，小开发商的清理整顿，民营企业在招拍挂中无论价高价低都无法取得土地，等等一系列重拳直击小鱼虾米。</p><p>土地将回到国家队手中，这个世界将变得清爽。</p><p>让时光倒流到80、90年代，我们的dfzf守着蕴藏着巨大财富的金矿、锡矿、铜矿却过着贫穷的日子。没有资金，矿山是没有办法变成财富的。于是招商引资，为了gdp,为了解决就业问题，出台了各种优惠政策，于是外商堂而皇之的走进来了。成为了这些矿山的主人。5年，7年或者10年，外商享受的免税期满的时候，外商卷着巨额财富走了，留下了一个个废弃的充满危险的大坑。这是血琳琳的教训，zf没有理由不吸取。外资、私企、小业主总有一天会让他们清场，尽管这一天晚来了十几年。</p><p>在土地日益稀缺的今天，房租难道不是可持续产出的金矿？让炒房客、投资客、民企开发商见鬼去吧。</p><blockquote><p><strong>kkndme：</strong></p><p>在土地日益稀缺的今天，房租难道不是可持续产出的金矿？</p><p><strong>百无一用一书生：</strong></p><p>如果人们宁愿住桥洞呢，如果人们决定离开呢，如果房租收入不断下降呢</p><p><strong>kkndme：</strong></p><p>宁愿住桥洞的早晚要当盲流处理的</p><p>逃离城市基本是一部分人被淘汰掉，选择，离开，而又有更多的人冲击去。</p><p>房租收入下降基本是做梦才会出现的事情，国家队的进场就是不让房租下降</p></blockquote><h2 id="普通人买得起「优质商品房」就尽早买把"><a href="#普通人买得起「优质商品房」就尽早买把" class="headerlink" title="普通人买得起「优质商品房」就尽早买把"></a>普通人买得起「优质商品房」就尽早买把</h2><blockquote><p><strong>懒兔爱散漫：</strong></p><p>楼主的意思是今后体制外的人（除最高层)外，是无缘商品房，只能住公租房了？</p><p><strong>kkndme：</strong></p><p>如果你现在还买的起商品房，那你就尽早买吧</p></blockquote><h2 id="商品房和公租房的区别"><a href="#商品房和公租房的区别" class="headerlink" title="商品房和公租房的区别"></a>商品房和公租房的区别</h2><blockquote><p><strong>中年不惑吗：</strong></p><p>有个疑问</p><p>商品房和公租房相比，优势在什么地方？</p><p>那些楼裂裂的商品房估计质量还不如公租房吧</p><p>楼主应该加一句，买质量好的商品房</p><p><strong>kkndme：</strong></p><p>商品房和公租房的区别实际就是土地性质的不同，一个是出让，一个是划拨</p><p>出让那必须是招拍挂，那必须是天价。</p><p>划拨就基本算是白给，收钱就是象征性的意思意思。</p><p>是商品房还是公租房，土地的性质说了算，dfzf说了算。跟房屋质量没有关系。</p><p>一套房子假设20000一平，房子的价值也就占30%，剩余的都是土地的价值</p></blockquote><h2 id="提议通过征普税调节贫富差距，不是傻，就是坏（制定政策的人不会让政策针对自己，那么政策都是谁制定的呢）"><a href="#提议通过征普税调节贫富差距，不是傻，就是坏（制定政策的人不会让政策针对自己，那么政策都是谁制定的呢）" class="headerlink" title="提议通过征普税调节贫富差距，不是傻，就是坏（制定政策的人不会让政策针对自己，那么政策都是谁制定的呢）"></a>提议通过征普税调节贫富差距，不是傻，就是坏（制定政策的人不会让政策针对自己，那么政策都是谁制定的呢）</h2><p>今天看到搜狐上一篇文章说道要通过征税来调节贫富差距，提出这个方案的人不知是无知还是故意，如果zf听了这种无耻参谋的建议，不知道多少老百姓会活的更惨。</p><p>假设出台又一个新税种，无乱它叫什么，我们暂定为财产税。既然有了新税种，就要定任务，那好了为了这个税种制定了年上缴多少多少的任务。</p><p>实操的时候，执行的工作人员发现一旦轮到权贵脑袋上的事就没办法执行，你执行，他先让你下课。</p><p>但是任务必须完成，那还是从普通老百姓身上打主意吧。于是政策就完全走样了，非但起不了劫富济贫的目的，反而加重了穷人的负担。</p><p>往近里说，个人所得税，挣的是谁的税？权贵没看见交，月薪3000块的工薪层可一个都跑不了。3000块月薪上缴的个人所得税你看着不多，可对于养孩子糊口的老百姓来说，哪怕10块钱都是重要的。他们可没有资本象月薪上万的小资一样动不动花500块钱泡个吧。</p><p>个人所得税是有任务的，工作人员必须完成任务，税别管是局级干部交的，还是连孩子幼儿园都上不起的穷光蛋交的，总之完成任务就是好样的。既然局长的税收不上来，就要从穷光蛋身上加倍收上来。</p><p>往远里说，王安石变法是怎么失败的，以史为鉴可以知得失。王安石的初衷难道不是好的吗，可结果怎么样呢？只有一个——民不聊生。</p><p>书生误国啊。</p><h2 id="调控带来的影响"><a href="#调控带来的影响" class="headerlink" title="调控带来的影响"></a>调控带来的影响</h2><p>许多兄弟关心房价什么时候会涨</p><p>那么先看看这次调控后都出现了什么样的现象。</p><ol><li>全国房产成交量大幅下降</li><li>一线城市房价略有下跌，但并不持续，到现在基本跌不动了</li><li>多数二三线城市房价不跌反涨，成交量逐渐回升</li><li>大多数二线以上城市租金持续上涨</li><li>农产品价格有上涨迹象，大蒜、姜等小品种农产品遭遇爆炒。</li><li>变化莫测的政策导致精英阶层出现移民潮</li></ol><p>还有什么，欢迎大家补充</p><h2 id="农产品的价格关系到影响稳定的吃饭问题"><a href="#农产品的价格关系到影响稳定的吃饭问题" class="headerlink" title="农产品的价格关系到影响稳定的吃饭问题"></a>农产品的价格关系到影响稳定的吃饭问题</h2><p>农产品价格的上涨是很值得警惕的。想买房子但嫌房子贵的都市白领对农产品的价格很不敏感，但是金字塔最底层的最大多数群众是很敏感的。领导们也很敏感。这牵扯到相当大比例人口的吃饭问题，稳定压倒一切。</p><h2 id="农产品价格的抬头会导致物价全面上涨，但国家不会坐视不管且有能力管"><a href="#农产品价格的抬头会导致物价全面上涨，但国家不会坐视不管且有能力管" class="headerlink" title="农产品价格的抬头会导致物价全面上涨，但国家不会坐视不管且有能力管"></a>农产品价格的抬头会导致物价全面上涨，但国家不会坐视不管且有能力管</h2><p>农产品价格的抬头将会导致物价全面上涨，在不引起质变的前提下，房价作为商品也不例外。这个引起质变的前提是出现饥荒的极端情况，这样的几率在现在社会很少。尽管干旱和洪涝使农产品大幅度减产，但是农产品还可以进口，国家还有粮食储备，保证全国人民填饱肚子还是不存在问题的。</p><h2 id="资金会在优质资产之间流动，而决定优质资产价格的是精英阶层的购买力"><a href="#资金会在优质资产之间流动，而决定优质资产价格的是精英阶层的购买力" class="headerlink" title="资金会在优质资产之间流动，而决定优质资产价格的是精英阶层的购买力"></a>资金会在优质资产之间流动，而决定优质资产价格的是精英阶层的购买力</h2><p>一线城市仍然沉默，国家队在积极运动。二三线城市的房价上涨的成交量的回升却给了市场一个明确的信号。这是资金运动的规律。国家队对一线城市的布局，迫使资金流向二三线城市。二三线城市相对（与一线城市相比）不高的价位给出了较大上升空间的预期。</p><p>全国富人买北京上海，全省富人买省会，房价的合理性已经不能用简单的本地平均收入来衡量。精英阶层的购买力才是关键。</p><h2 id="资金流向规律决定了农产品和资产价格总有一个要涨，人为压制，一定会按下葫芦浮起瓢"><a href="#资金流向规律决定了农产品和资产价格总有一个要涨，人为压制，一定会按下葫芦浮起瓢" class="headerlink" title="资金流向规律决定了农产品和资产价格总有一个要涨，人为压制，一定会按下葫芦浮起瓢"></a>资金流向规律决定了农产品和资产价格总有一个要涨，人为压制，一定会按下葫芦浮起瓢</h2><p>明年物价进入持续上涨期是一个不容回避的问题。</p><p>在资金总量不变的前提下，巨量资金推动农产品价格上涨或者推动房价上涨是一个必须的选择。</p><p>今年zf用行政手段严厉打击蒜和绿豆价格的暴炒，基本上没有起到作用，资金有自己的运作规律，光靠拿张悟本出气也不能解决问题。</p><h2 id="资金流向规律决定了洼地不会一直是洼地"><a href="#资金流向规律决定了洼地不会一直是洼地" class="headerlink" title="资金流向规律决定了洼地不会一直是洼地"></a>资金流向规律决定了洼地不会一直是洼地</h2><p>二三线城市的房价的上涨使与一线城市的差价缩小，为一线城市的发力提供了动能。</p><p>无论你喜欢还是不喜欢，都不是以人的意志为转移的</p><h2 id="大城市对近距离的小城市有虹吸效应"><a href="#大城市对近距离的小城市有虹吸效应" class="headerlink" title="大城市对近距离的小城市有虹吸效应"></a>大城市对近距离的小城市有虹吸效应</h2><p>许多人心怀房价肯定会跌回2004年的美好愿望，刻舟求剑似的思维错过了一次次购房的机会。在患得患失中，在牛刀的号角声中，在任志强的大炮声中，迷失了自我。</p><p>任何事物都是有其规律性的。关键是否有一双慧眼能够穿透重重的迷雾。</p><p>假设你是个投资客，你非要去石家庄和长沙买房子，结果发现不怎么升值，怨天怨地：</p><p>石家庄作为一个二线省会怎么会不涨？长沙的房价怎么那么低？</p><p>我们知道，北京的房子是全国有钱人买的，省会的房子是全省的有钱人买的。但是当省会城市距离一线大城市在6个小时高速以内，省里的有钱人的资金就会流向一线大城市，而不是省会。河北的富人一定会选择在北京投资房产，湖南的富人一定会选择广州深圳投资房产。</p><p>假设你是一个投资客，你去昆明旅行，发现昆明的房价甚至高过重庆，很不理解。你很疑惑昆明这么小的西部边陲城市投资价值在哪里？</p><p>昆明是云南省内唯一的大城市，且相邻的二线以上城市离云南省都比较远。云南地州资源丰富，虽然穷人占的比例大，富人的数量却也不少。昆明南有滇池，北有长虫山，作为一个700万人口的城市，土地资源非常稀缺。所以贵，一定有贵的原因。便宜一定有便宜的道理。</p><h2 id="决定房价的因素有很多，具体情况具体分析"><a href="#决定房价的因素有很多，具体情况具体分析" class="headerlink" title="决定房价的因素有很多，具体情况具体分析"></a>决定房价的因素有很多，具体情况具体分析</h2><blockquote><p><strong>zzz4697：</strong></p><p>楼主针对南昌的房价做个分析吗？从刚公布的100个城市房子均价看，南昌5k每平左右，是高了还是低了？</p><p><strong>kkndme：</strong></p><p>对于不了解的城市不敢妄下断言。没到现场调查就没有发言权啊。</p><p>房价会不会涨还要看dfzf的规划。 比如广州拥有大量的城中村，其周边有较多的大城市，广州的房价就比北京和上海低。如果广州的城中村一旦大规模拆迁，房价将会大幅上涨。</p><p>比如南宁东盟贸易自由港的概念使南宁的房价涨幅惊人。</p><p>南昌的地理位置，zf规划，发展前景，江西富裕人口的多少，都是决定房价的因素</p></blockquote><h2 id="房价暴涨是相对于钱而言的，不是相对于实际购买力而言的"><a href="#房价暴涨是相对于钱而言的，不是相对于实际购买力而言的" class="headerlink" title="房价暴涨是相对于钱而言的，不是相对于实际购买力而言的"></a>房价暴涨是相对于钱而言的，不是相对于实际购买力而言的</h2><blockquote><p><strong>tjOOSAN：</strong></p><p>。。。。。。暴涨之后。。。。。。</p><p>我们不就是第二个日本吗？</p><p>供求关系？供求关系，现在是谁在决定？国家！</p><p>国家的经济结构决定的。制造业的资金都进入房地产了。能不涨吗？普通人有几个可以够炒房资格的？</p><p>日本 当初也是供求关系！~~ 供求关系的根本也不应脱离，国家的经济实力！！</p><p>还暴涨？怎么涨？再涨都够去美国买房了！！ 你这不扯淡么</p><p><strong>kkndme：</strong></p><p>中国和日本最大的不同在于日本的货币是开放的，中国的不是，是不能自由兑换的。</p><p>暴涨是相对于钱而言的，不是相对于实际购买力而言的。</p><p>80年代工资200多块钱一个月的时候，是不能想象90年代末北京城区5000每平米的房价的。那时候万元户已经是富人的代表了。</p><p>90年代末工资1000块钱的时候是不能想象现在30000一平米的房价的。90年代的100万绝对是富裕群体。可现在连个中产都算不上。</p><p>货币的持续贬值你没有考虑</p></blockquote><h2 id="土地不稀缺，优质土地稀缺"><a href="#土地不稀缺，优质土地稀缺" class="headerlink" title="土地不稀缺，优质土地稀缺"></a>土地不稀缺，优质土地稀缺</h2><blockquote><p><strong>tjOOSAN：</strong></p><p>在反驳楼主一句！！</p><p>在中国的土地，可不稀缺！~~ 只是没开发罢了！！~~</p><p>中国与世界不同！ok？13亿人！！用十三亿的居住权作为市场竞争的资本。</p><p>那太可怕了！真的！！！如果可能，中国绝对可以产出世界第一贵的地价！</p><p>为什么？这么多人需要房子。能不涨吗？</p><p>呵呵！多少有点扯淡！！别再提供求关系了！~~ 供求根本是平衡的！！</p><p><strong>kkndme：</strong></p><p>中国有13亿人口，960万平方公里土地，土地一点不稀缺。</p><p>但假设你在北京西城上班，让你去塔特拉马干买房子，你愿意去吗？</p><p>全国有点钱的都要在一线城市和省会城市买房子，所以才会稀缺。</p><p>大兴安岭有大量的土地，哪个有钱愿意跑去置业呢？</p></blockquote><h2 id="集中发展大城市是导致优质土地稀缺的原因"><a href="#集中发展大城市是导致优质土地稀缺的原因" class="headerlink" title="集中发展大城市是导致优质土地稀缺的原因"></a>集中发展大城市是导致优质土地稀缺的原因</h2><p>中国经济发展不平衡，牺牲全国大多数城市和乡村，来保证北上广深及大部分省会城市的繁荣才是造成土地稀缺的愿意。</p><p>土地有的是，房子有的是，但好位置的土地和房子并不多。</p><p>一方面大量的小县城和乡镇、村庄人口锐减，因为缺乏谋生手段不得不背景离乡外出打工，另一方面超大型城市越来越拥挤，土地资源越来越稀缺。</p><p>这就是中国集中发展极少数标杆城市所造成的呀，也是因为如此，才造成了中国金子塔式的收入结构，贫富差距越来越悬殊。</p><h2 id="为人民服务是说给人民听的"><a href="#为人民服务是说给人民听的" class="headerlink" title="为人民服务是说给人民听的"></a>为人民服务是说给人民听的</h2><p>很多人很疑惑，贪官越来越多，根本不把老百姓的利益放在心里，这些贪官即使被曝光了，还能继续当官。这是为什么呢？</p><p>首先理解一下老百姓，也就是民到底是什么？</p><p>民就是牛养，古代的时候，官员管理百姓叫做牧。官员管理百姓就是替君主放牧，只要保证牛羊不逃跑，不骚乱，那么就是合格的官员。</p><p>秦始皇暴政，百姓揭竿而起，可是陈胜起事后基本视民众如草芥，项羽屠杀平民比始皇更残暴。</p><p>萧何是一个很贤德的人，对百姓很好，赢得了很高的名声。刘邦在广武山和项羽对峙，得知了萧何在关中深受百姓爱戴，就疑心萧何要造反。一个君主爱民如子是为了百姓的支持，江山永固，一个臣子对老百姓好是不是要造反呢？于是派人去调查萧何。</p><p>萧何是个聪明人，感觉到刘邦已经不信任他了。于是赶紧改变工作作风，开始霸占百姓的田产，上大街欺负漂亮的妇女同志，并且派自己的子女上前线给刘邦做人质。</p><p>刘邦看到了萧何的行为非常高兴，知道萧何不会造反就放心了。</p><p>百姓不是牛羊是什么？</p><p>在红色高棉统治下的柬埔寨人，民连牛羊都不如呀。</p><p>波尔布特同志坚持gongchanzhuyi的按需分配，取消了货币。于是市场经济完全没有了。群众完全变成了按阶级分配了。</p><p>阶级只分为两种，波尔布特老板及其打手是绝对的统治阶级，其他人为被统治阶级，也可以称为奴隶阶级。统治阶级对奴隶阶级不爽可以直接拿ak47突突。柬全国700万人口被波老板突突死了100万，当然不光是突突，还有活埋。</p><p>以至于越南派了10万军队侵略柬埔寨，受到了柬埔寨人民的夹道欢迎，称为解放人类的战争。</p><p>公道自在人心</p><h2 id="历史是一面镜子，不同的国情决定了采取同样的政策结果可能是南辕北辙"><a href="#历史是一面镜子，不同的国情决定了采取同样的政策结果可能是南辕北辙" class="headerlink" title="历史是一面镜子，不同的国情决定了采取同样的政策结果可能是南辕北辙"></a>历史是一面镜子，不同的国情决定了采取同样的政策结果可能是南辕北辙</h2><p>博古才能通今，不了解历史无法治理国家，不了解历史也无法对事务有一个清楚的认识。</p><p>我们的今天本来就是历史的延续，前人经验和智慧的总结，不是一句话就可以抹杀的。</p><p>因为秦以后漫长帝国时代的大一统，才会把中央集权延续到现在。</p><p>而西方封建时代延续到地理大发现，诸侯割据王国、公国、侯国林立为现代的西方提供了民主制度的可能。</p><p>在制度上完全的不可比性，使向国际接轨成为了笑话。</p><p>我们看到的结果就是，物价上涨与西方接轨，甚至堂而皇之的超过西方，体制外的工资则与非洲结果，也算是国际化了。</p><h2 id="zf限制政策房的利润，那kfs就一定会偷工减料"><a href="#zf限制政策房的利润，那kfs就一定会偷工减料" class="headerlink" title="zf限制政策房的利润，那kfs就一定会偷工减料"></a>zf限制政策房的利润，那kfs就一定会偷工减料</h2><blockquote><p><strong>mellyzhang：</strong></p><p>大家听过那个西三旗的有名的限价房——旗胜家园吧<del>！外表看起来那么光鲜，地段也不是特别偏，紧邻城铁，当然是被人疯抢都抢不到的两限房呀</del>！还不是质量问题一大堆。</p><p>ZF安排的政策房也是要KFS建的，哪个KFS没肉吃还能保证把房子盖好？？！！所谓检测都TMD是虚的~。</p><p><strong>kkndme：</strong></p><p>这是肯定的，开发商都追求利润最大化。</p><p>zf建设两限房限制开发商利润，开发商必然偷工减料，zf都知道怎么回事，必须争一只眼闭一只眼，否则这个政策就执行不下去了</p></blockquote><h2 id="屁股决定脑袋，人民不知厉害关系选房子，zf选农产品"><a href="#屁股决定脑袋，人民不知厉害关系选房子，zf选农产品" class="headerlink" title="屁股决定脑袋，人民不知厉害关系选房子，zf选农产品"></a>屁股决定脑袋，人民不知厉害关系选房子，zf选农产品</h2><p>对于渴望拥有一套产权住房的都市小白领对希望房价狂降已经到了歇斯底里的程度，他们赞成农产品价格放开，让资金炒作农产品，而离开房地产市场。理由很简单，一套房子一涨就是几十万甚至上百万，而大米小麦，一斤就算涨到10块，也根本不能影响到自己的生活质量。</p><p>如果我国农产品价格是开放的，资金流向大米、小麦、猪肉，并且允许囤积，房地产一定会下跌的，这是毫无疑问的。</p><p>但是，我们看到的绝不是10块钱一斤的大米、小麦，而是500块钱、1000块钱一斤的大米、小麦。</p><p>我国将会出现大面积的饥荒，几千万甚至上亿的底层人士饿死街头，社会将出现大的动荡。</p><p>而产权房屋价格的上涨牺牲的主体只是体制外部分都市白领的利益，换来的不过是网络上没完没了的牢骚和咒骂。</p><p>巨量资金必须有地方去，如今面临的房地产和农产品之间的选择，你认为zf会怎么做？</p><h2 id="各个阶层的住房问题都安排的妥妥的"><a href="#各个阶层的住房问题都安排的妥妥的" class="headerlink" title="各个阶层的住房问题都安排的妥妥的"></a>各个阶层的住房问题都安排的妥妥的</h2><p>体制内中层、高层可以分到多套福利房，低层至少能够分到一套保障房，即使最不重要部门的底层员工，搞到由单位补贴的公租房是没有问题的。</p><p>体制外的高层、中层，以他们的资金实力买多套房子都是不成问题的。</p><p>农民，分配有宅基地。国家要稳定，首先就是要农民稳定，因此我国只有农民能够分到土地自己盖房子。</p><p>军人，会享受到比公务员更好的福利，让军人享受更高标准的福利待遇，国家有深刻的认识。</p><p>那么只有体制外的都市中下层群众才是高房价的受害者，可是这个群体的地位真的很微不足道。</p><h2 id="顶层的岁月静好来自于底层的负重前行"><a href="#顶层的岁月静好来自于底层的负重前行" class="headerlink" title="顶层的岁月静好来自于底层的负重前行"></a>顶层的岁月静好来自于底层的负重前行</h2><p>这些既无稳定工作（低层都市白领失业的概率还是蛮大的）又无自己的房产的都市小白领是金子塔底层被压榨的对象，甚至远远不如交通便利地区的农民。</p><p>没有这个群体的存在，金字塔上层的权贵是无法享受舒适的生活的。</p><p>社会需要底层群体用巨大的付出和极少的收获为金字塔上层群体服务。</p><p>当然，在巨大的付出后，有少数人会从低层脱颖而出，爬到金子塔的中层、甚至上层。  这些少数人带给了底层群体奋斗的希望。</p><p>拥有一套属于自己产权的房子，就只有一套路：从金字塔的底层往上爬。这条路很艰辛，并且会越来越艰辛，但总有希望。</p><h2 id="底层指的是体制外底薪白领"><a href="#底层指的是体制外底薪白领" class="headerlink" title="底层指的是体制外底薪白领"></a>底层指的是体制外底薪白领</h2><blockquote><p><strong>天地间间：</strong></p><p>楼主有一点没说透彻，那就是白领的工资普遍较高，他们有能力买房子，但是受到几千年以来的小农经济思想的约束，他们普遍认为买房子不划算，占便宜心里普遍严重，别看他们外表光鲜，其实还都是一帮农民</p><p><strong>kkndme：</strong></p><p>我说的是买不起房的低收入小白领</p><p>高薪白领不买房的不多吧，都是网上吹的吧。</p><p>高薪白领一般还是有自住房的，只是有人不愿意投资房产。每个人想法不同而已。</p></blockquote><h2 id="资金终会流向具有稀缺性的资产"><a href="#资金终会流向具有稀缺性的资产" class="headerlink" title="资金终会流向具有稀缺性的资产"></a>资金终会流向具有稀缺性的资产</h2><blockquote><p><strong>天地间间：</strong></p><p>请问楼主所说的低薪白领一个月赚多少钱算底薪？</p><p>就拿我说吧，我06年买的房子，当时月薪3000元，这在当时算不算低薪？</p><p>但是我买房了，还是一个人买的，当然老爸赞助了点。每个月还完月供兜里就剩几十元，硬扛下来了。</p><p>目前年薪12万，我老婆年薪6万？这算不算高新？</p><p>如果我当时没买房子，以我们2个人的收入当下也买的起，只不过生活负担重一些。</p><p>所以请楼主明示，什么是低薪？</p><p><strong>kkndme：</strong></p><p>兄弟，你所描述的是另外一个问题。先说说你所说的这个问题，再谈谈什么叫低薪</p><p>先说06年你月薪3000买房子的问题。</p><p>我们打一个比方：</p><p>假设80年代，咱们两个月薪都是100块。你喜欢清朝的瓷盘子，咬咬牙，一年用好不容易攒下的100块钱买了清朝瓷盘子。我喜欢缝纫机，用一年好不容易攒的钱买了一个缝纫机。</p><p>市场有价值发现功能。显然，80年代清代瓷盘子的价值没有得到发现。</p><p>进入90年代，随着社会的发展，社会财富的增加，钞票也大幅度增加。清代瓷盘子的市场价值发现出来了，瓷盘子价格开始大幅上涨，你的瓷盘子由100块涨到1000块。而我买的缝纫机已经淘汰了</p><p>瓷盘子具备投资品的一切属性，能够吸收社会的富裕资金，而缝纫机没有这个功能。我很眼红，我虽然买的起这个瓷盘子（因为90年代我的工资由100涨到了800），但是我觉得价格太高了，没有买。而你的瓷盘子在90年代为你挣了900元钱。</p><p>时光又到21世纪，社会资金越来越多，钞票越印越多，可瓷盘子在市场上越来越少（都被收藏了），于是瓷盘子涨到了1千万一个，我即使想买瓷盘子再也买不起了，而不是嫌价格高的问题。而你已经成为了千万富翁。那个瓷盘子也并没有因为1千万的价格实在太高而暴跌，相反价格仍以每年20%的速度增长。</p><p>06年你在房价价值发现的初期买了房子，就像90年代你用1000块买清代瓷盘子。</p><p>如果你的工资不变，或者变化不足够大，现在你将没不起房子，就像你在21世纪不可能买的起瓷盘子。</p><p><strong>天地间间：</strong></p><p>楼主啊，你有一个概念错误：清代的瓷盘子是收藏品是古董，其价值是由拥有瓷盘子的收藏家决定的，而房子是商品（我指的是商品房，不是公租房之类的保障房），其价值远没有古董增值速度快，所以说收藏品和商品是有区别的。</p><p><strong>kkndme：</strong></p><p>呵呵，商品房当然和清代磁盘是不同的，升值空间不同，投资对象也不同，但价值发现的道理是一样的。投资品的基本属性：稀缺性是共有的，当然稀缺的程度不同。</p><p>我所讲的是投资品的价值发现，而不是商品房=清代瓷盘</p></blockquote><h2 id="土地的稀缺决定了大多数人永远买不起想买的房子"><a href="#土地的稀缺决定了大多数人永远买不起想买的房子" class="headerlink" title="土地的稀缺决定了大多数人永远买不起想买的房子"></a>土地的稀缺决定了大多数人永远买不起想买的房子</h2><blockquote><p><strong>天地间间：</strong></p><p>此外，您还没有正面回答我什么是低薪</p><p>我今年30多岁，如果我刚毕业肯定是拿底薪的，往最坏了想，我毕业几年到今年混的不好，今年只赚3000元一个月，我就买不起房么？</p><p>如果你觉得是，那么你错了，我仍然可以买的起，我会到比较偏远的地段去买房子，比如密云，延庆等买套小户型二手房，那里的房价我仍然可以支付月供，当然我还是要像老爸要点钱付首付的。</p><p>可是如果我不这么想，觉得去哪里不划算，在四环里买房子多好啊！那么我可能就买不起了，因为在四环里买房已经超出了我的能力</p><p>那么请问我买不起四环里的房子是房价的问题呢还是我的问题呢？是不是说我买不起四环里的房子就是我买不起房？</p><p>综上所述，每个人都有自己的能力极限，不同能力的人去不同的地段买房子，一味的强求自己做能力不及的事情，反而还怨天尤人的，这就是小农意识。</p><p><strong>kkndme：</strong></p><p>如果我们买首套房，不是为了投资。我们买房总有个基本的要求：</p><p>有一个自己的家，并且上班相对方便</p><p>如果你在长城饭店上班，你跑去密云买个房子。首先你上班就成问题。</p><p>如果我月薪3000块，我甚至不能在密云买房子（因为也上万了），但我可以在山西的某个县城买套房子。问题是我买这套房子干什么？</p><blockquote><p><strong>先天下之友：</strong></p><p>请问楼主，在密云延庆买房子就不能去长城饭店上班吗？貌似密云延庆的城轨马上就要开通了，一个小时就可以到三元桥的，如果你仍然觉得不可能，那么我就很同情生活在东京纽约的白领了，他们买房子都在离工作单位50-100公里的地方，他们大部分人也靠城铁上下班的，所以说东京和纽约的白领生活在水深火热中啊</p><p>此外，密云和延庆的二手房子10000元一平？用不用我贴个卖房帖子啊？密云和延庆县城里的二手房子均价6000一平，一居室50平吧，总价 约30万，首付12万，月供1200元左右，这个对于月薪3000元的人来说是不成问题的，当然去密云延庆买别墅确实是10000元一平。</p><p><strong>kkndme：</strong></p><p>这种抬杠没什么意义，如果密云的轻轨修通了，1小时到三元桥，密云就由远郊区变为了近郊区，房价也不会维持现有水平，一定会水涨传高。</p><p>我没看过密云的规划，如果真有这个规划，且密云房子还没有大涨的时候，还时值得购买的。</p><p>密云的房价我倒真没去看过，不过以前有个住密云的同学说密云的新盘1万多了，老房子价格我并不知道。</p><p>我们只不过打的一个比方，假设密云到城里上班没有问题，普通小白领又买得起，那么不买的可以称为傻空。</p><p>但是确实有真正买不起的，连密云也买不起的，月收入3000，但要供养老人和孩子的，即使能在河北某个县城买，可是房子不能上班就完全没有意义了。</p></blockquote><p><strong>天地间间：</strong></p><p>我的中心思想是：北京的白领普遍买的起房子，但是有一部分不买，其原因是想花最少的钱去获得最好的地段，最好的楼层，最好的朝向的房子，这是划算不划算的问题，不是买得起买不起的问题</p><p>当然有的人会说：买房了，得病了怎么办？失业了怎么办？一大堆怎么办！那么请问：既然你知道早晚要见马克思，为什么现在还活着啊？一刀了断了算了，呵呵</p><p><strong>kkndme：</strong></p><p>你说的这类人其实是因为贪婪和恐惧，幸运不会垂青即贪婪又恐惧的人。用天涯的语言来说：就是传说中的傻空</p></blockquote><h2 id="不同阶层的人对收入高低有不同的理解"><a href="#不同阶层的人对收入高低有不同的理解" class="headerlink" title="不同阶层的人对收入高低有不同的理解"></a>不同阶层的人对收入高低有不同的理解</h2><p>再说说收入高低，不同城市，不同消费水平，对收入高低有着不同的理解。 我们举北京为例。</p><p>反映真实居住成本的是房屋租金，而不是房价。</p><p>在北京生活，一家三口的通常情况</p><p>一个位置能够满足上班条件的两居室租金大约3000元，小孩花费没有3000块是下不来的，再加上夫妻俩2000元的基本生活花费，也就是说8000月收入的家庭，刚好能达到收支平衡。</p><p>如果是体制外的都市白领，这个收入是很可怜的，因为还要考虑到失业问题，并且应付万一发生的意外支出。所以每月能有2000元的结余是必须的，那么10000元是在北京生活的基本水平。</p><p>而购买商品房所支付的金钱是要远高于租金成本的，因为你买的不是房屋居住权，而是房屋的产权，一定会出现溢价。</p><p>如果你现在的家庭收入能够再买得起一套房子，那么你的收入水平应该至少是小康，甚至达到中产</p><blockquote><p><strong>天地间间：</strong></p><p>楼主，一对有工作经验的年轻的北京白领夫妻月收入只有8000元？这是怎么统计的？</p><p>您的统计结果不准啊，我的结论是10000-12000元/月是北京标准的白领夫妻的月收入，那么这笔钱能不能买房子？</p><p>能，能不能付首付？可能不能，首付款怎么来的？一部分是父母赞助的。</p><p>作为父母就要把自己的孩子扶上马，再送一程，这和啃老没关系</p><p><strong>kkndme：</strong></p><p>呵呵，这个也不好这么说，不同行业间的薪水差距实在太大了。</p><p>比如一个有6、7年职业学校的教师或者一个有5，6年电脑分销经验的产品经理（都是大学毕业），他们辛辛苦苦干一年多点的也就7、8万块。他们都不晓得招商银行随便一个客户经理轻轻松松年薪几十万。</p><p>同是大学毕业，同是5、6年工作经验，北京几十万年薪收入的人不少，但一个月只挣3、4000块的数量更庞大。</p><p><strong>先天下之友：</strong></p><p>楼主，我说的是北京白领夫妻的标准工资，什么是标准工资？就是这个城市的可提供工作岗位加权平均工资，也就是说，你在北京混，正常的情况下，北京的白领夫妻在成为这个公司的主力员工以后就可以拿到的工资，什么是主力？就是在你的单位里能够独立挑起一滩活。</p><p>此外，在北京的白领，月薪3000元在大多数公司都是起薪价，工作几年后工资翻一番的比例很大，我在北京混了很久了，我相信在北京的绝大多数老板是给员工出路的，楼主你说是么？</p><p><strong>kkndme：</strong></p><p>我倒是觉得平均工资真没有什么意义。</p><p>你在中石化工作，各种收入加一起一年低于20万的还真没有。</p><p>你做基金经理年薪低于100万的还真不好找。</p><p>你在电力系统，有点职务的，一年搞个上百万都是轻轻松松的。</p><p>你要是公务员有点级别，好的一年收入上千万，不好的一年收入也就十来万。</p><p>但你要是在某个私营或者股份公司做个人事，行政，一年弄好了也就几万块钱</p><p>你要是做销售，好的销售年薪几十万，上百万，不好的销售一年也就挣2、3万。</p><p>我真不知道平均工资意义在哪里？</p><p>一个年收入千万的总经理跟100个失业的白领平均，人人都是年收入10万</p><p><strong>先天下之友：</strong></p><p>我还是要强调白领的平均工资，这个很重要，也是很多北漂留下来的重要理由，不同行业收入不同，但是主流行业的收入差距是不大的，至于你说的中石油和其他的高薪公司这个一般人进的去么？</p><p>至于失业问题，这个和国家的政策密切相关，属于不可抗力，一味的强调这一点没意思</p><p><strong>kkndme：</strong></p><p>如果仅指北漂而言，一般大学毕业的普通北漂白领有个几年经验的月薪大概是8000-15000不等吧。北漂几年的普通家庭月收入在15000-20000.</p><p>这个收入，即使在现在，在北京五环以外买房还是没问题的。</p><p>低于这个收入，真的考虑回家吧</p></blockquote><h2 id="一二线买房只会越来越难，最终租房会成为主流"><a href="#一二线买房只会越来越难，最终租房会成为主流" class="headerlink" title="一二线买房只会越来越难，最终租房会成为主流"></a>一二线买房只会越来越难，最终租房会成为主流</h2><p>在北京一个年薪15万的普通家庭仍然买的起房，在五环外，只是你愿不愿意买。</p><p>但以后一个年薪15-20万的普通家庭买房子，即使是五环外的，也只能是梦想了。</p><p>租房将成为今后小白领主流的生活方式。</p><h2 id="人需要一个安身之所，能买早买比晚买好"><a href="#人需要一个安身之所，能买早买比晚买好" class="headerlink" title="人需要一个安身之所，能买早买比晚买好"></a>人需要一个安身之所，能买早买比晚买好</h2><blockquote><p>房价是由土地决定的，而土地是咱们这个国家的根本，当年不就因为要改变土地的属性，才有了我们的党。</p><p>凡房屋也都是只有土地的使用权，土地属于国家，说收回的话不管你有无房证更不会和住房者商量，如（拆迁），这个性质决不变，想下，对有房者如此，会为了没有房子的而制定均衡均分的土地政策下降房价吗？</p><p>现在贫富分化越来越严重，真买的起房的考虑的重点不会是贷款，买不起的，房价跌去三分之一也还是买不起，不要看政府如何了，如果能少贷款或不贷款买处房的话就买吧，人早晚得有个安身之所，不要贪大求全，战争或地震来了房子不值钱，但万一战争或地震不来呢？</p><p>kkndme</p><p>没错，就是这个意思，如果战争来临，你手中的钱也变成废纸</p></blockquote><h2 id="股市"><a href="#股市" class="headerlink" title="股市"></a>股市</h2><blockquote><p><strong>新智战者：</strong></p><p>楼主对楼市的分析让人佩服！能否谈谈股市？现在的股市不管涨跌，我只是看到ZF在疯狂的发行新股大盘股，压大盘是肯定的了，看样子又是下一盘很大的棋！</p><p><strong>kkndme：</strong></p><p>你要注意2010年的股市与以往是不同的。因为股指期货的出现。</p><p>要时刻关注股指期货投入的资金量。</p><p>当股指期货资金量足够大的时候（什么叫足够大就要看个人的判断了），期指将指导沪深300指数。大盘会跟着固执期货走</p></blockquote><h2 id="如果房价不涨，那其他产品会怎么涨"><a href="#如果房价不涨，那其他产品会怎么涨" class="headerlink" title="如果房价不涨，那其他产品会怎么涨"></a>如果房价不涨，那其他产品会怎么涨</h2><blockquote><p><strong>lfastro：</strong></p><p>“上帝欲使其灭亡，必先使其疯狂！”</p><p>很想看看“报复性上涨”是个什么样子。</p><p><strong>kkndme：</strong></p><p>你可以这样理解（只是为了理解方便做个示意）：</p><p>假设房价从2004年的4000一平，涨到2010年的20000一平</p><p>猪肉从2004年的6块一斤，涨到2010年的10块一斤。</p><p>但是如果房价2004年4000一平，到了2010年还是4000一平</p><p>那么，猪肉从2004年的6块一斤，将在2010年涨到30块一斤，不仅猪肉，还有大米，小麦，大蒜、葱、姜、房租都会翻几倍的价格。</p></blockquote><h2 id="zf如何利用公租房控制租房市场"><a href="#zf如何利用公租房控制租房市场" class="headerlink" title="zf如何利用公租房控制租房市场"></a>zf如何利用公租房控制租房市场</h2><blockquote><p><strong>中年不惑吗：</strong></p><p>政府要垄断房租市场？市场上已有的和不断要产生的出租房源政府怎么让它们消失呢？</p><p>还是说政府要造足够多的公租房来占据市场主体 那就更难了 要花多少钱呀 公租房的地段好不了的</p><p><strong>kkndme：</strong></p><p>公租房将为房租市场树立一个标杆。有了这个标杆，私人出租房将会对比公租房做一个参照。</p><p>公租房是有限的，是需要申请的，而私人出租房会在相同位置将自己的房租定价高于公租房。</p><p>这样就保证了公租房的价格低于市场。</p><p>公租房不是廉租房，zf要持续赚钱，他的定价不会低，私人房就会定得更高，这将导致市场上的房租整体上涨。</p><p>公租房的吸引力在哪里？</p><ol><li>对体制内会有单位补贴</li><li>对体制外人员可以提供一个较长的稳定租期。</li><li>zf定价的标杆作用，无论怎么定价，公租房都会低于周边市场价格.</li></ol></blockquote><h2 id="城中村不会长期存在"><a href="#城中村不会长期存在" class="headerlink" title="城中村不会长期存在"></a>城中村不会长期存在</h2><blockquote><p><strong>中年不惑吗：</strong></p><p>城中村可是提供廉价房源的地方 这个公租房的竞争对手肯定要被政府干掉 所以城中村的拆迁改造那是一定的</p><p><strong>kkndme：</strong></p><p>城中村一定会消失的，不消灭城中村，哪来的GDP</p></blockquote><h2 id="三四线城市的未来"><a href="#三四线城市的未来" class="headerlink" title="三四线城市的未来"></a>三四线城市的未来</h2><blockquote><p><strong>alice_xg：</strong></p><p>写得非常好</p><p>楼主能否分析下未来三四线小城市的发展，是否会空心化</p><p>另外，请分析下海南的城市有没有投资价值</p><p><strong>kkndme：</strong></p><p>四线城市房价也会缓步上涨，但比较慢，主要还是因人工成本，原材料价格上涨造成的建筑成本上涨。</p><p>城市的空心化可能性不大，人口仍然会缓慢增长。但偏远乡镇却存在空心化的可能。</p><p>海南具备得天独厚的海岸线资源，这是全国任何一个其他海滨城市无法比拟的（其他的海滨确实比较差，毫无美感）。但关键还是zf如何开发，急功近利的开发，和毫无节制的圈海岸线可能会大幅降价海南的旅游与投资价值。</p><p>取决于政策，有较高风险</p></blockquote><h2 id="房租价格涨不上去，本质是买房还看起来有希望"><a href="#房租价格涨不上去，本质是买房还看起来有希望" class="headerlink" title="房租价格涨不上去，本质是买房还看起来有希望"></a>房租价格涨不上去，本质是买房还看起来有希望</h2><p>今天下午才出门，上午闲来无事，跑来再说两句。</p><p>一是再说说房租问题，房租的发展趋势：</p><p>现在房租低的一个重要原因是因为，大多数都市小白领还希望能够买一套属于自己的产权房，至少他们觉得即使现在钱钱不够，但是努力一把，跳个脚还能够得着。所以他们省吃俭用拼命的存钱。一个月薪10000块的小白领租一套月租金3000元的还算舒适的两居室是没有问题的，但是他为了攒钱买房宁可几个人合租一室，仅仅愿意在居住上花费少得可怜的500元钱。</p><p>随着国家队的进入，民营资本的退出，房地产开发和房地产投资的门槛都会大幅度提高，投资房产以后就成为富人的专属。</p><p>小白领的生活将变得“轻松”，因为除非能够上位，否则一般人跳脚是够不到属于自己的那套房子的。对于拥有房产失去希望，将使他不得不搬出合租房而转而租住一套还算舒适的两居室。</p><p>高昂的商品房价把大量的小白领从合租房中解放出来，转而去租住两居室或者三居室。</p><p>房租的价格一定会通过市场发现功能，找到他的位置。</p><blockquote><p><strong>想住清合吗：</strong></p><p>看了那么久，突然间觉得，楼主会不会过于武断了？</p><p>尽管我也看好房价和房租都上涨，但是，买房应该不会只是富人的专属。例如在日本，有许多的普通白领买的起房，难道在中国，白领就买不起吗？</p><p><strong>kkndme：</strong></p><p>白领是分层次的，有技术，有能力，有背景，肯吃苦的白领将通过努力获得更多的收入，获取更高的职位，走进金字塔的中层，买房子肯定没有问题。但进入金字塔中层的绝不会占大多数比例。</p><p>低级白领，公司办公室普通职员，一无技术，二无资 没有特殊的技能或本领，又没有什么关系和背景，对机会的把握能力也不是很强，如果家里也不富裕，这样的同志今后买房子就比较困难了。金字塔的底层人数比例是最大的。</p><p>日本的国情确实跟中国有很大不同，另外日本东京的房子也不是普通白领买的起的。我认识个NEC的部长（相当于中国企业的总监），也算大企业的中层干部，他也在东京买不起房子，家在离东京很远的郊区。</p><p><strong>中年不惑吗：</strong></p><p>日本的城市化已完成 不过东京市中心的房子小白领是买不起的 他们买的是东京卫星小城市的房子 如同你在上海工作 去扬州买房子还是能承受的 人家的地铁一个小时能跑200公里 你说生活半径能扩大多少呢 再说日本是有选票的</p><p><strong>kkndme：</strong></p><p>没错，就是这个道理。天涯里有些人说年薪30万买不起房，年薪70万买不起房。原因还是期望太高了，以为自己年薪70万了，就是人上人了，就必须住市中心的大房子。</p><p>但事实上市中心的大房子是绝对稀缺的，人上有人，天外有天。</p><p>买房子还是量力而行。有1000万资产的人是买不起价值2000万的翡翠的。有1个亿资产的人也不能买下故宫的居住权。</p></blockquote><h2 id="稀缺房的价格永远涨"><a href="#稀缺房的价格永远涨" class="headerlink" title="稀缺房的价格永远涨"></a>稀缺房的价格永远涨</h2><blockquote><p><strong>sunxishila：</strong></p><p>我认为房价不可能跌的（至少5年内） ，尤其北上广，因为</p><ol><li>地球资源就那么点，美国人不可能允许所有的人都过上他们那样的高消耗生活，所以美国人就尽可能地创造无产阶级国家来为其当奴隶进行打工，中国的现状也一样，利益集团以及国家政府为了其利益以及维稳庞大的执政集团必须要通过工具将更多的人丧失生产资料以便当其奴隶。试想如果人人都有房住，人人都有闲钱可以自由的选择生活方式，我们以出口为主的血汗工厂还能招得到工人吗？北上广还能存在这么多外资企业吗？外资企业没的话，没这么多就业机会，所有的外地人回家了，上海的办公楼，出租房不全完蛋了 ，那么势必减少了各种税收，那么北上广正常的维持城市运行的资金必将断裂…怎么可能呢。</li><li>适度宽松的货币政策（也就是过量发行的货币）必将导致通货膨胀，在中国货币多了必将走进房地产，因为在中国基本没有别的更靠谱的投资渠道。长期看来，货币一直是贬值的 ，世界上几乎所有的国家货币一直都在贬值，这是货币的固有属性，就是剥削。除非取消货币，可能吗？</li><li>房价下跌或者价格合理当然是有可能的，可是这取决于政治，除非取消一党执政，除非土地似有话，原因相信大家都清楚，你们认为近期可能吗？</li></ol></blockquote><h2 id="粮食和房子的不同是，房子无法和土地剥离"><a href="#粮食和房子的不同是，房子无法和土地剥离" class="headerlink" title="粮食和房子的不同是，房子无法和土地剥离"></a>粮食和房子的不同是，房子无法和土地剥离</h2><p>二是再说说粮食问题</p><p>中国的粮食实行储备制度，国家每年从农民手里收购一定数量粮食以及进口一定数量的粮食用于储备。</p><p>中国的稻米主要出自东北和广西，东北米好吃但产量小价格高，广西米难吃但产量达价格低，都市人都愿意花高点的价格购买东北米。</p><p>各地储粮通行的做法是以储粮为名收购的东北米加价在市场上出售牟取利润，再低价收购难吃的广西米用于粮食储备。</p><p>米在市场上的价格差别还是很大的，好的东北米可以卖到5块钱一市斤，一般的东北米卖到3块钱左右一斤，差点的东北米卖到2块钱一斤。而广西米基本在2块钱以下，而且除非比较穷的，一般人都不愿意吃。</p><p>大家可以看到在市场上交易的大米跟其他商品并没有什么不同，好的稀缺的就贵，差的产量大的就便宜。  但是米和房子不同，一方面米是当年的好吃，放到第二年陈了就不值钱了，第二年土地上新的稻子又长出来，会有新的米下市。但是房子不会，一栋楼今年卖掉了，明年这块已经卖掉了的土地并不能长出另外一栋楼。另一方面，中国实行的储备粮制度将会在粮食减产的时候平易粮食价格的上涨（尽管储粮和市场上销售的粮食完全不是一个品质），而且国家对口粮的问题会高度重视。  粮食作为商品本身是与土地剥离的，而房屋作为商品却无法从土地剥离出来。这是粮食与房子的根本不同。</p><p>商人在粮食稀缺时期进行囤积会枪毙，在粮食丰收时期囤积粮食只能亏损（第二年的米就没人吃了。</p><p>商品房作为商品在市场上交易，而保障房是为了保障低收入群体的最基本居住，这与粮食分为储备粮和商品粮又多少有些相似。</p><p>但是商品房土地和房屋无法剥离，产权和居住权却是剥离的，这就使既保障人民的基本居住权，又通过产权的升值牟取巨大的利益成为可能。zf实在是再明白不过了。</p><h2 id="购买房价基数低的省会城市，怎么都不会亏的"><a href="#购买房价基数低的省会城市，怎么都不会亏的" class="headerlink" title="购买房价基数低的省会城市，怎么都不会亏的"></a>购买房价基数低的省会城市，怎么都不会亏的</h2><blockquote><p><strong>Razerwu：</strong></p><p>我也年纪小，07年才毕业，学经济的，人文历史基础有一点，关注房价有两年了。看了楼主帖子，更是开朗了。</p><p>升斗小民一定要跟形式跑，千万别一厢情愿，也别被媒体的话语误导了。</p><p>以后，征服会逐渐保证居者有其屋，但是不是每个家庭住的房子有自己产权。中国社会阶层分化很严重。主要分体制内和体制外两个群体。体制内的即使明摆着的收入一般，但是福利好。体制外的，有高薪的，但是低收入的更多。我们公司一般在年收入到手5-6W左右。这个应该是这个城市的平均水平了。我相信50%的人都在这个数。这个收入租个房子，除去其他生活开支，一年还能余个1,2W，如果是两个人一起生活，也能养小孩的，只是，你永远买不起自己的房子。</p><p>但是我也知道，更多的小白领，在空调房里工作，一个月就领1000来块的薪水，而那里房价也不低，8000-10000了。你还是买不起。</p><p>所以，未来你可以选择在房价高的地方生活，然后租房。你也可以选择回到三四线城市。但是很可能，到时候那里的房子价格也不低，如果你能力够，还是有希望买到商品房。</p><p>非常有钱的人很多，我不知道他们会怎样投资。</p><p>我想给一些跟我一样收入层次的人一些建议。</p><p>物价必涨，这是趋势，如今农村的农民都不怎么种地了，征服在搞平整，以后都会自动流转，每个村的徒弟承包给一个人，别的农民给他打工。有资金的农村出来的，可以考虑往农业方向发展。</p><p>我薪水收入一般，但是有外快，跟女友一块存钱，年收入超过20W，</p><p>楼主在帖子里提到长沙和石家庄的例子，我认为，二三线城市也要具体分析，像我老家长沙，房产升值空间还是有的，只要每年涨20%，我就满足了。一线城市的房子更稀缺，但是，城市化的进程，不可能继续像上一个10年那样，大家都往一线城市跑了。所以，房地产暴涨的时代我不相信还有。我还相信二线城市和一线的房价差距会慢慢拉近。</p><p>所以，我用09年的结余，在今年上半年长沙贷款买了一套，我准备下半年再买一套。我不是炒房，我是略有结余的工薪阶层，我选择保值，总比放在银行要好。事实证明我是对的上半年买的现在已经涨了10%了。</p><p>一线和省会城市的商品房，未来一定会成为更加稀缺的资源。</p><p><strong>kkndme：</strong></p><p>长沙的房子一定会涨，只不过涨得会比其他城市慢。</p><p>低价买涨幅滞后的房子有一个好处，一旦长沙放出“大量拆迁”等利好因素，你就赚大了。购买房价基数低的省会城市，怎么都不会亏的</p></blockquote><h2 id="房地产是资本市场还是实体经济？"><a href="#房地产是资本市场还是实体经济？" class="headerlink" title="房地产是资本市场还是实体经济？"></a>房地产是资本市场还是实体经济？</h2><p>还有一个关于实体经济的问题，房地产是资本市场还是实体经济？</p><p>我们回顾一下，房地产的居住属性和产权属性是剥离的。</p><p>依照房地产的居住属性，房地产绝对属于实体经济。</p><p>从下游来说，不搬新家重新购买一套家具、一套家电、做一次大的装修的可能性都不大。在没有改善住房的前提下，去换家具家电，搞装修的应该是一个很小的比例。</p><p>从上游来说，钢铁、水泥、机械等行业无一不受到到房地产的影响。</p><p>房地产影响到钢铁、水泥、机械、家电、家具、建筑建材等多种领域，影响真的不小。</p><p>依照房地产的产权属性，房地产又是资本市场。</p><p>资金推动了商品房价格的快速上涨。</p><p>房地产为政府积聚了大量的财富（卖地），这些财富用来建造地铁、公园、广场、办公大楼、公款招待、潇洒挥霍，又推动了实体经济的增长。</p><h2 id="什么是傻空"><a href="#什么是傻空" class="headerlink" title="什么是傻空"></a>什么是傻空</h2><p>关于买房量力而行的事，还是有必要再说得清楚些的。</p><p>还是打个比方</p><p>假设某人家庭月收入15000块（都市小白领的通常收入），工作6年，手里有50万存款，我可以在北京北五环外（比如西三旗或者回龙观）买一套价值150万的房子（2万每平米，70几平米）。首付50万，贷款100万，月供7000多，是完全买的起的，而且因为轻轨的开通，即使在市中心工作，上班时间肯定可以在2个小时之内（作为北京这个城市来说是可以接受的）。</p><p>但是这个人心比较高，非要在北四环内，买一套100平的住宅，二手房3万一平米，100平米就是300万。首付按30%算，也就是90万，还要贷210万，已经完全超过了他的收入水平及收入预期。于是这个人成天怨天尤人，成天喊自己买不起房，抱怨zf，憎恨炒房客和开发商。天天叫唤社会不公平。</p><p>过了1年，国家队布局完毕，西三旗、回龙观房价涨到30000一平米了，买个70平的还要210万。首付30%，要60多万，贷款150万，月供12000左右。这时，他买西三旗70多平米的房子已经很费劲了。</p><p>这种行为叫什么？这就叫傻空。</p><h2 id="什么是真买不起房"><a href="#什么是真买不起房" class="headerlink" title="什么是真买不起房"></a>什么是真买不起房</h2><p>再比如说</p><p>某人家庭月收入比较低，8000块，在北京上班，西三旗和回龙观的房也要150万的总价，是买不起的。他的收入水平只能在密云或者河北买房子，但是即使在密云或者河北买了房也没办法上班。这个人就叫做真的买不起房。</p><p>如果他对未来的收入预期也不是很高的话，房价未来的上涨将使他进一步对买方绝望，他将彻底放弃攒钱买房，带着老婆孩子搬出跟人合租的城中村，每月花费2500块钱在回龙观租一间两室一厅的住宅。</p><p>日子就这么过下去了。</p><p>量变将引起质变，8000块钱的家庭月收入，是真买不起房的家庭，而15000月收入的家庭买不起房就叫傻空。</p><h2 id="具体情况具体分析，如果看不懂，一定是没有抓住问题本质"><a href="#具体情况具体分析，如果看不懂，一定是没有抓住问题本质" class="headerlink" title="具体情况具体分析，如果看不懂，一定是没有抓住问题本质"></a>具体情况具体分析，如果看不懂，一定是没有抓住问题本质</h2><p>小时候看春秋战国之类的书籍，总弄不明白一个问题：</p><p>a国家跟c国家打，他的邻国b就会很害怕，害怕a国家灭了c国家实力更强大，对自己不利。</p><p>e国家跟g国家打，他的邻国f就会很高兴，高兴e国家与g国家两败俱伤，自己可以获取利益。</p><p>后来我终于弄懂了。</p><p>当a国家跟c国家打仗时，如果a的国力明显强过c,他的邻国b就会很害怕，因为a国家很轻易就会灭掉c国家变得更强大。</p><p>当a国家跟c国家打仗时，如果a的国力跟c差不多,他的邻国b就会很高兴，因为a国家跟c国家会拼得两败俱伤。</p><p>分析问题，一定要深入的研究啊</p><h2 id="桂林-vs-南宁"><a href="#桂林-vs-南宁" class="headerlink" title="桂林 vs 南宁"></a>桂林 vs 南宁</h2><blockquote><p><strong>leeyq88：</strong></p><p>楼主的观点高明，因为把房价与整个经济及政治层面的东西联系起来了。请教一个问题，桂林属于5线城市了吧，现在均价近5000，请楼主分析一下桂林这种级别城市房价的趋势。</p><p><strong>kkndme：</strong></p><p>缓慢上涨，有钱买南宁吧，东盟贸易提供了巨大的空间</p></blockquote><h2 id="公租房的量级不会冲击到商品房市场"><a href="#公租房的量级不会冲击到商品房市场" class="headerlink" title="公租房的量级不会冲击到商品房市场"></a>公租房的量级不会冲击到商品房市场</h2><blockquote><p><strong>vavan2010：</strong></p><p>楼主说得好，根据你所描述的，关于房租的这一块，我看到的前景是，由于国家队的加入和垄断，以后开发商只有可能是财雄势大集团的地产商和国家队这两种了。</p><p>而大量的建筑公屋，也是要分租赁市场的一杯之羹，又有公租房又有廉租房，再加上物业税的出台，这样愿意持有普通住宅多套的收租客会不会减少？</p><p>因为没钱买的会去租公租或廉租，有钱租的也去租高端好房，就象香港一样，有钱的买商品房，一般的买普通限价房，经济实用房，没钱的住公屋或廉租。反而持有普通住宅多套的会不会逐渐减少？</p><p><strong>kkndme：</strong></p><p>公租房只能是有一定量，不会是大量，首先解决的也是体制内的住房问题。持有多套住宅的有自己的市场空间</p><p><strong>醉生梦思1：</strong></p><p>这个问题很好解答，香港公租房占5成比例，私人租房市场委缩了吗？没有，这是市场上不同档次的产品，对应不同的需求。</p><p>就像有人看盘，绿化不好，没有游泳池的房子坚决不要是一样的道理。</p></blockquote><h2 id="贵阳，资源的稀缺导致权贵更容易垄断，通过低收入高物价的方式剥削底层群体"><a href="#贵阳，资源的稀缺导致权贵更容易垄断，通过低收入高物价的方式剥削底层群体" class="headerlink" title="贵阳，资源的稀缺导致权贵更容易垄断，通过低收入高物价的方式剥削底层群体"></a>贵阳，资源的稀缺导致权贵更容易垄断，通过低收入高物价的方式剥削底层群体</h2><p>旅行的第一站，是贵阳。</p><p>一座低收入高消费的西部边远城市。</p><p>当地人说贵阳的消费太黑人，太畸形了。大多数当地人的收入相当于中部城市的县城水平，生活必需品的消费却超过了北京。</p><p>越偏远的地方越黑暗，越偏远的地方越不存在公平，越偏远的地方贫穷群众的比例越大，越偏远的地方权贵生活的越腐败、越奢华。</p><p>越是资源匮乏的地区，权贵阶层越富裕，这是以绝大多数人的贫穷为代价的。</p><p>资源的稀缺，导致权贵易于对资源形成垄断，通过以低收入高物价的方式，对底层群体进行赤裸裸的掠夺。</p><p>于是权贵们鲜衣怒马，下层群众褴褛衣衫。</p><p>贵州难道不是中国的缩影吗？</p><p>在欧洲的商业区，我国权贵们一掷万金，引来欧洲群众围观，瞠目结舌。以至于全世界都没法相信我国不是超级发达国家。</p><p>贵阳的近郊房价已经9000一平米，远郊的金阳房价已经接近了6000一平。</p><p>但是我们能就此判断贵阳的房价存在巨大泡沫吗？</p><p>贵阳到处是山，地少人多，物产极不丰富。</p><p>因此，贵阳的商品房就像贵阳的餐厅一样，和普通群众是完全没有关系的。而对于权贵与精英来说，即使再翻几倍的价格也一样买得起。（腐败啊）</p><p>看看贵阳，想想中国。</p><p>资源的匮乏将形成高度的垄断，导致贫富分化进一步加剧，生活成本大幅度提高，中国正走向低收入高消费的畸形社会结构，群众生活越艰难，权贵的生活就会越富足。  生活必需品和房价都会变得比西方国家更贵。</p><blockquote><p><strong>fzh_0931：</strong></p><p>鉴定完毕，聪明的房托！ 通篇围绕通货膨胀核心立论，既然商品房是商品，那就不具备投资品的一些属性，（帖子里关于清代磁盘子的案例很不错）为什么还要在这里忽悠呢？抵御通货膨胀的手段，除了买房以外还有很多不错的选择，为毛还在这里大谈特谈房价暴涨呢？既然在上世纪90年代是商品房价值发现初期阶段没有买进，那么到了现在这个所谓的价值发现中期或者后期阶段还有什么理由买进呢？（当然，没有自住房的例外，对于投资者来说，眼下投资房产恐怕不是最好的选择）我相信，随着通货膨胀的加剧，我们手里的钞票不断贬值，房子肯定还是会上涨，只不过不是暴涨和普遍上涨，会是局部的，具有某些概念的，那么试问，我们作为普通百姓，怎么才能未卜先知到底是哪一部分的房子会上涨？那一种概念的房子会上涨？恐怕也只有那些个具有神通的精英阶层才能知道，所以作为一个普通小民来说，俺是不会淌这趟浑水滴，俺自己够住就行，真要有天，时来运转，中了六合彩或者虾米大奖之类的，俺实在是不知道那钱做什么用时才会考虑在海南？还是杭州？抑或是南京买所蜗居来等待升值，否则俺只能望房兴叹。。。</p><p><strong>kkndme：</strong></p><p>从2005年开始</p><p>傻空眼里 凡是认为房价不会降的都是房托 凡是买房子的就认为49年加入国民党的。</p><p>装成傻空专骗真傻空的人，一面天天喊着房价暴跌，一面抄了一套又一套</p><p>真傻空除了骂街恨社会，什么也没得到</p></blockquote><h2 id="重庆：高层和别墅怎么选？"><a href="#重庆：高层和别墅怎么选？" class="headerlink" title="重庆：高层和别墅怎么选？"></a>重庆：高层和别墅怎么选？</h2><blockquote><p><strong>yourrainbow：</strong></p><p>Lz还在吗？咨询下重庆房价的走势呀！</p><p>投资别墅与高层的比较！</p><p><strong>kkndme：</strong></p><p>我个人很不喜欢重庆这个城市，但是我不得不说重庆的发展空间很大，无论是经济还是房价。</p><p>别墅，如果有钱投资，一定是别墅，只要不是太偏远的。</p><p><strong>hollybible2018：</strong></p><p>我给你解释为什么楼主推荐别墅了。看问题不是看短时间内，而是要看长远。</p><p>第一，中国富裕阶层追捧什么房型？别墅。要想富，先学会用富人的思维方式思考问题。</p><p>第二，随着中国经济越来越强，人均住房面积会进一步增加，人们选择的房型会由公寓逐渐转移到别墅。</p><p>第三，如果你有在欧美，日本这些发达国家的生活经验，你会知道，公寓是给穷人住的地方，而稍微收入可以的住的都是别墅型的房子。我国按照这样的发展趋势，是能达到这些发达国家的水平。我国曾经现在将来发生的事情都是那些发达国家曾经现在发生的事情。</p></blockquote><h2 id="货币贬值"><a href="#货币贬值" class="headerlink" title="货币贬值"></a>货币贬值</h2><p>刚从青岩古镇玩回来，饭前说说货币贬值。</p><p>货币贬值，来自于大量的印钞</p><p>可不可以少发点钞票。</p><p>对不起，不行。</p><p>这是我国的官有经济体制决定的。</p><h2 id="为什么美国人工高于中国，但大多数商品的物价却低于中国"><a href="#为什么美国人工高于中国，但大多数商品的物价却低于中国" class="headerlink" title="为什么美国人工高于中国，但大多数商品的物价却低于中国"></a>为什么美国人工高于中国，但大多数商品的物价却低于中国</h2><p>凡是去过美国的朋友，会惊奇一个现象  除了人工服务行业，几乎大多数产品的绝对价格都低于国内。</p><p>从数码产品，到奢饰品，从矿泉水，鸡蛋到汽车，统统比国内的绝对价格（把美金换成人民币，再拿人民币进行比较）便宜。（美国的餐馆比较贵是因为包含了人工服务成本）</p><p>不仅仅是美国货比在中国卖的便宜，几乎所有made in china的商品在美国卖的绝对价格都低于国内售价（一件国内生产出口的服装在美国售价150人民币左右，但在国内售价竟然达到800-1000人民币）</p><p>贫穷的发展中国家——我们的物价却远远高于美国，这是什么样的原因呢？</p><p>我想主要还是我们的体制决定的：</p><p>1、高昂的行政成本</p><p>中国庞大的公务员队伍对货币的消耗达到惊人的程度。任何一种商品的销售都要分摊政府高昂的行政开支。不大量印钞票是无法维持正常运转的</p><p>2、过渡依靠政府投资。  大家都知道，中国的经济发展，是依靠政府投资为主导的，全世界都知道，政府投资的效率是最底下的，1个亿的投资往好了说只能产生3000万的效益，剩余7000万损耗掉了。因此政府不得不持续增加货币发行量  3、惊人的fb成本</p><p>一集中箱货物运到美国的成本甚至低于从北京运到深圳的国内运费。这是令人惊讶的事情，又是确凿的事实。中国高昂的高速费用使物流贵得吓人，从农民手中2分钱收购的蔬菜，运到了目的地，成本就变成了1元钱。</p><p>这中间不仅仅是高速费，当公路及铁路运输变得紧张的时候，你不得不花费比高速费更贵的支出用于打点关系。</p><p>关系的成本已经远远贵过商品本身。惊人的fb成本是物价上涨的重要原因，因为权贵贪心也是逐年增加的，fb成本越来越高。fb成本的每年高速增长，迫使印钞需求高速增长。</p><p>4、低附加值产品出口创汇</p><p>低附加值产品出口创汇是我国经济发展的主要支柱。</p><p>可以这样理解，我们的商品卖到了国外，换回的是外汇。国内的商品少了，就变贵了。换回的外汇，国家就会按照外汇的总金额依据汇率全都印成人民币，投放到社会。社会上不但商品变少了，每年还会多印出一大堆钞票，这就是通货膨胀。货币的购买力在持续贬值，国家通过货币持续贬值来收割普通劳动者的羊毛。</p><p>所以说我国高通胀，货币持续贬值，是官有经济体制所决定的。</p><p>是不可能改变的。</p><p>持有闲置现金的风险，比持有任何一种可保存的商品的风险都大。</p><h2 id="还能上车的赶紧上车"><a href="#还能上车的赶紧上车" class="headerlink" title="还能上车的赶紧上车"></a>还能上车的赶紧上车</h2><p>奉劝那些盼着zf政策出打击房产直到崩盘，以此得到高潮的同志们，真的不要等了，除非出现明末的极端事件，否则一辈子等不到高潮。</p><p>也奉劝希望房价能降个30%-50%好买套自己的房子的善良百姓，还是看有什么机会多挣点钱吧，等房价大降真的不现实。</p><p>百姓们希望领导们能给自己做个主，可是几千年以来，中国的上位者们从来都只考虑一个问题：“卧榻之上，岂容他人安睡。”真的没有时间管你们的那些小事儿。</p><blockquote><p><strong>中年不惑吗：</strong></p><p>大家应该知道所谓的康乾盛世，开元盛世都是什么样子了</p><p>上层阶级的盛世而已</p><p>底层老百姓在史书上连“某人甲，某人乙”都留不下</p><p><strong>dantez13：</strong></p><p>康乾确实是虚假的所谓“盛世”开元还是不错的</p><p>看历史不光纵向看 也要横向看</p><p><strong>kkndme：</strong></p><p>开元盛世留下巨大的隐患才导致玄宗悲惨的人生，不应简单的认为是杨玉环和安史之乱的原因。</p><p>首先是大量的土地兼并，大量的农民同志逃跑，社会的不安定为安史之乱埋下了隐患。还有就是节度使的权力太大，以全国之力供养节度使的军备，而内地养了一群废兵。</p><p>相当于老大把精兵干将派去边远山区收保护费，结果自己身边连个像样的保镖都没有。有个收保护费的领班突然不爽，自己想当老大，带着打手跑回去揍老大，准备上位。这时老大就光杆司令一个，看着自己的手下叛变之能干瞪眼</p><p><strong>dantez13：</strong></p><p>我说的看历史纵向横向的意思是指</p><p>康乾时期 纵向来看 还算是个稳定时期 但是17 18世纪 欧洲正轰轰烈烈的搞工业革命</p><p>乾隆却几下江南 还搞什么骑射乃满洲之本</p><p>而开元时期 ，虽然的确有很多隐患 但是大唐还是当之无愧的世界老大</p><p>唐朝也是那个时候达到的巅峰</p><p><strong>kkndme：</strong></p><p>呵呵，大唐当世界老大也不知道是好事还是坏事</p><p>欧洲经历了漫长的中世纪黑暗时代，结果由诸侯割据的封建社会直接进入了资本主义社会，并向国家社会主义过渡。</p><p>中国早在秦就结束了诸侯国林立的封建时代，进入了大一统高度集权的帝国时代，到现在也没完全结束。</p></blockquote><h2 id="武汉：城市发展空间的大小，往往和房价的升值空间成正比"><a href="#武汉：城市发展空间的大小，往往和房价的升值空间成正比" class="headerlink" title="武汉：城市发展空间的大小，往往和房价的升值空间成正比"></a>武汉：城市发展空间的大小，往往和房价的升值空间成正比</h2><blockquote><p><strong>dantez13：</strong></p><p>挨楼主好近 呵呵</p><p>请教一下楼主对武汉这个城市的看法 房价 以及将来发展的空间</p><p>今年刚在武汉出手两套房</p><p><strong>kkndme：</strong></p><p>对武汉的房价真没研究过，不敢妄言。但很看好武汉这个城市的发展。城市发展空间的大小，往往和房价的升值空间成正比，虽然不是绝对</p></blockquote><h2 id="权利让革族成为苗族的一支"><a href="#权利让革族成为苗族的一支" class="headerlink" title="权利让革族成为苗族的一支"></a>权利让革族成为苗族的一支</h2><p>刚从大山深处（枫香）出来，做了6个小时车，到榕江现城，居然赶上全程停水，狂晕。</p><p>枫香是革家聚居区，名族识别的时候本来应该定为革族，结果苗王（也是贵州shengzhang)一句话就把完全不同祖先的革族变成苗族的一支啊。这就是权利的力量。</p><h2 id="房价是否会跌，如果会，会怎么跌"><a href="#房价是否会跌，如果会，会怎么跌" class="headerlink" title="房价是否会跌，如果会，会怎么跌"></a>房价是否会跌，如果会，会怎么跌</h2><p>几天没有上来，发现来了很多比较鸡冻的同志。心情可予以理解。</p><p>但是鸡冻并不能让日子过的更好。</p><p>油价大涨小跌，我们鸡冻了，但是事实并没有改变。</p><p>高速费早就收回成本，可是依然雷打不动的收着，我们鸡冻了，可是事实也没有任何改变。</p><p>房价就能真如很多人所愿，使劲跌到人人买的起吗？今后的现实将告诉我们答案。</p><p>房价会不会跌？</p><p>我说在较远的将来一定会跌，但下跌的方式是完全不同的。不可能象大家所期望的由2010年的30000一平跌到2004年的6000一平。</p><p>下跌一定是另一种方式：当农产品价格以几年翻10倍甚至几十倍的速度上涨的时候，房产却相对滞涨。这是最有可能的下跌方式。</p><h2 id="通货膨胀是减缓灭亡最好的良药"><a href="#通货膨胀是减缓灭亡最好的良药" class="headerlink" title="通货膨胀是减缓灭亡最好的良药"></a>通货膨胀是减缓灭亡最好的良药</h2><p>最善良的意愿并不能阻止事务向邪恶的方向发展。</p><p>我们大家都很清楚却都没关注的一个常识，当我们满怀热情无偿献血的时候，有哪个贫穷的患者在需要输血时，能够因为广大群众的无偿献血而得到医院的优惠吗？</p><p>不能，无论你是穷是富，只要你是平头百姓，你都不得不因为需要输血而支付昂贵的医药费。</p><p>同样，zf并不会因为拆迁给你补偿的太低，而强迫开发商降低房价卖给群众。压低建设成本，抬高售价，中间的利润由商人和权贵进行分配，这是官商结合的通行做法。自古以来，能够赚大钱的都是红顶商人，而不是普通个体户。</p><p>对于很多鸡冻的群众，指着鼻子问我：国家会不管吗？疯狂难道不是导致灭亡吗？</p><p>我告诉你，通货膨胀就是减缓灭亡时间的最好良药</p><blockquote><p><strong>被忽悠的群众：</strong></p><p>请楼主解释一下</p><p>通货膨胀是zf偷偷掠夺人民财富的手段，极少数人暴利，怎是良药？？？</p><p><strong>kkndme：</strong></p><p>通货膨胀是zf偷偷掠夺人民财富的手段，极少数人暴利————没错，通货膨胀就是剪老百姓的羊毛，让权贵的财富更集中，中下层群众更贫穷。</p><p>但是，从国家的统治与巩固来讲，的确是良药啊（当然有一定限度）。</p><p>当大多数资源掌握在少数人手中的时候，占有绝大多数的金字塔下层的群众能够分配到的资源就越少，资源的价格就会越高，少数的金字塔中上层的既得利益者就会越富有。</p><p>大家知道，有些资源会变成富人间的游戏（比如现在的古董，字画），完全失去群众基础；而如果与生活密切相关的资源过度集中，一定会爆发极端冲突事件，造成社会动荡。</p><p>zf通过不断稀释货币的实际购买能力，并且对粮食等生活必需品实行平准制度，一方面保证了绝大多数人民的基本吃饭问题，另一方面让中下层群众手中的余钱基本消耗在特定的商品上，以至于不得不马不停蹄的劳作，这才能保证社会的稳定和向前发展。而上层精英就可以坐享其成。</p><p>让我们回顾一下过去</p><p>80年代，那时的人们靠省吃俭用积攒出节余，被消耗在自行车、手表、缝纫机上。通过不断的劳动，才能吃饱饭，才能攒点钱买三大件取媳妇。</p><p>80年代末，90年代初，人们的工资提高了，手里的结余增加了，彩电、冰箱的大规模普及又消灭了老百姓手中的流动性。</p><p>紧接着电话、空调又接过了彩电、冰箱的大旗。那时安装个电话可要5000大元啊。</p><p>随着工业化水平大幅度提高，经济高速增长，货币发行量也迅速增加，彩电、冰箱等工业化大规模产品已经不具备稀缺资源的特性，也无法吸收百姓手中庞大的结余资金。</p><p>汽车和商品房的发展成为消灭老百姓手中的流动性的最好工具。</p><p>在经济发展的大潮中，一旦对资源的支配权可以换取利益，贫富两极分化是发展的必然。随着贫富分化开始加剧，财富集中在少部分人手中，集中了大量财富的少部分人已经不满足于购买普通的消费品（汽车是工业化的产物，不具备稀缺性），对投资品的追捧造就了2005年房地产的崛起。</p><p>房地产具备了投资品和生活必须品的双重属性，即可以让金字塔中上层的精英群体依靠房地产保值增值，又可吸收掉中下层群众的未来若干年的结余资金。</p><p>大量印刷的货币还是有一定数量留到勤劳肯干的白领手中的，而这些货币又因为通货膨胀因素消耗在不断上涨的生活必需品上，必需品中商品房占了大头。</p><p>于是拥有大量房产的金字塔中上层精英可以坐享其成，享受房产升值带来的收益，而中下层群众不得不为房子打工。</p><p>发行大量货币满足经济发展的需要，同时通过通货膨胀来消灭广大群众手中的流动性，是zf稳定社会，发展经济的法宝，适度的通货膨胀当然是缓解社会矛盾的良药</p><p><strong>tjOOSAN：</strong></p><p>楼主！这段话，我不是很明白。</p><p>好像世界上，每个国家都是如此把？谁会不买东西？谁会不买生活必须品？</p><p>别忘了，中国发展到现在，百姓也没有能力购买一切生活必须品！当然，随着社会的发展，人民在一点一点的去完善基本生活。</p><p>这你却说成。。。精英和国家的阴谋。。。我。。。很难理解。</p><p>稳定粮食价格，这对每个国家而言，都是必须的啊！？？这最最基本了吧？</p><p>房子为什么涨价？？？国家决策！懂吗？间接取消了经济适用房政策。市场上百分之九十都是商品房！！你告诉我，房价能不涨吗？</p><p>房价涨了，受益人是谁？？？是政府！！不是你嘴里所谓的精英，他们只是傀儡罢了！</p><p><strong>kkndme：</strong></p><p>不是阴谋，我没提过一句阴谋，是国策</p><p>好比美国，以中产阶级利益为代表的美国，一个币值相对稳定的国家，主导借钱消费，这就是国策。</p><p>当08年的金融危机，多数中产却尝到了惨痛的教训。而在美国的华人，因为热爱储蓄的原因（这跟美国币值相对稳定、华人储蓄习惯都有关系），生活并没有受到太大影响。</p></blockquote><h2 id="货币供应不足是明朝的真正原因"><a href="#货币供应不足是明朝的真正原因" class="headerlink" title="货币供应不足是明朝的真正原因"></a>货币供应不足是明朝的真正原因</h2><p>明朝末年，可怜的崇祯皇帝面临的最可怕的问题貌似两个:一是努尔哈赤的入侵；一是大饥荒下，到处闹蚁贼。光是努尔哈赤的入侵，明末的关宁铁骑完全可以将满人挡在山海关外；光是蚁贼肆虐，凭洪承畴、孙传庭等名将镇压一群乌合之众还是易如反掌的；内忧外患才导致了明朝的灭亡。这是通行的说法。</p><p>明朝灭亡的真正原因，是经济原因。</p><p>当然，这也是句废话，无论是社会的稳定，还是国家的动乱，或者邻国间的战争，都是经济原因导致的。</p><p>明朝真正灭亡的原因是：货币供给不足。</p><p>不要说百姓的经济行为受到很大制约，即使是军队也发不出饷银。以至于除了关宁铁骑以外，明朝就找不出一支有战斗力的军队，甚至洪承畴、孙传庭打高迎祥、李自成、张献忠，居然靠农民军的馈赠过日子。</p><p>货币供给不足，明朝的经济崩溃了。</p><h2 id="经济问题是导致清朝灭亡"><a href="#经济问题是导致清朝灭亡" class="headerlink" title="经济问题是导致清朝灭亡"></a>经济问题是导致清朝灭亡</h2><p>再谈谈鸦片战争和那个满脑子浆糊的林则徐。</p><p>鸦片战争的原因，在于大清国与欧洲诸国之间存在的巨大贸易顺差。</p><p>大清虽然闭关锁国，丝绸、茶叶、瓷器通过民间和官员私下大量出口欧洲换取白银，却没有任何的进口需求。以至于英、法国家不得不世界范围开采银矿，但依然不能满足采购中国商品的需求。</p><p>英法诸国必须要与中国通商贸易，才能解决贸易顺差这个根本的问题。英国人实在不知道拿什么商品来进行贸易(貌似中国什么都不需要），于是不法商人想出了鸦片撬开中英贸易缺口的馊主意——这并没有得到英国官方的支持。</p><p>但是林则徐同志既不懂得经济，又不懂得外交，对欧洲人的认识也就停留在：我不给你茶叶，你的腿都站不直。  不管洋人打算干什么，总之洋人就是邪恶的，就该抓起来打板子。于是，自然而然的一顿开打，结果可想而知。  于是清朝官员施展出了村骗乡，乡骗县，一骗骗到guowuyuan，的传统技能，咸丰同志在故宫几乎自始至终听到的都是捷报频传。</p><p>清末，一会儿闹拳匪，一会儿闹白莲教，一会儿闹太平天国。然而，靠鸡冻的群众杀几个洋毛子并不能使中国变得强大。林则徐如果能够有点知识，不妄自尊大，能够说动咸丰开放正常通商贸易、拒绝鸦片，联军入侵圆明园的事大致可以避免。</p><p>经济问题才是导致社会动荡，战争爆发的根源。</p><blockquote><p>挑个刺 第一次鸦片战争清的皇帝是道光不是咸丰 白莲教不是清末的而是清中叶嘉庆年间的</p><p><strong>kkndme：</strong></p><p>确实是道光不是咸丰，笔误，特此道歉。</p><p>白莲教始于宋，最早可以追朔到南北朝时期，最早的名字叫“白莲社”。白莲教其实就是摩尼教，也就是倚天屠龙记里的明教，朱元璋靠白莲教得了天下，所以明代对白莲教的镇压异常残酷。清代的白莲教出现了许多分支，如八卦教、天地门教，先天教等等，总之白莲教从元代开始一直到清末都是闹得很凶的。</p></blockquote><h2 id="房产投资的几点建议"><a href="#房产投资的几点建议" class="headerlink" title="房产投资的几点建议"></a>房产投资的几点建议</h2><p>感谢大家的支持，不少朋友还提了一些关于房产投资的问题。</p><p>我觉得无论做什么样的投资，自己一定要做足功课。就房产来说，对于区域经济发展，要有深刻的理解，否则就不要轻易出手。</p><p>关于房产，我只是从大方向上说了一下自己的判断，并没有对区域的房产升值做过研究，所以没法给大家提供建议，请大家谅解。</p><p>不过，关于房产投资的方向，也有几点心得：供大家参考：  一、坚决不能投资自己不熟悉的城市 二、坚决不投资中小城市，一般省会及计划单列以上城市问题都不大，但中小城市即使房价上涨也存在变现困难问题。 三、坚决不投资距离大城市较偏远的旅游城市，比如山东乳山之类的，几乎无法变现。 四、慎重投资大城市的郊区，除非价格绝对低。如果外来人口比较多，zf又有发展规划，且价格与城区相比有较大的价差，才可以考虑</p><h2 id="人民币对外升值，对内贬值"><a href="#人民币对外升值，对内贬值" class="headerlink" title="人民币对外升值，对内贬值"></a>人民币对外升值，对内贬值</h2><blockquote><p>楼主，据sz的统计公布09年底的商品房存量4~5万套，33%左右的自由率，10年新建成面积在300万平米左右，应该不算泡沫吧？目前美元走强，人民币贬值会导致国外热钱以及权贵的钱逃走么？对房地产影响怎么看？</p><p><strong>kkndme：</strong></p><p>人民币对外是升值，对内贬值</p></blockquote><h2 id="南宁买房建议"><a href="#南宁买房建议" class="headerlink" title="南宁买房建议"></a>南宁买房建议</h2><blockquote><p><strong>showforme：</strong></p><p>LZ帮忙分析南宁的楼市情况，这边的房价均价是6000多，最近中央说要投资1.5万亿给广西发展北部湾经济，也许对南宁楼市有一定的刺激作用，我想近期买一套房自住+投资，现在入手合适还是等到年底合适？</p><p><strong>kkndme：</strong></p><p>自住+投资？</p><p>自住房首要考虑的还是生活方便，不要太多考虑涨跌，没有意义，如果手里有钱就可以买。</p><p>南宁的房价我不清楚。但南宁是一个经济高速发展的城市是毋庸置疑的。</p><p>相对于昆明，南宁在面向东南亚贸易方面，有着更得天独厚的优势——港口。</p></blockquote><h2 id="经济适用房都是内部分配的"><a href="#经济适用房都是内部分配的" class="headerlink" title="经济适用房都是内部分配的"></a>经济适用房都是内部分配的</h2><blockquote><p><strong>yjfsam：</strong></p><p>看新闻说,在经济适用房里提供一定数量的廉租房,而不是大量廉租房,经济适用房是可以购买的,而且是建在市中心附近,如果是我,我当然是想买经济适用房,而廉租房又不多,这会不会跟楼主的意思有点不一样?</p><p>另外经济适用房在高价房附近推出,可以打压附近房价?</p><p><strong>kkndme：</strong></p><p>你认为建在市中心附近的经济适用房是给普通老百姓建的吗？是低收入群众有资格购买的吗？</p><p>经济适用房都是内部分配的，但一旦走进市场就可以牟取暴利了。</p><p><strong>tjOOSAN：</strong></p><p>大哥！！我真服你了。。。。。。</p><p>你知道 定向分配吗？？？就是只有拆迁户才有资格买的房子。不存在收入的问题！！</p><p>你纯粹是胡诌啊！我发现</p><p><strong>kkndme：</strong></p><p>兄弟，你一直比较鸡栋，呵呵</p><p>拆迁户的定向房属于另外的问题，作为有产阶级的拆迁户来说，部分是城市扩大化的受益者，而部分又是受害者，不能一概而论。时机不同，城市不同，境遇也不同。</p><p>但是有一点可以肯定，拆迁的目的，不是为了拆迁户过得更好更舒服。开发商愿意支付高额的拆迁费（只限于超大型文明的城市，许多城市拆迁户的补偿是很可怜的）而是有更大的利润可图。</p><p>zf为主导建设的市中心经济适用房也不仅仅为了拆迁户回迁，拆迁户回迁比例最多占小区总放量的30%，而其余的基本上是权贵房</p><p><strong>tjOOSAN：</strong></p><p>我可不激动！就是闲的没事，来找事吧！还算是正事！</p><p>你说的什么给权贵房，固然存在。但是比例太太少了！！你说的话，根本没有依据！</p><p>现在买限价房的和经济适用房的人，都要在报纸上公布姓名和住址。</p><p>而且只要不是太穷的，基本都希望拆迁！因为第一，给的钱多。 第二 可以有定向分配。而且还是好地段的房子！！</p><p><strong>kkndme：</strong></p><p>兄弟你还是去了解一下体制内分福利房的真相吧。</p><p>福利房占用的都是经济适用房的指标啊</p><p>真正向社会公示的保障房才有多少呢？相对于数量庞大的福利房，可以说凤毛麟角。</p><p>不了解真相就没有发言权啊</p><p>特别是在二三线城市，房源比一线相对略为宽松，一个有点级别的公务员，通常都是分两三套房，这些房子占用的都是保障房的指标，都是要统计入保障房数据的。</p><p>不信你可以问问身边的公务员、银行员工、垄断企业员工。</p><p><strong>tjOOSAN：</strong></p><p>奥！你说的是，传说中的 国企员工啊！！</p><p>可你一开始却说得是 经济适用房！是你搞错了把？</p><p>国企员工分配房子的，也要够一定工龄！一定级别！不是谁都有的。好伐？</p><p>而且 现在中国地产，很大一部分就是国企投资的。</p><p>所以叫内部分配么！！国企分房，在中国的体制内是正常的！</p><p><strong>kkndme：</strong></p><p>传说中的上海人？</p><p>我没有搞错，体制内员工分配的福利房就是经济适用房。</p><p>我举个例子，昆明武警干部的福利房叫恒安新邻居，它的官方名称叫什么？</p><p>我告诉你，叫做“武警经济适用房小区”</p><p>你看到的内部分房，占用的都是经济适用房的指标，也就是占用的是：我们所说的为了解决民生问题的保障房的指标。</p><p><strong>tjOOSAN：</strong></p><blockquote><p>kkndme</p><p>你认为建在市中心附近的经济适用房是给普通老百姓建的吗？是低收入群众有资格购买的吗？</p><p>经济适用房都是内部分配的，但一旦走进市场就可以牟取暴利了。</p></blockquote><p>这可是您自己的原话啊？？对吧？？</p><p>市中心的经适，就是叫做定向分配。就是 在这附近拆迁的人，住的！！</p><p>你非要说，有人谋私，我也不反对！但绝对不会多。</p><p><strong>kkndme：</strong></p><p>我估计是你理解错了，谋私和牟取暴利是两回事。</p><p>假设你是某市科级公务员，分到两套房子，以保障房的价格购买，但是却可以按照市场价格出售，只要一转手就可以进账几十万甚至上百万。</p><p>这就是分房双轨制给体制内有级别的员工带来的暴力机会。这跟谋私没有关系</p><p><strong>tjOOSAN：</strong></p><p>我觉得楼主拿经济适用房 做例子。很愚笨。</p><p>中国房价高起的根本原因，不就是国企，制造业资金进入地产么。</p><p>经济适用，现阶段就是为拆迁户盖得。</p><p><strong>kkndme：</strong></p><p>晕，也许你们上海是吧，放眼全国肯定不是</p><p><strong>jellyoak：</strong></p><p>上海今年以前根本没有过经济适用房，恰恰相反，上海是商品房最彻底的城市</p><p>给动迁户的叫动迁安置房，绝对都是建在最偏僻的地方的，最近5年基本上没有原拆原回的安置。</p><p>那位激动的同志有点多动症的嫌疑，忽略算了。</p><p><strong>tjOOSAN：</strong></p><blockquote><p><strong>kkndme：</strong></p><p>我估计是你理解错了，谋私和牟取暴利是两回事。</p><p>假设你是某市科级公务员，分到两套房子，以保障房的价格购买，但是却可以按照市场价格出售，只要一转手就可以进账几十万甚至上百万。</p><p>这就是分房双轨制给体制内有级别的员工带来的暴力机会。这跟谋私没有关系</p></blockquote><p>你。。我不知道你说这个是什么意思？</p><p>贪污腐败是少数。这是肯定存在的现象。但我现在讨论的是大众现象！</p><p>而且内部分房的们都要够一定级别！就算他们一人分三套，那根本对楼市没有影响的</p><p><strong>kkndme：</strong></p><p>我说的是房产双轨制，是一种制度，不是说个人的以权谋私。</p><p>房屋问题实际上是土地问题，当一少部分人群能够以很低的代价占有更多的土地，市场上的土地就会变得稀缺，价格就会上升。</p><p><strong>jellyoak：</strong></p><p>可以说上海是最彻底的商品房市场化的城市。</p><p>没有小产权，没有福利分配，完全的市场化。</p><p>唯一的例外就是动迁户能分配到动迁安置房，虽然都是地处偏远但现在也都价值高昂。</p><p>lz说的那种公务员分配的安置房在很多城市是很普遍的。</p><p>情况绝非那位偏执狂TX所理解的</p><p>事实是庞大臃肿的公务员机构都有机会给这些公务员分配到一套住房，总数量很是惊人。</p><p>如果严控贷款的话，现在上海的房价是得不到长久支撑的。</p><p>看长期政策如何了。</p><p>现在没人相信贷款可以一直这样卡下去。</p></blockquote><h2 id="普通人怎么办：尽早买房，努力挣钱抵御通胀"><a href="#普通人怎么办：尽早买房，努力挣钱抵御通胀" class="headerlink" title="普通人怎么办：尽早买房，努力挣钱抵御通胀"></a>普通人怎么办：尽早买房，努力挣钱抵御通胀</h2><blockquote><p><strong>被忽悠的群众：</strong></p><p>楼主：我们P民怎么办呢？只有买房保住自己的社会地位！？</p><p><strong>kkndme：</strong></p><p>问题是房子将会是普通人越来越难以参与的游戏，门槛越来越高。</p><p>只有努力工作赚钱才是唯一能抵抗通胀的办法，这也是zf最希望看到的。</p><p>当然体制内员工，工资制度本身就可以抵御通胀。这些多发出来的钱是需要体制外广大群众创造出来的，因为体制内员工本身并不直接创造价值。</p><p>而体制外的广大群众要想抵御通胀，就必须努力工作，创造更大的价值来提高收入水平。</p><p>这也就是国家能够维持运转的根源所在啊</p></blockquote><h2 id="房价会出现很多上下波动"><a href="#房价会出现很多上下波动" class="headerlink" title="房价会出现很多上下波动"></a>房价会出现很多上下波动</h2><blockquote><p><strong>fengyu1218：</strong></p><p>楼主，你所分析问题透彻明晰，很受启发</p><p>但是立足于将任何问题都用P民跟精英阶层对立的观点，我觉得有点绝对</p><p>社会阶层的复杂性，以及相互之间的博弈会在特定的阶段</p><p>有特定的表现形式，比如，当房价太高，P民阶层抗议不断的时候</p><p>会有所谓的调控出来，尽管成效不大</p><p>统治阶层也不会任由社会矛盾积累到最大程度而不作为</p><p>所以房价的表现形式会出现很多的上下波动</p><p><strong>kkndme：</strong></p><p>你说的对，房价趋势是上涨，但一定会有短期的波动</p><p><strong>tjOOSAN：</strong></p><p>而且对于你所标榜的“暴涨” 你自己后来也改了，是在波动中上涨！</p><p>那还是暴涨吗？你都违背了自己的标题。</p><p><strong>kkndme：</strong></p><p>呵呵，短期的调控并不能改变长期上涨的趋势，</p><p>当资金的运作规律收到外力的压制，短暂低头的房价就会迎来暴涨。这是规律。</p></blockquote><h2 id="买房时机的选择（真TM厉害，这竟然是2010年的建议，可恨的是2020年才看到）"><a href="#买房时机的选择（真TM厉害，这竟然是2010年的建议，可恨的是2020年才看到）" class="headerlink" title="买房时机的选择（真TM厉害，这竟然是2010年的建议，可恨的是2020年才看到）"></a>买房时机的选择（真TM厉害，这竟然是2010年的建议，可恨的是2020年才看到）</h2><p>很多朋友都关心买房时机问题</p><p>对于自住需求者和投资需求者是要区别对待的</p><p>对于一线城市与二三线城市也是要区别对待的</p><p>对于自住需求者（仅指普通群众）来说，只要你还有钱能够买的起房，那你就买吧。</p><p>不要赌博和赌气，因为真的赌不起。</p><p>人人都可以买得起商品房，只是一个美丽的童话。</p><p>当然如果你赶上了国家调控的好时机，那你就要认真选房，做足功课，迅速出手。因为买到一套户型、位置、楼层都让你满意的房子，在商品房热销期，是很难的事情，根本没有给你挑选的机会，而在调控期，或许房价没怎么下降，但绝对给了你挑选的余地。</p><p>对于投资来说，问题就比较复杂，要考虑的问题就会更多，不同条件的人就有不同的需求。</p><p>总的来说在严厉调控期，需要关注以下几点：</p><p>一、当新盘的价格低于周边二手房的价格。 二、当看房的人不断增加 三、当kas拿地热情大减，以至于多处土地流拍</p><p>以上三点是提示你准备出手的信号。</p><p>对于一线城市，一定会有一段时期小幅下跌，及跌后滞涨。</p><p>对于二三线城市，多数城市会缓步持续上涨。但遇到大规模拆迁的城市，那房价就会忽视调控，选择快速上涨。近期，在二三线城市，无论自住还是投资，都是早买好于晚买。</p><h2 id="收入分配改革跟体制外的人没关系"><a href="#收入分配改革跟体制外的人没关系" class="headerlink" title="收入分配改革跟体制外的人没关系"></a>收入分配改革跟体制外的人没关系</h2><blockquote><p><strong>feifeilongdi：</strong></p><p>请问楼主国家的收入分配改革调整的是哪一部分人的收入？</p><p>我们底层p民如果真的连公租房都只能勉强供得起，那以后子女的抚养费用，夫妻以后的养老资金如何解决</p><p><strong>kkndme：</strong></p><p>工资收入分配改革应该只是个说法，对公有制经济是很有实惠的。但非公有制员工的工资是阳光雨露都撒不到的。</p><p>以前说涨工资基本都是公务员，收入分配改革后可能对事业单位及国企工资收入有明显改善。</p><p>至于体制外，无论打工仔和个体户都是自生自灭的</p></blockquote><h2 id="体制外的人要早早考虑养老问题"><a href="#体制外的人要早早考虑养老问题" class="headerlink" title="体制外的人要早早考虑养老问题"></a>体制外的人要早早考虑养老问题</h2><p>体制外人员养老确实是个问题</p><p>做生意的赚钱养老</p><p>聪明的下手早的以房养老</p><p>最惨的是没有混上去，且又没有特殊技能的私企打工仔。养老实在是个大问题。</p><p>所以东部地区才有宁挣老板1000元，不赚打工5000块的说法。</p><p>双轨制下，低层群众想翻身确实比较难。</p><h2 id="永远不要和白痴争辩，因为他会把你的智商拉到和他同一水平，然后用丰富的经验打败你"><a href="#永远不要和白痴争辩，因为他会把你的智商拉到和他同一水平，然后用丰富的经验打败你" class="headerlink" title="永远不要和白痴争辩，因为他会把你的智商拉到和他同一水平，然后用丰富的经验打败你"></a>永远不要和白痴争辩，因为他会把你的智商拉到和他同一水平，然后用丰富的经验打败你</h2><p>鸡冻先生</p><p>能够有资格跟你辩论的一定只有两种人</p><p>一种是智商极高，世间罕见的</p><p>一种是智商比较低的。</p><p>其他人跟你辩论那是自找苦吃</p><h2 id="当个农民也要懂政策，要顺政策而为"><a href="#当个农民也要懂政策，要顺政策而为" class="headerlink" title="当个农民也要懂政策，要顺政策而为"></a>当个农民也要懂政策，要顺政策而为</h2><p>刚从深山老林钻出来，终于找到地方洗澡了，我激动啊。</p><p>洗完澡轻松，讲一个刚从支书那里听来的故事。</p><p>大家普遍感觉很穷的贵州省榕江县栽麻乡宰荡村，在解放前却是有名的富裕村，他们靠勤劳开垦荒地，良田多到种不过来，直到土改后，zf将宰荡的良田分给了加所、林所等周围几个土地较少的村子的村民（这些村子土地少的原因主要还是周围几个村子的村民比较懒惰，宁肯受穷也不愿意开垦荒地），宰荡才穷下来。</p><p>因为宰荡村过去比较富裕，拨给的富农指标就比较多。有一户人家很富裕，按理应该划为富农，但这户人家很了解政策，知道评上富农就会挨整，于是走关系，成分改成了中农。</p><p>而其他大多数依靠勤劳致富的人家非常老实，也不懂评为富农有什么不好，认为什么成分都无所谓，还不是老老实实干活。结果可想而知。当上了富农接下来就是没完没了的批斗。</p><p>这个故事告诉我们，哪怕当个农民也必须了解zf的意图。</p><h2 id="存钱不如存资产，钱会贬值，资产会升值"><a href="#存钱不如存资产，钱会贬值，资产会升值" class="headerlink" title="存钱不如存资产，钱会贬值，资产会升值"></a>存钱不如存资产，钱会贬值，资产会升值</h2><p>去年在宰荡做了一段时间的田野调查，今年这次来算是回访。时过一年，发现去年村子附近的大多数农田，今年都变成了房子。</p><p>现在农民政策还是可以的，即使贫困如贵州山区，农民除了能够完全自给自足外，多余的粮食蔬菜也能换来一定的经济收入，随着家境变好了，对更大的房子的需求也就产生了，农民愿意把闲钱都用来盖成更大的房子，宁肯牺牲掉自有耕地。这其实是一件可怕的事情。</p><p>这次同样对村民做了入户调查，发现了一件有意思的事情。</p><p>村民最感到遗憾的事情就是早在2000年初，那时村里还没有电，村民为了想让全村通电，卖掉了所有山上的古树。电通了，当时的村民很高兴，而且认为古树卖了一个高价格（当时总共卖了6万块钱），换来了全村的生活方便。</p><p>大约在三年后，其他村寨，zf都给免费通了电。如果那些古树不卖掉，现在随便一颗的价格都超过了6万。现在那些古树至少值几百万。</p><p>村民们用最朴实无华的思想总结了一个道理：存钱不如存房子、存木头、存树</p><h2 id="房子越早买越好，zf想钱想疯了"><a href="#房子越早买越好，zf想钱想疯了" class="headerlink" title="房子越早买越好，zf想钱想疯了"></a>房子越早买越好，zf想钱想疯了</h2><p>全国人民都知道有个以雷厉风行著称的球书记</p><p>球书记曾说过一段著名的话，大意是：昆明的开发商拿地价格很低，卖的价格却很高，腐败才是高房价根源。</p><p>当时昆明的很多无房户都很鸡冻，以为这下可好了，找到问题根源了，昆明房价要降了。</p><p>可是我听到的意思却是：zf卖地卖得太低了，应该大幅提高土地价格。</p><p>果然不久就出台了54321政策，以前拿地没走招拍挂程序的，一律按照54321补交土地款，否则开发商不发放任何证件，以至于升级到已买了房的业主也拿不到房产证。</p><p>于是昆明的新盘由于手续问题都无法开盘，已经卖掉很久的老盘，开发商还要求业主补交房款，否则退房。</p><p>结果可想而知，昆明的房价以一环与二环之间为例，由去年下半年的6000多涨到现在的均价过万。</p><p>如果从民生着想，会做出这样荒唐的事来吗。</p><p>帖子里有朋友问昆明的买房时机，我只能说越早买越好，因为dfzf想钱已经想疯了</p><h2 id="利益才是zf行为的指挥棒"><a href="#利益才是zf行为的指挥棒" class="headerlink" title="利益才是zf行为的指挥棒"></a>利益才是zf行为的指挥棒</h2><p>北大朱晓阳用了十多年时间跟踪昆明城中村，对刚刚建好5年的宏仁村就要因为商业利益而拆迁已经出离了愤怒，结果这事捅到CCAV曝光了，拆迁的事只好暂停。</p><p>利益才是zf行为的指挥棒</p><h2 id="建议一定是建立在严肃考察的基础上"><a href="#建议一定是建立在严肃考察的基础上" class="headerlink" title="建议一定是建立在严肃考察的基础上"></a>建议一定是建立在严肃考察的基础上</h2><blockquote><p><strong>爱情就像跳恰恰：</strong></p><p>这两天全部看完了，深受触动，楼主是个睿智的人，赞一个~</p><p>想说下自己的情况，楼主帮我参谋一下，我在上海，女性，前几年由于一些特殊个人原因，导致一直没有自己的房子，这两年专注于事业，今年发展不错，进帐了260万左右，但是，通过几次看房，我发现 300万以内，已经找不到理想的房源！</p><p>我现在是租住的市中心高档住房，每月租金 8500块，100个平米左右，这样的房子大概售价 500万左右，所以，现在的情况是 我想住的房子买不起，买的起的我也不想住~</p><p>我本人对买房和租房没有太大感觉，从某种意义上说 我倒更喜欢租房，可以每两年换个区 换套新房住住 比较有新鲜感~但是，我手上也不想持有现金，由于物价上涨，通货膨胀，我觉得持有现金的风险也不小！</p><p>不知道楼主对扬州的房产怎么看，我想放弃上海，到扬州购入房产，处于保值或者以后升值空间大后再售出，比如在市中心购入两三套高档小户型，用于出租！扬州由于地理优势，一两年后可能开通上海高铁，这样考虑在扬州安个家也不错，再置入一套生活便利的大点房子，以后可以考虑自住~</p><p><strong>kkndme：</strong></p><p>你的想法显然是经过深思熟虑的，在扬州买房子自住，花更少的钱过更舒适的生活很好啊，当然前提是你自己喜扬州这个城市。</p><p>说到投资，其实没人能够取代你自己的判断。我也没法给你提供究竟有多大升值空间的建议，因为建议一定是建立在严肃考察的基础上的。</p><p>我只能说东部地区的城市房产保值还是没问题的，但在哪个城市投资更好，确实需要认真实地考察。</p><p>如果从全国范围看，仅对投资而言，我比较看涨西安和重庆。但我个人不会在这两个城市买房子，因为本人不喜欢重庆的酷热和西安的气氛。</p></blockquote><h2 id="石家庄"><a href="#石家庄" class="headerlink" title="石家庄"></a>石家庄</h2><blockquote><p>楼主，请评价下石家庄的楼市，是暂时的价值洼地还是长期？</p><p><strong>kkndme：</strong></p><p>石家庄的地理和经济上的位置都比较尴尬。山西和天津都比石家庄有更好的优势</p></blockquote><h2 id="投资最重要的是稀缺性，买房首选公务员小区"><a href="#投资最重要的是稀缺性，买房首选公务员小区" class="headerlink" title="投资最重要的是稀缺性，买房首选公务员小区"></a>投资最重要的是稀缺性，买房首选公务员小区</h2><p>说到买房子，无论投资还是自住，最重要的还是稀缺性，首选还是学区房。</p><p>自住最好买政府公务员小区，无论是商业配套，教育配套以及休闲娱乐配套都是商品房所无法比拟的。特别是商品房经过十几二十年，房子旧了，电梯很容易出故障，如果物业有问题或者小区里有人不交物业费，那么这个小区就很难住了。公务员小区则完全不用考虑房子老旧的问题，那都是zf包干到底的。</p><blockquote><p><strong>usstcai：</strong></p><p>怎么找这种房源呢？</p><p><strong>kkndme：</strong></p><p>每个城市的情况不一样，北京基本上是单位的老公房，老计委的房，中石化的房都有上市交易的，但新房很难找。</p><p>至于二三线城市，现在还存在大量的公务员、垄断企业的新小区，并且很多房源都在市场上交易。比如昆明，存在大量的权贵小区，比如金江小区是省政府公务员小区，月牙塘小区是市政府公务员小区。</p></blockquote><h2 id="远离垃圾人"><a href="#远离垃圾人" class="headerlink" title="远离垃圾人"></a>远离垃圾人</h2><p>关于流氓无产者，在宰荡村子里还听了个故事</p><p>说很久以前的事情。</p><p>宰荡村民都很勤劳很淳朴。但是意外的出了一个叫罗老黑的人。</p><p>这个人好吃懒做无所事事，看见人家地里庄稼蔬菜长的好就跑去抢，为此挨过几次打。有一天罗老黑路上遇到个大兵，骗了大兵的枪，于是开始在村子里耀武扬威，不但抢人家辛辛苦苦种的菜，遇到单身的姑娘还动手动脚。</p><p>罗老黑在村里到处宣传他的逻辑：村里的庄稼、蔬菜、猪牛应该见者有份。</p><p>村里一些年轻人受了罗老黑的感染，开始变得好吃懒做，谁家种的东西都跑去拿。于是，村里人都不愿意劳动了，宰荡村开始变穷。</p><p>村里有个人很憎恨罗老黑的行为，但不敢明着跟王老黑作对，就在晚上在王老黑家放了一把火。侗族人住的房子都是杉木的，一旦一家着火，很可能全村遭殃，那把火烧了整个宰荡寨子，连青石板都烧裂了。</p><p>罗老黑，这个典型的流氓无产者，他的光荣事迹被当作反面教材激励着世世代代的宰荡村民。</p><h2 id="高房价或许有天会崩盘，但你等不到那一天"><a href="#高房价或许有天会崩盘，但你等不到那一天" class="headerlink" title="高房价或许有天会崩盘，但你等不到那一天"></a>高房价或许有天会崩盘，但你等不到那一天</h2><blockquote><p><strong>zhuce010022：</strong></p><p>不合理的制度不会永远的存在下去的。。。正如国父当年说的一句“天下大势浩浩荡荡，顺之者昌，逆之者亡”。。。</p><p>现在的高房价是目前中国的政治、经济结构失序造成的。</p><p>楼主上面分析了那么多，确实是，在目前这种局面下可能一直冲到崩是唯一的选择，但是，你怎么知道这种失序的大局面会一直持续下去呢？</p><p><strong>kkndme：</strong></p><p>一个朝代从鼎盛到衰亡至少维持个一两百年。所谓天下大势分久必合，合久必分，由合到分，总还是有个时间跨度的。</p><p>侥幸能在有生之年平平安安就是最大的福气，身死之后，哪管洪水滔天</p></blockquote><h2 id="房子不仅要早买，而且有能力的话不要怕压力，争取一步到位"><a href="#房子不仅要早买，而且有能力的话不要怕压力，争取一步到位" class="headerlink" title="房子不仅要早买，而且有能力的话不要怕压力，争取一步到位"></a>房子不仅要早买，而且有能力的话不要怕压力，争取一步到位</h2><blockquote><p><strong>傻子也疯狂：</strong></p><p>楼主</p><p>你好</p><p>跟你的帖子已经两晚上了，还是没看完</p><p>不过已经到第六页了，我会继续跟下去</p><p>感觉你分析很有道理，也很深奥 以前在一个炒房人的终极预测也看到过类似的帖子 慢慢的也有所感悟 现在想请教你个问题，也是我自己面临的问题</p><p>人在深圳，想趁今年调控在武汉买套房子，因为有回武汉发展的想法 我毕业三年，收入不高，目前可能首付都不够（40万总价我想付10–15万，别笑我无能）总是在想是等我存够了首付再回去看房子还是现在就订下来，订下来吧钱不够，可能要问朋友借点，既要还债又要月供怕压力大，如果先不买等存够钱我怕那时候房价又上去了，所以想你帮我参考参考，给点建议，谢谢，诚信请教</p><p>另外，我和我女朋友月总收入8000左右，你觉得买总价40万的压力大吗 准备两年后结婚，再次感谢。</p><p><strong>kkndme：</strong></p><p>40万首付15万，贷款25万，月供1000多，你和女朋友月收入8000，你觉得有压力吗？</p><p>二三线城市往往早买好于晚买，特别是你是自住。</p><p>40万的房子要不然是比较小的，要不然就是郊区了，如果你们有8000的月收入供60万的房子是不成问题的，建议不要图便宜，首选还是位置，宁可买贵点买离城中心近的房子，因为将来能够买得起改善性住房的会越来越少，有能力的话还是尽量买到位。要特别考虑今后小孩上学的配套问题。</p><p><strong>傻子也疯狂：</strong></p><p>楼主可能还不明白我的意思</p><p>我的首付目前也就10万</p><p>如果买大了首付要三成，按你说的卖60万的好是好</p><p>可首付至少要18万</p><p>我没有这么多怎么办呢</p><p>如果借钱，还债又月供，还要考虑两年后结婚。。。。。。。。</p><p>你觉得怎么办好，或者你有更好的建议</p><p>谢谢</p><p><strong>kkndme：</strong></p><p>如果只差8万，家里支持一些，亲戚朋友借一些，一挺就过去了。很多刚开始买房的年轻人都是要咬牙买的，换来以后的轻松。甚至很多人因为今后收入的提高，几年就把贷款还完了。</p><p>当然，如果真的凑不上，还是量力而行，但买房还是买位置，首选离城中心近的，宁可买小一点。住在远郊区的大房子里花1个多小时的时间上班才是受罪</p></blockquote><h2 id="金融杠杆是炒房赚钱的放大器"><a href="#金融杠杆是炒房赚钱的放大器" class="headerlink" title="金融杠杆是炒房赚钱的放大器"></a>金融杠杆是炒房赚钱的放大器</h2><blockquote><p><strong>错误角色：</strong></p><p>其实个人觉得普通炒房者不一定就能获多少利，比如他买一套新房是三千每平，等新房价到六千时出手，他能卖到五千每平。看上去他每平赚了二千…但是，他要继续炒的话，就要再加每平一千的本金进去买新房…看上去他们是资产翻翻了，但是他们的二次投资也是翻翻的…也就是说他以前三十万买了一百平，现在卖出去是五十万，看上去赚了二十万，但是，他想再买个一百平的却需要六十万…他还得从老本掏十万买同样大小的房子…这样算我也不知道对不对…要是对的话，就说明炒房的人不是抬高房价的最根本原因和最关键因素……</p><p><strong>kkndme：</strong></p><p>你没考虑金融杠杆的作用，真正的投机炒房是贷款炒房，而投资客更愿意一次性付清。一个炒房客用20万可以买100万的房子，等到200万卖掉，投入20多万，赚了170多万。然后用变现的钱又可以贷款买多套，这就是投机炒房比股市更吸引人的地方，但是一旦资金链断掉就会比较惨。</p><p>这种赌徒心态的投机炒客还是比较遭人恨的，这次调控提高首付比例，对这类投机炒家打击不小。小资金的纯粹投机客数量控制在一个比较小的范围内，房产市场才会健康发展，这个国家是有共识的。所以二套房首付比例提高后，有可能变成常态</p><p><strong>tjOOSAN：</strong></p><p>这话。。。让我肝颤！~~ 投入20万？赚170？？还贷了80万呢</p><p>还有利息呢！~~</p><p><strong>kkndme：</strong></p><p>09年初20万首付买的100万的房子，2010年初涨到200万卖掉，你认为1年能还多少利息。难道炒房客一套房子拿满20年再卖？</p></blockquote><h2 id="要用发展的眼光看问题，只要努力，只会越来越好，越来越轻松"><a href="#要用发展的眼光看问题，只要努力，只会越来越好，越来越轻松" class="headerlink" title="要用发展的眼光看问题，只要努力，只会越来越好，越来越轻松"></a>要用发展的眼光看问题，只要努力，只会越来越好，越来越轻松</h2><p>要用发展的眼光看问题，只要你还年轻，即使你现在给老板打工只能赚4000块，并不意味着以后多少年都只赚4000块，随着经验和阅历的增长，薪水是会提高的，当然前提是肯学习，肯吃苦，提高能力和才干。</p><h2 id="性格决定命运"><a href="#性格决定命运" class="headerlink" title="性格决定命运"></a>性格决定命运</h2><blockquote><p><strong>错误角色：</strong></p><p>我只买得起4000元内100平的房子！哪怕住小点，住旧点…我也不愿意背着几十年的债度过我最美好的青年和中年时代、我更不愿意每天睁开眼就开始为了还房贷而奋斗。我不想短短的一辈子只是为了一堆只有七十年产权的砖瓦而奋斗。我只是一个平凡普通的人，我只想和老婆有一个快乐安逸的小家…但是“家”这个商品已经成了现在对我来说最昂贵的奢侈品。哈哈！</p><p><strong>kkndme：</strong></p><p>有一句话叫做怎么样付出就会怎么样的收获，看到许多人买房获利，另一些人坐不住了，心态变得鸡冻了，但是，当初人家咬牙买房的时候，另一些人还在追求所谓的生活品质。性格决定了命运</p></blockquote><h2 id="2012年不取消调控，还有房价维稳顺利换届考虑"><a href="#2012年不取消调控，还有房价维稳顺利换届考虑" class="headerlink" title="2012年不取消调控，还有房价维稳顺利换届考虑"></a>2012年不取消调控，还有房价维稳顺利换届考虑</h2><p>zf希望房价维稳，为2012年换届后上涨留出空间，所以调控政策不会轻易取消，但是在高通胀预期的背景下，能不能稳住房价是很考验zf智慧的。</p><p>换届后的老板不可能去接一个烂摊子，这是关键的地方</p><h2 id="洼地最终都会被填平，多数城市是早买胜于晚买"><a href="#洼地最终都会被填平，多数城市是早买胜于晚买" class="headerlink" title="洼地最终都会被填平，多数城市是早买胜于晚买"></a>洼地最终都会被填平，多数城市是早买胜于晚买</h2><p>目前传言与辟谣越来越频繁，如何透过重重的迷雾看到事情背后的真相。</p><p>这次调控zy盯的主要还是一线城市，从提高首付比例，直到监管预售款的准备推出，都是为了提高房地产进入门槛，踢出大量小资金投资客，让小开发商民营开发商知难而退，为国家队入场铺路，zy需要稳定一线城市房价，使2012年能够顺利换届，为换届后的上涨留足空间。有了国家队的后盾，zy无需因为调控导致部分小开发商资金链断掉而担心，相反这是zy希望看到的。</p><p>当然在政策和市场的博弈中，是否能够达到zy的预期，zy的心理也不一定完全有底，因为资金有他自己内在的规律。在打压房地产的同时，会带来农产品等生活必须品的价格全面上涨，这就需要xy做出一个权衡。因为填饱肚子的问题比房价的问题更重要。</p><p>多数二三线城市会在一线城市滞涨期间进行补涨，补足09年行情中远低于一线城市的涨幅。</p><p>作为二三线城市的刚需买房者，多数城市的情况都是早买胜于晚买</p><h2 id="西部"><a href="#西部" class="headerlink" title="西部"></a>西部</h2><blockquote><p><strong>mstsc_XP：</strong></p><p>楼主对成都的房子咋看？</p><p><strong>kkndme：</strong></p><p>在西部地区，重庆、西安、成都、昆明投资房产都不会有问题。西部的其他城市就要谨慎，不是因为房价不会涨，而是因为变现比较困难。</p><p>四川、重庆经济的高速发展是不容置疑的，但存在最大的隐忧就是三峡大坝对生态和环境的破坏根本无法预测。</p></blockquote><h2 id="短期波动属于正常现象，需要关注的是长期趋势"><a href="#短期波动属于正常现象，需要关注的是长期趋势" class="headerlink" title="短期波动属于正常现象，需要关注的是长期趋势"></a>短期波动属于正常现象，需要关注的是长期趋势</h2><blockquote><p>mobster6789</p><p>楼主的一番讲解真如拨云见日！</p><p>但是本人认为，在目前基本面疲软的情况下，成交会进一步萎缩，房价在短期内也还有小规模下调的趋势，请楼主评议。</p><p>kkndme</p><p>短期的波动是再正常不过的事情，把握政策可以把握趋势，但很难做到准确的逃顶与抄底</p></blockquote><h2 id="领导人的智慧和才干决定了国家的命运，统帅的智慧和才干决定了军队的命运，而个人的智慧和才干决定了个人的命运"><a href="#领导人的智慧和才干决定了国家的命运，统帅的智慧和才干决定了军队的命运，而个人的智慧和才干决定了个人的命运" class="headerlink" title="领导人的智慧和才干决定了国家的命运，统帅的智慧和才干决定了军队的命运，而个人的智慧和才干决定了个人的命运"></a>领导人的智慧和才干决定了国家的命运，统帅的智慧和才干决定了军队的命运，而个人的智慧和才干决定了个人的命运</h2><p>领导人的智慧和才干决定了国家的命运，统帅的智慧和才干决定了军队的命运，而个人的智慧和才干决定了个人的命运。</p><p>精英社会相对于法制社会存在更多的不稳定性，更崇尚个人能力、才干与职业精神，如果刘备只懂得眼泪是不可能得到三分天下的。</p><p>精英社会的根本就是以人治国，就是要承认人与人之间的差别。</p><p>百年战争，法国拥有全世界最强大的重骑士军团，可是由于统帅的无能，被英国长弓兵打得落花流水。</p><p>而耶路撒冷王国的鲍德温四世，一个年轻的麻风病人，率领几百个骑士打得萨拉丁三万马木流克骑兵溃不成军，几乎全军覆没。</p><p>一个人很可能决定一个国家的命运。</p><p>也许任何一个国家，甚至中国历史上任何一个朝代都没有象现在那样金权至上。</p><p>无论中国的儒家思想还是西方的骑士精神，都告诉人们，人总是要有所追求的，不能仅仅盯着钱。</p><p>秦时，有个老头叫郦食其，70多岁了还跑到刘邦大营参与革命，当然最后下场比较凄惨，被齐王煮了。郦老头本事很大，只身到齐国说服齐王归降了汉王刘邦。韩信害怕郦老头功劳太高，超过自己，于是很不仗义，在郦老头人还在齐国的时候，带兵攻打了齐国。齐王很愤怒，后果很严重，把郦老头放在锅里煮了。郦老头的才能出众，本想做一番事业，可惜没有算到人类本性丑恶的一面。</p><p>当然韩信也没有好下场，这个军事上的天才，政治上的白痴，本来做了齐王，汉、楚、齐三足鼎立，结果向刘邦缴了枪，直接兔死狗烹了。</p><p>另一个喜欢没事找事的老头叫姚广孝，是个和尚，法号道衍。虽是和尚，但既无和尚的慈悲心肠，又无和尚的遁世清修，这个老头专门搞权谋，不玩阳谋专玩阴谋，背靠朱棣这颗大树，不图名不图利，专搞武装夺取政权。</p><p>姚老头的头脑比郦老头高得多，不但是牛叉的阴谋家，也是牛叉的政治家，此人协助朱棣夺权后，深味帝王权术的精髓。不立家室，不营产业，把一脑袋阴谋全都转向文化事业，跟大才子解缙纂修《永乐大典》，是为数不多投身权谋得了好死的大师级人物</p><p>另一个喜欢没事找事的老头叫姚广孝，是个和尚，法号道衍。虽是和尚，但既无和尚的慈悲心肠，又无和尚的遁世清修，这个老头专门搞权谋，不玩阳谋专玩阴谋，背靠朱棣这颗大树，不图名不图利，专搞武装夺取政权。</p><p>姚老头的头脑比郦老头高得多，不但是牛叉的阴谋家，也是牛叉的政治家，此人协助朱棣夺权后，深味帝王权术的精髓。不立家室，不营产业，把一脑袋阴谋全都转向文化事业，跟大才子解缙纂修《永乐大典》，是为数不多投身权谋得了好死的大师级人物</p><blockquote><p><strong>打工不易：</strong></p><p>我个人认为：个人的智慧来自对大方向的把握，否则再有才干也难有作为。</p><p>单位司机，工厂工人即便技术再好，工资也高不到哪去。</p><p><strong>kkndme：</strong></p><p>聪明智慧决定了人的眼界，有远见的人一定会未雨绸缪。刘邦身为区区亭长可以得天下，朱元璋一个穷和尚驱除鞑虏重建朝廷，一个司机未尝不能当富商，一个小姐也可能当局长</p></blockquote><h2 id="对于具备投资属性的商品，供求关系是指货币与商品之间的关系"><a href="#对于具备投资属性的商品，供求关系是指货币与商品之间的关系" class="headerlink" title="对于具备投资属性的商品，供求关系是指货币与商品之间的关系"></a>对于具备投资属性的商品，供求关系是指货币与商品之间的关系</h2><p>关于供求关系还是有必要解释一下的</p><p>一提起供求关系，马上口水就来了，什么空置率啦，闲置率啦，空置我心啦，电表显示6000万套房没人住啦。</p><p>实际上供求关系跟空置率和闲置率完全没有关系。</p><p>对于具备投资属性的商品，供求关系是指货币与商品之间的关系。当货币量大于商品供应量时，商品价格就会上涨，即使人为打压也是短期行为，这是铁律。</p><h2 id="早买的风险小于晚买"><a href="#早买的风险小于晚买" class="headerlink" title="早买的风险小于晚买"></a>早买的风险小于晚买</h2><blockquote><p><strong>fantabulouski：</strong></p><p>楼主给点意见吧，想在上海市内环内买套二手房，现在出手合适嘛？</p><p>等等的话可能跌点么？有没有什么风险吗？</p><p>多谢！ 因为首套房可以贷款七成，多谢！！</p><p><strong>kkndme：</strong></p><p>如果手头有钱，又是自住，到不一定非要考虑抄在最底部。</p><p>因为钱要贬值是毋庸置疑的，房价在一段较长时期上涨的趋势也是毋庸置疑的。</p><p>但短期，波段性的抄底和逃顶是很难把握的，尤其是自住，考虑太多实在没有意义。</p><p>持币要冒房价持续上涨的风险，买房可能会面临短暂小幅下跌，哪个风险更大，需要自己认真考虑。</p><p>一线城市如上海一定会有短期的滞涨甚至小幅的下跌，当新房的价格低于周边二手房价，并且成交量开始逐渐攀升就是买房的时机。  我反复强调，这次调控期却是二三线城市的补涨期，对于一线城市正好可以仔细的挑选好房，这种机会在房价上升期是难以遇到的。</p><p><strong>fantabulouski：</strong></p><p>楼主再问一个问题，看看这一两天调控的信息满天飞，上海房产税的消息也到处都是，银行在不断的紧缩，感觉这次调控可是不同以往，是外松内紧啊，至少到年底前看不到放松的迹象，还什么情况下才可能会放松呢？难道要等到KQ 接班不成？</p><p><strong>kkndme：</strong></p><p>可以肯定的是首付款的比例是不会轻易放松的。房产税的推出就没那么容易了。</p><p>上海和北京城区的二手房价有点幅度的下跌几乎不可能，很长一段时间都会滞涨或者维持小幅度的上涨。</p><p>手里资金多的人全款买房的比例大幅提高，精英阶层的购买力基本能够维持一线城市的正常的成交量（09年下半年的高成交量zy认为是反常的，已经影响了金融秩序，是zy不愿意看到的。）</p><p>现在的状况是，zy对调控后一线城市的房价增幅及成交量基本是满意的。</p></blockquote><h2 id="小开发商的房子能不能买？"><a href="#小开发商的房子能不能买？" class="headerlink" title="小开发商的房子能不能买？"></a>小开发商的房子能不能买？</h2><blockquote><p><strong>mstsc_XP：</strong></p><p>楼主的分析让我明白了很多之前误解的东西，所以自己错过了买房时机也是有一定道理的O(∩_∩)O哈哈~</p><p>比如空置率、供求关系、当地房价和当地平均收入关系等的解释，非常感谢</p><p>想再请教一下，zy要挤出小开发商的话，到2012年，这些小开发商修的房子会不会烂尾?因为被挤出了，也不好好修了，或者干脆跑了…..因为我买的房子不是华润、中海这些有实力的开发商的楼….</p><p><strong>kkndme：</strong></p><p>如果不是经济危机，基本不会出现这种情况，当然排除个别不诚信的开发商</p></blockquote><h2 id="大兴土木搞建设的城市，房价都底不了"><a href="#大兴土木搞建设的城市，房价都底不了" class="headerlink" title="大兴土木搞建设的城市，房价都底不了"></a>大兴土木搞建设的城市，房价都底不了</h2><blockquote><p><strong>黛眉轻：</strong></p><p>LZ厉害，分析得很透彻。请教LZ，对于目前的合肥房价怎么看呢？做为皖江城市带的中心城市，合肥的房价目前中心城区已经到了7000，也有了超过万元的所谓豪宅。和武汉长沙比起来，经济上感觉合肥还是差的，可是房价却已经不差了。</p><p><strong>kkndme：</strong></p><p>凡是大兴土木积极拆迁的城市，房价都低不了，城市发展规划的资金都要得益于dfzf卖地。这是zf主导投资经济模式的必然结果。这也是二三线城市在这次调控中补涨的根本原因</p></blockquote><h2 id="北京老式砖混板楼的最终命运？"><a href="#北京老式砖混板楼的最终命运？" class="headerlink" title="北京老式砖混板楼的最终命运？"></a>北京老式砖混板楼的最终命运？</h2><blockquote><p><strong>汝爱之罪：</strong></p><p>楼主我想请教一下：就是北京二三环甚至四环有不计其数的老式砖混板楼，年代分布从六七十年代到八十年代初的都有，这些房子都是北京城市发展的产物，也是北京留给土著们的天然福利，但是现在有个问题是它们的房龄已经超过30年奔着40,50去了，这些房子的命运如何呢？拆迁吗？在原址上盖回迁房或者重新规划把里面的居民赶到周围郊区？</p><p>因为随着政策的收紧，这类房子越来越不容易流通了，银行不给贷款，升值空间也逐渐放缓，但是地段都非常好。是不是随着房龄的增加，这类房子只剩下保值功能而最终无法流通了呢？</p><p>这批房子最终会大规模寿终正寝，不知道dfzf会怎么处置？很想听听你的看法。</p><p><strong>kkndme：</strong></p><p>这个情况比较复杂，因为大多数老房子是各大部委的单位房。原则还是谁的孩子谁包干，谁的孩子谁认领。所以说买房子买到公务员小区最保险，即使房子旧了也不会没人管，也不会存在物业跑路、小区沦为贫民窟的问题，即使老房子拆了单位盖了高楼，保证会在原址上还你一套。</p><p>至于说单位不行了或者单位不存在了的老公房也是有的，早晚会走拆迁的路子，那就没有原址回迁那么幸运了，肯定是搬到远郊区县，但补偿条件肯定不差，离开城中心到郊区就成了富翁。</p><p>位置决定了价值。北京郊区农民房拆迁补偿两万一平就算高的，但是城中心房屋拆迁，补偿款那都是10万一平起步的。愿意一掷千金全款买城中心老房子的人只会多不会少，说白了就是：哥买的不是房子，是位置。</p><p><strong>welldayzwb：</strong></p><p>现在貌似 还没有听说10万的，反而是听说政府给你的补偿比市价二手房价格还低不少，如果没有拼死斗争的话</p><p>前段看新闻说是北京要控制拆迁成本，估计就是为了这一步压缩成本来着</p></blockquote><h2 id="把房买在zf边，差不了"><a href="#把房买在zf边，差不了" class="headerlink" title="把房买在zf边，差不了"></a>把房买在zf边，差不了</h2><blockquote><p><strong>yy45678：</strong></p><p>楼主您好，想请教下，最近想买房，三线城市老住宅区（我们那里最早的商品房90年建的）附近一幢私房，上下二层半，120平一层,带地皮93年的房子，所有证件齐全，不好的是建在一个山坡上不能进车子。售价一起30W，另是城市新区，新市政府边，小区房。现在还很荒，什么都不方便,但环境很好。请问是买哪一个房子好？我们那里平均楼价2000左右。</p><p><strong>kkndme：</strong></p><p>2000一平的地方，好像算不上三线城市，大概应该是地级市或者县级市的房价。</p><p>一般来说房子买在市政府边上怎么也不会有问题，只要确定新市政府已经搬到你说的那个地方，该地的升值空间肯定是有的。但是如果仅仅是zf规划就要谨慎了，因为规划并不等于真的搬迁。</p></blockquote><h2 id="天子脚下：二手老房买得好，拆迁补偿少不了"><a href="#天子脚下：二手老房买得好，拆迁补偿少不了" class="headerlink" title="天子脚下：二手老房买得好，拆迁补偿少不了"></a>天子脚下：二手老房买得好，拆迁补偿少不了</h2><p>旅行中，上个网是很不容易的事情。</p><p>关于拆迁补偿的事，巨大的利益驱使，那真是鲜血淋淋的。所以二手老房买在哪里很重要。银行的房、zf的房、各大部位的房，有上市交易的，买下来肯定不会吃亏。</p><p>存在风险的就是弱势群体聚居区。但是北京，毕竟天子脚下，不能搞得太僵，最终该补的还是会补到位，至于外省就很不好说了</p><h2 id="3万入手北京四环，你也是幸运的"><a href="#3万入手北京四环，你也是幸运的" class="headerlink" title="3万入手北京四环，你也是幸运的"></a>3万入手北京四环，你也是幸运的</h2><blockquote><p><strong>汝爱之罪：</strong></p><p>北京七八十年代的砖混老房有体制内的，也有体制外的。现在公房上市流通，好多央产房也易主了，也许过个十年二十年的这批房子的产权证上早已换了一波又一波人。除非像楼主所说的昆明那种大型的省市公务员小区，房子新，户型好，环境和地理位置都不错，一般公务员没个20年轻易不会卖。</p><p>北京的这些老楼，不管谁是房主，肯定值钱，房子不值钱，位置还值钱呢。</p><p>至于这些房子使用寿命到了以后怎么处置，谁也说不清，能不能回迁，要看dfzf和规划局的利益。比如眼下金融街西侧月坛的老房子就要被集体拆除，连中学都要搬迁，这些西城人很有可能被撵到昌平回龙观西去，那边已经在建大批安置房了。</p><p>所以说，这些老房子不管是体制内的还是体制外的，命运如何不在自己手里。即使体制内的比较不错的老小区（比如三里河的建设部小区），如果牵涉到地方的利益，肯定也是毫不犹豫全部拆除，除非那里面住着实权人物当官的不让拆。这个时候就要看这些被拆迁户的谈判能力了，谈判能力强的，当个钉子户，当然是要得越多越好。</p><p>我以前买房的时候，也想了这些，不过最后还是买了新楼。现在因为地皮的价值，北京新老楼的房价差距不大，这个在别的城市是不可思议的。</p><p>很感谢楼主发这么一个帖子，版主还给了个绿脸，要不然可能就错过拜读的机会了</p><p>其实有些问题平时自己也在思考，比如GDP为什么保八，房价和滥发纸币等等，但是关于炒房和房租这一块，思考的并不多，而楼主的帖子比较有条理和逻辑的分析了这些方面，真的是很感谢，我甚至不用自己写分析，只要把楼主的帖子稍微整理，就是一篇很不错的分析资料了。</p><p>关于zf收紧口子，抬高小老百姓炒房门槛这一块，天涯房观有几个高人和楼主的看法一致。我细细想了一下，这个提高首付到50%的政策，确实会成为长期政策保持下去，而其实即使没有这个政策，稳健型的小老百姓也会掂量自己的钱袋买房。没有谁想断供，因为刚需需要房子。</p><p>至于以后十年甚至更长时间，房价仍然会涨。因为城市的发展离不开勤劳的人民，zf在不断的修建地铁画大饼，就是为了土地能卖个好价钱，只有不断的卖地搞铁公鸡，才会有gdp，才会有政绩。统治阶级带着他的各种利益集团一起玩，而老百姓以后可玩之物会越来越少，只能老老实实的干活挣钱。</p><p>由于家人的优柔寡断和缺乏对北京房地产现实的认识，我直到今年初才在四环买了第一套房，3w多的均价，让家里背负了100多w的债务。我错过了07年1w的机会，和09年1w+的机会。世上没有后悔药，历史也不会重演，那些07年买房和09年买房的人是幸运的。我现在努力攒钱挣钱的同时，最希望看到的事情居然是房价尽快远离我的成本区，我知道没有买房的同学一定会抨击我这种想法，但是现实就是这样可笑，一方面希望房价能降，这样可以把老人接到身边，另一方面又希望房价涨，这样自己在还贷的时候心里稍微能好受点。呵呵，不知道自己这样是不是活得太累。</p><p>不管怎么说，希望大家都能住上自己称心如意的房子，这几年来，zf真把我们这些人折腾的够呛。我和家人都是传说中的体制内，体制内确实有福利，可惜要想自己的财富不缩水，还得靠自己。</p></blockquote><h2 id="君为贵，商人、技工次之，农民为轻，打工人为底"><a href="#君为贵，商人、技工次之，农民为轻，打工人为底" class="headerlink" title="君为贵，商人、技工次之，农民为轻，打工人为底"></a>君为贵，商人、技工次之，农民为轻，打工人为底</h2><blockquote><p><strong>傻子也疯狂：</strong></p><p>今天看到新闻 什么房产市场回暖啊 温州炒房团又出江湖了 成交均价上涨啊</p><p>请问这个是真的吗，房价会在短时间涨上去吗 如果是真的，那中央调控有什么用，在没有下降的基础上再涨10% 不是自己打自己嘴巴吗</p><p>很想听听楼主怎么看待这个事情。</p><p><strong>kkndme：</strong></p><p>维持在正常成交量，保持一个缓步上涨的趋势，是zy最愿意看到的。因为zy很清楚，除非体制上有大动作，否则让房价下跌只是唱给人听的口号。体制是不能动摇的根本，是国家稳定的基础，高房价是体制造成的必然结果。zy很清楚，最好的方式就是以一个平缓的速度增长。但是决策者是不是有此能力控制房价缓慢上涨，这是值得仔细研究的。</p><p>任何一个朝代，即使是我们在电影里常看到的奸佞当权，往往政策的初衷都是好的，但是执行效果却常常适得其反，领袖的智慧与执政能力对国家的命运起着至关重要的作用。</p><p>明朝朱厚照时期有个太监刘瑾，权势一手遮天，是个典型的奸佞。但他其实是很想做点事情的。</p><p>明朝开国时，朱元璋搞了个戍边屯田，相当于现在的军垦，因为军队自给自足，给国家省了大笔的银子。但是到了后来，军官们都变成了大地主，霸占了士兵的土地，把士兵当作佃农，依靠盘剥士兵来实现让一部分人先富起来的号召。这是与杀良冒功、贪吃空饷并列齐名的第三大快速发家致富手段。</p><p>我们说了刘瑾是个有雄心壮志，很想做点事业的高责任心人士。对于军官霸占士兵田产导致士气低下这件事很看不惯，很不满意。决定坚决打击这种行为。于是下令地方zf</p><p>清理军官霸占田产的问题。</p><p>军官霸占的田产不仅仅是士兵的，更多的是当地老百姓的。</p><p>按理说，这应该是个老百姓叫好的政策，而事实上这是老百姓头上的噩梦。</p><p>执行人是谁？地方官。</p><p>地方官执行的时候就实在为难了，军官老爷手里都是握着重兵的，你上门还没开口，兵大爷的刀已经架在脖子上了。可是刘瑾刘老板下达命令的同时，还是要下达任务指标的，没收的田产有任务指标，以前军官老爷占有的田都不交税，既然清理田产就要交税，交税也有任务指标。</p></blockquote><p>有些地方官比较聪明，不敢找军官大爷收，就摊派给了老百姓，结果老百姓又交田又交税，自然是连活路都没了。有些地方官脑子不清醒，真的跑去找军官老爷要田要税，结果造成军官勾结宁王造了反，最后刘瑾自己的脑袋也保不住了。</p><blockquote><p>历朝历代，统治者代表的都是地主阶级的利益。历朝历代的改革都只是为了缓和底层群众与地主阶级的矛盾，防止因为过激发生极端群体性事件。</p><p>调控也是为了缓和矛盾，要温水煮青蛙，而不要一把火把青蛙烧死。</p><p>关于自己打自己嘴巴的事，那是太多了，自古以来，统治者也从来不怕自己打自己嘴巴。古人就总结过，只准州官放火，不准百姓点灯。</p><p>以前的科举制度与现在的公务员考试制度基本目的都是相同的，让全天下的优秀的和不优秀但有出身的知识分子依附于官，这样就有了绝对的话语权。无法进入体制内的知识分子，有商业头脑和技术专长的人员，就相当于过去的商人、小作坊主，尽管也许还算富裕，但是没有任何地位，任人支配。要是没有一技之长，又不能经商，就基本上在社会的最底层很难翻身，相当于过去城市里的贩夫走卒，甚至无片瓦立锥，糊口都是困难，地位和稳定性反而远远不如自给自足，拥有宅基地的农民</p><p><strong>中年不惑吗：</strong></p><p>说到底空空太幼稚了 当年拖拉机之夜太学生怎么也想不到机关枪和拖拉机真的会招呼到自己身上 这和他们从小接受到的教育不一样 呀 主流宣传中party妈妈都是慈祥的温柔的全心全意为p民服务的</p><p>有皇帝大力支持的王安石变法到了地方法令也大变味 如今虎温的威权要远远小于当年的宋神宗和王安石 而且统治阶层从上到下的改革从来是为了巩固统治地位 至于p民收益那从来都是附属作用</p><p><strong>kkndme：</strong></p><p>这就是中西方的不同，西方的拖拉机是对外的，中国的拖拉机从来对的都是p民，对外基本比较忪。所以才有元和清，明明是外族入侵灭了国，还要把蒙古人和女真人一起拉进来统一叫中华民族，居然认为中华民族很强大，元朝时一直打到亚得里亚海。也不管蒙古人跟中华的两河文明有关系没有。</p></blockquote><h2 id="10年的调控和08年调控的区别、带来的影响、机会"><a href="#10年的调控和08年调控的区别、带来的影响、机会" class="headerlink" title="10年的调控和08年调控的区别、带来的影响、机会"></a>10年的调控和08年调控的区别、带来的影响、机会</h2><p>这次调控与08年调控后的结果是有所区别的。08年调控的结果是一线城市的暴涨；而2010年调控的结果是房价以二三线城市为主的全面上涨。不但是二三线城市，高房价甚至已经传到至四线及以下城市。</p><p>在二三线以下城市，无房户的需求其实并不大，真正的刚需来自改善性住房。城市升级使人们开始不满足过去老旧式住房的居住环境，开始追求大盘大开放商的品质住宅。房价也由此迎来全面上涨。这种全面上涨，不能理解为全面泡沫，而是有基础存在的。不能理解为全国炒房。特别是四线及以下城市尽管新盘价格高涨，老旧住宅却乏人问津，县级市二手房变现也比较困难。在2010年的调控的大背景下，却神奇的出现了二三线以下城市的刚需大量释放现象，不得不令人叹为观止。这神秘的幕后推手其实就是资金的规律。</p><p>对于在2010年初布局二三线城市的房开商和有远见的投资者，在这次调控中，无疑是受益者。</p><p>一线城市，这次调控给刚需买房者一个最好的入市良机，但是能够抓得住的只是少数。</p><h2 id="历史总是惊人的相似"><a href="#历史总是惊人的相似" class="headerlink" title="历史总是惊人的相似"></a>历史总是惊人的相似</h2><blockquote><p><strong>汝爱之罪：</strong></p><p>其实，几千年来，唱的都是同样的戏，只不过台上的演员变换而已。</p><p><strong>kkndme：</strong></p><p>赞赏这一句，呵呵，历史规律是不变的，变化的只是时间、地点、人物、事件。</p><p>城头变换大王旗。</p><p><strong>tjOOSAN：</strong></p><p>历史规律是不变！但他妈世界变了！~~ 中国采用资本主义制度了</p><p>还只参考中国历史？</p><p><strong>kkndme：</strong></p><p>你知道什么叫资本主义制度吗？</p><p>首先基础是三权分立。</p><p>早在1748年，孟德斯鸠男爵发表了伟大的划时代的巨著“论法的精神”明确提出了三权分立。奠定了资本主义制度的基础。三权分立制度就是国家的立法、行政、司法三权分别由三个机关独立行使，并相互制衡的制度。讲的是法律精神，讲得是私人财产神圣不可侵犯。</p><p>而作为一个人治而非法制国家，怎么能说是资本主义呢？</p><p>建议个别（tjOOSAN）不读书，不研究，不了解中西方历史，不懂经济，对社会制度基本的理解基本是个白痴的同志，就不要乱发表议论了，惹人笑话。</p></blockquote><p>无论是中国还是西方历史对现在都是很有借鉴意义的。这就使毛说过的“古为今用，洋为中用”，毛建的武装斗争及建国思想其实很大程度来自于朱元璋。</p><p>古代君主统治国家征服世界靠战争武器，现在则靠金融武器。</p><p>西方，我们所熟悉的具备最纯正贵族血统的哈布斯堡家族，曾经的德意志王国和神圣罗马帝国的统治者，家族成员曾经统治过欧洲诸国：包括波希米亚王国 、匈牙利王国 、克罗地亚及斯洛文尼亚王国、伦巴第及威尼斯王国 、奥地利皇室领地 、萨尔茨堡公国 、塞尔维亚及塔米斯-巴纳特公国等等无数欧洲国家。</p><p>而现在，哈布斯堡家族控制着华尔街，继而通过华尔街控制着全球的经济。</p><p>历史是在继承的前提下发展的，特别是在西方，现在几乎每一个显赫的家族都能追根溯源。因为尽管西方也发生大革命，但是象文革一样彻底否定历史是完全不可思议的。</p><p>我们有点英雄情结的人听到最多的西方中世纪十字军三大骑士团：圣殿骑士团、条顿骑士图案、医院骑士团；直到现在仍有两大骑士团存在。条顿骑士团总部现在还在德国，专门从事慈善事业。医院骑士团后来改名为马耳他骑士团，也就是现在的马耳他，世博会还来上海参展。只有圣殿骑士团灰飞烟灭，但现在仍有大量的修士组织自称为圣殿骑士团的继承人。</p><p>完全不懂历史，就等于完全不懂得社会。</p><h2 id="关于房贷"><a href="#关于房贷" class="headerlink" title="关于房贷"></a>关于房贷</h2><blockquote><p><strong>四环四环：</strong></p><p>同意LZ。 刚刚父母帮忙首付、自己还贷，在北五环边买了个小房。 判断依据非常简单：一个是国家政策和我等屁民生活是两岔儿的，既然移民无望，就赶快站队；一个是力所能及、负担得起。</p><p>07年底和09年底都错过了机会，也是当时条件不允许，一次是自己嫌弃燕郊太远；一次是嫌弃通县太远。完后工作逐渐稳定，一狠心安了家，剩下的就是往体制外金字塔中层挤吧。</p><p>LZ所说，正是我说不清楚、但能判断大概的那些事儿。 哈哈。</p><p>请教LZ：</p><p>眼下商业贷款贷款46万。 分20年还，月供3066 分30年还，月供2562</p><p>朋友劝我贷款时间越长月供越少越好。 直觉判断我觉得也是这样。 有科学依据么？</p><p><strong>kkndme：</strong></p><p>你的朋友考虑是有道理的。 如果不考虑通货膨胀，当然是利息越少越好，20年还的利息要少于30年还的利息。 但是因为通货膨胀的因素，我国是高增长高通胀的国家，每年的通胀率远远大于实际公布的数字，更远远高于贷款利息，所以贷款时间越长越好。 至于月供是否越少越好，完全取决于个人的承受能力，有条件当然买大房子，宁肯月供多一点。但是条件不够就买小的，量力而行。</p><p><strong>四环四环：</strong></p><p>谢谢楼主指点。</p><p>假设通胀率有一个固定值（当然实际这是没有的，它也是个取决于经济规律和国家意志的不确定因素）、贷款利息有一个值。 完后不同的贷款年限。 就能估算出两个值此消彼长。</p><p>需要选择判断的是，通胀率这个值的数字。 但通过对国际意志不确定因素极端情况的估算，预计这个值。</p><p>完后把这变成一个数学题。</p><p>是这意思么？</p><p>那不用算了，按常识，知道该怎么选了。</p><p><strong>kkndme：</strong></p><p>银行贷款的年限越高，利息支出越高，但不会高过通胀。你能贷30年就贷30年，这是你年轻的优势。年纪大点的就只能贷25年，甚至20年了。</p><p>所以说40岁买房的人很不靠谱，首先40岁的人不一定有钱，反而错过了最敢买房的黄金年龄。其次是40岁贷款年限就短了好多，相当于月供压力更大了。</p></blockquote><h2 id="买卖商品房会逐渐变成富人的游戏"><a href="#买卖商品房会逐渐变成富人的游戏" class="headerlink" title="买卖商品房会逐渐变成富人的游戏"></a>买卖商品房会逐渐变成富人的游戏</h2><p>以后，商品房本来就变成了富人间的游戏，普通人将不能卖进参与的门槛。</p><p>到多数人真的买不起房时也就安心了，也不用关心房价的涨跌了。</p><p>但是现在，房价还没有到那个高度，很多人还觉得有希望，所以对房价的涨跌才会特别关注。这个时期应该就是普通人最后买房的机会。错过了，将不会再有。</p><h2 id="zf还是更在意农民问题"><a href="#zf还是更在意农民问题" class="headerlink" title="zf还是更在意农民问题"></a>zf还是更在意农民问题</h2><blockquote><p><strong>肖肖19850706：</strong></p><p>楼主虽然有很多观点写的很有道理，但是对于历史这块，并不太正确</p><p>引用一段楼主的话： —————— 自古以来，民生问题的底线就是不要出现陈胜吴广的极端情况。所以zf更在意的是农民问题。 因为历史的改朝换代都是大饥荒引起的，无论是汉末、唐末、隋末、还是明末。农产品价格上涨的对zf的震动要远远大于房价的上涨。 农民具备最原始的力量，而他们关心的并不是三线以上城市的房价，而是能否填饱肚子。 而关心自己能否拥有一套产权房的都市白领，除了呻吟一下意外，几乎是没有什么有效反抗的可能的。 ——————</p><p>其实在当今政权建立之前，还有一个政权，叫做中华民国 这个政权是由民主革命带来的 他们所举的旗帜是资产阶级革命，所建立的政权是资本主义社会 为什么会失败？ 这是一个值得思考的问题 让一个经历了5000年封建社会的国家经过一次革命就达到资本主义社会的境界 没有工业革命的基础 没有原始的积累 有的只是借鉴西方 想先变制度再进行调整，结果固然是失败 于是“农民起义”卷土重来，我想大家肯定明白“农民”所指的是什么 于是又了现在的这个政权 由工人阶级和资产阶级去推翻帝制 再由农民阶级把土地抢回来，最终回到封建政权来压迫资产阶级 他们最怕的还是农民么？ 显然不再是了 他们最怕的正是资产阶级 其次就是你说的那些 “关心自己能否拥有一套产权房，除了呻吟一下意外，几乎是没有什么有效反抗的可能的都市白领” 攻占巴士底狱的不是农民 正是这些“几乎没有什么有效反抗可能的都市白领” 是工人阶级结束了地球上长达上千年的封建统治 而改革开放，市场经济的发展，给了这一切充足的物质基础 社会的转化过程有两种 一种是和平演变 一种就是革命</p><p>现在所存在的问题，不是他们更怕谁 而是他们选择面对哪种演变方式</p><p><strong>kkndme：</strong></p><p>最可怕的不是农民而是失去土地的农民。 为什么说新民主主义革命是工人阶级领导的？ 那时的工人阶级是什么？就是失去土地的农民和破产的手工业者，除了体力一无所有，所以他们才具备脑袋掖在裤腰带上，为了抢土地而玩命的动力。解放战争时期，我军的宣传就是：“同志们，国民党要把分给你们的土地抢走，你们说怎么办？”于是广大失去土地的农民兄弟不干了，玩命了。 工农红军一四方面军胜利会师，在选择南下和北上发生了分歧，真的为了北上抗日吗？1935年抗日战争还没有打响，日本人在东北而不是西北。北上抗日的说法实在有些牵强。 我想真正的原因还是群众基础。 近几年多次在西南地区的乡村进行田野调查，发现一个问题：解放前，即使如贵州山区的偏僻乡村，农民自给自足吃饱肚子是完全没有问题的，更别说富庶的四川平原。 那时参加红军要有不要脑袋的玩命精神，对于多数能够填饱肚子的农民来说，主动参加革命显然是不现实的。红军在西南地区完全没有群众基础，战斗中的减员得不到有效的补充，所以人才会越打越少。 而西北地区完全不同，自然条件恶劣，农村耕地很少，存在大量食不果腹，无地可种的农民。李自成起义也是从陕西发起的，可以说具备了随时发动武装暴动的群众基础。所以毛选择了北上的正确路线。而张同志南下凄惨的下场印证了毛的正确判断。 北上延安的另一个重要原因是获得苏联的支持，没有强大的后援是无法取得决定性胜利的。</p><p>一旦农民失去了土地，而又没有去处，那是相当可怕的，所以农民工就业问题是zy最为关注的。甚至提出如何让农民工在城镇买房子置业，处理好农民问题，是社会稳定的重中之重。</p><p>将来，有地可耕的农民将会成为都市中的底层群众羡慕的对象，农民有地有住宅有粮食。进可以在城市打工，有聪明的甚至通过经商迈进富人阶层，退可以回乡种田，虽然现钱不多，但是吃穿住行都是没有问题的。</p><p>而真正一无所有的将是大量在都市中沦为贫困的人群。在打拼挣扎的打工仔，如果没有能力购置房产，也没有得到向上爬的机会，在都市立足将变得困难，而又毫无退路。</p></blockquote><h2 id="治国需要用贪官、反贪官"><a href="#治国需要用贪官、反贪官" class="headerlink" title="治国需要用贪官、反贪官"></a>治国需要用贪官、反贪官</h2><p>讲个故事，可能这个故事很多人都看过，并且曾经多次被转帖：</p><p>宇文泰是北周开国的奠基者。当他模仿曹操，作北魏的丞相而“挟天子令诸侯”之时，遇到了可与诸葛亮和王猛齐名的苏绰。宇文泰向苏绰讨教治国之道，二人密谈 三日三夜。</p><p>宇文泰问：“国何以立？”</p><p>苏绰答：“具官。”</p><p>宇文泰问：“如何具官？”</p><p>苏绰答：“用贪官，反贪官。 ”</p><p>宇文泰不解的问：“为什么要用贪官？”</p><p>苏绰答：“你要想叫别人为你卖命，就必须给人家好处。而你又没有那么多钱给他们，那就给他权，叫他用手中的权去搜刮民脂民膏，他不就得到好处了吗？”</p><p>宇文泰问：“贪官用我给的权得到了好处，又会给我带来什么好处？”</p><p>苏绰答：“因为他能得到好处是因为你给的权，所以，他为了保住自己的好处就必须维护你的权。那么，你的统治不就牢固了吗。你要知道皇帝人人想坐，如果没有贪官维护你的政权，那么你还怎么巩固统治？”</p><p>宇文泰恍然大悟，接着不解的问道：“既然用了贪官，为什么还要反呢？”</p><p>苏绰答：“这就是权术的精髓所在。要用贪官，就必须反贪官。只有这样才能欺骗民众，才能巩固政权。”宇文泰闻听此语大惑，兴奋不已的说：“爱卿快说说其中的奥秘。”</p><p>苏绰答：“这有两个好处：其一、天下哪有不贪的官？官不怕贪，怕的是不听你的话。以反贪官为名，消除不听你话的贪官，保留听你话的贪官。这样既可以消除异己，巩固你的权力，又可以得到人民对你的拥戴。其二、官吏只要贪墨，他的把柄就在你的手中。他敢背叛你，你就以贪墨为借口灭了他。贪官怕你灭了他，就只有乖乖听你的话。所以，‘反贪官 ’是你用来驾御贪官的法宝。如果你不用贪官，你就失去了‘反贪官’这个法宝，那么你还怎么驾御官吏？如果人人皆是清官，深得人民拥戴，他不听话，你没有借口除掉他；即使硬去除掉，也会引来民情骚动。所以必须用贪官，你才可以清理官僚队伍，使其成为清一色的拥护你的人。”</p><p>他又对宇文泰说：“还有呢？”</p><p>宇文泰瞪圆了眼问： “还有什么？”</p><p>苏绰答：“如果你用贪官而招惹民怨怎么办？”宇文泰一惊，这却没有想到，便问：“ 有何妙计可除此患？”</p><p>苏绰答：“祭起反贪大旗，加大宣传力度，证明你心系黎民。让民众误认为你是好的，而不好的是那些官吏，把责任都推到这些他们的身上，千万不要让民众认为你是任用贪官的元凶。你必须叫民众认为，你是好的。社会出现这么多问题，不是你不想搞好，而是下面的官吏不好好执行</p><h2 id="二线城市典型代表"><a href="#二线城市典型代表" class="headerlink" title="二线城市典型代表"></a>二线城市典型代表</h2><blockquote><p><strong>klid：</strong></p><p>LZ 成都属于您口中的二三线城市么？ 那么这次属于补涨阶段？</p><p><strong>kkndme：</strong></p><p>成都、重庆、西安、昆明、武汉都是二三线城市的典型代表。</p></blockquote><h2 id="关于商铺和住宅投资"><a href="#关于商铺和住宅投资" class="headerlink" title="关于商铺和住宅投资"></a>关于商铺和住宅投资</h2><blockquote><p><strong>马甲马甲_马马甲：</strong></p><p>请教楼主：</p><p>因为种种原因， 错过了很多买房的好时期，现在租房住，（ 享受到了朋友提供的体制内的好处， 远低于市场价格租了一套房子）。</p><p>手上200万左右的现金， 在上海，想买房子保值增值，</p><p>1，有套著名大学附近的二手房子，57平米， 130万左右，估计租金大约是2.5万-3万 之间， 2，在市中心成熟的商业区有个店铺， 124万， 年租金现在是6.4万一年。</p><p>2个选择，个人倾向于投资店铺， 因为在上海店铺的涨价远远低于住宅的涨幅，况且店铺的资金回报率也达到了 5% ，不知道楼主是否有更好的建议？</p><p><strong>kkndme：</strong></p><p>很多人不愿意投资商铺还是在于风险大，好位置熟铺是很少有人愿意拿出来卖的，谁愿意放弃生蛋的母鸡呢？而新开发的商铺要不然位置比较偏，不知道能不能做的起来，要不然就溢价太高，超出了大多数人的承受。好的商铺是市面上很难买到的。</p><p>如果经过考察确认商铺没有问题，还是首选商铺，但是一定要经过认真的考察。</p><p>而住宅的风险就相对小多了，而且投资不需要很多的经验，更适合一般投资者。</p></blockquote><h2 id="关于房产调控"><a href="#关于房产调控" class="headerlink" title="关于房产调控"></a>关于房产调控</h2><blockquote><p><strong>tianxiaobing11：</strong></p><p>请问楼主，房价会在年底重新确立上涨趋势吗？如果再不涨，政府的地卖不上好价钱，地方财政就回吃紧，地方政府还会像去年那样出各种政策救市吗</p><blockquote><p><strong>九五二七八：</strong></p><p>全国各地 一线二线三线 情况都有不同 楼主预测时点 怕不好预测啊</p><p><strong>kkndme：</strong></p><p>不但是不同城市情况有区别，同一城市的不同区位情况也有区别。就拿北京来说，过渡爆炒的通州房山等远郊区县，房价一定会有所回调，但是城市中心，特别是学区房是没有下降可能的。</p><p>而对于多数二三线城市，均价下降的原因主要还是远郊区的房源投放量增加，城区内的房子不但不降，而且涨得还很厉害。</p><p>房产投资最重要的还是位置，当远郊区县的房价远低于城中心的时候，一定会有补涨的要求，但当远郊区县的房价向城中心接近的时候，一定会出现城中心的补涨，当然在调控期也会体现为远郊区县房价的回调。</p></blockquote><p><strong>kkndme：</strong></p><p>仔细看一下各地的房价，不要被公布的所谓均价迷惑，只有少部分城市价格下降或者持平，多数城市都在上涨，只不过幅度不大而已。现在成交量属于正常水平，不存在dfzf吃紧的问题，当然不可能象09年那样的疯狂，09年底甚至银行出现无款可贷，太高的成交量会被zy视为危险的信号，是达到危害金融安全的高度的。</p></blockquote><h2 id="关于房产税"><a href="#关于房产税" class="headerlink" title="关于房产税"></a>关于房产税</h2><blockquote><p><strong>tianxiaobing11：</strong></p><p>还有一问题请教楼主，目前我一共有三套房，一套自己住，一套父母住，一套是投资房，在大连最繁华的地方，租金回报是百分之六点五，请问房产税会很快推出吗？我的那套投资房是卖掉还是持有呢？卖的话能赚白分之五十</p><p><strong>kkndme：</strong></p><p>在卖掉之前，你要先问问自己，拿这笔钱打算干什么？如果没的可做，干等着贬值，那你为什么要卖呢？ 如果你有更好的投资或者创业渠道，那当然立刻卖掉，不用犹豫。 至于房产税，第一：近两年一定不会征收，因为条件还不成熟。第二：房产税只是一项苛捐杂税，目的是补充财政收入，并没有降低房价和租金的功能，并且只能导致租金的上涨。怕房产税的应该是租客，而不是房东。</p></blockquote><p>任何税种最终都要转嫁到社会最底层群众身上。丛林法则实际就是大鱼吃小鱼，小鱼吃虾米。</p><p>上层人士的享受是靠底层群众勒紧裤腰带过日子换来的。</p><h2 id="老公房的拆迁问题"><a href="#老公房的拆迁问题" class="headerlink" title="老公房的拆迁问题"></a>老公房的拆迁问题</h2><blockquote><p><strong>wofuleyumin1：</strong></p><p>从头至尾，一口气看完了。。赞同之极。。。</p><p>也向楼主问些问题。。。</p><p>是否老公房都会拆迁？ 在成都，一环，二环内还有非常多的老公房，总量比商品房还多，这么多的房子都会拆迁吗？ 我在想是否先买套老公房。。因为价格也便宜。新的商品房一般八九千。。老公房才5千多。买了后灯拆迁。</p><p>但这么多老公房都会拆迁吗？我觉得可能很多房子是不会拆迁的吧？否则只要现在买这些房子，以后都发财了。</p><p>是否拆迁的只是很少部分？</p><p><strong>kkndme：</strong></p><p>将来多数房都会拆迁，这是中国体制和经济发展模式决定的。在城市拆迁改造升级过程中，大量的老房拆毁，大量的新房拔地而起。而随着拆迁改造的成本的上升，房子也越来越贵。 现在拆迁改造集中建设70-90的小户型，将来会沦为新的城中村，通过二手置换，这类房子会变成新的贫民窟，而将来的拆迁改造建设的一定是追求环境品质的大户型。 因为zf官员任期的限制，决定了官员的短视，决定了城市规划的短视。 但是市中心的房子，即使在将来人口下降的过程中，仍然是稀缺的，房价高不可攀的。如果手有余钱首选的是市中心的大户型。 关于市中心老旧二手房的购买，还是有一定学问的，一定要选择位置好，低密度的矮层住宅楼，因为密度低，便于拆迁。而密度高的塔楼拆迁非常困难，拆迁成本太高，开发商很难有利可图。现在住在市中心高层旧式塔楼的富裕人口，将来一定会二次置业，这些旧式塔楼逐渐会沦为新一代年轻中产阶层的过渡性住房。</p></blockquote><h2 id="投资新房还是老公房"><a href="#投资新房还是老公房" class="headerlink" title="投资新房还是老公房"></a>投资新房还是老公房</h2><blockquote><p><strong>wofuleyumin1：</strong></p><p>楼主。。谢谢你的答复</p><p>我接着问</p><p>你说现在投资是投资一套新房好，，还是找个老公房投资？</p><p>新房，，一切都好，但价格贵。。</p><p>老公房，一切都不好，但价格便宜。。主要是等拆迁。。但可能要等七八年。。（从我近2年的观察，一般都要这么久。。除非有内部消息）</p><p><strong>kkndme：</strong></p><p>有钱当然是新房舒服。</p><p>老公房如果是学区房，随着住着不舒服但是不影响小孩上学。至于啥时拆迁那真是有年头等了。运气好，三年五年，运气不好十年八年。</p><p>关键是拆迁后，原地回迁是很难的，拆迁后安置一般都到远郊区县。如果碰上个铁腕书记，拆迁还真不见的能得什么便宜。条件还没谈好，推土机就开来了。</p><p><strong>wofuleyumin1：</strong></p><p>有钱当然是新房舒服。 老公房如果是学区房，随着住着不舒服但是不影响小孩上学。至于啥时拆迁那真是有年头等了。运气好，三年五年，运气不好十年八年。关键是拆迁后，原地回迁是很难的，拆迁后安置一般都到远郊区县。如果碰上个铁腕书记，拆迁还真不见的能得什么便宜。条件还没谈好，推土机就开来了。 。。。。。。。。。。。。。。。。。。。</p><p>楼主的意思是。。还是投资新房比较好？</p><p><strong>kkndme：</strong></p><p>还是量力而行，买老公房也比不买强，有条件当然买新房。</p></blockquote><h2 id="高端盘有房价带动作用"><a href="#高端盘有房价带动作用" class="headerlink" title="高端盘有房价带动作用"></a>高端盘有房价带动作用</h2><blockquote><p><strong>wofuleyumin1：</strong></p><p>楼主。。。又有一个问题</p><p>我附近的普通房子大概9000 旁边有个02年的别墅现在13000 现在又有一个新的楼盘开盘了。。是电梯 容积3 十多层的 是中海的高端项目，装修过的 居然卖将近2万。。。离谱吗？旁边容积0.8的老别墅才13000啊</p><p>请问中海这个项目是否价格过高？ 另外，这个项目对我这附近的房价能拉动多少？</p><p><strong>kkndme：</strong></p><p>高端房产，开发商都是不急着卖的，而且也从来不乏有钱人慷慨解囊。你说的情况跟昆明的空间俊园完全相同。在市中心徘徊在万元关口的时候，空间俊园直接开出了19000的均价，之后市中心的二手房紧随攀升到15000.而一环二环间的房价在万元关口徘徊。</p><p>大盘高端盘对房价的带动作用是显而易见的。</p><p>自调控刚刚推出的时候，与一个朋友闲聊，说起调控将是二三线城市大涨的机会，还聊了聊昆明的发展，结果那个朋友头顶调控的大棒，去昆明投了n套房产，当时价格7000多点，时过几个月，现在看房价已经涨到9000.而且他买的位置周边先后有高端大盘推出，预计开盘价格在12000-15000，一旦高端大盘开盘将让他买的房子直接迈上万元的台阶。</p></blockquote><h2 id="买房和没买房的差距"><a href="#买房和没买房的差距" class="headerlink" title="买房和没买房的差距"></a>买房和没买房的差距</h2><blockquote><p><strong>汝爱之罪：</strong></p><p>新穷三代。。。ORZ 我可不想做穷一代。。。。</p><p>房子真的让人抓狂，当跟你同样起点的人早你三年买房的时候，这种感觉尤为明显。</p><p>我老公是77年的，他一个女同学2007年底在清河新城买了一套房，一百多平100多万吧，找家里东拼西凑的全款。其实当时我老公也能拿出100w不用借钱的，可是他偏不听我的话，认为清河在五环外，那种地方还要100多万不可思议。结果北京经历了09年的疯狂以后他同学那套房子已经翻倍，借的钱也已经还清。</p><p>而我们呢，在犹豫和老公的优柔寡断中错过了时机，终于在2010年3月最疯狂的时候入手了，这时候即使首付160多万，还要背负100多万的贷款，生活质量比他的女同学差的不是一点半点。</p><p>这是真实发生的事情，犹豫和无知真的能让人付出很大的代价。</p><p><strong>kkndme：</strong></p><p>清河新城好像是50年产权吧。反正我对50年产权的都不感冒。 我一朋友06年买的水木天成，买时5000多，现在25000，调控都不带降价的。</p><p><strong>汝爱之罪：</strong></p><p>清河新城盘子还是很大的，分好几期，有70年也有50年，他们买的是70年的。07年底刚开第一期，相当于股市里的打新股了，基本上没什么风险。</p></blockquote><h2 id="房产交易历史"><a href="#房产交易历史" class="headerlink" title="房产交易历史"></a>房产交易历史</h2><p>最早的房产交易，出现在一个名字叫“盉”的西周青铜器上。在公元前919年农历三月份，一个叫矩伯的人分两次把一千三百亩土地抵押给一个叫裘卫的人，换来了价值一百串贝壳的几件奢侈品，包括两块玉，一件鹿皮披肩，一条带花的围裙。</p><p>周厉王三十二年又发生了一宗土地买卖。这宗土地买卖的交易过程也被刻在青铜器上。</p><p>这次记录的是周厉王买地的事，周厉王为扩建王宫，买下一个叫鬲从的人的地，没有立即给钱。鬲从担心周厉王赖账，周厉王派人对鬲从说：“你别怕，我一定会照价付款的，如果我赖账，就让上天罚我被流放好了。”这是个很毒的誓。</p><p>周厉王买地花了多少钱，铭文上没写。不过李开周说，有人买地，有人卖地，说明当时除了有土地抵押，还存在土地买卖，房地产市场已经有了雏形。</p><p>隋唐时，有个叫窦乂的人，他生在陕西，很小的时候就死了爹娘，无依无靠，跟着舅舅一块儿生活。</p><p>他舅舅是个公务员，住在长安城。窦乂先通过卖鞋、卖树等生意赚了一些钱，后来有了80万钱的身家，于是开始向房地产行业进军。</p><p>当时长安西市有一个废弃的化粪池，面积不小，有十几亩，闲置七八年了，一直没人买。窦乂把它买了下来，雇人填平，在上面盖了20间店铺，租给波斯胡人做生意，平均每天都收上来几千钱的房租。</p><p>再后来，窦乂听说当朝太尉李晟喜欢打马球，于是斥资70万钱买下一块地，又花30万钱把这块地建成一片马球场，送给了李晟。</p><p>李晟很高兴，从此跟窦乂结成死党，有求必应。有这种靠山保驾护航，窦乂发得更快了，不到40岁就成了长安首富，人称“窦半城”。</p><p>除了像窦乂这样的开发商，古代的业余开发商还有一些是公务员、退休干部等，甚至官府自己就是开发商。</p><p>比如在北宋，中央政府下面就有个专门搞开发的机构，叫做“修完京城所”。这个机构本来只能是修筑城墙和宫殿，后来城墙修得差不多了，宫殿也盖得够豪华了，这个机构就开始转型，开始给中央财政搞创收。</p><p>怎么搞创收呢？修完京城所向朝廷请示，划拨给他们大片地皮，他们在上面盖住宅盖店铺，盖好了，有的卖给老百姓，有的赁给老百姓，给国库做了很大贡献。</p><p>古代是没有专业的开发商的。做开发商最需要的是钱。买地、买建材、雇人、摆平关系，哪个环节都得花钱。尤其买地，流动资金不能少，钱不够，就得找同行拆借，或者找银行贷款。</p><p>古代没有银行，但有钱庄，可是钱庄规模一般很小，即使有一些大型的全国连锁的钱庄，他们也不做开发商的生意，都把钱借给别的老板了。</p><p>史料上有这样两个办理房地产抵押贷款的例子，一个是南北朝时候的梁朝郡王萧宏，让人家拿着房契去贷款，一张房契最多只贷给几千钱；还有一个是明朝嘉庆年间山阴县的一个富户，名叫求仲，最多的一次才贷给15000文。这点儿钱别说搞开发，吃一顿大餐都不够。 直到民国时期，外国银行纷纷到中国开展业务，开发商们才能贷到大笔的贷款。所以中国的职业开发商直到民国才出现。</p><p>古代开发商如果大量囤地得挨板子</p><p>以唐朝为例。唐玄宗在位时，土地政策里有这么一条：“应给园宅地者，良口三口以下给一亩，每三口加一亩，贱口五口给一亩，每五口加一亩，……诸买地者不得过本制。”意思就是说，政府给老百姓划拨宅基地，划拨的宅基地大小取决于家庭等级和家庭人口，如果是平民家庭，每三口人给一亩宅基；如果是贱民家庭，每五口人给一亩宅基。另外老百姓也可以购买宅基，但是购买的面积有限，不能超过政府规定的指标。</p><p>政府规定的指标是多少呢？平民家庭买地，每三口人，最多只能买一亩宅基；如果是贱民家庭买地，每五口人，才能买一亩宅基。</p><p>在唐朝，商人也属于贱民，再有钱的商人也是贱民，贱民老板去买地，即使是上百口人的大家庭，最多也只能购买20亩地，用这20亩地搞开发，一两年就倒腾光了。而如果超标大量买地会怎么样呢？</p><p>唐朝法律规定：“诸占田过限者，一亩笞十。”意思是买地超过指标的，得挨板子，每超出一亩指标，挨10大板。</p><p>虽然古代开发商没有现如今的开发商这么“牛”，环境和政策对他们都不太有利，但是在拆迁问题上，始终还是开发商们占优势。就比如窦乂，他就知道要搞房地产，首先得朝上有人，于是傍上了当朝太尉。</p><p>古代拆迁过程更为暴力，因为普天之下，莫非王土，国家要用哪里就用哪里。</p><p>当然，在古代，也不乏一些民主的君主。例如北宋元丰六年(1083年)，开封外城向外拓展，规划中的新修城墙要占用120户居民的住宅，宋神宗让开封府制定拆迁补偿计划，开封府写报告说，总共需要补偿款两万零六百贯，平均每户至少能拿到补偿款171贯。</p><h2 id="契税的历史"><a href="#契税的历史" class="headerlink" title="契税的历史"></a>契税的历史</h2><p>关于契税、物业税或者房产税，其实也不是现在的创造或者纯粹的拿来主义。</p><p>早在东晋时期，就开始收契税，当时叫“散估”，这也是中国第一个有据可查的契税。其后，几乎所有朝代都有契税。</p><p>唐初魏征等人写出了房产税的实质：“其实利在剥削也”——当时“剥削”没有现今这么贬义，与“增加财政收入”是一个意思。</p><p>从税率上看，东晋税率为4%，隋唐税率是5%，宋代4%，元明清三朝基本是3%。我们现在的契税大户型也是3%。</p><p>万历三十三年，利玛窦在北京宣武门附近买了处房子，他在意大利、葡萄牙、印度都呆过，那些地方并没有“契税”这一说，所以他也没有去有关部门办理手续。</p><p>《大明律》规定：“凡典买田宅不税契者，笞五十，仍追田宅一半价钱入官。”好在利玛窦同志上面有人，托了户部官吏，最后交了一笔可观的滞纳金了事。</p><p>相比之下，“物业税”这税种兴起较晚，而且断断续续。公元783年，唐德宗向长安城内拥有房产的市民开征物业税，叫作“间架税”，乃是按照房屋的等级和间架计税，上等房屋每年每间缴纳两千文，中等房屋一千，下等房屋五百。</p><p>结果民怨载道，当年深秋五万军兵哗变，口号就是“不税汝间架”。迫于压力，784年唐德宗废止了这个税种，也就是说，中国第一个正规的物业税仅仅活跃了半年就夭折了。</p><p>到了五代十国，梁唐晋汉周的每一代帝王都曾征收物业税，不过鉴于“间架税”惹过乱子，改叫“屋税”。</p><p>北宋物业税不是常设税种。南宋由于军费困难，每年两次向城乡居民征收屋税。元代，不叫间架税或屋税了，改叫“产钱”，按地基面积征稻米若干或折成钱若干。明朝，物业税不常设，江浙地区小范围征收过一段，叫“房廊钱”。清代，物业税也不常设，往往临时征收，比如1676年由于对吴三桂用兵，朝廷财政紧张，康熙下诏“税天下市房”，规定“不论内房多寡，惟计门面间架，每间税银二钱，一年即止。”算下来，是只对门面房征税，二钱税额相当于两斗大米或七斤白糖的价钱，不多。</p><p>总而言之，无论是间架税、屋税、地基钱、产钱、房捐，都是不折不扣的物业税。只不过，它们与国际上通行的物业税是不同的——不是为了调节需求，而是单纯地敛财。</p><p>然而物业税在中国并不能成为常设税种，因为这个税是纯粹的苛捐杂税，税又比较重，很容易激化矛盾，直接结果是百姓吃不起饭，太容易导致大规模的农民运动，所以很难持续征收。</p><h2 id="廉租房的历史"><a href="#廉租房的历史" class="headerlink" title="廉租房的历史"></a>廉租房的历史</h2><p>言及公房和廉租房系统，最是宋朝搞得好。</p><p>宋朝原则上不分房，京官无论大小，一律租房居住，宰相那样的高干都是如此。偶尔有“赐第”，只照顾部级领导和有军功的将军。算起来大家的住房自有率不高。</p><p>南宋初年，大量流亡人口涌进杭州，三十平方公里的杭州城一度住了一百万人口，人口密度接近上海浦西。</p><p>因人多地少房价高，居民普遍租住公房。除了大规模公房出租，宋朝还有住房救济体制，一是灾年对租住公房的市民减免房租；二是政府建房（福田院、居养院）免费安置流民和赤贫民众；三是修建比公房条件要差的简易房，但是租金更低，堪称“廉租房”。此外，宋朝还有安济坊——慈善医疗，还有漏泽园——安葬无人认领的尸身，比较有人性。</p><p>如果是公务员的话，生在元代也还不错。建国开始，就给半数京官和所有地方官分了房，叫“系官房舍”。一般分不到的市民以自主建房为主导，但是盖房不用买地，政府批给一块官地，然后每月交一次租金，时称“地基钱。”</p><p>满人刚进北京那会儿，也给领导们分房子。一品官二十间，二品官十五间，三品官十二间，四品官十间，五品官七间，六、七品官四间，八品官三间，不入流小军官每人两间。按照每间十五平方米估算，从一品官的三百平方米、到小军官的三十平方米不等。</p><p>廉租房主要由寺观经营。土地由政府划拨，建房资金由民众捐献，房产维护可以从香火钱里冲销，僧尼道士理论上讲不以盈利为目的，再加上信仰需要，正适合执掌这项半慈善业务。大都市的庙宇常有上千间客房，供应试的学生、出门的商旅和遭了天灾的百姓临时居住。</p><p>《西厢记》里张生和崔莺莺在山西停留一整月，在那永济县普救寺里，莺莺住西厢，张生住东厢，该故事充分说明：在廉租房里也可能发生爱情。</p><p>到了明清两代，又多出个廉租房的来源，便是会馆。在这异乡人建立的聚会场所里，客房租金相当便宜。顺治十八年建于北京的漳州会馆，福建人来租住，只象征性地收取租金：每月三文钱！</p><h2 id="历史上买房最好的朝代"><a href="#历史上买房最好的朝代" class="headerlink" title="历史上买房最好的朝代"></a>历史上买房最好的朝代</h2><p>历朝历代，哪朝买房最容易呢？</p><p>南北朝最不靠谱，贫富相差极为悬殊，普通居民收入只有几千，房价则是几百万。谢灵运那样的大财阀“左江右湖，南北二山”，房价都被他们给炒上去了。</p><p>唐朝不用说啊，我们都知道“居长安，大不易”，而且士大夫时兴攀比，为了写诗题名好看，非得有个别墅不行。比如王维有辋川别业，岑参有南溪别业，杜牧有樊川别业，就是白居易本人，后来也在洛阳买了十七亩地，修了个“履道园”。</p><p>宋朝文人叶梦得说：“人未有无产而致富者也。有好便田产，可买则买之……勿计厚值。”这话一再被地主老财们重复。有点闲钱，买房子置地，不惜一切代价。</p><p>明代买房也不是件容易事。《金瓶梅》第五十六回，西门庆的结义兄弟要买房，朋友帮他算了算帐，“一间门面，一间客座，一间床房，一间厨灶——四间房子是少不得的。论着价银，也得三四千多银子”。小户型房子，要三四千两银子。而清河县县令，从七品国家公务员，每年薪水不过三百五十两。就是说，就算县长去买房，如果不贪污的话，需要十年不吃不喝才能攒够房钱。明代楼市虚火上延，与攀比之风分不开。尽管明太祖规定，任何人不得超越等级建房，例如居民门窗不得使用朱红油漆；庶民住房不得超过三间；功臣宅邸两边可以保留五丈空地；军民房屋不许建成五间或九间；寺观庵院不得使用斗拱。但如小说里所说，庶民西门庆“现住着门面五间到底七进的房子”，超标超大发了。</p><p>嘉靖年间，大家纷纷打肿脸充胖子，浙江人的房子必须带客厅了，江西人的房子必须带兽头了，江苏人的房子里必须摆上时尚家具和精美古玩了。明朝中叶，北京的地皮已经涨到每亩纹银两千两，就是折成人民币也有好几十万。</p><h2 id="未来房地产市场的发展"><a href="#未来房地产市场的发展" class="headerlink" title="未来房地产市场的发展"></a>未来房地产市场的发展</h2><blockquote><p><strong>中年不惑吗：</strong></p><p>楼主旅行结束呢？</p><p>将来房租市场会如何演化？</p><p>房租涨的太多，如果大多数租客的收入承担不起该如何？</p><p>例如租客的平均工资4000元/月，你让他和别人合租一个小两室要6000元 他们承担不起恐怕就只能离开这个城市了</p><p><strong>kkndme：</strong></p><p>公租房具有平准作用，zf要敛财，不能定价太低，但也不会高的离谱。有了这个参照物，个人普通房出租应该保持在比公租房稍高水平，当然位置好的高端房精装房也可能租出天价。</p><p>中国的房价在未来将成为多数群众遥不可及的梦想，也可以说大多数人都不再关心商品房的房价涨跌。</p><p>未来，租房将成为常态，所以房子的位置环境装修的档次不同，房租的差距将会非常明显。但好房子一定只有中等收入以上家庭才租得起。</p><p>而买房子是富人阶层的事，中等收入家庭想都不敢想。</p><p><strong>中年不惑吗：</strong></p><p>呵呵，将来，只要中等收入的家庭2个月的收入能买1平米，他们也会买房子的</p><p>难道将来的房价要涨到中等收入家庭半年甚至更长的时间才能买1平米？</p><p><strong>kkndme：</strong></p><p>除了房价高，贷款也没那么容易。而且除了房子，各方面的花销都会涨得离谱，这是太平盛世后期的普遍规律。</p><p>关键还在于体制外的中产，都是逆水行舟，一旦不能前进，就可能沦为赤贫。</p></blockquote><h2 id="房产到期"><a href="#房产到期" class="headerlink" title="房产到期"></a>房产到期</h2><blockquote><p><strong>不明真相的草民：</strong></p><p>向LZ请教</p><p>商品房的土地证年限有多重要？</p><p>现在一个二线城市的开发区，中心地段很多小区房子倒是新盖的，但地是90年代初拿的，有40年、50年的，还有30年20年的，大部分房子的土地证从现在算起只有10几年20几年，有的房子土地证已经到期了，但由于位置较好所以房价一点不便宜。按KFS的说法，土地证到期将来再续就是了，没有大的影响。</p><p>LZ给分析一下，这样房子将来的风险在哪？如果买来自住又如何？</p><p>谢谢！</p><p><strong>kkndme：</strong></p><p>其实有无土地证都无所谓，无论有没有土地证，最大的风险都在dfzf，人治社会法律文件其实就是一张纸，关键还是zf做得不要太过份。</p><p>即使你证件齐全zf想拆一定会拆，即使没有土地证拆的时候也会同样补偿。</p><p>这个东西实在没多大意义。</p><p><strong>不明真相的草民：</strong></p><p>感谢LZ答复。都是新建的高层，应该不会轻易拆迁，这么说自住还好。但如果将来要出手是否就存在困难？？</p><p>期望LZ继续指明。</p><p>Lz似乎没有看到这个问题，再次感谢Lz，望答复。</p><p><strong>kkndme：</strong></p><p>出手不存在困难。二手房交易国家不会对土地证进行严格限制，关键还是房产证。</p></blockquote><h2 id="买学区房问题"><a href="#买学区房问题" class="headerlink" title="买学区房问题"></a>买学区房问题</h2><blockquote><p><strong>开洋木瓜：</strong></p><p>楼主，有个问题想咨询一下。</p><p>家在南京，郊区有一套自住房，130平，市值大概150万左右。市中心有一套小公房，居住权，目前空置（刚分到的，还没有装修，而且单位也禁止对外出租）。现在宝宝一岁，想给宝宝买个学区房，很多名校都要求提前三年落户，所以必须要在2年内买房。一线的学区房单价在2万2-2万6之间。一线小学的分校学区房在1万5-2万之间。我想买的是一个名小的分校，近几年的小升初成绩都非常不错，可以进入南京前三名。</p><p>我想买的一个房子位于这个小学的学区，是拆迁安置房，97年的房子，小区环境比较杂乱，没有物管，停车也不方便。但是周围配套都非常齐全，菜场超市医院都很近，上学也不用过马路。今年年初，2月份的时候我本来在这个小区买了一套，但因为房价上涨房主违约。当时买的房价是12500，现在看中一套，房主要17000，挂了很久没卖掉，我出15000，可能有机会成交。</p><p>这个隔壁有个新小区，物管环境都很好，但价格也上到2万一平了，如果要在这个新小区买房，我们家里的钱就不够了，如果要卖掉现有的房子去买，老公也不愿意。</p><p>还有个问题是，房主要求净得价，12月的时候满五年，就不用付营业税。如果现在交易过户也可以，但要多付几万块。如果算上这几万的税，房价就差不多一万七一平了，我也不愿意现在过户多付这个钱。如果现在签约等12月再交易过户会不会有风险？另外现在是否是出手时机？请楼主赐教。</p><p><strong>kkndme：</strong></p><p>学区房即使在调控最严厉的时期也几乎不可能下跌。但是在上涨期就很难买到，因为房东会跳价。</p><p>12月过户有一定风险，如果到12月时，房价上涨比较厉害，房东有可能违约。</p><p>制约房东违约的方法就是签较高的违约金。</p></blockquote><h2 id="历史的结局"><a href="#历史的结局" class="headerlink" title="历史的结局"></a>历史的结局</h2><blockquote><p><strong>Peter_Takeshi：</strong></p><p>LZ写的不错，有些意见不敢苟同。 LZ既然熟读历史，又在安抚众人去接受被统治的命运，那能否告知最后的结局呢？ 是否跟前几十个朝代一样？呵呵~ 人性几千年从未根本改变，所以即使过程不同，结局仍旧是一样。 谁上台都改变不了这一切。</p><p><strong>kkndme：</strong></p><p>历史上的结局三条路： 和平演变——在中国好像没发生过，今后也不可能，没有土壤 大革命——哪次也少不了 外来入侵——这个也比较靠谱</p><p><strong>facetowall：</strong></p><p>对lz的深厚的历史功底十分佩服。lz说改朝换代的方式有三种：1.和平演变；2.农民qiyi；3.外族入侵。我觉得前苏联的解体看似像是和平演变吧，第2、3条好像不符合。lz说zhongguo无和平演变的土壤，但是前苏联好像也没有啊。这该如何解释呢？</p><p><strong>kkndme：</strong></p><p>苏联的文化背景与中国完全不同。我国是自秦以来进入帝国时代，是一个上千年大一统的国家。 而苏联是在近代革命后才出现的。俄罗斯的主要人种是斯拉夫人，在日耳曼民族眼中是奴隶的意思，人种低劣。中世纪叫做罗斯地区，由基辅公国、莫斯科公国、立陶宛公国等多个公国割据，在元代一直附属于拔都建立的金帐汗国。罗斯诸国在西方中世纪非常弱小，直到波兰立陶宛联军大破德意志的条顿骑士团后，才逐渐强大。俄罗斯于1721年彼得大帝时期才开始崛起，19世纪末才成为帝国主义国家，根本就没有大一统的土壤存在，这也就是苏联能够和平演变，而中国不行的原因。</p></blockquote><h2 id="人口普查"><a href="#人口普查" class="headerlink" title="人口普查"></a>人口普查</h2><blockquote><p><strong>平静的房奴：</strong></p><p>看来楼主今天比较空闲，一口气发了这么多帖子。</p><p>有个问题想青椒哈楼主，我在武汉，最近武汉在全免清理个人和家庭住房信息，晚上调查人员还上门登记、记录，请问这是何意？是否在为出台房产税做准备。</p><p><strong>kkndme：</strong></p><p>人口普查。不但武汉，连穷山沟里也在忙这个，穷乡僻壤的支书天天忙得不亦乐乎。这是第六次人口普查，前面查过五次了</p></blockquote><h2 id="昆山房价分析与买房"><a href="#昆山房价分析与买房" class="headerlink" title="昆山房价分析与买房"></a>昆山房价分析与买房</h2><blockquote><p><strong>買房難：</strong></p><p>樓主﹐麻煩你分析一下昆山的房價吧﹐先謝謝﹗﹗</p><p>昆山是一個縣級市﹐原先是屬于蘇州的﹐離上海很近﹐動車只要20分鐘﹐現在高鐵也開通了﹐原先房價還算便宜的﹐現在連鎮上也貴到五千多六千了﹐市中心最便宜的也要七千多八千﹐09年10月的時候一下子漲了很多﹐原先我看好的一套二手房32萬﹐現在要50多萬﹐太奇怪了</p><p><strong>kkndme：</strong></p><p>昆山不能理解为县级市，要理解为上海的卫星城。相当于北京的燕郊。所以房子八千多一点也不奇怪。</p><p><strong>買房難：</strong></p><p>謝謝樓主回復﹗昆山市中心的房子大一點的開發商開發的如世茂在一萬左右一平﹐這個價位算不算高啊﹖</p><p>買房子要在市中心好點呢﹐還是城東靠近上海方向好些﹖</p><p>昆山很小的﹐就那么几個鎮﹐現在火車站﹐汽車站﹐高鐵﹐人才市場都在城南﹐另外除市中心的玉山鎮外﹐其它的都是工廠很多﹐污染還是多。</p><p><strong>kkndme：</strong></p><p>买在哪里合适，你要看zf规划，跟着zf规划走。比如房山，zf打造的是长阳而不是老的镇中心，所以买房就应当买在长阳。道理是一样的。</p></blockquote><h2 id="为什么现在租售比这么低-amp-同小区买一套大还是两套小"><a href="#为什么现在租售比这么低-amp-同小区买一套大还是两套小" class="headerlink" title="为什么现在租售比这么低 &amp; 同小区买一套大还是两套小"></a>为什么现在租售比这么低 &amp; 同小区买一套大还是两套小</h2><blockquote><p><strong>我爱的飞飞：</strong></p><p>对待房子，我的看法是这样的，50-60年代的人，兄弟姐妹至少5-10个，2004-2020年之间正50、60、70、80、90年代共存的时代，人口达到了爆发阶段，现在好多小年轻70、80代人因为买不起房结不起婚，甚至晚婚索性不育，等50.60后在未来20-30年离世之后，将会有大量的房子空出来。而80后的子女2000后，人口根本不足以养活上一辈。</p><p>我在成都，我的父母是体制内的，我是体制外的80后，刚结婚，老公是体制内的。原家里有一套单位的集资建房，只有小产权，在二线城市的一环内，98年的房子，因为担心迟早有一天拆迁以后没有房子住，小产权也不会赔多好的地段或者得到较好的补偿，再加上以房养房的心理作祟，以及我参加工作以后想从家里独立出来，于是父母在08年底四川地震以后全国大降价赶上好时光在三环外买了一套140的房子，那会儿才买成2900，今年交房以后装修到一半，就有人以双倍价格想买入，父母不卖，留着养老。一年不到翻了一番起来，我结婚以后，也和老公一起在一环附近购入一套小户，8千多。老公家在外省某市有2套，这样算下来，我门要是生一个孩子，以后这孩子手里就有我父母在成都的2套加上老家的1套，我和我老公的1套，孩子爷爷奶奶的2套，一共6套，您说等我父母和老公父母都去世以后，房子嗖的一下就空出来了不少。所以我觉得80后到了四十岁左右肯定都能住上房子，那个时候房子也不再值钱，不过话又说回来，其实我的父母也是年轻的时候住在单位的公房，三十五近四十岁才有了第一套集资建房，而他们的第二套和第三套相对比较快了。所以我现在觉得年轻人还是应该多奋斗吧。但是我真的不清楚，到了房子不缺的时候，那个时候又会炒什么。</p><p>虽然我是土著，也不缺房子，但是压力也不小，特别是还贷，连车也没敢买。有时候我跟LG也想，为啥我们买的房子首付了二十几万，装修十万，我们每个月还还着2500的按揭款，租房客2000就租走了，那不是我们垫着钱给别人提供福利么？向楼主求解。</p><p><strong>kkndme：</strong></p><p>打个比方，假设你打算在某地开个游乐园，竞拍一块地，经过计算当时的门票定价10元一张，根据人流测算，你认为出500万投标这块地，5年可以回本，于是你出了500万，但是别人出到了1000万，你认为1000万要10年回本，风险太大了，于是你放弃了。你冷笑着认为那个傻子一定会赔钱。</p><p>结果过了2年，票价涨到100元一张了，人流量一点也没减小。人家5年就回本了，以后赚的盆满钵满。可是这个生意你却因为太能算计没有做成。</p><p>为什么房价租售比低？</p><p>其中原因之一是现在的房价预期了以后的租金。</p><p>另一个也是最重要的原因就是：现在的房价不够高，说明了很大一部分普通家庭都有希望买得起房，所以宁肯省吃俭用住合租房，为了攒首付。但当房价高到普通家庭不敢问津的时候，这部分中等收入的合租家庭就会放弃买房转而追求租住有一定舒适度的房屋，房屋租金就会上涨到合理的程度。</p><p><strong>welldayzwb：</strong></p><p>楼主在线啊，真好，这个道理大概也明白，不过现在出于”活雷锋”阶段，心里还是很不舒服 去年底在北五环投资的一套大一居，首付加税款超过60％，贷了30年的公积金，现在房租还是不顶月供，而且空租期很长 很怀疑自己的投资决策，好象不是一个很明智的选择，纠结中</p><p><strong>kkndme：</strong></p><p>当房价快速脱离你的成本区，你的心理就好受了。</p><p><strong>welldayzwb：</strong></p><p>再多问一句，有机会一步到位买个满意的大房好(也是老房，得房率高，三居)，还是买两套小房，一套凑合着住，一套放租好？</p><p>当然两套小房的总额比一套还是要多不少，帮忙分析一下，短期和长期来看的情况？谢谢！</p><p><strong>kkndme：</strong></p><p>其实买两套同一小区的房子是最好的，投资自住兼顾，可进可退。如果家里有老人，和老人分别居住，又在同一小区，照顾起来很方便。</p></blockquote><h2 id="买房难之回不去的乡-amp-拉美人过得比你想象的好"><a href="#买房难之回不去的乡-amp-拉美人过得比你想象的好" class="headerlink" title="买房难之回不去的乡 &amp; 拉美人过得比你想象的好"></a>买房难之回不去的乡 &amp; 拉美人过得比你想象的好</h2><blockquote><p><strong>九五二七八：</strong></p><p>楼主说的以后大部分人买不了房的论题 中美在这个方面的差距 怎么这么大呢 现在产业转移 一部分人就业就有回乡的趋势 今后再有一波转移 会不会再离故乡近一些 这样 分散置业 购买难度会不会下降</p><p><strong>kkndme：</strong></p><p>中美体制不同、文化不同、人口不同。一辆在美国2万美金的汽车，国内要卖几十万人民币。一件made in china的服装美国卖20美金，国内卖900人民币。</p><p>不管一线城市、三三线城市都是人满为患的，从一线城市逃离的也会驻扎在二三线城市，绝没有可能大中型城市向小城市回流。</p><p>返乡潮指的是家有自留地的农民工，如果工资待遇差不多，与其到沿海地区漂泊不如回乡打工或者种地。比如贵州镇远的油漆工一天工资是150，而在珠三角打工一天工资还不到150，这也是大量农民工返乡的原因。</p><p><strong>九五二七八：</strong></p><p>最难的怕是现在三四流的大学生和跟着打工父母生活在城里的二代 失去了农村生活本领 在城里也无法立足 楼主 难道拉美化真的不远了</p><p><strong>kkndme：</strong></p><p>很多人都丑化拉美，但是拉美的生活水平要高过我国。不说远超中国的巴西，即使是法属及荷属圭亚那(苏里南）这样的小国，人民的生活也很富足。</p><p>前几年有个援助项目去苏里南等拉美国家，去之前所有的人给我灌输的都是拉美国家如何贫困。但事实上，这些国家与中国完全不同，国穷民富，藏富于民，与中国正好是相反的，只要勤快点的家庭都还比较富裕。当然不排除也有很多穷人（美国也有很多穷人），穷人一般以当地的黑人为主，好吃懒做，整日无所事事。</p><p>这些国家的人民不如中国人勤奋，从不攒钱，只图眼前享受，我想主要原因还是由于币值不稳定，通货膨胀比较严重，所以没有人愿意攒钱。在拉美国家是无法炒房地产的，比如苏里南平均25平方公里有一口人，真的是地广人稀。所以才保留了世界上最高的森林覆盖率。</p><p>拉美人的懒惰会让中国人瞠目结舌，当地的蔬菜价格昂贵，尽管有大片肥沃的土地，当地却没有人愿意耕种，很多去苏里南种植蔬菜的中国人为此发了大财。</p><p>而相反中国人可以说是全世界最勤劳的民族，但是大量勤劳的中国人却过着低水准的生活。这与中国的国富民穷，藏富于国，与民争利的政策是分不开的。</p><p>拉美国家尽管有这样那样的问题，但是确实是法制国家与民主国家，私人财产神圣不可侵犯，这是与中国完全没有可比性的。</p><p><strong>九五二七八：</strong></p><p>一般对“拉美化”的定义是这个吧：贫富悬殊扩大、腐败严重、国有企业效率低下、社会治安恶化、城市人口过多、地下经济泛滥、对外资依赖性强、金融危机频繁和政局不稳定，等等</p><p>没去过拉美 不知道真实的拉美</p><p><strong>kkndme：</strong></p><p>看来拉美妖魔化后，深入人心了。好比在越南旅游，越南人自己说越南官僚太腐败，我笑了，能有中国腐败？</p><p>拉美的官僚机构，国企、医院、警察我都见识过。</p><p>说到官员的官僚，相比中国我真的觉得那里的官员很亲切。我曾经以一个游客的身份和苏里南的司法部长一起在街边小店喝咖啡。以一个陌生的外国游客身份在财政部长家里做客，逗他家的几个黑小孩玩。</p><p>说到治安，我在街边咖啡店坐了一下午，每二十分钟一辆巡逻车从我身边经过。里约热内卢的治安绝对不会差过广州。</p><p>国有企业效率低下恐怕是全世界的通病，况且拉美根本没有可能赚钱的行业全部由国企垄断。</p><p>政局不稳要看怎么理解，拉美国家是相对民主的国家，国家元首倒是常常因为民众的不满而换届（排除少数经常政变的军政国家）。但人民并没有感觉到不幸福。</p><p>拉美国家的经济基本被美国所控制，所以才会对外资依赖严重和金融危机频繁。作为一个主权国家我们看到的是国家财政贫困，但是作为拉美地区的中下层人民群众，生活水平和幸福感是要高于国内的中下层群众的。</p></blockquote><h2 id="租房的苦"><a href="#租房的苦" class="headerlink" title="租房的苦"></a>租房的苦</h2><p>说到租房举个活生生的例子。</p><p>我有朋友是个房产的死空头，一直租住着北京一套两居室的老公房，租金不高1000多点，所以没什么负担，对买方族恨不能理解。结果今年他租住的那片老公房要拆迁，限期20天内搬家走人，结果终于理解了找房子的辛苦，而且随便租一套两居室也找不到2500以下的了。</p><p>真是心态决定命运。</p><h2 id="北京西三旗"><a href="#北京西三旗" class="headerlink" title="北京西三旗"></a>北京西三旗</h2><blockquote><p><strong>bjwxw：</strong></p><p>楼主在线啊，今天几乎花了大半天的时间从头至尾的看了楼主的帖子，分析和解释的真的很实在到位，也许我了解的不是很多，但是确实觉得现实好多都是这样的，麻烦我现在有个问题，我住在西三旗，我租住的这个小区去年的这个时候价格是60-70左右，我失去了机会，可是今年这些房子基本都是120-140万之间了，我现在是在忍不住，也憋不住了，因为我是刚需，虽然心里是万分的懊丧和后悔，但是事情还的做，房子还是的买，可是我很担忧，我花140万买只隔一年就升值一倍多的房子，后果会是什么，我真的怕等了好久，可是等我出手了，房子真的跌了，尽管不会跌很多，但是把我的首付跌光那也是件很可怕的事，毕竟辛苦的攒了这么多年的钱，我是实实在在像楼主说的那样的底层奋斗着的接近中年的刚需外地人，挣钱太辛苦了，所以很害怕，楼主，我现在也很急，老婆看好了一套140万的房子，要我去买，我也知道她也很无奈了，可是我心里这关好难过啊，想听听你的指点，急盼回音</p><p><strong>kkndme：</strong></p><p>西三旗的房子与不远的立水桥相比，涨速是相当慢的，尽管离市区更近当房价跟回龙观相仿，并没有拉开差距。随着8号线的即将开通，8号线地铁站中央部位保障房项目的启动，西三旗房价上升空间还不小。</p><p>西三旗附近最值得购买的小区是枫丹丽舍，因为低密度将来必定稀缺，但是目前价格也高过其他几个楼盘，甚至高过新盘富力桃园。配套最成熟的小区当属育新小区。象硅谷先锋、森林大第也都比较好住。西三旗这片地区属于难得的价值洼地，值得购买。</p><p><strong>bjwxw：</strong></p><p>多谢楼主，看来您真的对西三旗了解的太透彻了，我真的很幸运，我就直接跟您说了吧，我说的房子是龙乡小区，您肯定也很了解，这个是个老小区，房子已经超过了10年，优点就是交通好，周边医院，学校，购物都极其的方便，因为钱有限的原因，只能买这里的，情况就这样，您能给我多说几句吗？多谢</p><p>一着急字都打错了，不好意思</p><p><strong>kkndme：</strong></p><p>龙乡小区的房价在西三旗片区相对较低，因为房子是90年代的，但是周围配套相当齐全，去超市购物也很方便。如果你在上地上班也算比较近，唯一的遗憾就是房子旧了点，户型与2000年后的次新小区相比，有点不尽如人意。</p><p><strong>bjwxw：</strong></p><p>确实是这样，今天通过从头看到尾您的帖子，基本心中已经有了概念，买吧，尽管我从这个小区的70万的房子如今花140万去买这个心理关很难过去，但是还是过吧，既然已经这样了，认命吧，不害羞的问一句，房子价格已经16000了，您说这个地段在将来是会升些，还是会跌一些，呵呵，实在不好意思，添麻烦了</p><p><strong>kkndme：</strong></p><p>这个地区的房价，两年内是可以看到25000的。</p><p><strong>喜欢8号线：</strong></p><p>楼主看好西三旗地区房价，本人深有同感。 西三旗地区的焦点不在京藏高速路口，也不在林翠路路口，而在西三旗东路。也就是地铁8号线西三旗站附近。 现在这附近已经有宾馆、饭店、百汇商品市场、中小学、3甲医院、银行。 到2012年，8号线开通，百汇市场新增电影院，龙旗广场新增写字楼2座和3星级酒店一座， 随着北新建材厂的搬迁，原厂区还会有更多的新楼拔地而起，西三旗东路将南延、拓宽至永泰。整个地区的房价将随着新楼盘的不断推出而节节高升。</p><p><strong>kkndme：</strong></p><p>西三旗地区一直相对滞涨主要还是缺乏大品牌开发商入住，没有高端楼盘的带动，涨幅偏低。但也正因如此，才形成了一块价值洼地，以后才有更大的上涨空间。</p><p><strong>跳坑的青蛙：</strong></p><p>没想到楼主对西三旗地区如此熟悉~ 想问问楼主对于上地附近二手房的看法，如当代城市家园这样的地方，有没有升值潜力？ 觉得这边交通还是有很大问题~</p><p><strong>kkndme：</strong></p><p>上地区域的房产在2008年之前，涨幅较快。但在2008年以后由于上地区域的产业以民营iT为主，属于充分竞争，利润下滑较快的产业，区域经济的发展前景远不如望京，所以上涨空间受限，涨幅趋缓。 区域发展是房价升值的动力，个人不太看好上地区域。</p><p><strong>汝爱之罪：</strong></p><p>对上地一点也不了解，不过今后北京的私企郊区化应该是趋势，好多公司因为成本问题已经开始向密云等地搬家。上地的价格若被炒太高，也难逃此运。</p><p>也许zf会注意到这个发展趋势，引导郊区，现在大力发展郊区地铁就是为今后的卫星城铺路吧。不过能不能成功，是另一回事。里面牵涉利益太多，比如海淀，主导还是高科技产业，如果全都搬家，地区zf就头大了。上地区域，可是海淀政府大力度发展的重点区域。</p><p><strong>kkndme：</strong></p><p>你说的很有道理，现在海淀的it产业基本就是以处于链条底端的制造业，毫无科技科研，急需产业升级，才能得到持续的发展。象联想这样的it公司完全沦为了90年代家电厂商的境遇，毫无未来。</p></blockquote><h2 id="买房争取一步到位"><a href="#买房争取一步到位" class="headerlink" title="买房争取一步到位"></a>买房争取一步到位</h2><blockquote><p><strong>hohowell：</strong></p><p>楼主，诚心请教下，从开贴开始就一直在潜水关注，终于坚定了买房的决心</p><p>现在在犹豫，一是买个80平米的小户型，开发商一般，房型尚可，这样贷款比较少，基本不影响供车，旅游和以后小孩的开销，不过考虑5到8年左右，这个房子就不能满足居住要求了，回头换，又是一大笔钱，而且城区内的好小区也会越来越小，另外一个就是保利的大户型，开发商物业都靠得住，基本上短期可以不用换，不过贷款至少贷100多万，短期内还会要小孩，压力会比较大，基本手里每个月都没有闲钱了，很容易回到赤贫线，一直犹豫不决，诚心请教楼主解惑，我在南京，一个一线以下二线以上的鬼地方，两处房子都靠地铁，周边商业中心配套齐全，谢谢！</p><p><strong>kkndme：</strong></p><p>买房子如果有能力还是要争取一步到位。将来改善，除非个人有较大的发展，否则将很难很难。而且买楼首选好位置，大开发商，大盘，升值空间才大。</p><p><strong>welldayzwb：</strong></p><p>看来楼主分析说购房应该一步到位，我就犯了一个错误，用投资的眼光来选择自住房，后来买的两居室比同小区的三居室性价比高很多，但是居住环境不好，临一条小街，所以现在住起来不是很爽，现在调控着价格先不说了，光是现在限制换房的一些条条框框感觉再置换就很麻烦 另外一套买的外面一点，小区环境非常棒，不过当时是被环境给迷惑了，放租的房子管那么多环境做什么，感觉两套房子操作反了 纠结中啊纠结中，现在唯一能安慰自己的就是，买上房子总比没买强，如果去年年底再犹豫一下或是赌气的话，那就真是悲剧了，一个好三居得活活等成质量差些的两居了</p></blockquote><h2 id="收入稳定的家庭如何买房"><a href="#收入稳定的家庭如何买房" class="headerlink" title="收入稳定的家庭如何买房"></a>收入稳定的家庭如何买房</h2><blockquote><p><strong>黑眼圈钱：</strong></p><p>请教楼主，买房子的事情，比较纠结。</p><p>1）夫妻两人均在西部某高校任职，一个教师，一个行政人员，年龄都不小了，37和35，两人每月总收入在8000-10000，1年算10万收入，应该会多一点。</p><ol><li>一个女儿，才两个多月。</li><li></li></ol><p>3）每年给双方父母1万，双方父母均已60出头，一方父母城里的有退休金及医保。另一方父母农村的，得为他们准备点钱。</p><p>4）目前租住单位两室一厅房，就在学校住宅小区内，除了小点，别的都好，房租100。</p><p>5）公积金两人很少，约1000元每月，未来1-2年内会有购福利房机会，估计90多平方的旧三室一厅（约需 10万元），可能有120平米的房子，但需要排队看单位建房情况（2000每平米）。</p><p>6）两人都有单位医疗保险。</p><p>7）孩子可以上学校的幼儿园和小学、初中，就在150米范围内。</p><p>8）对于车没有什么想法，每天步行上班用不到车代步。不过会买辆10万左右的。</p><p>9）现在没有任何投资和理财。银行存款1-2年期定期存款50万，这个傻了，已经存2年了，平时光顾着干活。</p><p>有没有必要买个商品房呢，周围的房价从08年的4500涨到现在8500，容积率还非常高，并且楼间距等等不理想，那种房子我不想住的。</p><p>其实在附近买套120平米的房子，首付后也供得起，买房子放那等涨价或者出租？ 不想放弃单位的房子，每天睡到自然醒再去上班还是挺惬意的，送孩子上幼儿园上学也方便。</p><p>买了房子后经济会紧张些，不像现在自由。财务自由也算一种幸福吧，我太太对于房子没什么要求，所以也不给我什么压力。</p><p><strong>kkndme：</strong></p><p>对于工作稳定，收入不错的体制内家庭，基本上的情况就是有闲钱就买房。主要还是由于收入稳定不用担心失业，钱放着只有贬值，不如置业。投资型住房与自住型住房在选择方向上有很大不同。</p><p>举个例子，昆明打造了个螺丝湾，几乎半个昆明做生意的人都聚集在哪里。如果自住没有人愿意选择在那里买房，实在是不好住。但是投资确是最好的选择，因为可以获取较高的租金的收益，将来升值空间也不会小。</p><p>假如在昆明一环附近买一套两居室，月租金一般在1500-1800，而房价在万元左右。而在螺蛳湾附近买一套两居室，月租金都在2000多，而房价在7000多。</p></blockquote><h2 id="北京回龙观"><a href="#北京回龙观" class="headerlink" title="北京回龙观"></a>北京回龙观</h2><blockquote><p><strong>baiyang11112010：</strong></p><p>LZ,你好，我2010年3月在回龙观买一复试房子120平米，户型不是很好，全部下来，161万，我尽量提前还贷，控制在3-5年以内，所以，这房加利息定能控制在170万以内，我想问的是，3-5年我想出手，会不会亏？</p><p><strong>kkndme：</strong></p><p>你的问题太短了，虽然问了几遍，居然没看见。 回龙观地区的配套设施齐全，积水潭医院入住将提升该地区的物业价值。随着中关村高新区北延规划的利好，回龙观地区的房价在未来两年内有50%左右的上涨空间。</p><p><strong>baiyang11112010：</strong></p><p>我觉得LZ你的分析思路不错，但是这种涨幅应该不会再有了吧？虽然我今年4月投资了一套，但是，我能回本就行，没敢过分估计，你这样有煽动别人之心啊</p><p><strong>kkndme</strong>：</p><p>首先投资房产不是炒股，不能有炒股的心态。目前说起投资房产是最安全的品种，指的是长线投资，而不是短线投机炒房。短线投机炒房还是因政策的不稳定有较高风险的，一旦资金链断掉，将万劫不复。</p><p>对于4月份，在山雨欲来风满楼的特殊时期，投资一线城市郊区房地产肯定是欠考虑的。</p><p><strong>对于房地产调控，主要针对一线城市，且一线城市在09年行情涨幅过大，郊区楼盘一定会受到调控影响，而资金的运作规律告诉我们，调控抑制住了一线城市的投资资金，一定有相当部分转向二三线房价相对不高的城市，大开发商对二三线城市的入住，将加速城市升级。所以调控征兆的开始，正是布局二三线城市的时机，而不是一线城市。：</strong></p><p>值得安慰的是，回龙观地区并没有遭遇疯狂炒作，表现比较抗跌，即使被套损失也不会大。从未来两三年看，回龙观的区位一定会有50%左右的涨幅，这是不用担心的。</p></blockquote><h2 id="贷款还是全款"><a href="#贷款还是全款" class="headerlink" title="贷款还是全款"></a>贷款还是全款</h2><blockquote><p><strong>jhjdream：</strong></p><p>楼主，请教一下，</p><p>也正是8月初看来楼主的帖子，坚定了我此时买房的决心</p><p>我在3月份卖了一套小房子，8月底买了套大点的，也是学区房，学校在建</p><p>现在考虑一个问题，是全款付清好还是贷款比较好 全款付清，欠亲戚10多万，没有还钱压力，年底可还清，但是手头没有余钱 贷款的话，手头会有20多万余钱，可以装修，或者等年底再攒点钱，投资其他的 所在省会城市房价8000多，偏一点的6000左右。</p><p>装修好出租2500左右，贷款月利息2000左右 也就是说我全款还清，一年相当于收益2.4万的利息及3万的租金，房款70万左右， 是否值得？还是贷款35万比较合适？</p><p>因为考虑到通货膨胀时期，应该是负债比较划算～～ 谢谢！</p><p><strong>kkndme：</strong></p><p>肯定是贷款划算，这是毋庸置疑的。当然如果你的余钱实在找不到其他投资渠道，也可以一次性付清。如有可能也可以贷款买两套，而不是买一套。 70万的总房款月租金达到2500，租售比还是很高的，贷款35万，租金抵月供完全没有问题，说明你所在地区的房价具备较大的上涨空间。</p></blockquote><h2 id="00后的买房需求从何而来"><a href="#00后的买房需求从何而来" class="headerlink" title="00后的买房需求从何而来"></a>00后的买房需求从何而来</h2><blockquote><p><strong>和风中的树叶：</strong></p><p>看了那么多 有点意思</p><p>不过在下有一事想不明白：</p><p>因中国的计划生育政策 往近了说 人口红利会在这几年消失 往远了说 80后基本都是独生子女 父辈在城市里都是有房子的 这些房子作为遗产 按理说 在未来应该使00后没有买房的需求。 LZ如何解释在这种情况下在未来房子仍然看涨？</p><p><strong>kkndme：</strong></p><p>前面已经说过了，你往前翻。</p><p><strong>和风中的树叶：</strong></p><p>LZ能不能再贴一次？或者说明一下在第几页？谢谢哈~</p><p><strong>kkndme：</strong></p><p>回去找了一下，居然被删了。 大意基本是讲中国经济未来的发展模式，城市升级与拆迁改造的关系，没想到这样也不允许说。实在懒得再长篇大论说一遍。 关键的意思就是一方面是富裕阶层对更高端产品，更大面积的追求，一方面是城市升级带来的大规模拆迁改造。下层群众将被挤出城市核心区。许多住房都会被拆迁置换。</p></blockquote><h2 id="意大利的住房模式"><a href="#意大利的住房模式" class="headerlink" title="意大利的住房模式"></a>意大利的住房模式</h2><p>我本人对意大利的住房模式还是比较赞同的。 有去过米兰的朋友可能很清楚，米兰城区的房屋居住的大多数是富豪显贵，一旦出了城区，则是大片大片鳞次栉比的公租房供普通工薪族居住。 以后的中国有可能学习这个模式，原市中心的居民被拆迁安置到郊区，城区居住的都是达官贵人。郊区将形成拆迁安置房、中产阶级商品房、公租房、廉租房混居的模式。</p><h2 id="中国的学术"><a href="#中国的学术" class="headerlink" title="中国的学术"></a>中国的学术</h2><p>97年我大学毕业的第一任老板就是在龙乡小区买的房，我还到他家送礼。那时从城里骑车到西三旗，花了我将近两个小时。一晃就十几年过去了，真是有很多感慨。</p><blockquote><p><strong>汝爱之罪：</strong></p><p>感觉您是学者型的啊，看您去做田野调查什么的。大学毕业送礼给老板。。。。</p><p>看您点评回龙观的那一段，估计很多人要捶胸顿足的后悔了。回龙观真是个奇迹，从2600涨到15000，让所有人大跌眼镜。</p><p><strong>kkndme：</strong></p><p>送礼也算学者型？晕</p><p><strong>九五二七八：</strong></p><p>他是说本以为你是学者型的 不需要送礼 现在看到你说送礼 觉得自己判断失误了 呵呵 现在这个时代 学者也需要送礼啊</p><p><strong>汝爱之罪：</strong></p><p>差不多这个意思，呵呵。我一直以为楼主是搞学术的。</p><p>其实吧，虽然大多数学者砖家都成了贬义词，但我觉得在北京这个大环境里，还是有土壤培养一些目光敏锐犀利的人，BBS的P民也需要这样有前瞻性的引导者，因为毕竟不是每个人都强大到能把这些东西娓娓道来，没有积淀，根本悟不出。</p><p><strong>kkndme：</strong></p><p>中国的学者是很难拿出点时间好好搞搞学问的，功利性太强。</p><p>以前跟一伙民族学者到元阳考察，这帮人没呆满两个星期就跑回去了，说是又要评职称了，人不能不在单位。而日本学者已经在元阳与当地人同吃同住了3年，还没有一次回日本。真不知道这帮民族学者研究了两个星期的东西能发表什么样的惊世论文出来。</p></blockquote><h2 id="北京远洋山水"><a href="#北京远洋山水" class="headerlink" title="北京远洋山水"></a>北京远洋山水</h2><blockquote><p><strong>tianxiaobing11：</strong></p><p>不知楼主了解远洋山水吗？在西四环外，我舅舅想在那买房，去年一万七没买，今年最高到过三万，现在两万六左右，能买吗？还有升值空间吗？诚心请教。</p><p><strong>kkndme：</strong></p><p>别提了，08年的那次调控，开盘才1万1，这是个让人悔得肠子都青了的楼盘。 北京的楼市前景，在未来的两三年，北四环西四环东四环达到5万，北五环西五环外到达3万应该不是什么难事，南面可能相对低一点。远洋山水的位置2万6不能算便宜，但将来只有更贵。</p></blockquote><h2 id="精英的资产"><a href="#精英的资产" class="headerlink" title="精英的资产"></a>精英的资产</h2><p>5万一平的房子对于中国的精英阶层真算不上什么。500、600万一套的房子一次性付清的人群在北京大把的存在着。这是很多工薪阶层一辈子都觉得不可能挣到的财富，但对于另外一些人却可以轻而易举的拿出来。平均工资的概念在中国是完全没有用处的。</p><h2 id="北京三环塔楼"><a href="#北京三环塔楼" class="headerlink" title="北京三环塔楼"></a>北京三环塔楼</h2><blockquote><p><strong>bluesyang2010：</strong></p><p>请问楼主，北京三环内的塔楼，80年代末的房子，以后会有什么走向，现在能出手吗？谢谢</p><p><strong>kkndme：</strong></p><p>三环内都是老公房，干嘛不买个板楼呢。这种房子老到不好住了，迟早还是要换。板楼还可以拆迁，塔楼拆迁就比较困难了。不过今后的北京可能存在一个相当奇怪的现象，一部分高端富裕人群居住在市中心老旧的小区，而令广大住在远郊的中产阶层羡慕不已。</p></blockquote><h2 id="普通人买房的未来"><a href="#普通人买房的未来" class="headerlink" title="普通人买房的未来"></a>普通人买房的未来</h2><blockquote><p><strong>baiyang11112010：</strong></p><p>直白说，我刚毕业一年，完全靠着父母资助，要完全靠自己根本买不起房，我一些同学在北京两人的话年薪也就15万左右吧，现在好歹还能惦念着买房，要是像您所说，“北四环西四环东四环达到5万，北五环西五环外到达3万应该不是什么难事”，那他们根本就没有盼头了，这是很可怕的事啊</p><p><strong>kkndme：</strong></p><p>将来年薪20万的中产阶层一定连北京6环内的房子都买不起。这一天，不会很远。</p></blockquote><h2 id="北京房价超香港"><a href="#北京房价超香港" class="headerlink" title="北京房价超香港"></a>北京房价超香港</h2><blockquote><p><strong>tianxiaobing11：</strong></p><p>金岩石说未来五年房价还得翻一翻，北京核心区域得到二十万一平，真会那样吗？请楼主说说</p><p><strong>kkndme：</strong></p><p>北京北四环，东三环，西三环，南二环内区域的房子，价格一定会超过香港。</p><p><strong>tianxiaobing11：</strong></p><p>香港怎么也得几十万一平吧，还是得早买房，早买早心安</p><p><strong>kkndme：</strong></p><p>香港都是按尺算的。富翁住的千尺豪宅相当于我们的大约100平米。现在香港的房价换算成平米大概是十五、六万一平吧。</p></blockquote><h2 id="中国的新闻不可信，精英的有钱是你想象不到的"><a href="#中国的新闻不可信，精英的有钱是你想象不到的" class="headerlink" title="中国的新闻不可信，精英的有钱是你想象不到的"></a>中国的新闻不可信，精英的有钱是你想象不到的</h2><blockquote><p><strong>bluesyang2010：</strong></p><p>搂主分析一下,现在的新闻都说房屋成交量的上升是因为kfs打折才上升的,但这个很不成立,为什么新闻这么懵老百姓.是不是政策上还有可能收得更紧?</p><p><strong>kkndme：</strong></p><p>中国的新闻最不可信，为了抓眼球不惜胡编乱造，不惜前后自相矛盾。我倒觉得这个成交量放大的背后的意义更值得深入研究。</p><p>在二套房首付50%，三套房首付更是严格控制的前提下，成交量大幅提升，中国的货币到底泛滥到何种程度，中国的精英阶层的绝对数量多么庞大，手里多么有钱。中国的贫富差距很可能已经达到了一般人不敢想象的程度。</p><p>这是一个坏的预兆。</p></blockquote><h2 id="40年的商住房没有70年的住宅有投资价值"><a href="#40年的商住房没有70年的住宅有投资价值" class="headerlink" title="40年的商住房没有70年的住宅有投资价值"></a>40年的商住房没有70年的住宅有投资价值</h2><blockquote><p><strong>klid：</strong></p><p>LZ 请教一下，市中心没有天然气的房子能买么？自住兼投资</p><p><strong>kkndme：</strong></p><p>商改住，40年产权？ 不影响出租，但是变现可能不那么容易。</p><p><strong>klid：</strong></p><p>是70年产权住宅，但是不通天然气！ LZ请教一下啦，可以自住兼投资么</p><p><strong>klid：</strong></p><p>自住只要你觉得不用天然气也很方便，当然没问题。</p><p>投资首先是出租不存在问题，另外市中心的位置可以填补任何房屋设计方面的不足，70年产权具备投资价值。购买这样的房产还是可以的。</p></blockquote><h2 id="限贷对精英没用"><a href="#限贷对精英没用" class="headerlink" title="限贷对精英没用"></a>限贷对精英没用</h2><blockquote><p><strong>tianxiaobing11：</strong></p><p>楼主，我也是不明白，现在成交量确实上来了，按说现在贷款控制的这么严，第三套房都贷不到款，是谁在买房，难道都是第一套房的刚需吗</p><p><strong>kkndme：</strong></p><p>民币发行泛滥，有钱人绝对数量庞大。在北京上海等城市，手中拥有千万现金的人不在少数，都是全国的精英阶层啊。精英阶层的财富积累已经逐步完成，提高首付，严控贷款只能抑制小白领保值的需求，但对于精英阶层是没有任何作用的。</p><p>如果将来推出房产税就更好笑了。精英阶层谈笑风声，小白领神情紧张，最终结果是全部转嫁租房客。</p><blockquote><p><strong>bluesyang2010：</strong></p><p>我认为,这个跟kfs和政府之间的博弈有很大关系,投资人前段时间一直在观望或者投入到农产品等领域,我不记得是7月还是8月,突然听到热钱大量涌入国内房地产市场的传闻,之后成交量就上来了,这些信息之间有很大的关系,但我捋不清. 请楼主评评</p><p><strong>kkndme:：</strong></p><p>你说的很有道理，当资金泛滥无处可去，一定会找到一个出口。资金如洪水在于疏而不在于堵，资金一旦冲破调控所筑的堤坝，将一发不可收拾。所以屡次调控屡次暴涨。如果不能有效开渠，将注定调控政策的失败。</p></blockquote><p><strong>tianxiaobing11:：</strong></p><p>我现在就被抑制住了，现在是认房不认贷，我也不能贷款了，可现在动不动就得百万以上才能买房，真是力不从心啊，房贷新政看来是堵塞了中低收入的房产投资渠道了，对精英阶层反而是利好，这调控就搞笑了</p><p><strong>bluesyang2010:：</strong></p><p>zf倒是想调控精英层呢,但zf本身就是精英的组成部分,所以zf只能借砍掉投机者之名,开拓自身,抢占市场,特别是楼主说的租赁这个大市场,所以特别佩服楼主之前说的:zf找到了吃租赁这块蛋糕的最好时机,明着是抑制房价,其果却是让很大部分老百姓租着zf的房,zf的钱就更多了,到时候想拆哪儿拆哪儿,精英更精英,百姓更百姓….可悲呀</p><p><strong>kkndme:：</strong></p><p>估计给政府出这主意的幕僚熟读过宋史，宋代官府就是靠出租房给群众敛财的。</p></blockquote><h2 id="外汇管制决定了大部分有钱人只能在国内投资"><a href="#外汇管制决定了大部分有钱人只能在国内投资" class="headerlink" title="外汇管制决定了大部分有钱人只能在国内投资"></a>外汇管制决定了大部分有钱人只能在国内投资</h2><blockquote><p><strong>tianxiaobing11：</strong></p><p>还有一个问题始终不明白，请教楼主，现在五六百万的房子都有人全款买，这些人为什么不买国外的别墅呢？难道就因为中国的房子升值快吗？要我有那么多钱早移民了</p><p><strong>kkndme：</strong></p><p>我国实行的是外汇管制，人民币不能自由兑换，不可能大批人口通过地下钱庄转移资产。只有官员和少部分有背景的高端人士才能做到人民币资产顺利兑换转移。</p><p>一旦发现较多资金量的人民币兑换美元出境，国家将采取强制管制措施。</p><p>现在国家对外汇外流已经非常重视，携带价值50美元以上的商品入境都要交税，实际上国家给出了一个不希望人民币兑换成外币外流的一个强烈信号。</p></blockquote><h2 id="外国国籍在中国生活是更好的选择"><a href="#外国国籍在中国生活是更好的选择" class="headerlink" title="外国国籍在中国生活是更好的选择"></a>外国国籍在中国生活是更好的选择</h2><blockquote><p><strong>理财的猫咪：</strong></p><p>我有段动过移民的念头，但现在基本放弃了。不知自己的选择正确与否，想听听楼主高见。</p><p><strong>kkndme：</strong></p><p>移民不见得能够适应，毕竟文化差异太大，但是如果拥有一个外国国籍，在中国生活，是一个比较好的选择，至少，你的财产是受到保护的。</p></blockquote><h2 id="分期付款买房，如果房价上涨，很容易毁约-amp-自住要选大品牌开发商"><a href="#分期付款买房，如果房价上涨，很容易毁约-amp-自住要选大品牌开发商" class="headerlink" title="分期付款买房，如果房价上涨，很容易毁约 &amp; 自住要选大品牌开发商"></a>分期付款买房，如果房价上涨，很容易毁约 &amp; 自住要选大品牌开发商</h2><blockquote><p><strong>showcar:：</strong></p><p>楼主说的正确啊，除非世界经济再次崩溃或者朝内变天，否则的房价要跌，太难！</p><p>到处听说是纸币不受截至的发行，有点现金留在手上都发抖啊，是因为“贬值”发抖！</p><p>所以，出手了，淘一套保值去吧！！总价150万左右。</p><p>楼主请教付款方式： 1：分期付款，30%首付，6个月内付30%， 12个月内付30%，10%交房前付清（约24个月）； 2：商业银行贷款，需要50%首付，50%余款贷款，首付3个月后按揭，110%的贷款利息。 商业贷款的话，计划交房后就付清。</p><p>不知道哪个更合算？期待楼主解惑。。。。</p><p><strong>kkndme:：</strong></p><p>分期付款是你和房东的约定？这个比较不靠谱，如果是付清后过户，一旦房价上涨，很可能出现毁约。</p><p><strong>showcar:：</strong></p><p>楼主，忘记说了，是期房，我们这里是房子盖到一层高就预售了。房子结顶是按揭。结顶后1年半左右交付。</p><p><strong>kkndme:：</strong></p><p>貌似你们那里的房产商很不规范。我还是觉得投资自住都要选择大开发商、大体量楼盘，不仅配套好，升值空间也大，这样的楼盘几乎没有风险。</p></blockquote><h2 id="通货膨胀和房价的关系"><a href="#通货膨胀和房价的关系" class="headerlink" title="通货膨胀和房价的关系"></a>通货膨胀和房价的关系</h2><p>要解释通膨和房价的关系，我来建个简单的模型，跟大家说说</p><p>假设5年前，某个国家一共有10个一篮子生活必须品（包括吃，穿，住，行的所有的必需品），这个国家发行了100万货币，一共有10个人。那么这个国家的毎个篮子生活必须品价值10万。</p><p>假设这10个人每人得到了10万元收入，则每个人刚好分配了一个篮子。</p><p>实际情况是，这10个人中，有人得到了10万元，有人得到了8万元，有人得到12万元。那么这10个篮子通过在品质上的差别有所区分，卖给这10个人，刚好1人1份，只不过有的品质略好些，有的品质略差些。 时间过了5年，这个国家增加到20个一篮子生活必须品，人口还是10个人，但是发行了1000万的货币，那么这个国家的毎个篮子生活必须品价值50万。价格翻了5倍。如果每个人平均是100万，则每个人可以得到2篮子生活必需品，生活提高了。但实际上是，这10个人中，4个穷人每人还是10万，3个普通人每人是20万，剩下3个富人每人300万。</p><p>这3个富人共900万可以买掉18个一篮子生活必需品。剩下7个人只能分配到2个一篮子生活必需品。这样势必有人会饿死。而且无论是穷人还是普通人都买不起任何一个一篮子生活必需品。社会不可能只有富人才配生存，没有穷人，富人就不会存在。</p><p>因此必须有一项物品能够从一篮子生活必须品中剥离出来，吸收掉富人庞大的资金，同时也要让穷人和普通人能够买的起一篮子生活必需品中能够维持生命的最基本的生活品。</p><p>于是就要把一篮子生活必须品进行拆分。找到一项物品，不拥有不会饿死，但拥有能够让人过的舒服，具备高的使用价值，能够保存，具备稀缺性。</p><p>这个东西就是具备产权房屋（注意不是使用权），而一篮子生活必须品中其他的东西都不具备这个条件。 吃的不能保存，</p><p>衣服不具备稀缺性，</p><p>土地和房屋，是生产，居住，商业贸易的必需品，可以保存，具备稀缺性，富人拥有房屋土地的所有权可以租给普通人和穷人进行生产和居住。土地和房屋超过租金部分的溢价就变成了富人中吸收资金，炫耀财富的特殊品。</p><p>所以请注意，真正吸收大量发行的被富人拥有的货币的，是土地和房屋超过租金部分的溢价，所以房屋的租售比很低是货币大量发行造成的。房屋土地租金成为了新的一篮子货币中的必需品，而房屋土地所有权被剥离出来变成了富人之间货币再分配的游戏。 这样一篮子生活必须品进行了重新定义，本来包括的房屋，变成了房屋租金，而房屋所有权被从一篮子生活必须品中剥离出来，变成了吸收富人多出来的货币的奢嗜品。而一篮子生活品分成两大类，即最基本的和品质高的。</p><p>最基本的又变成了10万一个，保证这个国家的4个穷人可以每人得到一份。</p><p>品质高的，20万一个,3个普通人和3个富人每人得到一份就可以得到较好品质的生活。</p><p>多出来的840万，就是房屋的所有权，供3个富人拥有。房屋所有权的价格远高于租金，这是因为房屋所有权已经变成了富人炫耀的资本，身份的象征。 因此说，高房价的根本原因是由于货币发行泛滥和收入分配不公。这个根本问题不解决房价不可能下降。</p><p>而且单纯的依靠行政手段让房价下跌不但不能抑制通货膨胀，多出来的流动泛滥的货币得不到有效吸收，会推动生活必需品上涨，使穷人的生活更加艰难。 当然，有人的说，这多出来的840万为什么不投入到创新领域带动需求，增加一篮子生活必须品的品质。</p><p>这显然是不现实的，900万的财富集中在3个人手里，剩余7个人总共只分到100万，而平均一篮子生活必需品的价格是50万，7个人应该有350才能满足生活需要。购买力的不足一定会使远离生活必须品的任何东西都没有市场。</p><p>高房价，低租金是货币泛滥发行和分配不公的必然结果，而不是推动通货膨胀的，阻碍实体经济发展的原因。</p><p>货币泛滥和分配不公才是实体经济发展困难，房价高企的根本原因</p><blockquote><p><strong>fataltomato：</strong></p><p>有钱人的投资渠道一般都不是房子</p><p>房子最多是资产配置中的一项</p><p>开始投房收租，说明财富控制能力的下滑，往往意味着人生下坡路的开始</p><p>所以诸君，还是努力赚钱改变人生为第一要务</p><p>评来论去，于事无补</p><p>别人说到了，你不一定明白，你明白了，不一定有体会</p><p>你有体会，不一定能做到，你做到了，不一定能做好</p><p>你做好了，还不一定有机会呢，呵呵</p><p><strong>welldayzwb：</strong></p><p>对于不善理财的人来说，买房收租未尝不是一个选择，到没必要上纲上线，当然为了收租而买房，目前看起来不是很理想的一个选择</p></blockquote><h2 id="南京买房分析-amp-买房要做好调查分析工作"><a href="#南京买房分析-amp-买房要做好调查分析工作" class="headerlink" title="南京买房分析 &amp; 买房要做好调查分析工作"></a>南京买房分析 &amp; 买房要做好调查分析工作</h2><blockquote><p><strong>闲坐庭前也：</strong></p><p>楼主，一直跟帖， 觉得你的认识颇有见解 请教一下 最近看了南京奥体附近的仁恒楼盘 2万2左右每平方 不是自住，用做投资的话现在出手是否合适呢？ 一直在犹豫中 望不吝赐教</p><p><strong>kkndme：</strong></p><p>尽管南京去过多次，但对于那里的楼盘并不熟悉，所以不敢妄言。如果能够提供更详细的信息，或许可以试着为你分析。但以你目前提供的信息，真的不好评判</p><p><strong>闲坐庭前也：</strong></p><p>恩， 详细的话就是南京河西奥体那块推出了仁恒G53精装公寓 简称高汤，90平方复式上下两层的，180万左右 我对南京不太了解 有人说2014青奥会召开， 有点升值空间 我不准备贷款 因为平时也不怎么会理财 全付可以95折 楼主，请问我能买进吗？ 汗一个先，我买房好像总买在高点呢 泪奔 不知道这次怎么样 楼主不吝赐教哦！！！</p><p><strong>kkndme：</strong></p><p>房产毕竟是一笔相当大的投资，对于一个不了解的城市，就轻易购买，显得过于轻率。青奥会是噱头但不是利好，对于房产的长期升值没有任何促进作用，充其量也不过有些资金参与短线炒作。 经济的发展才是一个城市房价上升的驱动力。 建议在你购买之前，认真去南京进行考察。不但要考察周边楼盘，还要考察你所购买地区的经济发展状况、交通状况、商业和学校的分布。最好能够了解当地政府的规划。</p></blockquote><h2 id="北京华清嘉园"><a href="#北京华清嘉园" class="headerlink" title="北京华清嘉园"></a>北京华清嘉园</h2><blockquote><p><strong>dog19972009：</strong></p><p>请教楼主点评华清嘉园的房子以及上地一带的房子，谢谢楼主！</p><p><strong>kkndme：</strong></p><p>学区房，房价坚挺，配套齐全，环境也还凑活，紧邻轻轨，唯一的遗憾就是交通比较拥堵。如果有钱是可以考虑的。但是绝大多数人只能对华清嘉园的高房价兴叹了。我预计两到三年内，华清嘉园就将冲击5万关口。 上地可参加前两页的评述。</p><p><strong>dog19972009：</strong></p><p>谢谢楼主，但如果是上地的低密度低板房格局朝向及位置都较好的小3居可以考虑吗？另外知春路一带的九十年代的塔楼还有板房可以考虑吗？</p><p><strong>kkndme：</strong></p><p>北四环周围有许多不错的小区，都值得考虑，无论自住还是投资都还是比较合适的。比如志新村、塔院、牡丹园小区等等，配套齐全，居住舒适，特别是志新村还是学区房，这一片区位肯定是好过上地的。缺点就是户型较老，物业等于没有。</p></blockquote><h2 id="中国的朝代更替"><a href="#中国的朝代更替" class="headerlink" title="中国的朝代更替"></a>中国的朝代更替</h2><p>中国与西方最大的不同，是历次革命都要推倒重来，革命总是伴随着血琳琳的屠杀和破坏，无论是财富还是文化。每次建朝人民都要从一穷二白做起，所以才说中国人民苦难深重，几千年的历史，居然没有什么积累，有的只是统治者根深蒂固的帝王思想世代传承。 从项羽焚烧阿房宫到近代的破四旧，革命的都非常彻底，人民洗脑也非常彻底。所以帝国时代才能够一直延续。西方人贪婪对财富是占有和继承，东方人重义轻利所以破坏焚烧和屠杀。</p><p>西方的大革命产生了资产阶级新贵阶层，然而当时却不为普通群众接受，尽管他们有钱有势，但是却得不到群众的尊敬，直到资产阶级新贵们捐钱捐物，为群众做了大量的善事之后，才得到人民的认可。 而我们这个时代产生的新贵却太多的为富不仁。</p><p>而中国古代的乡村，通常族长就是村子里的大地主，族长是非常重视名胜的，一个族长必须有足够的威望，象修桥补路，借无米下锅的族人粮食，都是族长份内的事。去徽州旅游的人都知道，道路、桥梁等公益设施无不是富商修建。古人不但讲个人声望，还讲积阴功。假设你去贵州的深山中旅游，发现山径上常常有个亭子，不但有坐的地方，还有水井或者用水管从山上引来的泉水供路人休息。这都是周围的村里人为积阴功修建的，绝非政府投资。 时值社会主义的今天，反而一切行善积德的事都不讲了，全民金钱至上。没有文化建设的民族是悲哀的。</p><h2 id="中国可以无限印钞吗"><a href="#中国可以无限印钞吗" class="headerlink" title="中国可以无限印钞吗"></a>中国可以无限印钞吗</h2><blockquote><p><strong>tianxiaobing11:：</strong></p><p>中国可以无限印钞票吗？有没有个限度呢？我是请教楼主，肉食者会怎么思考呢？他们的幕僚能从历史中找到答案吗？楼主的历史资料库中有这方面的吗？</p><p><strong>kkndme:：</strong></p><p>如果你收集过铜钱，你会发现有一种大钱叫一当十五。这就是中国古代的铸钱方式。当铜不够了，zf用铸造2枚铜钱的铜铸造一枚大钱当作十五个大钱用。那时还没有纸币，所以采取了这种方法。 到了解放战争时期，物品紧缺，国军大量印制金圆券，今天用一捆钱没一斤米，明天用同样一捆钱却只能买一两米。当然这种金圆券无限制满天飞也和我军大量投放伪币有关。 当物质紧缺时，必然会通过发行纸币来缓和矛盾。小时候我常去买2毛钱的肉馅包一顿饺子，现在2毛钱仍在大街上也没人捡。肉馅从2毛钱涨到4块钱，货币贬值了20倍。为什么我们认可肉馅从2毛钱涨到4块钱的既定事实，但是却不能想象现在的物价会在未来的10年再涨20倍呢。 如果你收集过邮票，会发现50年代的老有票的票面价格都是500元一张，1000元一张，我们建国后的货币也并不是一开始就是圆角分的。50年代圆是最基本的货币单位，随便买个最小的东西，都是1000元起步的，很象现在的越南盾。 我们国家的印钞制度，主要跟外汇挂钩，在帖子里已经做过了描述，你可以在帖子里找一找。正是由于国内商品的内需不足，完全依靠低附加值商品出口创汇，才造成了人民币的外升内贬。</p></blockquote><h2 id="读史读的不是故事，还是找历史规律，以古鉴今"><a href="#读史读的不是故事，还是找历史规律，以古鉴今" class="headerlink" title="读史读的不是故事，还是找历史规律，以古鉴今"></a>读史读的不是故事，还是找历史规律，以古鉴今</h2><p>读史读的不是故事，还是找历史规律，以古鉴今，毛就是这方面的天才。 读史难在古人常常作假，事件往往扑朔迷离，必须象破案一样，从重重的迷雾中寻找真相，这也是读史的乐趣所在啊。 好比喜欢三国的度魏延，总认为此人天生反骨。事实上，魏延作为仅次于关张马黄（没有赵云，赵云的才能和级别都不能和魏延相比）的第五员上将，在关张马黄死后，成为了西蜀的军方顶梁柱，不但有极高的军事天赋，而且忠心耿耿，不足的是政治头脑不大灵光，结果诸葛亮刚死，就被小人杨仪给黑了，不但掉了脑袋，还被按上了背主的罪名。</p><blockquote><p><strong>汝爱之罪：</strong></p><p>《三国演义》里这一段完全是黑魏延来着。 我心里还想，其实魏延还是比较大度的，马谡刚愎自用的时候，诸葛亮很不爽，但是魏延还一个劲的替马谡说好话，我就觉得魏延一直忠心耿耿，怎么可能晚节不保呢？</p><p>唉，看来正史和演义，还是有很大区别啊</p><p><strong>kkndme：</strong></p><p>正史里很多信息都是极其可疑的，就更别说演义了，呵呵。 每次听评书赤壁大战一段，诸葛亮给关张布置任务就觉得好笑，赤壁大战时诸葛亮官拜军师中郎将，官职远不如关张，关张不可能直接听诸葛亮的将令。当时，诸葛亮顶多给刘备出出主意，调兵遣将还应该是刘备的事。演义一夸张诸葛亮，，就没刘备什么事了。</p></blockquote><h2 id="毛太阳往事"><a href="#毛太阳往事" class="headerlink" title="毛太阳往事"></a>毛太阳往事</h2><p>当年毛太阳发动文ge的原因是因为政府被刘奇和邓平的政经系所把持</p><p>当年要是老毛召开人大来决定谁去谁留，老毛肯定被PK掉</p><p>如此不发动底层，通过正常的程序夺不回权利</p><p>什么防止腐败，打到走资派都是借口</p><p>毛太阳比任何人都要腐败</p><p>死的时候存款有1亿多（不是工资积攒的，都是稿费，垄断市场的稿费）</p><p>70几年的时候，1亿多，确实恐怖</p><p>但是后来被邓平给没收了，讽刺呀，以这是全党的财富为由</p><h2 id="北京大兴"><a href="#北京大兴" class="headerlink" title="北京大兴"></a>北京大兴</h2><blockquote><p><strong>VVVMMMABC：</strong></p><p>楼主,现在大兴的房子新楼盘较多,某楼盘推出两次均卖光光.地理位置占尽优势,因为紧挨着将要建好的地铁.现在能出手买吗?首套,没有立马买房结婚的压力,但三四年内总得买吧.首付提高后也就刚刚好付首付.要是利率也真的不打折,真不知道如何是好.</p><p><strong>kkndme：</strong></p><p>通州、房山、大兴都是前期炒作比较厉害的区域，在楼市调控期要慎重购买，如果遇到明显低于周边二手房的楼盘可以立即下手购买，否则观望。</p><p><strong>VVVMMMABC：</strong></p><p>楼主圣明,楼主说得明显低于周边二手房的话是指大于多少一平的时候呢?现在的二手房和新房都互相盯着呢,都差不多</p><p><strong>kkndme：</strong></p><p>一般来说调控期内，郊区新盘比调控前的周边二手房大约低10-20%%之间，且成交放量，说明底部已见。</p></blockquote><h2 id="贵阳"><a href="#贵阳" class="headerlink" title="贵阳"></a>贵阳</h2><blockquote><p><strong>努力看透：</strong></p><p>楼主，谢谢你对贵州的关注！ 我是贵阳的，想听听你对贵阳的看法，我07年在小河区2400买了120平方的新房子，今年八月初买了套市里的二手房，93年的，65平方，学区房，总价43万，送家具家电！ 非常想听听你对贵阳房市的看法，还有金阳新区的看法，感觉金阳就是房地产撑起的，如果地产有个风吹草动，金阳会是最容易受打击的，不知对否？ 另外93年的老房子以后卖时不好贷款，是不是会影响成交价格？ 谢谢</p><p><strong>kkndme：</strong></p><p>刚从贵阳回来没多久，呵呵。 贵阳投资房产有一定的风险，主要是城市比较小，不好变现。如果我在贵阳投资，即使再贵也会选择喷水池附近市中心的楼盘，稀缺性较强，变现相对容易。 贵阳是一个城区尚未开始升级改造的城市，zf大力打造金阳花溪等外围区域，但是将来一定会遇到较大的交通瓶颈，城区的升级改造早晚都要启动。 关于金阳实际上就是政府的造城运动，因为市政府的搬迁对房价有一定的支撑力，但是随着人口的大量入住，从金阳到主城的交通可能出现瘫痪状态，谁又能保证政府不进行二次搬迁呢？ 贵阳的美女确实很多啊，是这个城市最靓丽的风景，令人留恋。</p><p><strong>努力看透：</strong>  贵阳小了，为什么房子不容易变现呢？毕竟全省只有贵阳繁华点，地方小，人多，更应该容易变现啊！我指的是市区房，不含郊区</p><p><strong>kkndme：</strong></p><p>市中心中高档房屋变现是没问题的，但市中心老房变现也不是很容易。贵阳的城中心改造升级还没有启动，市区存在大量的老公房，而贵阳最需要的是改善型中高端住房。现在zf全力打造金阳等外延区域，大片的新楼盘拔地而起，二手房交易的活跃度远不如其他省会城市。</p><p>贵阳与成都、昆明这些西部城市略有区别，昆明、成都有大量的外地人口，这些外地人口构成了买房刚需，因此市区位置的稀缺性就显得尤为重要。 但是贵阳的外地人口相较昆明、成都要少，以本地改善型需求为主，所以城区楼盘的档次尤为重要。 作为相邻的省会城市，重庆的吸引力要大于贵阳，贵州许多地州的资金可能会被重庆分流。</p></blockquote><h2 id="富人越富、穷人越穷"><a href="#富人越富、穷人越穷" class="headerlink" title="富人越富、穷人越穷"></a>富人越富、穷人越穷</h2><blockquote><p><strong>我爱的飞飞：</strong></p><p>其实很多空军比较SB，天天叫着加息，说是提高收入就可以买得起房子，试问穷人手里10万，富人有100万，按照现在的利息，穷人每年整存整取10万不开税收是2250元，而富人得到的是22500，加息以后假设穷人每年收入是4000，富人是40000万，成千上万的富人每年多出40000，而生产资料和资源是有限的，当每个富人的4万流入市场，试问是不是又要通膨呢？所以加息是最愚蠢的均贫富方法。行之有效的办法其实是重新发行货币。但是除了改朝换代几乎不可能。 其实穷人一穷就注定穷下去，除了少数几个可以翻身，原因很简单，因为生产资料掌握在富人手中，富人为什么有生产资料的支配和拥有权，答案很简单，只有革ming。 由此则可以明白为什么房子可以按照富人的想法定价，就因为土地，建材等生产资料掌握在富人手中。 妄想房子降价其实是更愚蠢的想法，为什么？GCD拼命给公务员和arm加薪，这些钱用印刷机印出来发到公务员手里最终却让老百姓埋单？统治阶层当然首先第一位维护和最大化自己的利益，任何朝代都是如此，只有当民心涣散的时候才出台一些政策缓和民心。现在看CCAV，对社会主义这充满美好想象的词的强调都逐渐弱化了，你不得不承认，在GCD的领导下大家都有肉吃了，国家安定，在这里嚷嚷的，不过是对贫富不均不满而已。</p><p><strong>kkndme：</strong></p><p>今年朝鲜搞货币改革，重新发行货币，结果导致不可控的通货膨胀，财政部长给枪毙了。</p><p><strong>我爱的飞飞：</strong></p><p>所以民众还是愚蠢的，只看到了15元最后换成1元的落差和失落，没有看到除去附加值的生产资料的价值。货币改革是富人最不愿意看到的，跟加息是一个道理，因为改革让货币的附加值骤然缩水，富人的货币不再比穷人有更多的附加值，而统治阶级恰恰是富人，没人愿意搬石头砸自己的脚。所以为什么我说不可能。</p></blockquote><h2 id="通货膨胀的形成原因"><a href="#通货膨胀的形成原因" class="headerlink" title="通货膨胀的形成原因"></a>通货膨胀的形成原因</h2><blockquote><p><strong>我爱的飞飞：</strong></p><p>在谈谈通膨是怎么形成的。生产资料是有限的，生产资料其实一直都没有变，而货币只是一种虚拟附加值而已。像楼主所言，一个国家，有人手里有8元（假设他是建材行业的），有人有12元（假设是石油行业的），但是人心不足蛇吞象，建材行业的员工觉得不够用了，8元的想变成13元，石油行业的12元想变成20元。因此，建材行业把原来卖8元的水龙头提价成13元，对于石油行业的人，装修的时候拿着12元发现自己买不了13元的龙头了，于是琢磨着把石油卖到20元，由此各行业依次提价，物价越来越高，实际上水龙头还是水龙头，一桶石油还是一桶石油，生产资料始终没有变，稀少，远远不够人均分配，但是生产资料的价值变了，提高了。拿成都的房价为例，02年的时候成都人均收入800-1200，房价2000-4000，约为房价的3倍，现在成都人均收入2500-3000，成都房价7500左右，仍然为3倍比例，看似7500比2000翻了多翻，实际上房子作为所谓的生产资料，始终是稀缺的，在02年的时候，拿着当时的工资买4000的房子仍然不容易。任何时候，其实都是一种相对平衡的比例，而空军喜欢拿现在的工资跟过去的房价相比，但是那种状态太过理想，想明白的，就会觉得房子不贵。</p><p>什么时候房价会下降，一句话供求关系，人口减少是房价下降的唯一出路。即便是出台房产税，很有可能富人顶着房产税不卖，变相加租抵消房产税，特别当今租房市场存在中介的操纵，很多房子都是通过中介渠道才租出，垄断的中介忽悠房东集体涨价，房产税很容易就转嫁给租房者。ZF也不是完全不作为，当你开着车逛着公园坐着快铁地铁的时候，就应该加速印刷的钞票有一部分投入了基础设施建设，如果不通过税收和出让土地收入来建设，我们很可能还走在乡间小路上。</p><p>虽然瓷器国是中yang高度集权的国家，但是任何朝代都是诸侯之间相互制约，上面出台个政策，各个诸侯执行与否或者执行是否到位都可以影响房价甚至很大影响，且不谈上面是不是真的想降房价，即便是动真格，下面的诸侯听不听招呼是另外一回事。有心无力的事情不是不可能发生。共同富裕其实是一种美好愿望，因为人与人的竞争天性，不可能人人平等，只要有人还想凌驾于其他人之上，就永远不可能GC主义。</p><p>任何社会都是这样的形态，忍无可忍-geming-平稳-不满足-垄断与剥削-改革-改革失败-再次忍无可忍。为何历史反反复复如此？就是因为人的劣根性，因为人性的贪婪。所以周而复始而已。</p><p>人性的贪婪决定了社会进程，刚开始穷人只想平均，从富人手中夺取生产资料，当GEming之后，穷人开始不满足于仅仅是平均，穷人想要凌驾于其他人之上，想变成富人，于是利用geming占有的各种手段获取利益，最终变成了富人，被凌驾的穷人再次想通过变革改变自己的地位。。。。如此循环。。。</p></blockquote><h2 id="深圳-amp-昆明仇书记-amp-通货膨胀体制内高枕无忧、体制外自求多福"><a href="#深圳-amp-昆明仇书记-amp-通货膨胀体制内高枕无忧、体制外自求多福" class="headerlink" title="深圳 &amp; 昆明仇书记 &amp; 通货膨胀体制内高枕无忧、体制外自求多福"></a>深圳 &amp; 昆明仇书记 &amp; 通货膨胀体制内高枕无忧、体制外自求多福</h2><blockquote><p><strong>sprina0321：</strong></p><p>楼主真是高人啊，追了两天，终于看完了。也想向楼主请教下房事</p><p>不知楼主对深圳了解吗，我们来深圳七年了，结婚也好几年了，可是最近才去布吉买了首套，布吉的可园，二手，单价一万四。现在深圳关内10年的二手都一万六，好一点的两万，关内基本没新房了，有的都3万左右了。大量的新房都在关外，基本2万吧。我们本来也想买关内，可是想着同样的价格在关外可以买好点的，就买了关外，不知这个决定是否正确？按楼主的意思，还是要买市中心，可是市中心的话，只能牺牲面积，房子也旧，这样住着也不舒服啊。</p><p>另外，我父母就在昆明，他们本来在一环上有套房改房，挺方便的，就像楼主说的，可恨的仇书记要制造需求，现在他们的房子说是要拆了，他们现在想买，可是一环外的都8000多，他们觉得有点贵，买了以后，手上的钱就都用完了，又想干脆等回迁。楼主觉得要不要买呢？ 我父母就我一个孩子，他们在深圳买过一套房子，就是市中心的塔楼，等我们不住了，这套房子要不要卖掉，还是留着出租好？</p><p><strong>kkndme：</strong></p><p>深圳不太了解，不过宁肯牺牲点品质也要选择市中心，这是无数人经过从市中心搬到郊区大户型再搬回市中心老房子而取得的宝贵经验，当然如果你在关外上班就另当别论了。 往历史人物上套，qh应该算作集酷吏与奸佞于一身，横施暴（）政早晚落到身败名裂的下场，不是不报时候未到。等拆迁主要是在昆明风险比较大，几年不知道能建起来，志远综合体就是很好的例子，如果有能力不妨先买一套。</p><p>至于说房子卖不卖关键你是否需要用钱，如果不需要，又没有更好的投资，不妨先留着。</p><p><strong>sprina0321：</strong></p><p>我有时候想，像QH这样的人应该不得好死，断子绝孙，老天还真是不长眼。</p><p>请楼主明示 志远综合体是怎么回事</p><p>我父母家就在东站，董家湾中间那里，原来厂里也在，现在厂子搬到开发区了，家里的房子也逃脱不了被拆迁的命运了。 现在家里在一环出去点看中一个房子，房子挺不错的，大社区，新房，算下来9000多，不便宜啊。一环内的估计我们买不起，家里人年纪大了，想住电梯房。</p><p>楼主对昆明现在的房价怎么看呢，会不会回调，感觉今年涨很多。 现在9000，难道以后涨到2万，和深圳现在价格一样？我和老公也工作很多年了，现在年收入30多万，我们都买不起2万的，我们去看过万科在深圳的新盘，房子没得说，带精装修，2万多一平，一套要300万，虽然很心动，也只能放弃，怎么现在昆明人这么有钱了？ 按照通货膨胀来说，如果以后昆明的房子卖2万，那深圳的岂不是要卖4万，那我们的收入也会涨到60多万吗？哈哈，实在算不过来了。通货膨胀对我们的收入有影响吗</p><p><strong>kkndme：</strong></p><p>一环外9000多的新盘，昆明还真没几个，滨江俊圆9000多，但容积率太高，又有大量的回迁户，个人很不看好。翡翠湾达到了12000，云上城、翠园等要开的楼盘估计开盘价也要上万了。呵呵 昆明的房价，我预计市中心将达到2万，一环二环间15000，滇池板块将达到12000，北市区及世博板块将达到1万。东市和西市在8000-9000。螺丝湾板块最不确定，但未来不会低于9000。 志远综合体早在几年前完成了莲花池片区的拆迁，但迟迟不动工盖房，时隔几年一点动静都没有，拆迁户没有买房的现在还在租房住。</p><p>关于通货膨胀问题，体制内的职工工资一定会与时俱进的。体制外人员的薪水不取决于通货膨胀，而是取决于行业的利润率，企业的利润和个人的能力运气。对于多数竞争激烈，产能过剩行业内的民营企业一般员工，工资增长是很难抵御通胀的，而且由于通胀导致生产成本的价格上涨，减薪甚至裁员的可能反而更大。</p></blockquote><h2 id="长春"><a href="#长春" class="headerlink" title="长春"></a>长春</h2><blockquote><p><strong>wkzjx2008：</strong></p><p>楼主你好，请帮我分析一下，谢谢</p><p>我在长春</p><p>长春的市政府在前几年的时候搬到了城市的南部，南部因为是空地，所以盖的都是新盘，价钱现在7000多，而我工作的所在的位置是原来的一个商业区，这里原来都是学校，医院和一些机关单位，好企业的家属楼，因为原来的购买力强所以居民楼的一楼都变成了小店铺，所以形成了这个城市的一个没有大商场的一片繁华商业区，但现在随着原住民的逐渐迁走，这里租房的人多。但这里有一个优势是离市里最好的小学和高中都很近，这也是这里房价坚挺的原因。现在这里的二手房如果是大户型在5000左右每平米，小户型6000左右，基本都是八九十年代的房子，2000年以后的次新房很少，距离这个区域较近的一个新盘是商住两用的卖到9000多每平</p><p>孩子现在在这上幼儿园，堵车太厉害了，为了孩子我在这租的房子 我现在手里有20万现金，请问这片区域值得购买么，买大的还是小的，我已经贷过一次公积金贷款，现在已经结清</p><p>现在这个城市很远的地方新开的楼盘也要4000多一平米</p><p>请楼主赐教，不胜感激</p><p><strong>kkndme：</strong></p><p>政府所在地区域又是学区房，这样的房子优势还是很大的，但是由于有大体量的老房子存在，将来有可能大规模拆迁，而拆迁补偿却决于zf是否铁腕，如果遇到铁腕领导，补偿额一定不会太高。这是购房的风险。对于非一线城市，新盘的风险肯定小于老房。</p></blockquote><h2 id="佛山"><a href="#佛山" class="headerlink" title="佛山"></a>佛山</h2><blockquote><p><strong>爱佛僧傲瞪詹牧师：</strong> lz高人！ 不知道来过佛山没有？佛山紧邻广州，两地的地铁即将贯通接轨，房价应该会快速飙升，但是另一方面，佛山是个制造业城市，村镇工业高度发达，外来打工的比较多，流动性很大，lz所说的，今后买房只是有钱人游戏，房租会高涨，这点对佛山这样的小城市不知道成不成立？村镇里还是有很多便宜的出租屋的，高端点的打工者，如果房租太贵，应该会嫌贵干脆回家发展，最后只能留下低端制造业产业工人吧？这样房租应该还是很难上涨。</p><p><strong>kkndme：</strong></p><p>佛山还真没去过，只去过东莞和中山，呵呵。 对于广州一带房价相对偏低的原因是广州并非全省唯一的大型繁华城市，而是广东省内形成了大片的都市群，使得城市的经济得到了均衡的发展。这是最健康的城市发展模式，但也制约了房价的上升空间。随着地铁的贯通接轨，佛山的房价将呈稳步上涨态势。</p></blockquote><h2 id="首付提高的逻辑"><a href="#首付提高的逻辑" class="headerlink" title="首付提高的逻辑"></a>首付提高的逻辑</h2><blockquote><p><strong>tianxiaobing11：</strong></p><p>请教楼主，最近有银行提高了首付，这是为什么？政府真要让中低层租房子吗？政府吃租赁的大蛋糕吗？</p><p><strong>kkndme：</strong></p><p>主要还是防范金融风险，政府调控的目的从来也不可能是解决穷人的买房问题。恰恰相反，金融风险来自于让穷人买房，所以提高首套房首付比例，杜绝穷人买房，才是防范金融风险的有效手段。同时可以推升租金上涨，政府推出的公租房才有市场，有钱可赚。</p></blockquote><h2 id="四线城市"><a href="#四线城市" class="headerlink" title="四线城市"></a>四线城市</h2><blockquote><p><strong>shs2009：</strong></p><p>楼主，我们这个城市离武汉60公里，四线城市吧。我打算在新开发的工业园区买一套房子，买的理由是认为工业区是人员比较集中的地方，应该有比较大的需求，无论租售都应该有潜力的。我的看法对吗？</p><p><strong>kkndme：</strong></p><p>四线城市一定要选择城中心或者高档住宅区买房</p></blockquote><h2 id="苏州工业园"><a href="#苏州工业园" class="headerlink" title="苏州工业园"></a>苏州工业园</h2><blockquote><p><strong>夏天来了我也来：</strong></p><p>我是昨天才看到LZ这个帖子的，一口气读完了，眼睛虽然有些累，但心里却是收获颇丰，今年四月ZY刚开始严厉调控的时候，我可是抱了一百分的信任，心想我们老百姓的好日子终于来了，终于可以用较低的价格买套属于自己的房子了，可现在都九月了，看着周围一直慢慢望上爬的房价，真的是失望极了！ 我九月三号的时候刚定了一套二手房，是我们的第一套房子，不知道LZ是否了解苏州工业园区的发展前景和房价，我们这套房子在园区的中心位置，也相当于市区吧，位置还不错，可就是这个房子属于政府修高速路时的拆迁安置房，房龄有十年了，原来房东的两证上写的土地性质是“出让”，不知道这样的房子以后是否有升值空间？因为在苏州园区同样的地段，同样旧的拆迁房价格基本都快一万了（我们定的这个房子因为离马路有些近，而且在顶楼，户型是小户带阁楼，上下两层复式结构的那种，所以便宜一些，只有八、九千），附近的高档商品房价格也要一万五左右！苏州和上海离的这么近，如你所说，江苏的有钱人都跑到上海买房了，苏州的房价是不是很难涨呢，同时也担心以后房价再继续上涨，ZY会出重拳打击楼市，真到那个时候，房价是不是要暴跌呢？</p><p><strong>kkndme：</strong></p><p>土地性质“出让”没有问题，“划拨”才有问题。 zf初重拳打击的结果往往取得相反的效果，因为政府如果希望继续执政是绝不可能让房地产崩盘的，房地产的崩盘将同时埋葬现有体制，社会“和谐”将不复存在。如何让房地产持续稳定与gdP同步上涨是政府最大的难题，完全取决于领导的智慧，但是以现在的水平来看，是很难做到的。 苏州工业园区房地产不是很了解，但是一个工厂及仓储所在地，缺乏高科技与文化历史底蕴的支持，房价一定会涨，但涨幅一定有限。</p></blockquote><h2 id="住房公积金利率"><a href="#住房公积金利率" class="headerlink" title="住房公积金利率"></a>住房公积金利率</h2><blockquote><p><strong>facetowall：</strong></p><p>另一个问题啊，我准备用住房公积金购买首套房，在其它的一些帖子上看到政府将在某个时间点上加息，那么对住房公积金的贷款利息（3.87%）会不会同样上调呢？上调幅度会是多少？对这个比较关心，麻烦楼主给解答一下吧。谢谢了！</p><p><strong>kkndme：</strong></p><p>如果当年加息，再次年的元旦后贷款利率也会相应增加，但公积金贷款利率增加的幅度很小，不用担心。加息说明通货膨胀严重，如果不是连续过度加息，对房价没有影响。从长期看更是不可能影响房价上涨趋势，除非经济崩溃。如果经济崩溃，持有纸币也没有意义，等同于废纸。 90年代我国高度通货膨胀，银行存款年利率曾达到百分之十几，但并没有影响房价的上涨趋势。</p></blockquote><h2 id="济南-amp-大规律拆迁的城市房价不会下降"><a href="#济南-amp-大规律拆迁的城市房价不会下降" class="headerlink" title="济南 &amp; 大规律拆迁的城市房价不会下降"></a>济南 &amp; 大规律拆迁的城市房价不会下降</h2><blockquote><p><strong>facetowall：</strong></p><p>不知道楼主对济南的房市了解如何？去年接着全运会的东风，济南房价涨了35%到40%，让许多人措手不及。现在市区的新开盘的楼盘依据位置不同大约在8000到13000rmb每平方。济南奥体中心附近的房子在9000到13000rmb每平方吧。我和老婆都在济南高校工作，目前俩人月收入6000+，公积金1100多吧。相比于其它省市地区高校，无论工资还是公积金</p><p>都比较少。我感觉高校老师属于体制内的边缘群体，工作忙(很多人不认同这点)报酬少，并且目前已经没有什么福利分房了，都要到市场上购买商品房。我们的家庭情况是这样的：均为独生子女，目前有一个孩子，二岁了，双方父母均是事业单位退休人员，我父母退休金合计1万每月吧，她父母大约7000.由于我父母在济南有两套房改房，所以现在他们住一套，我们三口住一套，房产证上都是我父母的名字，所以我和老婆属于无房户。目前想买一套房子给岳父母住，毕竟我们俩是独生子女，将来接到济南来住是早晚的事。感觉济南的房价几乎没有下降的可能，因为全济南正处于最火热的拆迁阶段，山东省已经把济南的改造升级列为战略了，并且全国的知名地产商如绿地、中海、保利、绿城、万达(好像万科没有)都来拿地盖房并且已经推向市场了。目前看中了奥体中心附近的一套2005年的二手房，房子很新，毛坯房，环境物业都不错，大约120平米，单价得9100，总价110万。我们想拿出70万现金，再以公积金贷款50万(10万装修)/20年，不知道这样有没有风险。一个是担心房价下跌，再一个加息。请楼主给出明示，指导一下，万分感谢。</p><p><strong>kkndme：</strong></p><p>大规模拆迁的城市，房价没有下降的可能，可以忽略政策因素。既然城市大规模拆迁，就晚买不如早买，这是本贴中一再提到的。</p><p><strong>facetowall：</strong></p><p>多谢楼主的解惑。感觉济南不像北京上海那样具有巨大的政经优势吸引全国的阔商巨贾和精英汇集，也不像昆明、杭州那样为渡假天堂，还不像西安、南京、武汉那样高校云集具有巨大的教育资源。也就是说济南不能吸引相当多的精英投资，始终是个不温不火的地方，所以济南的房价有点虚，再上涨的话就脱离了实际的承受能力。楼主对此有何看法？</p><p><strong>kkndme：</strong></p><p>济南的地理区位并不差，但城市搞的不好跟领导有关，济南的经济前景不错，而且房价的上涨是拆迁带动的，以后很多城市都会走这一步。</p></blockquote><h2 id="公务员小区牛逼"><a href="#公务员小区牛逼" class="headerlink" title="公务员小区牛逼"></a>公务员小区牛逼</h2><blockquote><p><strong>何金银银金何：</strong></p><p>不知楼主是否了解哈尔滨的房价？小弟有套小房子 想换大点的，现在可是时机？哎 早拜读你这文章 今年年六月份就能换套大的了，可惜现在搞得自己换不起了……杯具&amp;</p><p>哈尔滨的公务员小区是没有产权的，不知道这种房子买了做第二套之后要不要征税？而且也非常贵，按使用面积要1w多一平了</p><p>小弟小白，您有空给指点指点……</p><p><strong>kkndme：</strong></p><p>公务员小区比房产证和土地证还保险。我国不是一个法制国家，任何颁发的纸质文件的可信度都不高，反而公务员小区因为是特权房，信用度要远高于产权证。</p></blockquote><h2 id="房屋朝向只要不是纯北西就行-amp-买房首选市中心、公园地产"><a href="#房屋朝向只要不是纯北西就行-amp-买房首选市中心、公园地产" class="headerlink" title="房屋朝向只要不是纯北西就行 &amp; 买房首选市中心、公园地产"></a>房屋朝向只要不是纯北西就行 &amp; 买房首选市中心、公园地产</h2><blockquote><p><strong>pohangcity：</strong></p><p>楼主。兄弟在一北方省会城市太原，目前这里的商品房平均价为5000左右，上周看了市中心的一套房子，112平米，紧挨市区里的公园（有一大湖），周边就是万达广场，万达的房子均价8500，已经售完，这个房子售价7000，已经是现房，结构还可以，唯一的问题是不是正房，朝向向东，周边一片混乱，全是施工的、拆迁的，说以后要以万达广场为中心，打造太原的CBD，也不知道能不能实现。 房子总价74万，首付24万，按揭月供3400，现家庭年收入税后10万，不可以公积金贷款，我已有一套住房，不过感觉还款压力很大。 我的问题是： 1、楼主帮我房子一下这个房子值不值？我想以后自己居住，现在的房子可出租1500左右。 2、太原也有万达、恒大的楼盘，位置是在太偏，价格6000带精装，户型也好，如何取舍？ 非常谢谢楼主~~~~~~</p><p><strong>kkndme：</strong></p><p>房屋朝向问题，随着城市房价的不断飙升，已经不那么讲究了。只要是不是纯北房或者纯西方，都可以接受。 建议首选还是城中心，特别是公园地产，未来将更稀缺。</p></blockquote><h2 id="zf搬迁"><a href="#zf搬迁" class="headerlink" title="zf搬迁"></a>zf搬迁</h2><blockquote><p><strong>xhyyhzy：</strong></p><p>楼主您好，从您的帖中收获很多。觉得以前真的被洗脑洗的很厉害，从天涯学到很多。非常感谢您，又让我明白了很多事情。</p><p>请教您，市政府从原来的市中心，搬迁到另外一个地方，相对较远，因为城市不大。好的医院，学校，各种好的资源都在市中心。现在搬到一个特别偏远，荒凉的地方，重新开始建设，政府这么做是什么意思阿？以后这些医院，学校也会搬吗？多浪费阿。另，您怎么看该城市未来房价的变化。（注，离上海很近的3线城市）</p><p>期待您的分析。</p><p><strong>kkndme：</strong></p><p>政府搬迁到郊区不仅仅是个别城市问题，而是大多数二三线城市面临的问题。政府的用意在于扩大城市规模，扩充人口，追求gDP的高速增长，但对于新开发出一块荒郊野地，没有政府的带头搬迁，是很难炒作起来的。政府的迁入是一个信号，告诉老百姓，政府都搬过去了，以后配套肯定不会有问题。于是概念将透支未来，房地产价格就会飙涨。但是未来建成后政府是否真的搬迁就不一定了。 医院和学校全部搬迁会加深社会矛盾，所以通常是在新规划的区域建分校。如果自住还是主城，如果投资投机，可以考虑新城。</p></blockquote><h2 id="俄罗斯"><a href="#俄罗斯" class="headerlink" title="俄罗斯"></a>俄罗斯</h2><p>有同志提起俄罗斯很可以再说一说的。</p><p>俄罗斯的前身叫罗斯公国。首都不在莫斯科，而在基辅。</p><p>建立罗斯公国的，是东斯拉夫人，日耳曼人眼中的劣等民族。有人说过，俄罗斯和西方国家的差别，并不仅仅是经济上的差别，而是民族和文化的差别。这种说法还是很有道理的。用我们现在的话来说，斯拉夫的人种有问题。善于侵略，欺软怕硬，野蛮无礼。这是斯拉夫人的特点。所以在罗斯的土壤，永远出不了骑士精神。</p><p>罗斯人信奉基督教，源于弗拉基米尔一世娶了东罗马帝国安娜公主为妻。所以我们看到的俄罗斯教堂全部是拜占庭式的。拜占庭帝国灭亡后，东正教的中心就搬到俄罗斯。</p><p>罗斯国并不是统一的帝国，而是象我们的西周，搞的是封建分封制（我国在秦以后就不是封建社会了，因为取消了封建分封制，丞相都是打工仔，这一点是与我们的课本不同的），到了十二世纪，礼崩乐坏，罗斯国分裂了，罗斯的周天子弗拉基米尔二世·莫诺马赫的统一大业未能完成，故罗斯的土地上居然出现了十八个公国，很有点象我们的十八路诸侯。</p><p>十三世纪，成吉思汗的孙子，术赤的儿子，英勇的拔都同志西征，一个强大的统一的蒙古帝国攻击分裂的罗斯诸公国，很有点欺负人的味道。于是强大野蛮的东斯拉夫人在金帐汗国的铁蹄下，当了孙子。 莫斯科公国的伊凡一世·达尼洛维奇以贿赂的方式从金帐汗那里获取了弗拉基米尔大公的封号，并把东正教罗斯教区总主教驻地从弗拉基米尔迁到莫斯科。</p><p>莫斯科大公是很有一手的，一面拍金帐汗的马屁，一面组织军队，终于利用金帐汗国的内部分裂，一举击败了马迈汗率领的大帐汗国军队，并且兼并了科斯特罗马公国、加里奇公国、白湖公国、乌格里奇公国、下诺夫哥罗德公国、木罗姆公国和苏霍纳河流域北部等广大东北罗斯地区。</p><p>14世纪，莫斯科大公依凡三世在乌格拉河战役中，迫使阿合马特汗撤退，终于结束了金帐汗国长达两个多世纪的统治。</p><p>直到1713年，莫斯科公国干掉了罗斯地区的绝大多数王公，才形成了统一的集权国家，正式命名为俄罗斯帝国。</p><p>罗斯公国打得最精彩的战役就是楚德湖战役。 对手是称霸普鲁士的赫赫有名的三大骑士团之一，条顿骑士团，欧洲强大到令人恐怖的军事组织。 罗斯的最高指挥官是亚历山大诺夫格罗德公爵。 俄罗斯联军一方有1.5万到1.7万，主要是步兵。而条顿骑士团的大约有1万人，以重骑兵为主，其中大骑士应该不下千人，这是一支让整个欧洲都发抖的军队。 罗斯联军的步兵排成密集队形，据守冰湖东岸。骑士团的重骑兵以楔形阵发起冲锋。按常理看这是一场毫无悬念的战斗，罗斯步兵在强大的世界第一军事组织面前应该不堪一击。 但是亚历山大诺夫格罗德公爵是军事天才，军事才能相当于中国的乐毅。这位乐毅公爵仔细研究了重骑兵的楔形阵，认为弱点在于两翼的防御力量有限，如果重骑不能迅速撕开步兵防线，重骑的两翼会慢慢被侵蚀。 亚历山大同志于是把联军中主要的轻步兵安排在中间，列成加厚的方阵，消磨条顿重骑的突击能力，然后把他自己的诺夫格罗德精锐步兵放在两翼。 条顿骑士团的攻击开始还是成功的，但无法撕开罗斯步兵的军阵。最惨的还是条顿骑士狂妄自大，非要在楚德湖的冰面上发起冲锋（冬天结了冰），可想而知重骑兵跑到冰面上冲锋是什么样的效果，战争逐渐陷入僵持。 亚历山大的精锐步兵攻击骑士团的两翼，骑士团被包围了。亚历山大同志果断的派出最精锐的骑士亲兵卫队，从右翼后方包抄攻击骑士团。 可怜的条顿骑士，拥有世界上最强悍的战力，但在湖面上根本发挥不出来，大量的重装甲骑士掉进冰窟窿里，条顿骑士大团长也被俘虏了。 每次看这段历史，都为条顿骑士团唏嘘不已。</p><p>条顿骑士团败的最惨的是另一场战役，塔能堡。是中世纪欧洲最大规模的战争。 对手是波兰、立陶宛联军。 著名的波兰小说“十字军骑士”就是讲的这段历史。 骑士团的大团长是荣金根，大概有投入1万多名士兵。 波兰、立陶宛联军大约有3万名士兵。 联军方面指挥官是波兰国王Jagiello和立陶宛大侯爵Witold。 条顿骑士大团长荣金根是一个位标准的日耳曼大骑士，开战前，骑居然给波兰国王Jagiello送去两把剑，表示要进行一场骑士之间的较量。斯拉夫人是不敢这么玩命的，立刻拒绝了日耳曼骑士的要求。 条顿骑士团的骑士拥有强大的武力，真不是盖的，荣团长挥动旗枪组织冲锋，立陶宛军立刻溃败，波兰的翼骑兵也根本无法抵挡日耳曼骑士强大的冲击力，准备开始溃逃。这时一个意外发生了，大团长兼倒霉蛋荣金根同志在奋勇冲锋时突然遭了冷箭挂掉了，骑士团缺了指挥官陷入混乱，无法阻止有效的进攻，波兰立陶宛联军乘机组织起冲锋，条顿骑士团莫名其妙的大败。 真是谋事在人，成事在天。强大的条顿骑士的惨遭溃败居然因为一个意外。</p><h2 id="珠海-amp-唯一自住房不只是投资-amp-调控是最佳的选房时机"><a href="#珠海-amp-唯一自住房不只是投资-amp-调控是最佳的选房时机" class="headerlink" title="珠海 &amp; 唯一自住房不只是投资 &amp; 调控是最佳的选房时机"></a>珠海 &amp; 唯一自住房不只是投资 &amp; 调控是最佳的选房时机</h2><blockquote><p><strong>期待艳阳天：</strong></p><p>楼主，想就以下问题请教： 1、珠海属几线城市？您对投资珠海的房产前景作何分析？ 2、我一朋友刚出手一套自住的房，打算租房住一段时间，想抄底再入，他是坚信房价会跌派，考虑到目前他供房确实有困难，且对刚出手的那套房不是很满意，请问他的做法是值得借鉴？ 3、我目前的对自住的房朝向及大小不太满意，也想倒手后再入，我目前的房出手的话比同地段的新房价略低10-30%（主要是小区及户型有差异），如果换大、好的承受不了借贷压力，但如果淘二手房的话，可以在附件找比我目前房价低20%左右的二手房，请问我是否可以考虑换个朝向、大小更满意的房？现在是好时机吗？</p><p><strong>kkndme：</strong></p><p>以上，请楼主不吝赐教！</p><p>珠海是个适合居住的城市，干净整洁，生活节奏不快，相当安逸。 将自己唯一一套自住房卖掉，跌了买回，这样做的投机性心理太强，风险很大，往往得不偿失。当然如果为了换更大更好的住房就令当别论了。</p><p>人的一生很短暂，在衣食住行中，住占了人生的大部分时间，有一个温暖的家，生活才觉得安逸。如果有能力确实应该换一套自己满意的舒适的住房。至于出手时机，我觉得房产不是股市，不能总想着抄底逃顶，只要房价的长期上涨趋势未变，调控时期正是选房的最佳时机。</p></blockquote><h2 id="经济崩溃，最后接盘的是老百姓"><a href="#经济崩溃，最后接盘的是老百姓" class="headerlink" title="经济崩溃，最后接盘的是老百姓"></a>经济崩溃，最后接盘的是老百姓</h2><blockquote><p><strong>vipboy223：</strong></p><p>看了LZ的帖子，受益非浅！谢谢！ 有一个问题还请教下：就像LZ所说，此次调控是ZY布局，赶出炒房者和小的kfs，目的是实现房子的垄断。但从政策和执行看，停止3套房贷并没有真正打击到真的炒房者，至多是改变了预期；二套房首付比例和利率的提高，确实实实在在的把改善性需求排除在外了；现在有些银行对首套房的首付都提高到4成，利率优惠也没有7折优惠了。当然我很愿意相信这次ZF在保护LBX，阻止老百姓去接房产暴利的最后一棒；显然这不是真正的原因。当然，首付和利率提高可以让银行增强金融防范能力。 随意想请教LZ对这个问题的看法；</p><p><strong>kkndme：</strong></p><p>政府阻止老百姓去接最后一棒？晕，如果真的到了崩盘的一天，接最后一棒的一定是老百姓，而且zf会千方百计的让老百姓接最后一棒。 分析问题不能用喜羊羊的头脑。</p><p><strong>vipboy223：</strong></p><p>显然LZ没有仔细看我写的内容。 换种方式问下：改善性需求是否现在就入市？首付高就不说了，利率1.1倍可是很厉害的；</p><p><strong>kkndme：</strong></p><p>如果是忙于拆迁的二三线城市就要抓紧买了，利率高也认了。 如果是一线城市不妨再看一下，但是观望也是有风险的，一旦上涨就买不到合适的房子了。</p></blockquote><h2 id="命运之矛"><a href="#命运之矛" class="headerlink" title="命运之矛"></a>命运之矛</h2><p>荣金根团长的挂掉会不会跟命运之矛有关呢。</p><p>1189年，神圣罗马帝国皇帝红胡子腓特烈一世在与教皇和解后，与狮心王理查一世、腓力二世·奥古斯都开始了第三次十字军东征。然而，红胡子腓特烈一世在小亚细亚渡过萨列法河时竟然意外溺死。原因是他突然丢失了传说中的命运之矛。</p><p>命运之矛也叫郎基努斯之枪。</p><p>正是一个叫郎基努斯的罗马士兵用这杆抢刺入了十字架上耶稣的身体，这只枪因沾有圣血成为圣物。</p><p>传说持有命运之矛的人可以主宰世界的命运，但失去的人会即时毙命，神圣罗马帝国的皇帝红胡子腓特烈一世就拥有这只命运之矛。</p><p>二战时期，希特勒从维也纳博物馆夺取了命运之矛，差不多占领了整个欧洲。但是在1945年4月30日下午2点10分，命运之矛又被美军夺走了，不到2小时，希特勒便吞枪自杀而亡，死时是下午3点30分，这难道仅仅是巧合？</p><p>荣金根是否也拥有过这只命运之矛？</p><p>我以为我们每个人都有一把属于自己的命运之矛，当你得到它的时候，你的事业、家庭、健康、财富都相当不错，但是当你失去它的时候，你的生命也将完结。</p><p>每个人对生命之矛都有自己的理解，希望我们都能够找到它。</p><h2 id="除非外族入侵或全国大饥荒，否则双轨制决定了房价不会崩盘"><a href="#除非外族入侵或全国大饥荒，否则双轨制决定了房价不会崩盘" class="headerlink" title="除非外族入侵或全国大饥荒，否则双轨制决定了房价不会崩盘"></a>除非外族入侵或全国大饥荒，否则双轨制决定了房价不会崩盘</h2><blockquote><p><strong>戈者：</strong></p><p>不要枪，不要炮，我只要选票，有了票，谁不让老百姓好过，就让谁滚蛋</p><p><strong>kkndme：</strong></p><p>我们连依法治国都办不到，何谈选票。 我们是实行双轨制国家，在经济全球一体化的今天，内部并不与外部接轨。这个好比是互联网，我们重要部门的内网是绝不会跟外网联结的。 改变只有两个前提，一是外族入侵，二是出现全国性的大饥荒。否则期望房价崩盘重建一个新世界是没有可能的。</p></blockquote><h2 id="kkndme聊北宋、唐朝"><a href="#kkndme聊北宋、唐朝" class="headerlink" title="kkndme聊北宋、唐朝"></a>kkndme聊北宋、唐朝</h2><p>北宋时期，有个文豪及公务员叫苏东坡，一辈子也没能在首都开封买上房子，不得已，在外省小县城投资了几套房地产。苏文豪公务员的儿子在首都结婚的时候，居然都没搞到一套新房，苏公务员急眼了，最后想办法跟朋友借了一套房子，总算把喜事办了。北宋跟我们的现实还是有区别的，象苏文豪公务员这样的中层国家干部，在京城大都是有几套房子的。可见北宋时期公务员待遇还不如现在。</p><p>苏文豪公务员的弟弟苏辙就比较幸运了。该同志也是公务员国家干部，工作上兢兢业业，勤勤恳恳，熬了几十年工龄，在七十岁的时候终于买到了房子，但是买的位置还算不上首都开封，而是在开封南边的许昌买的，相当于首都的卫星城。就好比在北京买不起房的同志，跑到天津去搞了一套。 苏辙公务员同志专门为买房的事写了诗，“我生发半白，四海无尺椽”，我老未有宅，诸子以为言”诗的意思反正是比较愤青，很想现在的傻空</p><p>唐朝还有个白居易同志，也是个公务员，级别相当于正处级，工作是在中央办公厅负责校对红头文件。白公务员职务一般，但工资可不低，每月一万六千钱。但是白公务员却买不起房，在长安东郊常乐里租了四间茅屋，因为房租比较高，城区的租不起，所以上班比较远，很潇洒的买了一匹马，相当于我们买车。白公务员还是很懂享受生活的，雇了两个保姆，每月的总支出大约是七千五百钱。白公务员很象蜗居里的海萍，不肯高价租城里的好房子，而是把剩下八千五百钱存起来，一心要买套房。但是存了十年，他也没能买的起长安的房子，白公务员兼诗人的文学功底很高，但是不懂经济，不了解通货膨胀。</p><p>最后白公务员急了，很愤青的说：“你们局级干部在长安炒房子，我处级干部就去周边炒房子。”于是白公务员跑到长安城的卫星城——陕西渭南县，买了套房子，平时在单位蹭房子住，逢假期和周末回渭南的家里跟老婆叉叉呕呕。可见唐朝时处级及以下公务员待遇也就跟我们的都市普通小白领差不多。</p><h2 id="宋代房奴"><a href="#宋代房奴" class="headerlink" title="宋代房奴"></a>宋代房奴</h2><p>关于房奴，也是宋代就有记载。宋代有本书叫《白獭髓》，写的就是房奴生活：“妻孥皆衣蔽跣足……夜则赁被而居。” 大意就是所有的存款不够，还借来钱砸在房地产上，不得不节衣缩食还债，别说家里人买新衣服，就连被子都是租的。 不知此人炒房后来发财没有，那时买房可都是全款，没有银行贷款一说。</p><h2 id="ZG民主"><a href="#ZG民主" class="headerlink" title="ZG民主"></a>ZG民主</h2><p>只许州官放火，不许百姓点灯，这就是我们的民主</p><h2 id="王安石的青苗法之国家出政策的动机"><a href="#王安石的青苗法之国家出政策的动机" class="headerlink" title="王安石的青苗法之国家出政策的动机"></a>王安石的青苗法之国家出政策的动机</h2><p>关于呼唤国家出政策已达成自己买车买房心愿的空空们，有必要听听王安石变法的故事。</p><p>我国的官僚有几千的当官经验，最不怕的就是新政策，只要是新政策，无论目的是为了民生还是敛财，反正就找到了由头，就有办法敛财，有空子可钻。</p><p>王安石变法的初衷是好的，但是不了解中国的官僚体制，变法让老百姓吃饭都成为了困难，加速了北宋的灭亡。所以盼着出房产税的空空要认真的用脑子想问题，梗着脖子泄愤是没有用处的。</p><p>说说王安石同志的青苗法。</p><p>青苗法，按理说是一项最为民生考虑的政策。</p><p>在百姓青黄不接，缺少粮、钱的时候，让老百姓自己估计当年谷、麦产量，先向官府借钱，谷熟后还给官府，称“青苗钱”。</p><p>青苗法规定把以往为备荒而设的常平仓、广惠仓的钱谷作为本钱。每年分两期，即在需要播种和夏秋未熟的正月和五月，按自愿原则，由农民向政府借贷钱物，收成后加息，随夏秋两税纳官。</p><p>实行青苗法的目的肯定是好的，可以让农民在青黄不接时免受高利贷盘剥、并且让农民不至于在没粮的时候土地被大地主所兼并。同时,让政府获得一大笔“青苗息钱”的收入————单纯为了民生，政府收不到钱的事情王安石同志也不同意。</p><p>按理说，出了这个政策，农民该欢呼了，zf出面了，农民们不用受地主老财剥削了，很多傻空老农民鸡冻的喊：“还是王领导的政策好啊。”</p><p>地方官员也鸡冻了：“太牛了，发财的机会来了，王领导这人人品虽然不怎么样，但是很给我们挣钱的机会啊。”</p><p>于是，王领导的青苗法一推行下去，完全走样了。</p><p>首先青苗息钱从王领导定的年息二分，本来就挺高的贷款20%利率，比我们房贷可高多了。但是就这个年息二分，在地方一下子变成了半年息二分，年利率高达40%：因为是春季发一次贷款，秋季发一次贷款，所以地方官每半年收回本利，还是按二分收，所以变成了半年息二分，年息四分。到了后来地方官想怎么收怎么收，甚至年息高达百分之几百。</p><p>傻空农民立刻傻眼，说反正自愿的，我不贷还不行吗？接着管地主老财借不行吗？</p><p>zf说了：不行。你贷也得贷，不贷也得贷，于是变成了强制高利贷。</p><p>王领导在推行青苗法的时候，还下了定额，贷款多少那是有任务的。任何朝代推行某个政策，只要涉及到收钱，都是有任务的。</p><p>王领导下达了任务，地方官必须完成，不然要罢官丢脑袋，扣个阻碍变法的帽子可不得了，同时本着无利不早起的伟大思想，不但要完成任务还要层层加码。</p><p>这下，傻空老农民彻底傻了，饭都吃不上了。</p><p>结果是王领导给zf增加了税收，官员闷声大发财，老百姓彻底崩溃。</p><p>所以请呼唤房产税的朋友，好好读一下王安石变法</p><blockquote><p><strong>tjOOSAN:：</strong></p><p>我想 这个 “房产税”出不出。不是什么决策问题吧？</p><p>是我们产权的解释问题！我们产权只有70年，换句话说就是租七十年，地和房子本身还是国家的！那么国家的房产再收税，是不是有点法理不通呢？ 这是 郎咸平说的</p><p>楼主！这个。你让我再次质疑你了</p><p>我其实 很想看进去你的文章！可惜。。。。唉 这成了您的历史秀了~~ 海</p><p><strong>kkndme:：</strong></p><p>连法制国家都不是还提什么法理。</p><p>拆迁条例是违背宪法的，后来又违背了物权法，但是管用的既不是宪法也不是物权法，而是拆迁条例。一群人说要修改条例，牵扯到利益就没了下文。</p><p>有时间你不妨研究一下，看看我们的政策有多少是违反宪法的。 在中国拿法理说事就比较搞笑了</p></blockquote><p>读懂历史</p><p>对自己真没坏处。</p><p>王安石不但动员zf放高利贷。</p><p>还是我国搞中央政采、垄断企业和官倒的先驱。这就是王领导推行的均输法。</p><p>宋初以来，为了供应京城皇室、百官、军队的消费，在东南六路设置发运使，负责督运各地“上供”物质。 　　</p><p>发运司只照章办事，各路丰年物多价贱时不敢多办，歉年物少价贵时却又必须办足。物货运到京城后往往因不合需要而削价抛售，朝廷所需却又要另去搜括。这些做法给富商大贾操纵物价，控制市场，囤积居奇提供了方便。</p><p>王领导希望能够节省劳务费，减少政府的财政支出和减轻人民的负担，就想出了均输法，相当于中央政府采购。</p><p>于是官府直接做生意，行政机构变成了大型国有垄断企业。</p><p>中石化、中石油、中国移动、电力等大企业的苦大家都吃过。</p><p>垄断企业的低效率，fb，强迫定价，强制消费，这些古今中外都是一样。</p><p>而且老百姓跟官府做生意，必须得上供。zf采购那是要多黑有多黑。 紧俏商品，官倒搞双轨制，体制内搞配额，体制外高价卖指标。 结果是zf闷声大发财，老百姓直接崩溃。</p><p>王领导的独断专行，刚愎自用还是很为大家所称道的，呵呵</p><p>张居正的一条鞭法从地主阶级的利益出发，反而成功了。</p><p>而王领导从民生的利益出发，搞改革，失败的很惨。</p><p>不能不说，历史是很搞笑的</p><blockquote><p><strong>中年不惑吗：</strong></p><p>符合地主阶级利益的张居正变法？？</p><p>怎么后来张被清算呢？</p><p>封建社会官僚本来就是地主阶级的代言人</p><p><strong>kkndme:：</strong></p><p>张同志的清算不是因为变法，而是把万历同志架空了，比皇帝还牛的首辅能活到寿终正寝已经算是奇迹了，跟他的变法无关。</p><p>这位徐阶先生的得意门生，政治上是青出于蓝的，无懈可击，贪污受贿大概也师承徐阶吧，呵呵</p><p>很多人只对张居正同志是否和太后有一腿感兴趣，呵呵</p><p>张居正通常是以正面形象出现，但是在贪污受贿方面是很有一手的。另一个贪污受贿的正面人物是戚继光。</p><p>我国历朝历代的体制，不搞点潜规则什么事都干不成。</p><p>比如一事无成的海瑞，光赢得了个好名，其实毫无建树。</p><p>关于写青词的严嵩搞掉了正值的夏言，忍耐力超强的徐阶搞掉了老奸巨猾的严嵩，心狠手辣的高拱搞掉了徐阶，而张居正又搞掉了高拱。</p><p>这是各机关、企业学习政治斗争的最好案例啊。</p></blockquote><h2 id="什么是社会公平"><a href="#什么是社会公平" class="headerlink" title="什么是社会公平"></a>什么是社会公平</h2><p>古今中外，任何一次武装革命，无论最终成功还是失败，上位者因为野心的极度膨胀，都变得更加专制。陈胜、李自成、朱元璋、罗伯斯皮尔、斯大林、 ，都是一个个鲜活的例子。</p><p>真正公平的社会并不是均贫富、等贵贱的乌托邦，也不是贵族享有领地少女初夜权的强权社会，而是法制社会，大家在一个完善的法律制度下，享有人身和财产自由，知道什么该做什么不该做，法典之下对于任何人都是平等的，无论是平民还是权贵。</p><p>作为爱好和平，小富即安的我等小民，最愿意看到的是社会的稳定而不是动乱。</p><h2 id="还是有很多有钱人"><a href="#还是有很多有钱人" class="headerlink" title="还是有很多有钱人"></a>还是有很多有钱人</h2><p>说起空空们们不买房是因为没钱，我还真不相信。</p><p>在某二线城市，调控重拳刚出的时候，我赶紧去买房，碰见一个大姐。</p><p>那个大姐很有意思，说从08年底看房，一直觉得房价高，所以坚决不买，结果等到了2010年，一直盼着降，但是调控政策刚一出就心慌了，害怕后面是大暴涨，赶紧把房买了，这位大姐买房是一次性付款。到现在房价涨了30%。</p><h2 id="双轨制之体制内的福利"><a href="#双轨制之体制内的福利" class="headerlink" title="双轨制之体制内的福利"></a>双轨制之体制内的福利</h2><blockquote><p><strong>汝爱之罪：</strong></p><p>水木社区上有很多愤青打电话给北京建委，举报领秀慧谷捂盘内购的事，我跟了个贴子说不要太幼稚，结果被骂的很惨。今天他们接到建委电话了，说是没有违规。我在想：有这些不明真相的群众存在，房价怎么会跌呢？通胀怎么会停呢？股市IPO怎么会停呢？底层不被收割就奇怪了</p><p><strong>kkndme：</strong></p><p>让北京建委去查国资委就比较搞笑。北京的房优先安置各大部委，剩余很少的部分才用于商品房开发，所以才说北京四环房价5万一平都不算贵。</p></blockquote><h2 id="开发商思维"><a href="#开发商思维" class="headerlink" title="开发商思维"></a>开发商思维</h2><blockquote><p><strong>鼻使豆豆：</strong></p><p>高房价不可怕，可怕的是没有辩别是非的能力，明明是老百姓，却有开发商的意识，可悲</p><p><strong>kkndme：</strong></p><p>其实这个道理是很浅显的，你不买房并不能代表房价不涨，而你买了房不但可以住的舒适，还可以获利。反而是有开发商的思维才能有好日子过。</p><p>这个道理跟炒股票是相同的。大家知道，股票与房地产不同，并不能创造财富，只是财富再分配的工具，但是财富再分配，是庄家分配散户的钱，而不是散户分配庄家的钱。所以炒股要有庄家的思维才能挣钱。</p><p>道理都是一样的。</p></blockquote><h2 id="农民政权的缺点"><a href="#农民政权的缺点" class="headerlink" title="农民政权的缺点"></a>农民政权的缺点</h2><blockquote><p><strong>tianxiaobing11：</strong></p><p>请问楼主，为什么历史上的农民起义军领袖，一旦得势后比原来的统治阶级还残暴呢？像黄巢，张献忠等等</p><p><strong>kkndme：</strong></p><p>是因为缺乏一个纲领。</p><p>农民伯伯因为没饭吃拿起武器造反了，造反之后怎么办？——对不起，从来没想过。国家治理到底是怎么回事？——对不起，一概不懂。</p><p>比如陈胜，刚占了一块地盘就不知道姓什么了，老子天下第一，农民暴富后，就想拼命享受，自己的属下和革命战友在自己眼中就是一坨屎，就更别说老百姓了。武装还没胜利呢，就生怕别人夺权，大搞内部政治斗争。吴广挂掉最高兴的就是陈胜。太平天国表现的更是淋漓尽致。</p><p>朱元璋就不同，是个军事天才和政治天才，懂得治国之道，有做皇帝的野心，也懂得当皇帝需要的知识，朱清楚的知道靠均贫富等贵贱是不能坐天下的。</p><p>古代能够夺取天下的，基本都是贵族阶层，有野心有理想有知识。最典型的就是李世民。汉高祖刘邦同样不是单纯的流氓无产者，他幸运的娶了吕雉，一跃成为地主家族的一员。</p><p>历史上只有朱元璋是个异数。这也是毛为什么要推崇朱的原因。</p></blockquote><h2 id="郑州有前景"><a href="#郑州有前景" class="headerlink" title="郑州有前景"></a>郑州有前景</h2><blockquote><p><strong>larryzs：</strong></p><p>最喜欢看楼主评说历史了</p><p>呵呵，看来历史要重新好好读一下了</p><p>不知道楼主对河南郑州的房价了解吗？</p><p>希望楼主对郑州将来的发展分析一下。</p><p>现在郑州的房价均价也差不多快到6000了，郑东新区的一万以上。</p><p>市政府也在大力修建地铁，个人认为还是有发展前景的。</p><p><strong>kkndme：</strong></p><p>郑州的交通区位决定了经济发展的空间，同意你的说法，很有前景</p></blockquote><h2 id="公园地产是稀缺资源"><a href="#公园地产是稀缺资源" class="headerlink" title="公园地产是稀缺资源"></a>公园地产是稀缺资源</h2><blockquote><p><strong>klid：</strong></p><p>LZ，省会城市二环边公园边房产和市中心无天然气房产，选择哪个比较好？</p><p><strong>kkndme：</strong></p><p>公园地产未来是稀缺资源，市中心虽好，但是没有天然气毕竟不方便。两者相较还是公园边合适。</p></blockquote><h2 id="张献忠屠川"><a href="#张献忠屠川" class="headerlink" title="张献忠屠川"></a>张献忠屠川</h2><p>关于张献忠屠四川，尽管学术上存在争议，但大致是不差的，虽不见于正史，但《蜀碧》及《求幸福斋随笔》都有记录。很多学者也做了大量的考证。</p><p>张献忠此人曾经读过书，做过zf最基层公务员——捕快，但是被开除了。人格比较扭曲，不但好色，且好杀成性，是典型的流氓无产者。大明的苦难子民指望这样的有严重心理疾病的杀人狂拯救，那是毫无指望的。</p><p>张献忠每攻城略地特别喜欢把当地的妇女同志送进军营当营妓，并且乐此不疲，军队没粮了，就把美丽的少女切成块做成腊肉。把儿童成群的围起来用火烧，谁往外跑就用刀刺，也是张大义军领袖最喜欢的游戏。</p><p>对于张的行为，我们只能用有严重的心理疾病来解释。</p><p>一个仇视社会的愤青，掌握了军队，破坏力是相当可怕的，是人民的灾难。</p><p>张攻陷四川建立大西国政权，与柬埔寨的红色高棉政权简直是异曲同工。以至于清军进入四川受到了百姓的欢迎而不是抵抗。这跟越南入侵柬埔寨，越南军受到了柬埔寨人民的欢迎是多么相似啊。</p><p>人民的眼睛是雪亮的，违反人性的，即使打着爱国的旗号，也终将被人民抛弃。</p><h2 id="洪秀全、黄巢、李自成"><a href="#洪秀全、黄巢、李自成" class="headerlink" title="洪秀全、黄巢、李自成"></a>洪秀全、黄巢、李自成</h2><p>洪秀全同志，人生比较悲剧，人家好歹是个落地秀才。洪教主考了20多年，连个秀才都没考上，相当于小学都没毕业。</p><p>洪教主考试不行，搞邪教确是个高手，夜里做梦居然梦见上帝（形象大概是个白胡子老道）说洪教主是他的二儿子。这个梦确实不太靠谱。很可能是洪教主有意编的。</p><p>洪教主的拜上帝教应该算是白莲教的一支或者说是余孽。</p><p>洪教主搞革命，对解放劳苦大众却一点不感冒，最感兴趣的是一夫多妻制，娶了88个后妃。好像历史上的农民军领袖对妇女同志都有出奇好感，大概是小时候性压抑的结果。</p><p>太平天国攻下南京得了半壁江山，洪教主从41岁开始，直到11年后自杀，竟然没出南京城一步。大概是收罗的漂亮的妇女同志太多了，实在没有时间干别的。</p><p>比起张大义军领袖的变态，洪教主还是比较有人性。好色，人之天性。</p><p>不过洪教主进南京，并没有因为女性的爱情滋润，而让他变得温柔。虽然没有张大领袖变态，实行的也是三光政策：杀光、烧光、抢光。</p><p>“凡掳之人，每视其人之手，如掌心红润，十指无重茧者，恒指为妖，或一见即杀，或问答后杀，或不胜刑掠自承为妖杀，或竞捶楚以死。”大意是手上没长茧子的就是妖人，就要统统杀掉。</p><p>农民起义带来的不是均田地等贵贱的乌托邦，而是血腥恐怖</p><p>说起洪教主玩弄的美女确实让人流口水，除了88个妃子外，女官侍婢不计其数，算下来用了11年时间玩了2300名妇女。</p><p>有一本《江南春梦笔记》：王后娘娘下辖爱娘、嬉娘、妙女、姣女等16个名位共208人；24个王妃名下辖姹女、元女等七个名位共960人，两者共计1169人。以上都属嫔妃，都是要和洪秀全同床共枕的。天王府不设太监，所以另外还有许多服役的“女官”。以二品掌率60人各辖女司20人计算，合计为1200人。各项人数加起来，总计有2300多名妇女在天王府陪侍洪秀全一个人。</p><p>一个农民当了教主，就有这样的眼福。换做了傻空当教主，会怎么做？</p><p>黄巢比洪教主学问要高一些，但是屡试不第，当了私盐贩子。</p><p>从起义的第一天开始，黄巢的脑子里也从来没有过百姓该如何如何的。</p><p>他是一个彻头彻尾的投机分子，说是义军，不如说是强盗。</p><p>新唐书中说，贼军所过州县，老百姓皆烧杀殆尽。黄巢的兵可并不懂三大纪律八项注意，那是能抢救抢，抢不了就烧就杀。</p><p>无论是旧唐书、新唐书、还是资治通鉴，从头到尾，就没有出现过黄巢的一句好话。</p><p>黄巢攻陷广州，至少屠杀了十二万人，把皇帝气晕了。</p><p>皇帝还知道体恤子民呢，而黄巢就是彻头彻尾的强盗外加杀人犯。</p><p>黄巢攻进长安当了天子，充分显现了流氓无产者的本质，穷奢极欲，挥霍无度，治理国家的事彷佛就跟他没有一点关系。不搞建设就只能做吃山空，结果长安的粮食都被糟蹋完了。</p><p>长安没有余粮，黄巢就把长安老百姓抓来，煮着吃，十万大军靠吃老百姓过日子。</p><p>幸好老天开眼，官军打进了长安，结果是老百姓对官军夹道欢迎。 农民军真是义军吗？</p><p>不但中国的农民军领袖都是杀人魔鬼的化身，就是法国资产阶级大革命领袖罗伯斯皮尔，同样也是法西斯暴政的先驱者。最后被人民送上了断头台。</p><p>只有一个真正的法制化国家，人民在法律的制约下，享有人身与财产自由，才能够安居乐业。</p><p>李自成在军队纪律上，是要比张献忠高明一点的，所以李自成打进了北京。李自成到北京后，拷贝了黄巢进长安的淫乐经验，对美女极尽淫乱之能事，对百姓烧杀抢劫做的也很出色。</p><p>历代农民军对妇女的态度与《水浒传》中梁山好汉完全相反。</p><p>施耐庵笔下的梁山好汉们似乎对妇女有天生的仇视，动不动就把女同志劈死，李逵甚至终生不尽女色，就凭这一点，我们只能说梁山好汉是农民军中的异类。</p><p>但是梁山好汉不是为了起义，而是为了招安。一群由小公务员和渔民组成的社会最底层群众梦想通过拉山头再跳槽的方式走进金字塔的中层，但是这个梦想破灭了。</p><p>古代历史上，能够治理天下的穷苦人，只有一个：朱元璋。</p><h2 id="朱元璋"><a href="#朱元璋" class="headerlink" title="朱元璋"></a>朱元璋</h2><p>为什么朱元璋可以，而别人不可以。</p><p>经过仔细研究发现，朱元璋的人生际遇不像黄巢、张献忠和李自成，他有点像刘邦，但又有很大区别。</p><p>朱元璋是一个到处要饭吃的和尚，但是喜欢思考，见世面，交朋友，并且找到了自己的宗教信仰——明教（也叫摩尼教、白莲教）。</p><p>朱元璋走投无路投奔起义军的时候，娶了起义军濠州大帅郭子兴的义女当老婆，就是那个著名的马皇后。郭子兴并不是一个农民，而是一个大地主，所以朱元璋加入的这个新家族，思想完全不同一个扛着扁担造反的农民。</p><p>郭子兴作为农民军的统帅，却在逛街的路上，被其他的农民军兄弟（真正的农民）绑了票，大概是因为农民对地主阶级比较仇恨。最后被朱元璋救了出来。</p><p>郭子兴看见朱元璋比自己强，反而起了憎恨之心，一心想把朱元璋弄死。</p><p>朱元璋在丰富的人生经历中看到了农民起义军领袖们的鼠目寸光，要想成大事，必须有远大的理想和抱负，而这些是黄巢、张献忠、李自成、洪秀全都没有的。</p><p>朱元璋与那些个农民军领袖最大的不同在于，他熟读历史，因此他把汉高祖刘邦作为榜样。目标是建立一个基业长青的强大统一的国家。</p><p>朱元璋就懂得无论是得到天下，还是治理天下，就必须有能力的人来辅佐。嫉贤妒能的人只能被历史的车轮碾碎。</p><h2 id="曹参治国"><a href="#曹参治国" class="headerlink" title="曹参治国"></a>曹参治国</h2><p>人们最希望的，就是在一个良好的社会环境下，安居乐业，自食其力。zf的职责就是健全法制，维护一个良好的环境，剩下的事，交给民间去做。三天两头出政策，过度插手百姓如何过日子，甚至朝令夕改，就会让百姓的正常生产生活无所适从。 早在汉朝初期，曹参已经参悟了这个道理。 曹参是刘邦当亭长时的领导，也是刘邦最亲密的战友。萧何是文官，曹参则是武将，曾经在韩信麾下效力，除了披坚执锐外，最重要的工作就是监视韩信，防止韩大军事家谋反。 这样一个万夫难敌的勇将，却在革命胜利后被分配给齐王刘肥（刘邦的私生子）当相国，主抓齐国的政务。</p><p>曹参是一介武夫，只懂得军事，并不懂治理地方，就用厚礼聘请了精通黄老之术的盖公。盖公认为：治理国家很简单，只要按照律法办事，给老百姓提供一个安全的稳定的环境，其他的都不用管，官府千万不要好大喜功，追求政绩，过多插手百姓的事物，顺其自然就好了。 曹参很赏识盖公，并且按照盖公的话去做，九年的时间，齐国变得非常繁荣。 这时候，传来噩耗，萧何挂了，皇帝刘盈聘请曹参出任相国。曹参上任以后，几乎罢免了所有办事效率高、口才好，有追求有抱负的能吏，提拔了一群只知道按部就班，照章办事的老实巴交的官员，然后就彻底大松心，成天喝酒吃肉听小曲。</p><p>很多人对曹参不满就给皇帝刘盈打小报告，刘盈的表现是很愤怒。 曹参就问刘盈：是陛下你牛呢，还是先皇刘邦牛呢？ 刘盈：当然是先皇牛 曹参又问：那我跟萧何比，谁牛呢？ 刘盈愤怒的说：你比萧何差远了。 曹参做了个总结：您讲的太对了，先皇和萧相国拟定的法令已经非常清楚了，只要贯彻执行下去就好，我只要按照他们的法令办，不就行了吗？ 刘盈虽然不事朝政，但应该算是比较聪明的君主，一听就懂：对于已经定下的治国方针大略，只要执行下去，一定会使人民休养生息，国家富足。如果大搞政绩工程，对于先皇刚死，吕后掌权时期风雨飘摇的大汉来说，将是灾难性的。 民间把成天喝酒吃肉听小曲的曹参称为贤相。司马迁在史记中也给了曹参极高的评价。</p><p>假设一个工程队要盖楼房，起初设计人员设计了20层，刚盖了两层，队长换人了，非要盖成30层，工人于是绞尽脑汁费劲办法改造。等盖到25层的时候，又换队长了，新队长说还是改成两层的别墅吧。刚把楼房都拆掉，别墅建了一半，又来了一个队长，说要建成比迪拜塔还高的大塔楼。这个楼建了n年也没建起来。 建房子跟治国的道理是一样的，我国汉代的相国曹参就已经明白了这个道理。</p><h2 id="晁错"><a href="#晁错" class="headerlink" title="晁错"></a>晁错</h2><p>刚才有人提到吴楚七国之乱，讲得是晁错。晁错其人是很值得讲讲的，一个有才能的人在错误的时间做了一个理论上正确的事，却导致吴楚七国之乱，汉景帝差点完蛋。结果是景帝砍了晁错的脑袋。</p><p>这个故事，几乎家喻户晓，蕴藏的道理却很深，大家如果懒得看史料，有兴趣可以参看易中天“帝国的惆怅”，还是很值得一看的</p><h2 id="民营小企业的老板和打工者"><a href="#民营小企业的老板和打工者" class="headerlink" title="民营小企业的老板和打工者"></a>民营小企业的老板和打工者</h2><p>糊涂人即使把道理说的再浅显，他也听不明白，呵呵。 现在我国已经进入高通胀期，但是地方巨额债务与人民币的升值又封杀了加息的空间，经济形式有可能恶化，民营小企业的老板和打工者只能自求多福了。</p><blockquote><p><strong>汝爱之罪：</strong></p><p>刚查了一下央行的数据，8月份的M2是68.75万亿，我没记错的话，7月份的M2控制的很好，基本没怎么涨，但是到了8月份，没想到有那么猛的涨幅，看来不到12月，我国的M2就要到70万亿了。2007年1月份，我国的货币供应量是35万亿。</p><p>今早去小摊买早点，原来一块五的加鸡蛋灌饼现在卖两块。如果涨工资，只会把通胀越推越高，如果不涨工资，P民就要忍受通胀的剥削。真是无语了</p></blockquote><h2 id="郭解"><a href="#郭解" class="headerlink" title="郭解"></a>郭解</h2><p>从古到今，小老百姓遇到不公，受了委屈，幻想最多的就是跳出一个大侠，劫富济贫，为自己伸张正义。所以金庸的小说广为流传，被称为成年人的童话。 我国古代，真有大侠，不过古代的大侠并不是会降龙十八掌的郭靖，也不是小李飞刀，而是黑帮的老大，相当于西方的教父。 最有名的大侠叫郭解，汉朝时有极高的威望，不然也不会写进史记。 郭解的爸爸是个职业杀手，非常有名，用古龙的话说，最厉害的杀手是没有名字的，郭解的老爸名声太大，注定活不长。有个米商请郭解的老爸到监狱里救出犯了法的儿子，郭老爸看在钱的份上去了，就再也没能回来。</p><p>郭解跟他老爸学过功夫，很有两下子，于是干起了抢劫和盗墓的这份很有前途的职业。因为功夫高，谁只要说句话让他不爱听，必然遭遇一顿暴打。本着流氓会武术谁也挡不住的精神，到了三十岁，郭解已经钱多的数不过来了。男怕入错行，女怕嫁错郎，看来抢劫和盗墓的职业选择对了。 30岁以后，郭解为了从强盗升级为教父，开始积累自己的名声，并且学习战国四公子，开始蓄养门客，但凡是哪个人有难，有求必应。俨然形成了一个严密的黑社会组织。在民间的声望，甚至超过了皇帝。 皇帝的权威是不容冒犯的，一个地方黑社会头子怎么能够这么嚣张呢？就把郭解抓了起来，虽然有大量的证据证明郭解作奸犯科草菅人命，但都是汉武帝大赦前的事情，没有办法定罪。汉武帝一筹莫展，人抓了不能定罪，又不能放掉，该怎么办呢？ 这时，正好有个书生，骂郭解不遵纪守法。正巧被郭解的门客听到了，就把那个书生给杀了。 汉武帝听了哈哈大笑，正巧找这个理由把郭解灭族。 侠客的黄金时代，从此结束</p><p>剑侠情侣，快意江湖，听着是一个充满了浪漫的世界，而事实是完全不可取，一个没有法制的社会，奉行者赤裸裸的丛林法则，什么是对？什么又是错？理由就永远站在强者一边，强者可以随自己的意愿决定弱者的生死。 这个社会是可怕的。 郭解，就让他永远埋葬吧</p><h2 id="2010年的中国房地产"><a href="#2010年的中国房地产" class="headerlink" title="2010年的中国房地产"></a>2010年的中国房地产</h2><blockquote><p><strong>汝爱之罪：</strong></p><p>今天跟家里人打电话，姨妈说了下近一年来老家云南东北方向一个地级市曲靖的变化。</p><p>主要就是：好些有资金的外地大佬大手笔拿地，开发酒店和商品房。都是市区的黄金地段。</p><p>其实房地产开发在中国的任何一个城市每天都在发生，不过令人感慨的是这样的“四线”城市也如此火爆，购买力之强令人感慨，她说最近几天曲靖正在举行房交会，人头攒动。 现在老百姓有钱都向往好的房子和户型了，已经不满足90年代的老旧房子了，而且通货膨胀也逼得大家不得不置业保值。</p><p>再回头看看北京，简直找不到跌的理由。那么多地铁要修，那么多优质生源每年涌向北京高校，那么多人口，每天要造就那么多富人。。。。</p><p><strong>kkndme：</strong></p><p>钱太多了，流动性泛滥，老百姓恐慌了。这次调控暂时抑制了一线城市房价的上涨势头，但是却直接导致了全国性房价的上涨，不光二三线城市，连四级以下城市都是如此。这就是领导水平。</p></blockquote><h2 id="房奴算不上不幸，相当当不了才算"><a href="#房奴算不上不幸，相当当不了才算" class="headerlink" title="房奴算不上不幸，相当当不了才算"></a>房奴算不上不幸，相当当不了才算</h2><p><strong>lanyu1121：</strong></p><p>普通老百姓都成房奴了。</p><p><strong>kkndme：</strong></p><p>成为房奴还算不上不幸，相当房奴当不了才不幸</p><h2 id="精英人群的平均收入决定房价"><a href="#精英人群的平均收入决定房价" class="headerlink" title="精英人群的平均收入决定房价"></a>精英人群的平均收入决定房价</h2><blockquote><p><strong>skysurfer2208：</strong></p><p>想请教一下楼主，对于很多的二线城市，比如武汉，市区房子的均价一万左右了，但当地的平均收入一般也就3000左右吧，难倒你不认为现在的房价里面有泡沫吗？特别是现在正处在调控期，对于我们这些近年打算买房的来说，是在等等看呢还是在在这个时期出手？多谢楼主</p><p><strong>kkndme：</strong></p><p>你所说的平均收入是什么概念？是人人都挣3000块，还是有人挣2000块，有人挣1万块。武汉的房价，要看湖北省包括各地市的人口，家庭收入上万的人有多少，如果你认为很少，几乎没有，那房价肯定存在泡沫。如果湖北省有20%的人口家庭月收入超过万元，那么武汉市区的房价就没有泡沫。</p></blockquote><h2 id="内地不是香港、海南"><a href="#内地不是香港、海南" class="headerlink" title="内地不是香港、海南"></a>内地不是香港、海南</h2><blockquote><p><strong>johny__：</strong></p><p>那香港97年的时候还不是一样跌了一大截，按LZ的说法，1）土地资源很稀缺；2）作为消费群体的白领收入也能买房；3）作为世界城市，更是汇聚了世界级精英的购买力，仿佛现在上海。最后，不是一样大跌？？中产都成了负资产了。就连林百欣的儿子林建岳97年以69亿港元高价购入中环富丽华，还不是赔得一塌糊涂。</p><p>楼价涨高了就要跌，哪都不例外，这个才是规律。什么通涨，精英购买力决定房价，都是涨了之后在找理由。</p><p><strong>kkndme：</strong></p><p>这就是体制上的不同啊，所以我们无法重复香港和日本。97年的金融风暴，还是中国以国家之力对抗索罗斯的量子基金，保住了香港，这种行为在西方国家是难以想象的。一个国家动用全国人民的外汇储备与美国的民间资本打一场战争，这是令全世界震惊的。索罗斯因为不了解中国的体制，悻悻而归。</p><p>人民币不能在世界流通，依照我国实行的货币制度，货币只不过是一种符号。如果有一天我们的人民币能够自由兑换，香港发生的事也一定会发生在我们身上，但你认为我们的人民币能够自由兑换吗？</p><p><strong>johny__：</strong></p><p>那92年的海南崩盘有从何说起？从7000多掉到了几百元，这难道是海南体制？发币行是海南银行？同样是国内，同样的外汇管理制度，不是日本也不是香港，是中国海南。</p><p>–据《中国房地产市场年鉴（1996）》统计，1988年，海南商品房平均价格为1350元/平方米，1991年为1400元/平方米，1992年猛涨至5000元/平方米，1993年达到7500元/平方米的顶峰。短短三年，增长超过4倍。</p><p>–海峡对岸的北海，沉淀资金甚至高达200亿元，烂尾楼面积超过了三亚，被称为中国的“泡沫经济博物馆”。</p><p>[经验交流]92年海南房地产泡沫始自于“击鼓传花”(转载) <a href="http://www.tianya.cn/publicforum/content/house/1/163988.shtml">http://www.tianya.cn/publicforum/content/house/1/163988.shtml</a></p><p><strong>kkndme：</strong></p><p>全国的资金去炒海南、北海，炒的纯粹是概念，没有实体的支撑，就是一种博傻游戏。今年年初海南房地产的爆炒，同样积聚了巨大的风险。买房并不是全无风险，好比通州、燕郊，经历疯狂的炒作一定会理性的回归。但是如果指望北京四环内房价下跌，也只是痴心妄想。</p><p>房产投资也不是随便买套房就只涨不跌，比如说山东乳山的房子，开发商疯狂炒作旅游地产概念，但如果真的想投资升值，那就成了天大的笑话，因为根本无法变现。</p><p>什么样的房产适合投资，投资者不是傻子，都会有理性的判断。</p><p>90年代初的强硬调控让海南和北海的经济崩盘，对全国来说不可怕，毕竟只是一隅之地，但是如果用粗暴手段搞崩了全国，zf一定会好好掂量的。</p></blockquote><h2 id="历史是一面镜子"><a href="#历史是一面镜子" class="headerlink" title="历史是一面镜子"></a>历史是一面镜子</h2><p>如果以为本帖讲的历史故事，那就完全理解错了。</p><p>本帖讲得不是历史，而是总结前人的经验，讲得是故事背后的道理。 如果毛不是熟读历史，也不可能取得胜利。毛在进京的时候，说过一句话：我们不学李自成。</p><p>只有认真总结过李自成失败的教训，才能够做出正确的选择。</p><h2 id="买房一次性到位比较好"><a href="#买房一次性到位比较好" class="headerlink" title="买房一次性到位比较好"></a>买房一次性到位比较好</h2><blockquote><p><strong>包容会通：</strong></p><p>我老婆是长春人,岳父母退休,都有退休金.我和我老婆现在都在国外,准备3年以后回长春工作,我们现在有40万的现金,放在银行也没什么用,也担心3年以后,长春的房价还要涨.</p><p>因此,现在准备用其中的20万作首付买套70平的小户型的,让岳父母住(岳父母有住房,但很快就要拆迁了).等3年以后回长春,把这套小的卖了换成大的.不知这样的计划是否可行?贷款如何弄? 　　　　　　　　 谢谢兄弟.</p><p><strong>kkndme：</strong></p><p>既然是自住型需求，何不买套大点的，70平（建筑面积）的房子无论是自住、父母住还是合住，都比较拥挤。既然有40万的闲钱，还是一次到位比较好，3年后长春的房价一定要比现在高的多。</p><p>只是贷款比较麻烦，你的父母是无法贷款的，除非你们夫妻能够回国，这种事用别人的名字办肯定是不行的，房价上涨后就有可能会陷入扯皮甚至打官司的境地。</p></blockquote><h2 id="外汇管制"><a href="#外汇管制" class="headerlink" title="外汇管制"></a>外汇管制</h2><blockquote><p><strong>tianxiaobing11：</strong></p><p>楼主，这个tj连人民币不能自由兑换都不知道，可见他的水平也太差了，就不用和他计较了，从上个月开始人民币换美圆好象收紧了，是怕民众把人民币换美圆出逃吗？</p><p><strong>kkndme：</strong></p><p>外汇外流趋势比较严重，zf开始严管，包括携带50美元以上商品入境必须征税等措施，都是限制外汇外流。富人从穷人身上赚了钱，换成美元在国外消费，这是zf不愿意看到的，zf不在意富人搜刮穷人，但肉一定要烂在锅里</p></blockquote><h2 id="一线和二线"><a href="#一线和二线" class="headerlink" title="一线和二线"></a>一线和二线</h2><blockquote><p><strong>yamazaki28：</strong></p><p>楼主好，小弟有问题请教，本人所在二线省会城市，存款40w,近来看中本市CBD区域高端住住宅一套，各方面条件十分优越，面积100左右，均价18000。但通过观察，又看中觉得北京五环附近的待建地铁房，均价16000，想贷款弄小户型60左右，不知哪个升值潜力大，本人已有房一套。谢楼主指点。</p><p><strong>kkndme：</strong></p><p>短期来看，二三线城市的房产升值速度要高于北京，这是这次调控造成的结果，从长期来看，北京房产的升值速度要高于二三线城市。五环附近地铁房，还是很有优势的。</p></blockquote><h2 id="吕后篡权"><a href="#吕后篡权" class="headerlink" title="吕后篡权"></a>吕后篡权</h2><p>大凡是60年代末，70年代初生人，小时候肯定看过一本小人书：吕后篡权。 在那个时代推出这本书，很有寓意，起到了很好的宣传效果。 吕后真的是十恶不赦的妖妇吗？让我们还原历史的真相。 我们读到的吕雉，通常的形象是蛇蝎心肠的女强人。 大家感兴趣的，首先是关于吕雉在项羽大营和审食其是否有一腿。 然后看到的是吕雉协助刘邦诛杀异性王、与倾国倾城的戚夫人争宠、帮助儿子刘盈与戚夫人的儿子刘如意争夺太子、杀害戚夫人和刘如意、提拔吕氏家族成员。 但是因为宣传的需要，几乎所有人都忽略了吕雉的另一面</p><p>刘邦见上帝以后，吕雉掌权期间，对待老百姓还是很够意思的。 俗话说嫁出的女就是泼出去的水。吕雉可不同，吕雉非常照顾自己的娘家人，想把自己的娘家人都提拔起来。 秦始皇把分封制改成郡县制，搞天下大一统，意识比较超前，结果政权不稳定，秦朝很短时间就完蛋了。高祖刘邦吸取了这个教训，仍然搞分封制，不过分封制做了重大的改革:首先是分封的诸侯王必须是皇族，也就是说必须姓刘。其次是从中央派丞相给诸侯王，丞相掌握诸侯国的军政大权，防止生变。 吕雉提拔娘家干部最大的障碍就是：高祖说过，诸侯王只能姓刘。</p><p>吕雉是一个极其精明的女人，她追尊自己的老爹吕公为宣王，吕公是刘邦的老岳父，追尊皇帝的老岳父，旁人自不能有异议。既然有了先例，剩下的事就好办了，吕雉趁机把自己吕姓家族的成员封为吕王。 吕王吕嘉这个人很嚣张，仗着外戚的身份，飞扬跋扈，不尊法纪。 吕雉是一个出色的国家领导人，不是黄巢李自成之类的强盗流民，是很关心民生的，所以很生气，把吕嘉给废了，让吕嘉的叔叔吕产当吕王。 吕雉掌权后，做了很多亲民的好事，减免老百姓的税赋，加强建设健康的人民文化娱乐，最受百姓欢迎的是废除了“三族罪”和“妖言令”。 三族罪的意思很直白，就是一人犯罪株连三族。 妖言令有点象后来的文字狱，哪里出现统治者认为的妖言，就把那个地方的所有百姓全部处死。这是一个伟大的历史进步。 吕雉还是女权运动的先驱者，在吕雉时代，女子也可以封官封侯，可以随意离婚再嫁。那个时代是中国古代史上，女人最幸福的时代之一。 吕雉，一个柔弱的女子，在残酷的宫廷政治斗争中表现的异常凶狠，然而权力的斗争本身就是你死我活，在治国方面，吕雉却无愧于一个贤明的统治者，可谓巾帼不让须眉。吕雉与后来的老佛爷完全就不是一个等级，毫无可比性。 吕雉执掌朝政十五年，直到病死后，吕氏家族才土崩瓦解。 还原真实的历史，我们不应该对这位叱诧风云的女政治家，致以深深的敬意吗？</p><h2 id="小产权房"><a href="#小产权房" class="headerlink" title="小产权房"></a>小产权房</h2><blockquote><p><strong>大水牛跟水牛仔：</strong></p><p>楼主,可以谈谈小产权房的看法吗?父母是珠海的原居民且拥有两套小产权房,无房产证只有村里所发的使用证,是村委会卖给原居民的,离市中心约半小时车程,近河边,而一路之隔的位置己建有大型高尚住宅小区,在售价一万二以上,请问这些小产权房可靠吗?听说往后政府对这些小产权房采取放宽政策,只需补一点钱就可改成商品房,你觉得有可能吗?</p><p><strong>kkndme：</strong></p><p>这个补点钱就改商品房的可能性不大，如果是大片的小产权房，拆的可能性也不大。这个问题很让zf头痛，城乡双轨制的结果，所以zf能拖就拖。</p><p>但是对于片区不大的小产权房，风险就很大</p><p><strong>大水牛跟水牛仔：</strong></p><p>谢谢楼主回复,父母手上的两套小产权房在同一小区,小区比较大,这类小区有好几个,由于村内将进行旧村改造,规划成高级住宅片区,那此类小产权房如遭迁拆的话会得到赔偿吗?</p><p><strong>kkndme：</strong></p><p>这个会比较扯皮，最坏的情况是按照原价退赔，最好的情况是回迁安置。如果原价退赔损失就很大。</p></blockquote><h2 id="商铺和住宅"><a href="#商铺和住宅" class="headerlink" title="商铺和住宅"></a>商铺和住宅</h2><blockquote><p><strong>deeplp：</strong></p><p>kkndme 兄，你好。</p><p>从这个帖子一开始就一只跟着，每天必看。受益良多。</p><p>你对广州感觉如何？请教一个问题，不知你对商铺是否有研究？你觉得眼下投资商铺好呢，还是继续投资房产。 本人已有2套房产，都在广州市区且近地铁但不带很好学位。现有如下两个想法，</p><ol><li>分散投资，投资一个商铺，目前看中一个广州北京路拐弯处二楼商铺一个，靠近地铁。</li><li>继续房产，买一个130以上大户型且带学位房，方便以后小孩读书。（计划明年要小孩，现在就做打算是怕以后买不起阿。） 麻烦兄台给些意见。十分感谢。</li></ol><p><strong>kkndme：</strong></p><p>找到合适的商铺是很难的，因为商铺投资风险大，所以非常考验个人的眼光，属于高风险高回报，找对了，将财源滚滚，找错了很可能血本无归。 如果你有眼光，首选商铺。如果不具备这方面的能力投资住宅比较保险。</p></blockquote><h2 id="体制内外"><a href="#体制内外" class="headerlink" title="体制内外"></a>体制内外</h2><blockquote><p><strong>tuzi1976：</strong></p><p>kkndme兄，你好。上周提了几个问题，可能你没看到，再请教一次，请抽空指点一二。 看到楼主说过“人民币对外是升值，对内贬值”，我认识到“人民币对外是升值，对内贬值”这一点也有一年多了吧，主要是从生活经历、经济新闻中得到的结论（本人学工科、不懂经济）。虽然看到了表面现象，但对其发生的根本原因、对群众生活的深刻影响、“中产阶级（勉强算是有这么个阶级）”的应对之策等等尚没有深刻的认识。楼主看到我提的这些问题恐怕也觉得范围太大、难以回答？难道体制外的“中产阶级”只有任人宰割、移民海外、钻营往上爬这几个选择？诚心求教，风险自担（呵呵，楼主也不是神仙）</p><p><strong>kkndme：</strong></p><p>普天之下莫非王土，决定了今天的土地国有 万般皆下品，也决定了以后知识分子的前途必须进入体制内。 不能考中进士的明清两代知识分子，即使经商发了大财，也一样让人看不起，不能光宗耀祖。今天的知识分子将面临同样的命运。 体制外，凭个人的本事和运气，自生自灭。</p></blockquote><h2 id="2010年的上海"><a href="#2010年的上海" class="headerlink" title="2010年的上海"></a>2010年的上海</h2><blockquote><p><strong>youme5845：</strong></p><p>看到LZ的帖子真是太及时了！因为要解决小孩子上学，我最近开始密集型的看房子.</p><p>感慨房价高的同时后悔没有早点考虑买房。头痛啊！！！</p><p>说说我们的情况：目前现金40W,家庭收入1W5,住上海，目前看的房子为周边世纪公园地铁10分钟老公房(新房很少)，81P 190W,地段很好，但房子都是95年左右的了。算下来除了首付家里帮助外每个月供5K还30年(扣除公积金还款),我们现在可以出手么？还是等十一新政策出来后买？</p><p>还是在交通稍微不便的地方买低价的房子？</p><p>请LZ给个意见~ 在线等~ 多谢！！！！</p><p><strong>kkndme：</strong></p><p>月供5k,收入1万5，说明的你的压力不大，完全可以承受。如果地段好，可以不考虑房子的新旧。一线城市的买房时机最不好拿捏，因为一线城市是调控的目标，你要仔细观察，如果发现中介的铺面里看房客越来越多，建议赶紧下手。</p><p><strong>youme5845：</strong></p><p>多谢！！！ 那我最近关注多一些！ 还有这块小区同时是学区房，是否可以买个100W出头的出租，然后自己租房住(我们长期租住房租很便宜 1700两室户)，这样即使以后出现金融危机等情况也不会担太大风险，是这样么？</p><p><strong>kkndme：</strong></p><p>对自己好一点的就会自己住，对钱看的比较重，可以买房出租，自己租便宜的。因人的性格而已。 不过人生苦短，在短短的有生之年，还是要对自己好一点。自己买的房子住起来跟租房子的感觉是完全不同的。</p></blockquote><h2 id="收紧住房贷款"><a href="#收紧住房贷款" class="headerlink" title="收紧住房贷款"></a>收紧住房贷款</h2><blockquote><p><strong>welldayzwb：</strong></p><p>顶楼主，越读越觉得受益良多 楼主分析一下，最近几年一线城市是否会一直收紧贷款，想改善住房是否也得必须全款了？一想起这个就很郁闷，去年机会没利用好，后面不仅仅是经济成本的问题了，又面临和无房空空类似的问题，攒钱永远赶不上房价了。。。</p><p><strong>kkndme：</strong></p><p>收紧住房贷款起码在未来的一段时间会成为常态。由于货币泛滥，一次性付款的人群数量庞大，收紧贷款虽然不能降低房价，但可以抑制房价上涨的速度，防止商品房卖给穷人，以规避金融风险，对社会稳定和经济平稳增长都是有利的。</p></blockquote><h2 id="买房：物业与房贷"><a href="#买房：物业与房贷" class="headerlink" title="买房：物业与房贷"></a>买房：物业与房贷</h2><blockquote><p><strong>fallenleafe：</strong></p><p>关注本贴多日，非常欣赏楼主的睿智和理性。 小女子也是上海众多买房人之一，目前所谓单身剩女，得家人支持有一百五十万的首付金。基本确定买在内环交通方便的次新房（老公房停车太成问题）。 对上海浦西内环内的诸多区位和楼盘做过研究，发现离地铁近的同时能有苏州河景观的房源最具性价比，满足交通性和景观稀缺性的双重优势（上海内环内几乎没什么安静同时又具有自然资源的地方）。 现在基本确定了两个小区，比较纠结的问题有两个。 第一个问题，一个是小区管理和区位优势明显单价在3万3左右，另一个区位和管理比较差，名声不好，但是面苏州河的独一无二景观，单价在3万左右。从小区管理的角度，我也认可楼主的看法，管理好的小区升值空间大，管理差的小区由于群租问题严重，目前价格偏低，但是这个软件问题在日后随着自住率的提高貌似也能解决。究竟我该选一个景观资源非常稀缺的管理和配套相对较差的小区，还是一个相对成熟价格稍高同时综合配套比较好的小区？那个小区比较有保值和投资优势？ 第二个问题，目前的月收入税后刚过万元，如果拿150万的首付买一房大概80平左右，是比较轻松的，月供不成问题（目前租的一室一厅租金3500，已经可以做为还贷资金了）。但是考虑长远问题和一些小户型的局限性，非常想投资一套能长久居住的两房甚至三房（众所周知，一个小区里好的位置总是留给最大的户型）。这样的话，大概一套就要在320万甚至350万，我需要每月还贷1万2左右，基本和我的月工资持平。从个人观点来看，我比较想冒这个风险，比较合适的做法是首付降低到3成左右，留出三十万左右的还贷资金用以应付前面两至三年的还贷。由于目前单身，两至三年后也许家庭收入就可以完全承受这个月供。即使还是单身，目前事业发展良好，对2年后的收入在2万以上很有信心，因此还是认为可以目前阶段多点勇气，目光长远，以保证日后生活安康。 不知道楼主怎么看这个问题？如果是房价持续上涨的情况，也许更该相信我的工资也会持续上涨，是否我看问题太乐观？贷款200万的风险是不是会太大？</p><p><strong>kkndme：</strong></p><p>第一个问题：物业管理对于小区的价值起着至关重要的作用，好的物业管理才能让人居住舒适，这一点是非常重要的。软件的提升往往比硬件的提升难度更大。物业很差的景观楼盘，可以比喻为鲜花丛中的一坨屎，周边环境再好，它也是一坨屎。一坨屎能否脱胎换骨变成黄金，存在着较大的不确定性。 第二个问题：是否承受较高月供，取决于你对未来的预期，所以你要仔细分析你的行业前途，如果你所处的行业告诉成长，或者你的能力职位将得到进一步提升，你可以承受较高的月供。 一般来说月供不要超过全部收入的70%，如果超过这个边际，就会有较大风险。</p></blockquote><h2 id="奸臣蔡京"><a href="#奸臣蔡京" class="headerlink" title="奸臣蔡京"></a>奸臣蔡京</h2><p>现代的纸币发行成本很低，拿着印钞机印就是了。古代就没那么好办，金银的开采量是有限的，别说金银，就是铸铜钱用的铜，也不是想要多少就有多少。</p><p>古代要想制造通货膨胀，最绝的办法就是拿一个铜钱当十个铜钱花，叫做当十大钱。搞当十大钱，扰乱货币秩序的领导，最有名的就是蔡京。</p><p>蔡京这个名字并不陌生，不爱读历史的人也一定看过水浒传。就是这个领导，被宋史称为六贼之首。大家一提起他，就自然把他跟奸臣划了等号，恨不得在他脸上踹几脚。</p><p>蔡京的确是个奸臣，但很多人可能不知道的是：蔡京是王安石的最得力干将，他的很多祸国殃民的政策，竟然是源于恢复王安石的变法。</p><p>王安石可以说是一个品德高尚的人，但是变法的流毒，竟直接导致了北宋的灭亡。王安石是一个在历史上有争议的任务，但是他的得力骨干蔡京同志，却是不折不扣的奸臣。</p><p>蔡京领导的罪恶，大家一致公认的就是那么几条 第一、花石纲，水浒传有精彩的描述，这个纯属于皇帝的个人爱好，似乎都推到蔡领导身上比较冤枉。 第二、大兴土木，大搞基础设施建设拉动内需，顺便搜刮点民财，以至于百姓怨愤 第三、恢复王安石时期的方田法，并且更改盐法茶法，国库和官员一起大肆搜刮民财，与民争利，结果租税混乱，富人把负担全部转嫁给穷人，穷苦百姓的负担更加沉重。 第四、就是当十大钱，制造通货膨胀，严重扰乱金融秩序和金融安全，北宋的经济崩溃了 蔡京，一个王安石变法的坚定执行者，最后成为祸国殃民的奸贼。</p><p>关于蔡京的奸臣形象，到了现在，有人企图为他翻案。但终究声音比较弱小。 因为在中国的古代，肆意敛财、大兴土木、搞官商垄断，与民争利，以至于人民不堪重负的领导，都被称为奸臣。对于减轻人民赋税，不胡乱插手民间生产和贸易，让人民修养生息的，被称为贤臣。 中国的古代，奸臣远远多于贤臣。</p><h2 id="体制内的28原则"><a href="#体制内的28原则" class="headerlink" title="体制内的28原则"></a>体制内的28原则</h2><blockquote><p><strong>facetowall：</strong></p><p>有人说，高校里20%的人掌握着80%的资源和财源，本人深有同感。所以经常想怎样才能成为20%里面的人。每天也很努力工作着，科研教学也可以，但是总看不到希望。</p><p><strong>kkndme：</strong></p><p>从一个小吏变成中高级干部，是需要深入研究中国古代政治斗争史的。否则就变成了宋江，企图另立山头通过跳槽达到目的，最终的结果只能是失败。宋江是一个政治上的白痴。</p><p>还有一个白痴叫贾谊，我们所熟知的“过秦论”的作者，才高八斗，政治却很白痴。被文帝做了棋子。如果贾谊同志知道晁错的下场，是无论如何不会仗着有才胡说八道，口无遮拦的</p></blockquote><h2 id="贾谊"><a href="#贾谊" class="headerlink" title="贾谊"></a>贾谊</h2><p>贾谊的粉墨登场，是有很深的政治大背景的。 首先要从吕雉死翘翘，以陈平、周勃为首的功臣集团铲出了吕氏一党说起。 吕氏一党灰飞烟灭，小皇帝是个吕雉制造出来的傀儡，甚至跟高祖刘邦都没有任何血缘关系。 难题是让谁当皇帝呢？ 于是中国历史上最为搞笑的一幕发生了，在高祖刘邦的子孙中要搞最弱外戚选举。</p><p>大概是被吕雉专权搞怕了，大家推举皇帝，专门看哪个皇子的外戚弱。于是众人的目光投向了刘邦的第四个儿子，代王刘恒。原因是刘恒的母亲薄氏出身低微，为人又很低调，堪当最弱外戚之名望。 提起薄氏，野史里记载的很香艳，很可以拍三级片</p><p>野史里说，楚汉争霸时期，高祖刘邦大败。 薄氏还是个姑娘的时候叫薄姬，逃难的时候占领了一个无人居住的民宅。忽然有一天看见一个浑身是血，穿着盔甲拿着兵器的男人闯进了自己的屋子，这个人就是刘邦。 薄姬听到后面有追兵，就把刘邦的盔甲和兵器藏了起来。然后放了一大桶洗澡水，把自己和刘邦脱光光，洗起了鸳鸯浴。追兵闯了进来，惊奇的看了一通三级片，然后走人。 这个只是野史，可信度不高，但是说明了薄氏的低微出身。</p><p>不管怎麽说，有着最弱外戚称号，并且做事很低调的刘恒当了皇帝。但是对于刘恒来说，陈平、周勃等功臣集团有着很高的声望，齐王刘襄是高祖长孙并且在铲除吕党是很有功劳，声望也很高，受到了很多人的支持，而刘恒却毫无功劳，因为功臣集团平衡关系，天上掉下了皇帝的帽子，砸在自己脑袋上。 所以刘恒必须提拔自己人，这个人不能有很高的功劳，也不能有结党的嫌疑，最好比较有本事能治理国家，于是大才子贾谊粉墨登场了</p><p>贾谊同志很有口才，一腔热血，要到现在来说最适合搞传销或者卖保险。 贾谊同志激愤起来甚至说：自己完全可以带兵打仗，灭了匈奴，把匈奴王象狗一样牵回来。”刘恒很贤德，但也很老谋深算，当然认为贾谊同志满嘴喷粪，所以一笑置之。 贾谊同志的胆子不是一般的大，向皇帝刘恒提供了一个深的帝心的建议：让所有的诸侯王滚回自己的封地。 为什么说这是深得帝心的建议？因为朝里功劳大的人太多，居功自傲，而自己却没有什么威望和功绩，如果功臣集团和齐王、淮南王联合起来造反怎么办？ 所以，最好的办法就是让诸侯王滚回封地。汉代的诸侯王可跟周朝不同，周朝的诸侯王是有实权的，有自己的军队。而汉代的诸侯王只能收收领地的税，军政事务全说了不算。 这个事，从贾谊嘴里说出来最好不过。</p><p>汉代的京城是最繁华的，有全国最好的教育、医疗、商业，有钱人的天堂，大臣们都可以花天酒地。让诸侯王回到封地，大家都不干了，回封地有什么好？房价又低，又没什么娱乐，漂亮姑娘也不好找，偏远的地方气候还不好，梅雨一来全身都要发霉。 首先带头反对的是功臣集团的领袖周勃（陈平已经死翘翘了）。在历朝历代，多数皇帝并不是想干什么就干什么的。既然所有大臣都反对，那就先暂且作罢。 但是贾谊，已经为刘恒种下了希望的种子，给自己埋下了祸根。 贾谊注定了只能是一颗棋子。</p><p>贾谊的建议没有被采纳，估计很郁闷，成天滔滔不绝的演讲，甚至建议刘恒削藩，要是贾谊知道晁错的下场，一定不敢这么建议。 这时候，贾谊已经得罪光了朝中几乎所有的大臣。于是大家的不满全部转移到贾谊的身上。 刘恒要的就是这个效果。</p><p>随着政权的逐渐稳固，刘恒把矛头指向了周勃。给予周勃最高的赏赐，却经常在治理国家方面，询问一些周勃不可能知道的问题。让周勃很尴尬。 周勃有个门客，就对周勃说：“皇帝经常给你很多赏赐，您就安心的接受，这很危险。皇帝给你的赏赐越多，说明皇帝对您越不放心啊。” 功高震主，弄不好会有杀身之祸，周勃不是傻子，立刻明白了这个道理。所以周勃才能称的上除曹参外，最有政治头脑的武将，最后得了善终。 于是周勃就上表辞职，表示年老体病干不动了。周勃还期望皇帝能挽留一下，但皇帝一点挽留的意思都没有，立刻同意了。 刘恒让周勃起个带头作用，回到自己的封地去吧。并且赐予了大把的金银。其他诸侯王看周勃都走了，也扛不住了，只好都回到了封地，这叫射人先射马，擒贼先擒王。 刘恒为了安抚大家，把遭人恨的贾谊明升暗降，贬到了长沙，从此离开了政治中心。 后来有一天，刘恒想起了贾谊，找他来中央谈话。贾谊一见皇帝立刻滔滔不绝，把皇帝立马侃晕了。 刘恒想：我靠，这厮死不悔改，留着没用，有多远滚多远吧。 再次把贾谊贬到了梁国。 贾谊不多久就死了。</p><p>关于魏豹和薄姬是否有一腿，也不好就肯定，也是个悬疑。因为记载薄姬的版本太多，我国古代人也比较八卦，呵呵。</p><h2 id="kkndme-推荐的历史书"><a href="#kkndme-推荐的历史书" class="headerlink" title="kkndme 推荐的历史书"></a>kkndme 推荐的历史书</h2><blockquote><p><strong>welldayzwb：</strong></p><p>这个帖子最大的感受就是应该认真读一下历史了，麻烦楼主给列个入门级的书单，鉴于我的历史水平只有演艺级的，书单请尽量入门级，当然演绎过的就免了，别读历史还别人顺带洗脑，比较郁闷了</p><p>先再次表示感谢！</p><p><strong>kkndme：</strong></p><p>比较浅显的是“史记”，入门级基本都读的懂。如果开始觉得部头太大，觉得累，刚开始可以从“古文观止”入门。逐渐增加难度。 入门以后，很多古文就好读了。 现代翻译的一般都加工的比较多，同一部历史可能有无数个解释。象易中天和当年明月，都是写的不错的。</p><p>关于古文观止，很多文章都曾被节选进中小学课本，篇篇堪称经典，其中就包括贾谊的“过秦论”。不看过秦论真的不知道贾谊的才华呀。所以想读读历史的童鞋，不妨回过头再温习温习古文观止，边品茶边看，真是一种享受。</p><p><strong>EchoMa9999：</strong></p><p>楼主晚上好！ 我看之前有跟贴的朋友提过，请楼主列个史书入门级的书单，我不求列了很多书的书单，只请楼主推荐三本，佛渡有缘人，楼主，望不吝赐书名，先谢了！</p><p><strong>kkndme：</strong></p><p>我觉得读史最基本的就是古文观止，读了古文观止，有了功底，再读其他的就好读了。 开始读的时候，通史类是很难看得进去的，象“资治通鉴类”的也不好读，因为“资治通鉴”应当算评史算不上史书。 入门开读的话还是选择文学性强的比较好读，故事性趣味性都高，比如“史记”“三国志”“汉书”。 有了兴趣再读大部头的“宋史”“明史” 现代编写的中国史纲之类的就不要读了，纯粹洗脑，很多加工过的历史类读物就是瞎扯。</p><p>特别是： 千万不要读“中国通史”那样的垃圾!!!!!!!!</p><p>一定要读懂原文，跟中国通史讲得完全不是一回事。读不懂原文宁可不读，也不要让中国通史洗脑。</p><p><strong>打工不易：</strong></p><p>请问楼主，范文澜的《中国通史》也不值一读吗？</p><p><strong>kkndme：</strong></p><p>从始至终以唯物主义角度阐述的历史，可信度究竟有多高？</p><p>唯物主义要很深的理解，比如子虚乌有的抢渡大渡河，就是唯物主义的杰作。</p><p>范对封建社会的理解，也很有问题，是唯物主义的需要，不能还原历史的真实</p><p><strong>welldayzwb：</strong></p><p>这个唯物主义的定义是什么？</p><p><strong>kkndme：</strong></p><p>我只能用唯物主义这个词，再直白就和谐了，呵呵</p><p>我们的历史教科书很多都出自中国通史，但是你真正熟读了史官的著作以后，发现那有多扯，歪曲的有点太不靠谱。中国通史我把它定义成政治类书籍，是政治需要产生的，专门用于洗脑，不能当史书读。</p><p><strong>EchoMa9999：</strong></p><p>楼主，简单研究了一下古文观止/三国志/汉书/后汉书/史记，古文观止，以目前的水平，看起来着实吃力，决定还是先从史记开始看起吧</p><p>淘宝上搜了一下，史记 （全四册），北方文艺出版社出版，2007年9月1号出版的，萧枫主编，绣像本，盒装， 这个版本的买来自读加收藏，可以吗？请楼主点评，谢谢！</p><p><strong>kkndme：</strong></p><p>古文观止可以买带注解的，但不要带译文的，看译文对读原文是有害的，可以通过注解提高古文水平。</p><p>史记买太好的版本，我是舍不得拿出来读，不能勾勾画画，我一定会把它高束焉,庋藏焉。读史记，最好买个普通本，带注解的，方便阅读，可边读边勾画，以提高阅读水平。</p></blockquote><h2 id="年轻人要早买房"><a href="#年轻人要早买房" class="headerlink" title="年轻人要早买房"></a>年轻人要早买房</h2><blockquote><p><strong>GGKMM：</strong></p><p>看了三天，终于看完了。。有些是一眼带过的，有些是比较认真的看下来的；</p><p>感觉回帖的筒子大多数都挺有钱的啊，至少相对我来说。因为都在计划一二百万的房子了。</p><p>本人在福州，目前月薪只有4K，但是福州市区的房产均价已经越过一万了，市中心的更是到了1.5万这样高不可及的地步。我就那楼主口中那种民企私企的体制外的P民了，属于自生自灭型的。但也还是得活下去啊，今年也二十五了，过两年也要结婚了。房子成为不可避免的头等大事；</p><p>不知道楼主对福州这样一个三线或者四线城市的房产怎么看待？平均工资水平约2000，有钱人据自己观察应该不少，至少超过20%的福州人口（有关这个，从大街上越来越多的好车做判断的，或许数字不准，但有钱人不少是肯定的）。如果在郊区能找到六千左右的小户型（65平左右），首付（还得存两年或者去借钱）自己掏，剩下的做货款，因为家里实在是没办法再支援了。这样的话应该还可承受，前提是付房贷的这二十年或者十五年里不失业。。</p><p>希望楼主给分析分析，写得有点乱。。。</p><p><strong>kkndme：</strong></p><p>25岁不是考虑失业的年龄，35岁体制外没有混出来的群众才应该考虑失业问题。 所以房子一定要趁年轻买，刚开始钱不够，就不要计较太多，先买个小的，以后有能力再换，如果没混出来，以后起码有个自己的窝住。不至于租房子被人赶出来。</p><p>福州是有点尴尬，明明是省会，又比不过厦门，不过市区1万左右的房价，在省会城市里真的谈不上高。你是自住，你又不打算去厦门生活，所以你该买还是得买。福州的房价也许涨得没那么块，但是也不可能跌。</p></blockquote><h2 id="不要低估通货膨胀"><a href="#不要低估通货膨胀" class="headerlink" title="不要低估通货膨胀"></a>不要低估通货膨胀</h2><blockquote><p><strong>someway2010：</strong></p><p>跟楼主请教一下： 楼主怎么看知春里小区的房子？那边连着双榆树小区，有大片的老房子，都是6层的板楼，都是上世纪8、90年代建的。环境看起来有点乱，以前的老公房，原单位早就没了，物业基本等于没有。将来拆迁的可能性有多大？值得买不？</p><p><strong>kkndme:：</strong></p><p>只要是4环内保值升值不会有问题，那个位置还是可以。关键是看投资还是自住，如果是自住，我就觉得那边有点乱糟糟的，不舒服。挨着中关村其实住着都不舒服，但不耽误升值。</p><p><strong>someway2010：</strong></p><p>多谢楼主，是自住<del>因为老公在中关村上班，想离公司近些，所以就挑了那里</del>是挺乱的，唉~ 希望以后等我们有钱了能换个别的地方的大房子，不过按照楼主的分析这个是极有可能实现不了了。。。5555~~~~~~ 再问一个，现在市场上卖200w的房子，十年后大概会涨到多少钱？麻烦楼主</p><p><strong>kkndme:：</strong></p><p>80年代你想象不出以后一瓶茅台会卖1000块 现在你同样想象不出十年后你的房子能卖多少钱。 那时也许人民币都是1000块一张的</p></blockquote><h2 id="二三线城市与重庆"><a href="#二三线城市与重庆" class="headerlink" title="二三线城市与重庆"></a>二三线城市与重庆</h2><blockquote><p><strong>dali_05：</strong></p><p>浏览了楼主观点，和我之前的货币推动楼市的看法完全一致 但由于无法像楼主那样掌握一些基础数据，对一些楼市的演变细节还有几个疑问</p><p>，还请lz指点 （1）二三线城市在这轮调控中的增长不出意料，但是二三线城市的房价增长，我始终认为存在一个最终谁接盘的问题。我是重庆人，以重庆为例，这个城市代表了典型的二三线城市。外来人口少，特别是外来的普通白领阶层。据我了解的数据，2008年之前，重庆的具备房子购买力的人群任然是净流出。到08年后才得以改观。但是流入任然缓慢，这也就是意味着重庆的楼市将没有长期稳定的接盘群体。而本地人，没有房子的是非常少的。在没有外来人群接盘的情况下，本地人在有房的情况下，任然投资囤积房产，最终，这些房产将如何变现。</p><p>一句话，房价要持续的上涨，还得有没房者接盘，而且这些人还得要有购买力。多次购房者无法稳定的解决这个问题。那么我就有理由对这样的二三线城市的房产前景表示担忧。</p><p><strong>kkndme：</strong></p><p>重庆房价的上涨得益于zy的战略规划，打造中国的大后方，把重庆的经济发展提升到了政治的高度。因为如果发生战争，重庆将变成第二首都，是中国最安全的大后方，蒋同志就很有眼光的选择过重庆。 重庆并不是以城中心为核心向外辐射的城市，繁华区域相对比较分散，所以房价很难快速上涨。这也就是过去重庆长期滞涨的原因。 重庆房价的崛起可以说完全是中央规划概念推动的，至于日后是否会吸引大量的精英和富人来重庆发展，我想一定可以。作为上升到国家政治高度的发展计划，就算是代价再大，也一定会搞得起来。</p><p><strong>dali_05：</strong></p><p>（2）高端房产还是普通住宅？ 看了lz的观点，认为高端房产，由于其稀缺性，更具价值。 但我认为，房产和古玩还是存在差别的。古玩最大的价值在于收藏把玩，只要有钱，买再多古玩来玩都无所谓。但是房产不一样，房产的价值除了和古玩一样的投资外，真正的功能在于居住。但是目前的二三线城市，精英阶层的数量是非常有限的，他们谁没个3，5套别墅，在没有外来精英加入购买的前提下，这些高端的房产也就是在精英圈子中流转，这样封闭的流转，如何实现价值的增长呢？</p><p>要知道，在2，3线城市，普通白领阶层能跳出自己的阶层而具备购买高端房产能力的概率是非常小的，不具有代表性。那这些每个富人，有权人都有很多的高端房产有什么价值可言？</p><p>而普通住宅由于有普通白领的接盘，是否投资价值更大？</p><p><strong>kkndme：</strong></p><p>二三线城市房价的支撑，要因城市而异的，大体上二三线城市的核心区域与高端住宅区都不会有问题。毕竟一线城市的体量，不可能满足全国中产以上群体定居，而且一线城市随着竞争的日益激烈，钱也不是那么好赚的。有很大比例的富裕人群仍会选择二三线城市生活。 中国的二三线城市的富裕人口，要比大家想象的多的多，特别是二三线城市，有相当比例的人口都有较高的隐性收入，权力寻租现象更为严重。</p><p><strong>dali_05：</strong></p><p>（3）长期持有房产的变数 中国房产只有70年，甚至50年的使用权，如果长期持有，随着时间推移，房产价值是否会受到影响。因为我在重庆，这个问题尤其严重，重庆只有50年。</p><p>如果我只是持有，出租。那我的租金将是较低的（相对房价而言），因为zf不会允许房租像房价那样疯涨，原因和粮食问题一样，基本需求嘛。那有可能50年到了，我的房租收益实际上还抵不上房款的综合支出。而那时房子早就是危房了，强拆将是完全可能的情况。那做为普通人，怎么可能和zf在赔偿上博弈。这个风险lz是怎么理解的？？</p><p>我的理解是，房子不能长期持有，必须在5年左右变现，否则将存在贬值和变现难度加大的风险，请lz指点</p><p><strong>kkndme：</strong></p><p>关于中国的房产能够持有多少年的问题，这要持续观察zf的动向。对于现在的80后来说，如果在有生之年能够平安度过，不经历大的动乱，已经是很值得庆幸了。 如果有动乱发生，即使你没有买房，你手中的现金也将变成废纸。</p><p><strong>dali_05：</strong></p><p>（4）天津现象（或者即将出现的重庆现象） 天津房价在二线城市中增长是惊人的，但收入水平并没有达到那样的高度。这种依靠所谓开发区吸引资金推动房价的模式，是否具备可持续性？？</p><p>我认为真正的天津常住精英阶层的资金实力是无法支撑这样的价格的，只能理解是外来游资的介入，推高了价格。 我想问的是，这些游资有可能退去吗，一旦退去，面临的风险是否很大。</p><p>据我的理解，中国真正成功的开发区，都是由于本身的条件好，而非开发区本身的作用。</p><p>比如深圳，享受的是经济转型的首发政策优势。上海浦东是由于本身就实力雄厚。而所谓的滨海新区，重庆两江新区，本身实力就不过如此，即使要真正实力上来，那也将是非常漫长的过程。那这些进入房地产的游资，将在概念炒作一遍之后，获得一定收益后撤出，一旦撤出，这些地区的房价将会是怎样的趋势？</p><p>放眼中国，房价高的地方无不是富人集中，或周边富人多的区域。天津重庆这样的地方，一旦外地资金撤出，将何去何从？</p><p>（5）新兴城区和老核心城区 新兴城区环境好，轨道交通也使得原本偏远的新兴城区变得方便起来。那老核心城区的房产是否不如这样的新兴城区有价值。这个问题一直很困惑。因为我是重庆人，这个问题尤其明显。现在重庆房价最高的是以前的郊区，江北，渝北。而传统的渝中，房价反而排着中等水平。这和北京的一二环贵，上海的黄埔徐汇贵完全不同。这样的状况具备可持续性吗，还是仅仅是阶段性的。但是感觉现在zf的规划更倾向于向外发展，避免主城区拆迁的高成本，这会否导致传统主城区的边缘化</p><p>先问这几个问题，困惑很久了，期待lz的高论</p></blockquote><h2 id="城区和郊区"><a href="#城区和郊区" class="headerlink" title="城区和郊区"></a>城区和郊区</h2><blockquote><p><strong>hey-hey：</strong></p><p>楼主 我在上海， 小白领一枚。最近想买房。稍微好点的区均价已经至少2万5+了， 现在考虑在其他价格洼地的区买套新房，看中了均价1万7左右，买90送30，到手面积120左右。此楼盘开发建造定位2万/米以上，因政策调控，故现1万7。好处是小区规划不错，属大型国企房产公司，2012年交房。附近有超大型公园，地铁明年开通（升值利好），附近有医院，学校，路上看到的在建建筑较多（百废待兴）。不好处是离上班开车要1个小时，属工业区（在另外一个方向），路上集卡较多，有传空气质量不好。</p><p>另外一个选择是在市中心或其他比较好的区买个小房子，大概5、60平方米左右，预算也是180万左右。 好处是地段好，租金回报可能较高。如果自住相对比较方便。</p><p>单身，买房投资愿望大于自住愿望。 请楼主给分析分析。谢谢</p><p><strong>kkndme：</strong></p><p>多数人买房子都是郊区买个大的，后来上班实在不方便，再想办法城里买套小的。住郊区牺牲时间，住城里牺牲面积。总得来说，还是住城里更方便些。 关于房价升值，一定是郊区和城区版块轮动的。当郊区房价较低时，资金就会关注价值洼地，当郊区房价炒起来以后，城区的房价跟着上涨，但总的来说，城区的房价涨幅一定高于郊区，且比郊区更抗跌。</p><p><strong>hey-hey：</strong></p><p>谢谢楼主。真是纠结阿。一样的钱想买个新点的。而且周边的觉着还有这样那样的优势，比如公园，比如现在的性价比。比如大了一倍。比如该区未来发展空间和前途。如路建好了地铁修好了，城市辐射发展的面扩展了。 市区现在虽然完善，但未来没什么发展空间，该发展的都饱和了该配套的都配好了。升值的空间是否相对就小了。</p><p>还请楼主再给说说。</p><p><strong>kkndme：</strong></p><p>你说的其实还是性价比的问题，比如郊区（前提是配套能发展的起来）1万7，城区2万5，那肯定是选择城区，毕竟相差不大。如果郊区1万7，城区3万以上，那肯定选择郊区。 好比北京的通州，城区2万的时候，通州8000，肯定选择通州，升值会快。但城区3万，通州2万5的时候，肯定会选城区。</p></blockquote><h2 id="守着金碗要饭吃"><a href="#守着金碗要饭吃" class="headerlink" title="守着金碗要饭吃"></a>守着金碗要饭吃</h2><p>守着金碗要饭吃，最典型的就是老一辈玩田黄寿山石的，收藏了一屋子石头，穷了大半辈子，第一次参加石头交易会，居然发现自己随便拿块石头出来能卖上千万。</p><h2 id="人制的社会，人就是制度"><a href="#人制的社会，人就是制度" class="headerlink" title="人制的社会，人就是制度"></a>人制的社会，人就是制度</h2><p>让李荣融来讲垄断巨头的功劳，这个事很有意思。</p><p>西汉时期，功臣集团和他们的后人势力比较大，大街上瞎晃的黑社会头子比较多，皇帝提倡以法治国，靠法律来制约功臣集团，先是重用了皇宫守大门出身的张释之大法官。 张法官完全按法律办事，该杀头的绝不会流放，但是该流放的也绝不会杀头。张大法官实现了我国历代百姓追求的天下无冤民的梦想。 史书上记录：汉文帝车驾过中渭桥，一个人从桥底下突然钻出来把皇帝的御马惊了，刘恒很生气，让张法官治他的罪。张法官审讯后发现是个意外，属于民事事件，打算罚点钱放掉。刘恒不干了，那可是惊了圣驾呀。罪该杀头。张法官却认为：律条上没有说因意外惊了圣驾就必须杀头，按律条就应该罚钱放人。要不然陛下你就不要把这个人交给我审，直接杀掉算了。既然陛下让我审，就必须按法律办事。刘恒只好按照张法官的审判结果，放掉了那个人。 其实，遵守法律，按照法律办事的不仅仅是张法官，而是刘恒自己。刘恒为了保证社会安定、基业长青，就必须限制特权阶层，限制特权阶层就必须依法治国。 但是文景之后，武帝就不满足于完全依法办事的张释之法官这样的人了，而是开始重用酷吏，张汤、义纵、宁成这些新一代法官登上了历史舞台。法律是什么？法律就是张汤，张汤就是法律，犯了法的要往死理打，没犯法的也要往死里打。 唐朝武则天时期，出现了一个史无前例的酷吏：来俊臣。 来俊臣法官不管法律专搞冤狱，专门养了一大群打手无赖，凡是武则天不喜欢的人，还有他自己不喜欢的人，一律刑讯逼供，屈打成招。发明的酷刑比张汤有过之而无不及。 古代，法律是什么？是皇帝？是张释之？是张汤? 是来俊臣？其实，法律什么都不是。</p><h2 id="准公务员的好处"><a href="#准公务员的好处" class="headerlink" title="准公务员的好处"></a>准公务员的好处</h2><blockquote><p><strong>xufangliang1120：</strong></p><p>楼主，请问新进公务员队伍的人员今后还会不会有住房福利。像年纪大的都有分房或定向开发的商品房，已经分过了。象新进来的，工资不高，每月不到2000，平时无任何待遇，过年也就发个千来快意思意思。我在湖南常德，这里的房价也在4000左右，今年涨起来的。象我们这种情况要怎么办才好？请您指教！！谢谢！</p><p><strong>kkndme：</strong></p><p>大哥，公务员也是有级别的，想想宋江为什么上梁山呢？ 你要是在重要部门，或者到了级别自然就有了。 西汉的张释之，冯唐、郅都都是皇宫守大门的出身。皇宫看大门的，不算是公务员，是体制外编外人员，相当于协管员，连工资都不发，但为什么大家都趋之若鹜的争当皇宫传达室老大爷这种有前途的职业？因为，可以有机会见到皇上，有机会成为高级公务员。当上了高级公务员，你就有了票子房子妹子。</p></blockquote><p>最著名的皇宫传达室看门老大爷叫冯唐，头发都白了还在未央宫值班呢。皇帝刘恒没事瞎溜达，看见老大爷一脑袋白头发，就叫过来神侃。不侃则已，一侃才知道冯大爷的爷爷是赵国的官帅将，跟大名鼎鼎的名将李牧是哥们。而且冯大爷不愧是名将之后，太懂带兵打仗的道道了。 刘恒说：我要是能有李牧这样的大将，还怕什么匈奴啊。 冯唐很牛叉的说：就是有李牧这样的大将，也得不到重用。 冯大爷直接把皇帝气晕，皇帝转身就走了。 后来刘恒气消了，又找冯大爷问话。 冯大爷就说了一番大道理： 对待将士，要以激励为主，才能得到将士拼死效力的心。重惩罚，轻奖励，光拿大棒不掏胡萝卜，将士怎么肯用命呢？（皇帝是信奉法家的，法家的精神领袖商鞅同志认为管理手下最高境界就是基本不怎么用胡萝卜，直接用大棒的最牛——罚九赏一。） 云中太守魏尚是个名将，让匈奴文风丧胆。魏尚的手下都是农民子弟，魏尚对待士兵很好，很舍得犒劳，也和舍得给钱，所以大家都很拼命。但是陛下您经常因为军兵的一点小错误，就扣掉军兵的赏赐，因为魏尚虚报了几个斩获的首级数量，就把魏尚抓起来关监狱，奖励太轻，而惩罚太重了。所以说陛下有李牧这样的良将也不能重用。 刘恒大悟，拜冯大爷为车骑都尉。 唐代的王勃，很不得志，于是写了《秋日登洪府滕王阁饯别序》:“嗟乎!时运不齐，命途多舛;冯唐易老,李广难封。” 冯大爷一下子因为王勃的文学作品，家喻户晓了。</p><h2 id="小城市房价会因为人民币贬值涨价，但依然难变现"><a href="#小城市房价会因为人民币贬值涨价，但依然难变现" class="headerlink" title="小城市房价会因为人民币贬值涨价，但依然难变现"></a>小城市房价会因为人民币贬值涨价，但依然难变现</h2><blockquote><p><strong>xufangliang1120：</strong></p><p>楼主,谢谢您的回复! 你您怎么看常德的房价呢,那我们现在还是想点办法先买房?</p><p><strong>kkndme：</strong></p><p>买一套自住房还是应该的，不是所有公务员都能够上位，也不是所有公务员能够分到房子，特别是二线以上城市，将来普通的底层公务员住公租房的可能性更大。</p><p>对于小城市，房价也会因为人民币的贬值而上涨，只是可能不如大城市好变现而已。所以，有能力还是应该买一套自住房的。</p></blockquote><h2 id="一线杭州"><a href="#一线杭州" class="headerlink" title="一线杭州"></a>一线杭州</h2><blockquote><p><strong>钱江风帆：</strong></p><p>看了个通宵啊，不知楼主对杭州了不了解，目前市区大概25000/m2,杭州未来房价的趋势如何？</p><p><strong>kkndme：</strong></p><p>杭州我都当一线城市看的，你就当一线城市理解。富人的天堂，房价多高都不稀奇</p></blockquote><h2 id="二三线城市的发展靠拆迁"><a href="#二三线城市的发展靠拆迁" class="headerlink" title="二三线城市的发展靠拆迁"></a>二三线城市的发展靠拆迁</h2><blockquote><p><strong>dali_05：</strong></p><p>支持楼主房价大涨房租必涨的观点</p><p>但是这仅限于外来人口众多的一线城市 二三线城市本地人几乎没有没房的，如果算上父母的，将来普遍一个家庭拥有两套以上的房子 房租也就失去了大涨的基础 唯一可导致房租上涨的就是拆迁，一旦便宜的旧房子少了，房租肯定是要上调的 但那也是有限的 总之，外来人口极其可支配收入是房租的决定性因素</p><p><strong>kkndme：</strong></p><p>二三线城市的敛财和追求政绩方式，全靠大规模拆迁，城市搞升级改造，这个拆迁规模是一线城市市民难以想象的。有的城市已经搞得如火如荼了，有的城市还没开始，但都会走这一步。</p></blockquote><h2 id="转篇文章：一个忽悠了几亿中国人的伪概念：所谓“中国房地产泡沫”"><a href="#转篇文章：一个忽悠了几亿中国人的伪概念：所谓“中国房地产泡沫”" class="headerlink" title="转篇文章：一个忽悠了几亿中国人的伪概念：所谓“中国房地产泡沫”"></a>转篇文章：一个忽悠了几亿中国人的伪概念：所谓“中国房地产泡沫”</h2><p><strong>中年不惑吗：</strong></p><p>一个忽悠了几亿中国人的伪概念-所谓“中国房地产泡沫”</p><p>作者：罗伯特卡帕</p><p>中国大陆大家目前最为关心，讨论最为热烈的一个问题就是中国的房地产泡沫问题。从政府到民间，从经济专家到普通百姓，大家都在关注这个问题。以前，我也觉得中国存在一个叫“中国房地产泡沫”的所谓概念，但今天我忽然感悟，原来多少年来包括我在内的几亿中国人都被蒙骗了，中国根本就不存在所谓“房地产泡沫”的问题，“房地产泡沫”这个概念本身就是一个伪概念。</p><p>如同市场经济一样，房地产泡沫也是一个外来事物，它是市场经济的产物。但问题是，中国是市场经济吗？显然不是，否则为什么大多数西方国家都不承认中国是一个市场经济国家。尤其是中国大陆的房地产市场，更不是市场经济，而是计划经济与市场经济相结合的一个怪物，政府操纵着房地产行业，政府对房地产有着绝对的掌控能力。</p><p>房地产泡沫是市场经济的产物，既然是泡沫，那么这个泡沫也会遵循市场经济的规律，即当泡沫足够大的时候，会破裂。因为日本与美国的经济是市场经济，所以当日本与美国的房地产产生泡沫的时候，就会破裂。</p><p>目前包括中国在内的几乎所有世界经济学家都以为，当年日本与美国的房地产泡沫破裂了，中国的房地产泡沫比日美大几倍，当然也会破裂。事实却是，中国的房地产泡沫在几年年前的膨胀程度就超过了当年日本与美国的房地产泡沫，中国的泡沫几年来虽然翻倍，但却没有破裂，这是何故？显然，经济学家们犯了一个错误，那就是把中国的房地产乃至中国经济当成了市场经济来看待，而事实是中国的房地产市场根本不是市场经济。所以，西方市场经济国家所有的房地产泡沫，在中国也根本不存在，所谓的“中国房地产泡沫”根本就是一个伪概念。</p><p>当然，我说到这里时，肯定有很多人不服气，中国的房地产明明几年之内翻了很多倍，远远超过了普通人的收入水平，这不是泡沫这是什么？我的回答是，中国的房地产价格确实虚高，远远超过普通人的收入水平，这是事实，但这不是“房地产泡沫”，因为泡沫会破，而中国的这个被大家称为“泡沫”的东西却不会破，因为它的真实名字其实不叫泡沫，应该叫“变相的税收”或者“房地产垄断价格”。</p><p>中国的房地产业本质上已经不是一种行业，像中国大陆的税收与垄断行业的垄断价格一样，成了少数人剥夺多数人财富的一种工具。在这个工具上，寄生着很多食利者。这个食物链的最上层为地方政府，地方政府通过卖地与房地产税收，养着一大批高薪的公务员及满足他们的奢侈需求。食物链的第二层为与官员勾结的房地产商以及受贿吃回扣的官员，第三层是炒房者，炒房者相当部分为拥有大量现金的官员及家属。</p><p>市场经济的泡沫会破裂的，但中国的房地产不是市场经济，房地产价格也不是“泡沫”，所以它也不会破裂。中国的房地产价格被政府严格操控着，不说是操控自如，也是有绝对的控制力。因为政府掌控着土地银行汇率等房地产的关键要素。中国的高税收是泡沫吗？中国的垄断行业的高垄断价格如水价电价油价是泡沫吗？当然不是，他们是转移财富的手段。中国的房地产价格也是一种变相的“税收与垄断价格”，其“税率”与“垄断价格”是政府控制的。这也解释了为何中国几年来房价如此之高，却不下跌，所谓“泡沫”却不破裂的原因。</p><p>中国房地产的所谓“泡沫”会“破裂”吗？会，只要政府愿意。中国的房地产的“泡沫”会不破裂吗？会，只要政府愿意。</p><p>其实，中国所有的问题都是政治问题，而不是经济问题，离开政治谈经济，永远找不到问题的答案。</p><h2 id="拆迁补偿"><a href="#拆迁补偿" class="headerlink" title="拆迁补偿"></a>拆迁补偿</h2><p>拆迁补偿的两种方式：1、现金补偿；2、回迁安置。 在二三线及以下城市，通常采用第二种，因为多数开发商没有钱现金补偿，房地产开发基本上是靠zf关系，空手套白狼，就是有钱也不愿意拿出来。 对于拆迁户来说，现金补偿也不划算，因为补偿的现金在与原地同级别的位置肯定是买不了相同面积的住房的，所以多数拆迁户选择回迁安置。 但是越小的城市开发新盘的速度越慢，往往回迁房盖个三五年也不见得盖得起来。在这期间，开发商会按月补偿拆迁户一定的租金，用于过渡。 手里现金多的拆迁户会先买房住，慢慢等拆迁，但是现金不多的拆迁户，就不得不拿着开发商的过渡款租房住。通常这笔过渡款都要高于相同位置的租金，所以拆迁户就把房租炒起来了。</p><p>北京已经没有原地回迁的说法了，一线城市，还有部分较发达的二线城市都不搞原地回迁了，土著一旦拆迁了就赶到郊区。反而是二、三线城市，特别是三线以下城市多数还在搞原地回迁。主要原因是城市小，住户多多少少都有些背景，特别是单位的老公房，开发商不让原地回迁，根本就拆不动，阻力太大。</p><p>房子从拆到迁是有时间的，快的情况是1年多，但很多情况都是拆迁安置房3,4年盖不起来。比如昆明的莲花池片区，大概是06年左右拆迁的，但拆迁安置房现在才开始动工，2012年才盖的起来。这种事情并不是个案。 贵州更离谱，房子04年拆了就再也没有音讯，开发商一直盖不起来，到现在都6年了。原来的拆迁户，现在还在租房住。</p><h2 id="城市底层"><a href="#城市底层" class="headerlink" title="城市底层"></a>城市底层</h2><blockquote><p><strong>游泳横渡马六甲：</strong></p><p>经常有人说收入是决定因素，其实人均收入没有意义。北京姑娘去外企做前台一个月2000，和公司外地姑娘拿这么多，和做公务员的外地姑娘拿这些，生活成本天差地远。不是说有10万个月入2000的外来人口，四环内就有一万处他们能承受的住房。而个体的外来人口的支出，会随着生活成本调整。开始很难理解月入两三千的白领在北京市如何生活，毕竟他们不可能像楼下卖蔬菜水果的大叔那样，炖点猪肉粉条就算开荤，穿特价五块的汗衫就算工作服。一样的月入，白领的幸福起点高得多。后来知道他们原先偶尔用兰蔻改成一直用大宝，早餐不再喝豆浆，住单位附近的搬到五环外，有人在燕郊买了房……突然想起小时候学新概念英语，说起蓝领工资比白领高，但还有人为了能西装革履宁可减薪做白领。</p><p>对80后而言，最恐怖的绝不是房价，而是养老。这也不是计生的问题，一个社会的生活资源是有限的，老龄化早晚会到来，为了改变老龄化呼吁多生育，那是饮鸩止渴。等多生出来这部分老了，再这么循环？而福利社会如英国是50多岁的人最幸福，有稳定养老金，二三十岁最痛苦，看不到未来依靠。家底不厚的像希腊，透支做社会福利，后果还不如不做。中国则是取不足以奉有余，竭全民之力供特权阶层挥霍，没有哪个年龄段享受过全民福利，还得共同面对养老难题。房子，真不算此生最纠结的事</p><p><strong>kkndme：</strong></p><p>正是如此，以后城市的底层吃饭都是问题，zf最喜欢拿房子说事转移矛盾</p></blockquote><h2 id="垄断企业"><a href="#垄断企业" class="headerlink" title="垄断企业"></a>垄断企业</h2><p>我们的垄断企业其实都是第二税务局的角色，比如石油、移动、电力、水务、地产、银行等等。zf一定要掏空百姓的钱包，所以说什么泡沫不泡沫，就是个笑话</p><h2 id="农村自来水"><a href="#农村自来水" class="headerlink" title="农村自来水"></a>农村自来水</h2><p>说起农村建自来水更搞笑，亲眼目睹要不然真不敢相信。 贵州有个村子，以前，自来水是村子集体出钱买的管子，然后全村出劳力从山上接下来（用的山泉水），要是水管坏了，大家再摊钱摊劳动力修。 结果zf不愿意了，说他们修的不规范，zf给重新修，还是从山泉引水下来，zf包给工程队换了一下管子，然后每户给按了水表，安好了以后，要按照2块钱一吨收费，全村都炸了窝了，集体抗议，现在还没有结果。</p><h2 id="袁盎"><a href="#袁盎" class="headerlink" title="袁盎"></a>袁盎</h2><p>丛林社会就是要承认人与人之间的差别，性格决定命运。 我要讲一个奇人，这个人叫袁盎。故事的出处是《史记·袁盎晁错列传》，如果鸡冻同志认为我瞎编，可以自己去看原文。</p><p>袁盎同志的神奇是一般人都无法想象的，这个奇人在吴国当相国的时候，他手下的一个小公务员跟老袁同志的爱妾乱搞，经常背着老袁嘿咻嘿咻。老袁知道了这个事就装聋作哑。 有人跟那个小公务员说:坏了，你跟袁领导的二奶私通的事让袁领导知道了，你死定了。 小公务员一听吓坏了，骑了马就跑，公务员这份全世界最令人羡慕的工作也不要了。 小公务员一跑，袁领导就使劲追，小公务员就更拼命跑，袁领导就更拼命追。袁领导的马要好一点，跑的快，终于把小公务员追上了。小公务员只好下马等死。 袁领导急了，对小公务员说：你跑什么呀？我正打算把我的二奶送给你。兄弟如手足，妻子如衣服。大概就是这个意思。 小公务员感激涕零，抱着袁领导的二奶继续嘿咻。 所以说老袁这人最仗义，人缘最好。上下都买他的帐。</p><p>老袁也有个把敌人。老袁在皇宫里当小跟班的时候，得罪了汉文帝宠爱的一个太监叫赵谈的，所以特别害怕，怕赵太监哪天找茬把自己给黑了。 老袁征求了侄子的意见，认为自己应该先下手为强，应该当众侮辱一下赵太监，这样如果赵太监再黑自己，就没人信了，别人都以为是公报私仇。老袁的政治手腕还是相当高的。 一天，文帝刘恒跟找太监坐在一辆车子里外出，老袁上前拦住车子，大义凛然的说：能够跟天子共乘一车的，都是天下豪杰，天子怎么能跟一个没小鸡鸡的人坐一辆车呢？ 赵太监当场就气哭了，还不能说什么。以后赵太监要黑老袁，也没那么容易了，因为大家都知道老袁义正言辞，充满正义的得罪了赵太监，如果赵太监再说老袁坏话，就是公报私仇。</p><p>老袁的人缘是公认的好，但是在朝里有一个最大的敌人，就是大名鼎鼎的晁错。 晁错这个人学的是商鞅之术，法家的代表人物。为人冷酷，不讲人情，人缘特别差。老袁和晁错关系不好，可能跟两个人的性格很有关系。 晁错跟贾谊很有一拼，特别喜欢喷，口才也特别好，跟贾谊同志喷的内容也差不多，一会儿说打匈奴其实很简单啦，一会儿说必须削藩啦。刘恒听晁错喷的很有水平，很欣赏，但是刘恒不是傻子。 打匈奴？那得是国力强大以后的事，现在必须让老百姓修养生息。 削藩？我也想削藩，但是总得有合适时机才行啊，现在削藩不是逼人造反吗？ 刘恒对晁错这种人的态度就是，你建议你的，我听听就可以了，不能当真。</p><p>晁错同志懂得要想发达，必须选择一个有前途的职业，所以凭着他气死保险推销员的口才，当上太子的老师。这个太子就是汉景帝刘启。 晁错的时代终于来了，原因是刘恒挂掉了。 刘启生下来就是锦衣玉食，可没他老子那两下子，也不怎么懂帝王之术，晁错说什么就是什么。 晁错于是抖起来了，不知姓什么了，仗着是皇帝的老师，飞扬跋扈，人缘极差。晁老师最爱追求政绩，立刻提出削藩。 削藩的结果就是吴楚七国反了。 这个故事跟明代朱允文同志的削藩如出一辙。明朝朱允文同志削藩的结果就是朱棣反了，当了皇帝。朱允文被迫流浪，泡吉普赛美眉去了。 吴王不是朱棣，性格有点象袁绍，生性多疑，手下有人才不会用，所以没能成大事，被周亚夫跟干掉了。如果吴王能有朱棣的本事，汉朝的历史就会改写。</p><p>吴王一反，老袁就着急了。老袁给吴国当过相国，吴王造了反，晁错必然要借机宰了老袁，老袁觉得自己冤枉啊，吴王造反不是你晁错逼的吗？ 晁错果然趁机对老袁打击报复，安排了两个手下去弹劾老袁。但是晁错的人缘实在太差了，老袁的人缘实在太好了，那两个手下竟然不同意弹劾老袁。而且还劝晁错,大意是：现在七国兵马造反了，形式很危急，我们还搞内斗就不好了。老袁这个人是不可能参与谋反的。 晁错也着急叛乱的事，就把老袁放一边了。政治斗争，不是你死就是我活。 晁错错了，赔进了自己的老命。 窦婴同学也曾经在吴国当过相国，立刻跟老袁站在了一条战线上，准备给晁错来个致命一击。 晁错这个人的死，完全是他自己性格造成的，对人苛刻，政治上又是白痴。吴楚七国打着“诛晁错，清君侧”的名义造反，皇帝问晁错应该怎么办? 晁错的白痴精神充分发挥了出来，“陛下您御驾亲征，臣留守长安，做好看家的工作。” 皇帝估计当时心里要多愤怒有多愤怒。你自己惹的祸，你一个当臣子的在家躲起来，让我当天子的上去当炮灰，你是何居心? 不过刘启涵养好，没说出来。 这时候老袁跑了进来，说有平乱之计，要单独跟皇帝说。刘启很不客气的就把晁老师请了出去。 老袁立刻献计，既然反叛打着清君侧的名义，就先把晁老师宰了，叛军就出师无名了，就得不到老百姓的响应，事情就好办了。 刘启一听挺高兴，正恨晁老师让自己当炮灰的事呢，立刻同意，腰斩晁错。 晁错的下场要比贾谊惨多了。</p><p>不过老袁的下场也并不好。皇帝的老妈想让皇帝的弟弟梁王在刘启驾崩后继承皇帝这份工作，但是老袁不同意，坚决表示反对，得罪了梁王。 梁王不是一般的高级公务员，最喜欢搞黑社会，找了杀手把老袁干掉了。 这个故事又告诉我们，即使人缘再好，在政治斗争中活下来也是不容易的。</p><blockquote><p><strong>welldayzwb：</strong></p><p>最好把历史故事表达的直白的意思讲出来，不排除观众里像我这么愚钝的人不少</p><p><strong>kkndme：</strong></p><p>我说的不是袁盎也不是晁错，说的是削藩，皇帝削藩怎么样？看看朱允文的下场，晁错几乎独揽了大权，削藩的下场是什么？腰斩。清查空置率，zf不参与一级开发，不是扯淡吗？</p></blockquote><h2 id="二三线城市，选新城还是老城"><a href="#二三线城市，选新城还是老城" class="headerlink" title="二三线城市，选新城还是老城"></a>二三线城市，选新城还是老城</h2><blockquote><p><strong>wofuleyumin1：</strong></p><p>楼主 我又有问题了。。。。请务必回答 谢谢</p><p>1。目前很多城市开发新城 我们主要谈二三线城市吧。。。这些地方的新城会超越老城吗？ 我们投资该投新城还是老城？</p><p>比如成都 南边的天府新城，口号国际城南。。</p><p>2。投资一定投越靠市中心越好吗？ 比如成都，西三环是比东二环还好。。但未来2环是否最终比3环好？</p><p><strong>kkndme：</strong></p><p>拆迁是块硬骨头，不够铁腕的领导会避开破旧但繁华的老城区的问题，转而开发新城，所以往往形成倒挂，即新城一下子变成了新贵聚居区，新城的房价甚至高过老城区。 但这是一种倒挂，老城升级改造是必然的一步棋，只是时间的早晚。未来老城区的升级改造，老城区的价值就会凸显，价格要远远高于新城。</p><p>但是老城区的多数老房子都可能面临拆迁，投资老城区的老房子不见得划算，特别是二三线城市的拆迁，离皇帝越远的城市，争取合理补偿越困难。</p></blockquote><h2 id="在中国，普通人手上闲钱不多的人被剥削"><a href="#在中国，普通人手上闲钱不多的人被剥削" class="headerlink" title="在中国，普通人手上闲钱不多的人被剥削"></a>在中国，普通人手上闲钱不多的人被剥削</h2><blockquote><p><strong>抽着雪茄喝着绿茶：</strong></p><p>兰州，我近来盛干人民币的贬值力度之强烈 现在手上还有十万的盈余 做什么好呢 咬紧牙关供一套房？买黄金？还是买车呢？ 总之不能空放着， 这样通货膨胀下去，汽车的价格也会涨吗？</p><p><strong>kkndme：</strong></p><p>买车是消费，不是投资，如果追求享受，可以买车，但不能保值增值。汽车属于工业品，通过扩大生产规模可以使边际成本下降，所以汽车会因为档次的不同有涨有跌。 黄金可以适当配置，但由于黄金的定价权不在国内，所以买黄金有一定的风险。 十几万买房子估计不够首付，除非特别小的城市。但小城市的房产变现起来比较麻烦。 至于古玩字画茅台酒之类的，真假难辨，不是专家很难参与投资，且一般人变现还是很困难的。 所以资金越小，资金实现保值增值越困难。我国实行的高通胀低利率政策，是对手中闲钱不多的普通群众赤裸裸的剥削。而手中闲钱较多的中产阶层，相对好一点，可以投资住宅商铺进行保值增值。</p></blockquote><h2 id="三分天注定，七分靠打拼"><a href="#三分天注定，七分靠打拼" class="headerlink" title="三分天注定，七分靠打拼"></a>三分天注定，七分靠打拼</h2><blockquote><p><strong>汝爱之罪：</strong></p><p>从晁错的上位过程可以看出，口才很重要</p><p><strong>kkndme：</strong></p><p>呵呵，这个也不一定，一个是看老板的风格，一个是看自身的运气。 说汉文帝刘恒去参观皇家动物园（上林苑）就问动物园园长：“咱们动物园有多少动物啊，都有什么品种啊？”一下子把园长问晕了，吭吭叽叽答不上来。 这时有个负责老虎的工作人员跑了出来，作了一通汇报，如数家珍，回答的头头是道。刘恒特别高兴，觉得这个管理老虎的工作人员口才特别好，想提拔他当动物园园长。 这时候张释之蹦了出来，对皇帝说：秦朝的时候，赵高口才就特别好，特别巧言善辩，结果忠厚的大臣都被迫害了，天下大乱，秦朝完蛋了。陛下要是提拔这个管理大老虎的人，恐怕所有的大臣都会效仿他，专门学习卡耐基演讲，并且天天琢磨吹牛拍马，就没人真正为皇帝干活了。 结果是可怜的管理老虎的工作人员白高兴了一场，不但没得到奖赏，还得罪了动物园园长。</p></blockquote><h2 id="人的前程有的时候不掌握在自己手里"><a href="#人的前程有的时候不掌握在自己手里" class="headerlink" title="人的前程有的时候不掌握在自己手里"></a>人的前程有的时候不掌握在自己手里</h2><p>某城市从外省调来个姓q的一把手。该一把手一上任就把该市原来的骨干公务员全部晾到一边，一概不用，名义上对外宣称的是：领导干部年轻化。提拔了一批没有工作经验刚毕业的博士生当处级干部，大多数30岁还不到。这些人一点工作经验没有，以至于外界都很惊讶，甚至惊动了日本友人。 该一把手正是要用这些毫无工作经验的白纸，第一：人是自己一手提拔的，他能不感激涕零吗？第二：这些人啥也不懂，自己想怎么干就怎么干，这些人听话就行。不这样做，怎么能一手遮天呢？ 一批期望往上爬的老公务员就这样牺牲掉了，而一批新丁就此崛起。人生的前程往往不掌握在自己手里。</p><h2 id="河南郑州与洛阳"><a href="#河南郑州与洛阳" class="headerlink" title="河南郑州与洛阳"></a>河南郑州与洛阳</h2><blockquote><p><strong>scdf1234：</strong></p><p>楼主，我想咨询一下，像洛阳这样的城市，它的经济在河南是第二位，但又离省会郑州很近，洛阳的房价现在大概是四千多，您认为洛阳的房价上涨的空间大吗？ 谢谢！！！！！！！！！！！！</p><p><strong>kkndme：</strong></p><p>洛阳只能成为郑州的影子，如果自住，趁早在洛阳买房，以后一定会涨，如果投资，还是在郑州买，郑州的上涨空间，肯定大于洛阳。 不过95年以后，我就再也没去过洛阳，所以洛阳买哪个楼盘升值快，你得自己仔细研究。</p></blockquote><h2 id="杭州"><a href="#杭州" class="headerlink" title="杭州"></a>杭州</h2><blockquote><p><strong>灵魂被枪决：</strong></p><p>不知道楼主还在不在，因为只看完前面几页。</p><p>我前两天刚定了一套二手房，昨天打了首付款，下星期应该就要办银行按揭手续了。</p><p>我一直很想买房，但我LG一直不愿意买房，就在定下这套房子之前他还是很不乐意，但</p><p>因为我的坚持，我们终于买了房子了。房子定下后一个石头落地了，但另一个石头有悬</p><p>地半空了，因为我们是做个体户生意的，就怕生意有变故贷款接不上（我是个悲观主义</p><p>者，总先把最坏情况打算在前）。我们是在杭州，虽然不是市中心，但也算是市区了，</p><p>请问楼主能分析一下杭州楼市情况吗？？</p><p>先谢过了，楼主的文章对我启发真的很大</p><p><strong>kkndme：</strong></p><p>前面说过了，杭州我是当一线城市看的。杭州这个城市，本来就是富人的天堂，房价涨到多高都不奇怪，而且极好变现。所以你根本无须担忧资金问题。</p></blockquote><h2 id="西安与重庆"><a href="#西安与重庆" class="headerlink" title="西安与重庆"></a>西安与重庆</h2><blockquote><p><strong>ttan12345：</strong></p><p>用了一整天的时间拜读了楼主的精彩文章，很是佩服！</p><p>印象最深刻的就是北周宇文式和苏的关于贪官的对答，古人真有高人啊！</p><p>感觉楼主知识面相当的宽广，尤其对世界历史比较精通，许多观点非常符合世界发展的规律</p><p>关于房产的问题，我也一直认为，最终不是我们小老百姓可以玩的东子，所以能买就</p><p>尽早买。看了楼主不止一次给大家推荐去投资西安和重庆的地产，楼主问什么看好西安</p><p>和重庆这两个地方，现在各个省会城市哪个不是大兴土木呢？为何西安和重庆会进入你</p><p>的法眼？</p><p><strong>kkndme：</strong></p><p>重庆我就不多说，论述的比较多了，发展重庆是国家战略性的，这是政治任务。 西安是西北地区唯一的大城市（乌市比较特殊，不讨论乌市），教育资源丰富，且房价基数较低，所以说后续发展潜力很大，未来该城市的发展一定会纳入zy的视野</p></blockquote><h2 id="谢国中「空置率」"><a href="#谢国中「空置率」" class="headerlink" title="谢国中「空置率」"></a>谢国中「空置率」</h2><blockquote><p><strong>林语边的鸽子：</strong></p><p>谢国中:”一是加息预期；二是政府对房地产的政策调控力度不改；三是市场对人民币升值的预期减弱；四是参考了实际的供应量，“到2012年，房地产的空置率会非常高，全中国13亿老百姓要有的房子都有了。” 谢国忠预测，“接下来可能会看到交易量一直在增长，而房价却不死不活地拖几年，房地产没有第二场戏了</p><p>请问楼主对谢国中的说法怎么看? 谢谢</p><p><strong>kkndme：</strong></p><p>谢是油价和中国房地产的长期唱空者，从04年开始唱空中国房产。谢的有些话还是很有道理的，但有些预测就另有目的了，毕竟屁股决定脑袋。 今年谢一直呼吁的是加息，兼带唱空房地产，唱空房地产的主要依据是空置率。 谢自己也说中国的房地产最大受益的是zf，但却用空置率给出了一个下跌的结论。 人民币升值，呼吁加息，唱空房地产，摩根史丹利的喉舌作用显而易见的</p></blockquote><h2 id="打工不如有一技之长的小老板"><a href="#打工不如有一技之长的小老板" class="headerlink" title="打工不如有一技之长的小老板"></a>打工不如有一技之长的小老板</h2><blockquote><p><strong>中年不惑吗：</strong></p><p>现在他们已经比一般的小白领强了</p><p>人力成本只会越来越高</p><p>现在去读个技校，当个技工</p><p>肯定比一般大学出来强多了</p><p>还有一个问题：</p><p>一般企业的工资10年没有变</p><p>10年前某个职位是5000，</p><p>10年后这个职位也是5000；</p><p>而在10年间，民工工资可能从1000涨到了3000， 房价更是涨了10倍；</p><p>菜价生活用品也翻了数倍</p><p>高房价问题其实就是分配问题</p><p>如果某个从事的职位10年前和10年后是一样的</p><p>那也就相当于这个职位的薪水降了相当多</p></blockquote><p><strong>kkndme：</strong></p><p>进不了体制内的，无论是不是大学毕业，凡是有头脑的、懂做生意的，会一技之长的，只要不懒，活的肯定比无特长一般在公司打工的小白领强。 古代也是这样的，街面上卖爆肚的肯定比大户人家厨房里负责切葱的日子过的稳当。卖爆肚的小本生意很累很辛苦，但是有个手艺就不会饿肚子。大户人家切葱的上班期间日子过的比较轻松，甚至收入比卖爆肚的还强点，在大户人家也体面些。但一旦大户人家不要切葱的了，裁员了，这个切葱的出来还真没办法养活自己。 大学文凭顶多算个秀才资格，有这个资格才有机会举士，但是举不了士的，就必须学点技术，否则收入远远赶不上瓦工、电工。 过去的穷秀才，饭都吃不饱，但是社会地位却不差，一旦中了恩科，就是宰相根苗。现在有点不同，进不了体制内，又没点技术，那肯定沦为社会的最底层，不要说买房子了，能不能解决吃饭问题都不一定。</p><h2 id="一线、二线的生活"><a href="#一线、二线的生活" class="headerlink" title="一线、二线的生活"></a>一线、二线的生活</h2><p>一线和二线选择哪个城市生活，其实就是围城。 在一线打拼，有技术有背景或者机会好的，进了金字塔的中层。对于没背景的，运气差点的，看着没什么希望就离开了，到二线发展，起码二线生活成本还低点。混不下去的离开了，又有大量的打算拼一把的冲进来。 很多人宁可在大城市当底层，也不愿意回小城市。这还是个观念问题。小城市从城东走到城西也就二十分钟，觉得过得太枯草。大城市灯红酒绿的，虽然跟自己其实没多大关系，但是看着就是舒服。</p><h2 id="讲故事含沙射影ZG之房子不属于市场经济"><a href="#讲故事含沙射影ZG之房子不属于市场经济" class="headerlink" title="讲故事含沙射影ZG之房子不属于市场经济"></a>讲故事含沙射影ZG之房子不属于市场经济</h2><p>不说历史了，讲个故事吧。这个故事纯属虚构，如有雷同，纯属巧合。讲故事麽，就不要和谐了。 传说王安石变法失败，后人小王跑到了海外，发现了大西洲。大西洲正处于混乱阶段，军阀割据，外族入侵。小王是个政治军事天才，煽动农民起义，统一了大西洲政权，建立了大西国。 小王继承了王安石变法的理想，建立了一个中央高度集权，百姓与百姓之间完全消灭差别的理想国家。农场、工厂、商场全部由国家统一经营，老百姓只需要在国家的农场、工厂、商场里快乐打工就行了。老百姓穿一样的，吃一样的，连结婚都是国家给安排。 大西国里有的知识分子认为这样治理国家太机器化了，有违人性。小王同志对这些知识分子很生气。 遥远的东方，有一个白鹿洞书院，书院的院长是个伟大的导师，这个人叫朱熹，此人提出了存天理、灭人欲的理论，给了小王同志治理国家理论上的支持。 于是小王同志大搞禁欲主义，凡是学习过陆九渊、王阳明心学理论的都抓起来改造。</p><p>不久，大西国经营的农场、工厂、商场就出了问题。效率特别低，老百姓出工不出力，胡干蛮干的比比皆是，后来出现了大饥荒，饿死了不少人。小王同志干不下去，被人赶走了。 新领导上台后，先把农场划分给农民，提高农民的积极性，先解决粮食问题。但是工厂、商场就比较不好办。 新领导认为，工厂、商场效益低，赔钱是因为负担太重了，城市里的老百姓生老病死都是由国家的工厂、商场负责，国家哪里管的起呢？ 于是新领导就提出给国家的企业减负，给点优惠政策，拿出胡萝卜，让胆子大愿意自己单干的同志们主动离开国家企业。对于很多死活不肯走的同志，新领导强令这些人卷铺盖，国家不再负担这些人的生老病死了。大家自己解决吧，国家不管了。 新领导把还留在国家企业的自己人，定义为内部人员。离开国家企业的，就是外人，定义为社会闲杂人等。 社会闲杂人等，有人欢喜有人忧。有人利用内部人员的关系，大把赚钱，有人跑去给外国人当洋买办赚的也不少，还有的知识分子凭着有点文化，给人打工生活的也不错，反正这些人都挺高兴，比在内部受穷强。当然也有没本事的，就比较惨，生活的比较困难。</p><p>新领导看见内部都是自己人了，闲杂人等都清理掉了，于是着手内部改革，凡是稀缺的，与老百姓生产生活密切相关的行业，都由内部来经营，不需要动脑子搞创新，只要定个价，老百姓就必须得接受。 而需要创新动脑子的产业，不具备稀缺性必须充分竞争的产业，不是跟老百姓生产生活密切相关的产业都交给社会闲杂人等去自由竞争。 相当于把肉都留给了内部自己，把骨头扔给了外部闲杂人员。 这样做还有个好处：新领导喜欢内部自己人直接跟外国人做生意，但是只要跟外国人做生意就赔钱，赔的还不是一点半点。赔的钱从哪里补呢？ 只要通过内部自己人经营的企业，抬高定价，将赔掉的钱转嫁给社会闲杂人等就可以了。 于是，当初离开内部的社会闲杂人等发现，钱也难赚了，生活成本也越来越高了，日子过得变得越来越艰难了。 这时有个傻空跳出来说：我就不信了，市场经济没有只涨不跌的商品。房价肯定会跌。 有个明白人告诉他：市场经济是分品种的。外部社会闲杂人等经营的电脑、电视是市场经济。但是内部人经营的石油、房地产不是市场经济。不能拿市场经济来解释。 这个傻空不信，本来在大西国能买房的，结果一直没买，后来买不起了，只好一直租房住。但是房租老涨价，吃饭越来越困难，一年难得吃两回肉。</p><h2 id="什么是好的政策"><a href="#什么是好的政策" class="headerlink" title="什么是好的政策"></a>什么是好的政策</h2><p>好的政策就象挂在驴子鼻子上的胡萝卜，让人永远有希望，但是拼命追也吃不到。这就是中国政治家的最高智慧。</p><p>洋人进北京，老佛爷把义和团推出来，结果拳匪搞的鸡飞狗跳，没法收场。 保钓也打算发动群众，靠爱国激情转嫁矛盾。不过好像这招不灵了。老板怎么对待员工，员工就会怎么回报老板。</p><h2 id="李商隐「渣男」祖师爷"><a href="#李商隐「渣男」祖师爷" class="headerlink" title="李商隐「渣男」祖师爷"></a>李商隐「渣男」祖师爷</h2><p>中秋节将至，撇开房地产的涨跌。喝一壶好酒，聊聊古人。</p><p>云母屏风烛影深，长河渐落晓星沉。 　　 嫦娥应悔偷灵药，碧海青天夜夜心。</p><p>借着中秋节的千古名句，我们八卦一下李商隐。 李商隐帅哥很有女人缘，据说谈了n多次荡气回肠的恋爱，不过这些恋爱经历没记录进正史，而是唐代的八卦记者通过李商隐帅哥的文学作品，侦破出来的。</p><p>李商隐帅哥不光会写诗，年轻人还在玉阳山修习过道术。但是当道士期间并没有认真的清修，以李帅哥的魅力，竟然吸引了一个美丽多情的女道士的目光。</p><p>这个女道士叫宋华阳，本来是个侍奉公主的宫女，跟随公主进山当了女道士。两人邂逅于山中，缠绵悱恻，但终究没有结果，宋美眉怀了李帅哥的宝宝，李帅哥也被轰下了山。但好像李帅哥也没负什么责任。</p><p>李帅哥伤痛的写下了“无题”以示纪念： 昨夜星辰昨夜风， 画楼西畔桂堂东。 身无彩凤双飞翼， 心有灵犀一点通。 隔座送钩春酒暖， 分曹射覆蜡灯红。 嗟余听鼓应官去， 走马兰台类转蓬。</p><p>李帅哥的第二个女朋友，被八卦记者们认为是锦瑟，锦瑟是谁？八卦记者们认为是令狐楚家的一个美丽温婉的侍女。</p><p>李帅哥很有才华，但是在晚唐时代，有点生不逢时。当时牛僧孺和李德裕搞党争，李帅哥跑去给牛党的重要人物令狐楚当幕僚，结果泡上了令狐大人的侍女。这个李帅哥和锦瑟谈恋爱的证据是根本没有。八卦记者是根据李帅哥的诗找到的蛛丝马迹。</p><p>这首诗就叫锦瑟。</p><p>锦瑟无端五十弦，一弦一柱思华年。 　　 庄生晓梦迷蝴蝶，望帝春心托杜鹃。 　　 沧海月明珠有泪，蓝田日暖玉生烟。 　　 此情可待成追忆，只是当时已惘然。</p><p>春 　　 风光冉冉东西陌，几日娇魂寻不得。 蜜房羽客类芳心，冶叶倡条遍相识。 　　 暖蔼辉迟桃树西，高鬟立共桃鬟齐。 雄龙雌凤杳何许？絮乱丝繁天亦迷。 　　 醉起微阳若初曙，映帘梦断闻残语。 愁将铁网罥珊瑚，海阔天宽迷处所。 　　 衣带无情有宽窄，春烟自碧秋霜白。 研丹擘石天不知，愿得天牢锁冤魄。 　　 夹罗委箧单绡起，香肌冷衬琤琤佩。 今日东风自不胜，化作幽光入西海。</p><p>夏 　　 前阁雨帘愁不卷，后堂芳树阴阴见。 石城景物类黄泉，夜半行郎空柘弹。 　　 绫扇唤风阊阖天，轻帏翠幕波洄旋。 蜀魂寂寞有伴未？几夜瘴花开木棉。 　　 桂宫流影光难取，嫣薰兰破轻轻语。 直教银汉堕怀中，未遣星妃镇来去。 　　 浊水清波何异源，济河水清黄河浑。 安得薄雾起缃裙，手接云輧呼太君。 　　</p><p>秋 　　 月浪衡天天宇湿，凉蟾落尽疏星入。 云屏不动掩孤嚬，西楼一夜风筝急。 　　 欲织相思花寄远，终日相思却相怨。 但闻北斗声回环，不见长河水清浅。 　　 金鱼锁断红桂春，古时尘满鸳鸯茵。 堪悲小苑作长道，玉树未怜亡国人。 　　 瑶琴愔愔藏楚弄，越罗冷薄金泥重。 帘钩鹦鹉夜惊霜，唤起南云绕云梦。 　　 璫璫丁丁联尺素，内记湘川相识处。 歌唇一世衔雨看，可惜馨香手中故。</p><p>冬 　　 天东日出天西下，雌凤孤飞女龙寡。 青溪白石不相望，堂上远甚苍梧野。 　　 冻壁霜华交隐起，芳根中断香心死。 浪乘画舸忆蟾蜍，月娥未必婵娟子。 　　 楚管蛮弦愁一概，空城罢舞腰支在。 当时欢向掌中销，桃叶桃根双姊妹。 　　 破鬟倭堕凌朝寒，白玉燕钗黄金蝉。 风车雨马不持去，蜡烛啼红怨天曙。</p><p>这是李帅哥写的燕台诗四首。 有个叫柳枝的美女，是洛阳大富翁的女儿，吟唱了这首诗后，就爱慕上了李帅哥。这个美女很大胆主动跟李帅哥约会，并没有嫌弃李帅哥没车没房，但不幸被李帅哥放了鸽子。李帅哥其实很喜欢这个柳枝，事后非常后悔，准备把失去的爱情找回来，但是柳枝已经给有权有势的大佬做了妾。</p><p>飒飒东风细雨来，芙蓉塘外有轻雷。 金蟾啮锁烧香入，玉虎牵丝汲井回。 　　 贾氏窥帘韩掾少，宓妃留枕魏王才。 春心莫共花争发，一寸相思一寸灰。</p><p>这首诗名为“无题”，写得是荷花。荷花是民间传说中李帅哥又一个女朋友的名字，也是李的初恋。美丽的荷花陪李帅哥进京赶考，半路上得了重病，李帅哥天天陪伴着她，但不幸的是，荷花还是香消玉损。李帅哥悲痛不已，常常以荷花为题，以纪念此段恋情。</p><p>李帅哥的才华，被节度使王茂元看中了，把女儿嫁给了这位帅哥。李帅哥娶了这位娇妻的同时，也给自己带来了麻烦。</p><p>原因是王茂元是李党的重要人物，而李帅哥的老师令狐楚却是牛党的重要人物。娶了王美人，李帅哥掉进了牛、李两党的夹缝，于是前途杯具了。</p><p>这个故事告诉我们，如果有个老大罩着你，日子过的还不错，就千万别轻易向老大的对手抛媚眼。否则，只能是杯具。</p><p>李帅哥尽管前途杯具了，但是跟娇妻王氏感情很好，王氏突然病逝，李帅哥伤痛万分，写下了“悼伤后赴东蜀辟至散关遇雪” 　　</p><p>剑外从军远，无家与寄衣。 　　 散关三尺雪，回梦旧鸳机。</p><p>无题 相见时难别亦难，东风无力百花残。 春蚕到死丝方尽，蜡炬成灰泪始干。 晓镜但愁云鬓改，夜吟应觉月光寒。 蓬山此去无多路，青鸟殷勤为探看。 　　 夜雨寄北 君问归期未有期，　　 巴山夜雨涨秋池。 　　 何当共剪西窗烛， 　　 却话巴山夜雨时。 　　 读这两首诗，第一个感觉就是李帅哥的用情之深，令人叹为观止；第二个感觉就是，其克女朋友的本事，也令人叹为观止啊</p><p>将近中秋，闲扯了一通李商隐，就以李商隐的无题结束这个闲话吧。</p><p>凤尾香罗薄几重，碧文圆顶夜深缝。 扇裁月魄羞难掩，车走雷声语未通。 曾是寂寥金烬暗，断无消息石榴红。 　　 斑骓只系垂杨岸，何处西南待好风。 　　 重帏深下莫愁堂，卧后清宵细细长。 　　 神女生涯元是梦，小姑居处本无郎。 　　 风波不信菱枝弱，月露谁教桂叶香。 　　 直道相思了无益，未妨惆怅是清狂。</p><h2 id="西五环内的别墅，是相当稀缺的资源"><a href="#西五环内的别墅，是相当稀缺的资源" class="headerlink" title="西五环内的别墅，是相当稀缺的资源"></a>西五环内的别墅，是相当稀缺的资源</h2><blockquote><p><strong>黎</strong>明中的星光：**</p><p>楼主，认真阅读您的帖子快两周了，以史为鉴，深入浅出，感觉受益匪浅！</p><p>这两天，也在为在北京买房子的事很纠结，请您指点一二：</p><p>为自住，我们最近要买房了，此前，已经关注一年了，一年中，看上的房子都翻了倍。</p><p>最近我们在西四环西五环之间选了一个低密度花园别墅，叠层，新房，小区面积不大，只有200多户，（第一期08年开盘，大约2万上下单价，已入住，这次是二期）。小区密度是1.0。一期为3到5层，2期为5层坡屋顶。小区本身绿化环境不错，堪称绿意盎然，对内部环境很满意，我们选的是1、2层叠层带小花园的房子，220平方米左右。 这个小区叫：“金隅—长安山麓”，您从网上可以查到。</p><p>目前价格均价37000元左右。年初开盘时31000左右。开发商的策略是每次小部分放量，慢慢卖，拉开每栋楼开盘时间。最近我们看上的这个，是8月份开盘的。</p><p>我们认为优点是： 1、低密度带花园；这在大都市太难得了。 2、周围绿色环境好，多。向北是香山方向，一路绿色。 3、距离石景山万达距离近，3公里左右吧。万达出现在哪里，哪里基本是一个商业服务中心了。</p><p>缺点是： 1、周围没有紧密连接大型服务超市，商场等。最近的沃尔玛在2公里以外。 2、周围环境还不够理想。饭后散步、娱乐休闲的地方几乎没有。</p><p>担忧和想咨询您的问题是： 1、现在出手买，是否太冒险？ 2、您对这个小区的前景判断如何？ 3、我有朋友说买市中心的高层更好，万一卖掉也方便。怕这里以后不好出手。</p><p>楼主，再次打扰，百忙中能帮分析下吗？不胜感谢！</p><p><strong>kkndme：</strong></p><p>关于西五环内的别墅，是相当稀缺的资源，相当于奢侈品，奢侈品是不会随着调控有大幅度的调整，可以参考收藏品的投资，收藏品的风险在于战乱发生或者**经济崩盘。</p></blockquote><h2 id="“奸臣”贾似道"><a href="#“奸臣”贾似道" class="headerlink" title="“奸臣”贾似道"></a>“奸臣”贾似道</h2><p>说一个存在争议的人物，这个人被宋史写入“奸臣传”，就是大名鼎鼎的贾似道。几乎所有人眼中的贾似道都是大奸贼的形象，仗着是贵妃的姐姐，由一个游手好闲不学无术的二流子，摇身一变成了飞扬跋扈的大汉奸。他贪污受贿，搜罗奇珍美女，蒙古人打过来媚外卖过，还向皇帝谎报军情，最后南宋在他手里灭亡。反正老百姓眼中奸臣能干的所有坏事，都安在了贾似道的头上，然而历史真的如此吗？</p><p>经过多方面史料对照，读书仔细的筒子会发现，宋史的说法并不可信，自相矛盾的地方太多，几乎可以说宋史几乎收罗的都是野史和民间传说。是什么原因使一部正史却采用了大量的野史资料呢？</p><p>原因只有一个，贾似道得罪的人太多。</p><p>贾似道得罪人的原因，在于推行了一个政策：公田法。推出的背景是连年征战，南宋需要庞大的军费开支。军费的开支从哪里来呢？当然是从最底层的农民的肚子挤出来。南宋的经济已经是非常困难了，巧妇难为无米之炊，于是zf推出了纸币，相当于给人民打白条，可见纸币并不是现在的专利。这就是恶性通货膨胀。眼看国家经济崩盘了。贾似道想的办法就是：公田法。</p><p>公田法的意思跟傻空说的把多军的财产充公的意思差不多，就是限制地主的田地，凡是超过标准的，超过部分的三分之一充公给zf，zf给佃农耕种，产出的粮食用于军粮。有点相当于物业税的意思。</p><p>就凭贾似道想出的这个政策，说贾似道是个不学无术的混混，说什么我也不会相信的。</p><p>贾的办法很大程度上缓解了南宋经济的彻底崩盘，延缓了南宋生存的时间，但是贾却得罪了几乎所有的地主士大夫阶层。</p><p>贾不是一个贤臣，但绝非二流子，政治上也许不够成熟，但是为了南宋的艰难维持也算是呕心沥血。关于向蒙古大军求和，也并不能就说明他是个汉奸，那样一个经济崩溃，军队毫无战斗力的朝廷，你让他硬着头皮打，下场也就相当于鸦片战争。当然，关于宋史里讲到的贾似道极尽献媚之能事，把汉奸表演得淋漓尽致，应当是士大夫出于地主阶层对公田法的憎恨，狂泼的屎盆子。因为宋史的记录实在是疑点颇多。</p><p>南宋的将领如范文虎、夏贵之流，才真是腐败透顶，拥兵自重，对抗元军极尽脚底抹油之能事，而贾似道能够亲自督师，所以说贾似道是个大汉奸，实在开玩笑有点过火。南宋灭亡了，元世祖抓了南宋投降的将领问话：你们为什么这么容易就投降了呢？</p><p>降将回答：都是贾似道，只重视文官，不重视我们，所以就投降了。</p><p>元世祖哈哈大笑：就你们这样的武将，贾似道能重视你们才怪。</p><p>贾似道最后被郑虎臣擅自给杀了。郑虎臣是个大地主，自己的利益被公田法害得不轻，恨透了贾似道。</p><p>贾似道死了，全体士大夫阶层拍手称快，并且把他列入了奸臣传，永世不得翻身。</p><p>全因为一个公田法。</p><h2 id="关于拆迁"><a href="#关于拆迁" class="headerlink" title="关于拆迁"></a>关于拆迁</h2><p>关于拆迁，我国只有一部91年颁布的拆迁管理条例，但是就是这个简单的东西，很多拆迁时并不遵守。</p><p>常规来说，拆迁应持有拆迁许可证，开发商的开发项目应通过规划局的审核（这个可以在规划局查到），如果连开发商是谁，有没有资格开发都不知道就奇怪了。</p><p>是否同意拆迁取决于拆迁户和拆迁方的博弈，但是拆迁补偿办法一定要具体详细，包括如何补偿，过渡期的约定，具体要有时间和操作办法，还要签订违约责任。关于协议不可能只留在拆迁方手中，这是不合法的。</p><p>暴利拆迁，zf侵害拆迁户的利益的例子比比皆是，关键是自己如何争取主动。</p><h2 id="保钓事件之死要面子活受罪"><a href="#保钓事件之死要面子活受罪" class="headerlink" title="保钓事件之死要面子活受罪"></a>保钓事件之死要面子活受罪</h2><p>保钓事件，既定对策就是争取更多小国穷国的舆论支持，减免他国债务，加大对外经济援助。钱的来源，要靠底层国民勒紧裤腰带。</p><p>自古以来，泱泱大国，威仪四海，对外“恩”显示国力强大，对内“威”显示权力强大，恩威并施，千古国策。</p><p>朱棣的恩泽海外，死要面子，是做的比较极致的。结果是国库空虚，人民吃饭一下成了问题。所以才有后来坚定的禁海。</p><p>如果开通海外贸易，不是为了皇帝的面子，而是为了充实国库和老百姓的腰包，明代的官僚就不会坚持禁海，中国的历史就会改写。</p><p>郑和下西洋，反而堵塞了中国通向大海的道路。</p><blockquote><p><strong>tjOOSAN</strong></p><p>我只能说，楼主不懂政治，就触及了。钓鱼岛就算所有您所谓的“小国”都支持。也没用啊。神经病 就是神经病</p><p><strong>kkndme</strong></p><p>这个做法不新鲜，从周恩来时期，我们的外交政策就是拉拢第三世界国家的选票，远到非洲拉美，近到越南缅甸柬埔寨，支援铁路基建，捐钱捐物，自认第三世界国家的带头人。但是第三世界国家基本有奶就是娘。比如拉美的苏里南，我国刚捐了钱物，米国给了点好处，马上又投向米国。</p><p><strong>tjOOSAN</strong></p><p>建议您看看nhk的中国力量。真实偷拍的中国在非洲都做了什么。</p><p>1、资源。铁矿石 2、建立国家通信网 3、人力。</p><p>呵呵。援助是拉拢，但是有条件的。</p><p>越南最新的高铁，由日本公司建设。中国从来没援建过越南。</p><p>唉。。。。你把中国当傻子了。</p><p><strong>kkndme</strong></p><p>周时代，越南的生产工具、军火、粮食，都是中国无偿援助。无知不可怕，无知还满嘴喷粪最可怕</p><p><strong>tjOOSAN</strong></p><p>呵呵！</p><p>援建越南？？！哪了？给我证据？！？</p><p>关于非洲，我给你们穿了视频！自己看就知道了</p><blockquote><p><strong>中年不惑吗</strong></p><p>还非洲的力量</p><p>当年红太阳把大米鸡蛋东方红拖拉机运到阿尔及利亚</p><p>换来的是“中国人民是我们最好的朋友”和对中国各种口头的声援</p><p>这和kkndme兄说的难道不一致吗</p><p>现在不给钱给物了</p><p>你还能听到“中国人民是我们最好的朋友”的说法吗？</p><p>拉拢非洲小兄弟，是具有政治意义的</p><p>你英国是一票，人家再穷的小国也是一票</p></blockquote><p><strong>kkndme</strong></p><p>你理解力看来真有问题，你哪只眼睛看到争取小国穷国的舆论支持里面，包括越南。</p><p>这个事是温总定的调子，挂在搜狐首页</p><p><strong>tjOOSAN</strong></p><p>中年！kk！！ 你们这两个同学啊！一看就跟成天上网的学生，没两样。争来争去。</p><p>哎呀，非要你赢他输。</p><p>唉。。。你说的怎么就对呢？？！证据！！明白吗？？光你自己打嘴炮。没用啊！</p><p>呵呵 我得出去玩会了</p><p>你们继续网络吧！~~ 两个宅男</p><p><strong>kkndme</strong></p><p>tjOOSAN你去图书馆查查当年的报纸，什么都清楚了。</p><p>典型的愚民政策教育出来的傻蛋。</p></blockquote><h2 id="中国的房地产不可能软着陆"><a href="#中国的房地产不可能软着陆" class="headerlink" title="中国的房地产不可能软着陆"></a>中国的房地产不可能软着陆</h2><p>中国的房地产不可能软着陆，甚至也不可能出现日本的硬着陆。一旦积蓄的问题爆发，会直接崩，崩的绝不会只是房地产。那时候绝对没有人会关心房价，很多人将庆幸于当天能够勉强填饱肚子，但绝不奢望还能见到第二天的日出。</p><blockquote><p><strong>xiangshangpa</strong></p><p>请教楼主，如果出现您说的大部分老百姓勉强甚至不能填饱肚子，房价没人关心的时候，也就是社会动荡的时候，作为您这样的中产以上的阶级，还没有移民，如何自保？我很感兴趣，谢谢！祝中秋快乐！</p><p><strong>kkndme</strong></p><p>这种事要静观其变，所谓山雨欲来风满楼，发生之前一定会有大的征兆。 自保是没**有办法的，只能看形势不对，脚底抹油。</p><p><strong>xxx</strong></p><p>按照我的理解，在发生很大征兆之前，党国就会采取措施，实施闭关锁国政策（倒回50年代），跑是跑不掉的，如果大量难民出去，也没有几个国家会接受，中产，富裕阶层也不例外，现在很多国家已经提高移民门槛了，我对这种情况的出现感到悲观，调适空间十分有限，权贵集团真的是永远无法满足，唉</p><p><strong>kkndme</strong></p><p>呵呵，人的命，天注定，自求多福吧。</p><p><strong>中年不惑吗</strong></p><p>我倒没有kkndme兄那么悲观</p><p>去看看美国20世纪30年代的新闻和文章</p><p>也是一片哀嚎</p><p>资本主义已经完蛋了，无可救药了</p><p>贫富差距太大，老百姓活不下去了</p><p>美国当时的知识界很多人都是向往苏俄模式的</p><p>左倾的名流非常多（包括卓别林和爱因斯坦等等）</p><p>即使到了20世纪50年代，美国还要搞麦卡锡主义</p><p>也说明了当年左倾很有市场</p><p>现在了，苏俄成为历史，资本主义反倒越活越精神了</p><p>还有就是如果在南北战争的时候想象一个黑人能当总统</p><p>人家肯定说你是凡尔纳</p><p>就是马丁路德的时候</p><p>也只是奢望能给黑人争取公平和权益 　　 社会进步总是靠人推进的</p><p>可以是谭嗣同蔡锷，也可以是邹容和陈天华</p><p>何必太悲观了</p><p>难道不是事在人为吗 　　 自己都不努力改变</p><p>怎么能埋怨前辈的选择错误不作为了</p></blockquote><h2 id="关于购买经济适用房"><a href="#关于购买经济适用房" class="headerlink" title="关于购买经济适用房"></a>关于购买经济适用房</h2><blockquote><p><strong>大学生007</strong></p><p>楼主你好，质询个问题： 我家要买个二手房，房子是经济适用房，房产证上写的是土地划拨，中介说买了之后就是商品房了，那买了以后房产证上写的还是不是划拨啊，如果以后遇到拆迁什么的是不是补偿跟人家正规商品房不一样啊？谢谢</p><p><strong>kkndme</strong></p><p>经济适用房需要补交土地款后才能上市销售，补交土地款后，就变成了商品房，所以不用担心。 购买经济适用房一定要把补交的地价款算进去，才知道房价是否高于或低于周边商品房楼盘。 我国房地产交易很不规范，特别是中介有很多办法欺骗客户，买房无论是自住还是投资都要多长几个心眼。</p></blockquote><h2 id="地级市买房"><a href="#地级市买房" class="headerlink" title="地级市买房"></a>地级市买房</h2><blockquote><p><strong>我是射手520</strong></p><p>楼主，您好。有幸看到您盖的楼，您对历史、政治和经济的研究让我如醍醐灌顶，很多隐约迷惑的东西，似乎有了出路能去寻找答案。万分感谢。 说到置业，您对一线二线城市谈的较多，想听听您对类似我们这样城市楼市和经济的看法。 我所在的是地级市，离您帖子提到的武汉有500公里。我所在的地市以汽车工业为主导，是三大汽车集团其中之一的发源地，目前是该企业的商用车基地。 在全省范围，离省会最远，但是在城市建设、居民生活水平、物价和房价可以排在全省前面，以前分析是因为我们这里是以工业为主，故经济发展比其他以农业为主的地市发展的要好，看了楼主的帖子，感觉跟离武汉最远也有关系。 我们当地最贵房价从05年前2000以内，到09年3000-4000元，到今年的5000元，最贵的6000元。 房价的飙升一方面随着全国大环境有关，我分析同时跟当地政府的发展思路密不可分，05年开始引进外地大开发商，新修了很多路，其中跟旧城区主干道平行的最重要的一条路，随着市政府入住，体育馆、美术馆，大开发商进驻，经过5年发展，该路段已经成为我们这里房价最贵的一条路，我们是小城市，在这里买房子的，除了投机成分以外，大部分应该是改善型住房，要大型小区，要绿化，这条路目前房子也是越盖越高。通过建设，当地政府财政也充裕，明显感觉对市政投入也大多了。 我们这里养老还是不错的，山多，空气好，工业城市，经济发展也交好。 我目前的置业状况是，在老城区广场旁边有单位分高层住宅一套，虽然是塔楼，但在广场旁边，弱化了容积率高，当年放弃了单位地段相对没这个中心，总价低的多层住宅，就是看中了地段，这个投资较成功，按照现在市价，房屋总价基本翻番，该房屋目前由父母住。 08年底，在开始说的新地段够买一套房屋，120平米，多层住宅，周边政府规划为大学城，周边有两所大专院校，对于该房屋地段较为满意，虽然比不上新修的路的北边和中部靠近体育馆，靠近政府地段升值快，但较看好该地段前景，该地段新修了 一条连接老城区的通道，唯一不太满意是购买的顶楼，因为是购买的该小区的多层住宅没有电梯，如果有了孩子，住顶楼生活就不太方便。购入均价2900，目前周边的新盘均价4500元，该楼盘创造了摇号去选房的记录。该套房屋自住，当年购买房屋没有多贷款一步到位，现在如果想换个满意的难度就大的多，满意的房屋都5000往上了。这套房屋有15万左右的贷款。 虽然很看好武汉的楼盘，远远现阶段大于经济承受能力，目前放弃。 对于我们当地的楼盘，也超出了我们这种普通人的能力，虽然最近楼盘都卖的很火。 好在单位公积金较多，我打算收复30%，剩下用公积金贷款，再购置一套房屋，怕再过一段时间，我的改善型需求就满足不了。 前一段时间，有个机会，但是考虑按照目前房价，30%首复，要耗尽目前自己和家人积蓄，犹豫中，错过了机会。 目前这种状况，不知道是否该再次买房？ 再次买房考虑标准时什么？我不太喜欢高层，但是原中心城区，没有大盘，都是单位或者小开发商盖的，基本没有绿化，在中心城区边上也有了一套高层住宅。 考虑学位房？我们城市不大，目前这套中心城区房屋虽然没有画片在最好的小学中学，但是离这些学校距离比较近。 在靠近那条政府搬入的路的北边靠近体育馆、美术馆（同时也靠近两所重点高中）地方置业，那里房价已经5000多，年底开盘的都是30层以上的高层，自住又不太考虑高层，总价也超出了承受范围。 在当地，离那个大企业居住地，区政府也新开了一条路，那条路待开发状态，据说区政府要搬过去（要搬也是2年以后，现在那条路只有一个大开发商在开发），那条路开车到市中心20分钟，那次有机会买的就是那个大开发商的楼盘，主推多层住宅并且带电梯，去年就预售完毕，这次犹豫中，错过了，住宅品质较好，目前地段太偏。 如果再有机会，该如何选择呢？</p><p><strong>kkndme</strong></p><p>地级市选房是比较麻烦的，因为投资风险要大于一线城市和省会城市。 地级市的购房需求，主要是以改善性需求为主，追求的是大盘，低密度，低楼层，高绿化，最好有个江景或者水景，环境优美的别墅是首选。 因为低级市城市较小，绝对的城中心如果环境比较嘈杂，小区不够高档最好不要选择。没有实力购置别墅，可以选择环境优美的高端住宅，最好是品牌大盘，一眼能够让人赏心悦目。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 摘录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>秦阳：一个PPT主义者的成长故事</title>
      <link href="/archives/219cebd.html"/>
      <url>/archives/219cebd.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>这不是一本书，而是秦老师做的一次分享，内容十分精彩，推荐给大家观看。下面是我做的观看笔记。</strong></p><p><a href="https://v.qq.com/x/page/c038161348x.html">https://v.qq.com/x/page/c038161348x.html</a></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/457829/1633862515242-d7a8bb84-24cf-4587-bbd1-d26389242a54.png" alt="img"></p><span id="more"></span><h2 id="九大主义"><a href="#九大主义" class="headerlink" title="九大主义"></a>九大主义</h2><ol><li>结构化思考（思考能力）</li><li>视觉化表达（视觉能力）</li><li>故事化演绎（说写能力）</li><li>生活化学习（学习能力）</li><li>价值化连接（连接能力）</li><li>迭代化精进（迭代能力）</li><li>通用化延伸（延伸能力）</li><li>百分化体验（行动能力）</li><li>平台化整合（整合能力）</li></ol><h2 id="1-结构化思考"><a href="#1-结构化思考" class="headerlink" title="1. 结构化思考"></a>1. 结构化思考</h2><hr><p><strong>关键词：</strong>#碎片化学习  #体系  #挖坑</p><p><strong>如何提升自己的结构化思维能力？</strong></p><p><strong>体系 → 长文 → 写作</strong>（由浅到深的一个过程）</p><h3 id="▌体系"><a href="#▌体系" class="headerlink" title="▌体系"></a>▌体系</h3><p><strong>如何构建自己的体系？</strong></p><p>给自己<strong>挖坑</strong>，将信息填到坑中。我们给自己挖了什么坑，看到的就是什么。</p><p>护宇：如果只给自己挖一个坑，就很容易陷入单一思维。比如学习《工作型PPT》，如果只给自己挖了学习PPT技巧的坑，那你就学不到课程开发、以及如何把一个知识点讲清楚这类的知识。</p><p><strong>如何构建一门知识的体系？</strong></p><p>动态的意识，不断更新不断淘汰不断深化。</p><p><strong>体系学习法：****构建体系 → 获取信息 → 实践体验 → 整理/纳入。</strong>这是一个循环，从哪步开始并不重要。</p><p>护宇：体系有时候不是一步到位的，可以迭代精进，先有个1.0版本，之后再有2.0版本、3.0版本……</p><h3 id="▌长文"><a href="#▌长文" class="headerlink" title="▌长文"></a>▌长文</h3><p><strong>不知道写什么怎么办？</strong></p><p>生活记录、书评影评、时事评论、收获感悟、经验总结、为图配文、留言互动、伙伴合作（来自严歌苓《一个写稿佬的生涯》）……</p><p>上课时，我们的同学都是坐成一个圈，十二个同学，老师坐在中间，然后他就说，某某某，你出一个词儿。被点名的同学先出一个名词，然后 老师叫第二个人说你接一个动词，接了一个动词以后他就说，用任何一 个你想到的最最独特的一个动词来让这个名词动起来。这样一种训练就 是首先是他告诉你什么能使文章变得非常有活力的、非常有动作的、非 常往前走的，走得比较快的是动词而不是形容词。</p><p>老师老是教我们看着它，直到看见它，看见它的形状，Do you smell anything？你闻到了吗，你嗅到了吗？调动的是你所有的感官，来把这 个故事往下进行。</p><p>为什么我现在写小说的画面感很强，我觉得这是跟我们学校的训练是很 有很有关系的。写一个东西要有质感。这段文字你写出的一个场景，要 有质感，最好还有触感，就是说有六种感觉都有，六种感官都有。”</p><p>——严歌苓《一个写稿佬的生涯》</p><p><strong>这些怎么感觉都是零碎的东西？</strong></p><p>长文章不是一蹴而就的，就像拍电影，不是一下子拍完了所有场景，而是抓住一条主线，把场景串起来。</p><p>提示：长文章可以是之前积累内容的串联过程，不是非要在一晚上就写完。</p><h3 id="▌写书"><a href="#▌写书" class="headerlink" title="▌写书"></a>▌写书</h3><p><strong>把写书当成一个过程，而不是结果。</strong></p><p>护宇：</p><p>老秦对于很多知识都有自己的分类文件夹，比如IP，社群营销等，而其中已经有6个真的实现了出书！</p><p>他会把所看所学的内容整合到每个文件夹中，等到抓住某个时机，比如近段时间IP很火，能够以非常快的速度出书。</p><p>在以出书的思维锻炼自己时，结构化思考的能力，相对于写长文提升更快，因为要注意的内容更多了，不再是像长文中只用关注几个段落，写书面对的章与章、章与全书的联系。</p><p><strong>总结：多学思路，少记套路。</strong>通过结构视角观世界，带着独立思考过人生。</p><h2 id="2-视觉化表达"><a href="#2-视觉化表达" class="headerlink" title="2. 视觉化表达"></a>2. 视觉化表达</h2><hr><p><strong>1）美是第一感受</strong></p><p><strong>2）岂止于美，重要的是让听众理解并记住</strong></p><ul><li>PPT辅助理解与记忆（制作完成后，问自己，我可以记住吗？）</li></ul><p><strong>3）除了PPT，也有很多东西需要视觉化</strong></p><p><strong>对别人视觉化：</strong>公开用PPT演讲的场合，少之又少，更多的是生活中的口头沟通与表达，纯粹的文字语言里藏着生动的场景画面。</p><p><strong>对自己「视觉化」：</strong>增强自我激励的功效（讲到自己在参加全国比赛时，将全国冠军的头P成自己的，顺便还把老师也P进去了，让自我激励更加具象，心理作用↑）</p><p><strong>4）如何提升自己的视觉化表达能力？</strong></p><p>关键词：<strong>眼界</strong>（拓宽眼界，重复内化）</p><p>打开眼界，从一个点扩展出来，将自己的思维扩展</p><p>护宇：老秦由一个包装设计体会到图片裁剪/局部的力量，而非单纯地学到把一张图片放在幻灯片两边可以带来更好的展示效果。其实就是透过现象看到更深层次的东西。</p><p><strong>Q：发现自己在看完之后还是很容易忘记……</strong></p><p>A：举了小马哥从锅炉工到创意总监的故事。</p><p>收集精品 → 分类整理 → <strong>烂熟于心 → 持续刺激</strong></p><p>我们大多数人只做到前2步。</p><p>我用了一个笨办法，和同事用半个月的时间把德国的一本世界级广告创 意杂志十年来的作品从网上全部下载下来，一共是20000个顶尖的创意 作品，我又用了近一个月的时间，把他们分门别类整理成了10个PPT。</p><p>而我则把这20000个创意反复看了三遍以上。当我看完了这些创意后， 我发现，其实市面上大部分广告，创意方法都是来自这些经典的创意， 无非变变形式而已。</p><p>同时，我也收集了世界上最经典的文案，全部抄写了一遍。大部分经典 的文案我都是背诵或者能够够复述。这时，你写文案的时候就有了各种 不同题材和思路帮你。而我个人也在从事广告的6年间每天保持着阅读 10个以上广告案例的习惯。”</p><p>——小马宋《从锅炉工到创意总监》</p><p><strong>提炼版：</strong></p><p>1）收集十年来的20000个顶尖的创意作品</p><p>2）分门别类整理成了10个PPT</p><p>3）反复看了三遍以上</p><p>4）收集世界上最经典的文案，全部抄写了一遍</p><p>5）大部分经典的文案都能背诵或者复述</p><p>6）从事广告的6年间每天保持着阅读10个以上广告案例</p><h2 id="3-故事化演绎"><a href="#3-故事化演绎" class="headerlink" title="3. 故事化演绎"></a>3. 故事化演绎</h2><hr><p>会讲道理的人，永远打不过会讲故事的人。</p><p><strong>如何提高讲故事的能力？</strong></p><p>推荐书籍：《小说课》。</p><ol><li>目标：主人公的目标是什么？</li><li>阻碍：他的阻碍是什么？</li><li>努力：他如何努力？</li><li>结果：结果如何？（通常是不好的）</li><li>意外：有超越努力的意外，可以改变这一切吗？</li><li>转弯：意外发生，情节如何转变？</li><li>结局：最后的结局是什么？</li></ol><p><strong>结果发现，积累了很多讲故事的模板，还是讲不好……</strong></p><p>Why？缺素材！</p><p>故事的种类：</p><p><strong>1）自己的</strong>：经历多、爱折腾、记性好（注意细节）</p><p><strong>2）别人的：</strong>听的多、看的多、聊的多（讲出彩的）</p><p><strong>3）虚构的：</strong>想象力、好奇、脑洞（要有圆满的逻辑，能够回到你要想讲的道理或某个点上）</p><p><strong>总结：深入浅出，似非而是。</strong>从别人的演说中思考，在自己的故事里成长。</p><h2 id="4-生活化学习"><a href="#4-生活化学习" class="headerlink" title="4. 生活化学习"></a>4. 生活化学习</h2><hr><p><strong>正向：</strong>一开始借书看，发现大多都是技巧教学，学了不知道干嘛，比如如何改模板等，讲的东西不实用，不知如何应用（从0 → 1，看不到结果）</p><p><strong>逆向</strong>：尝试从1 → 0，从后往前推，结果直观，保持学习过程不枯燥（有目标，知道自己在往这个点靠近，学习是为了呈现某个结果），每一步都在接近结果，兴趣和动力更足。</p><p>在哪里学习并不重要，关键在于了解自己的结果在哪里，能否拆解出要做的操作和基本功。</p><p>护宇：我觉得自己可以利用自己整理的PPT灵感库啊，这里面都是结果，我能从1到0的去学习。另外，说到拆解出要做的操作和基本功，《工作型PPT》这门课体现得淋漓尽致啊……</p><p><strong>如何提高「生活化学习」的敏感度？</strong></p><p>挖坑挖得深 + 学习体系建立 → 提高敏感度</p><p><strong>总结：取之生活，用于生活</strong>有一颗持续学习的心态，就时刻拥有学习的平台。</p><h2 id="5-价值化连接"><a href="#5-价值化连接" class="headerlink" title="5. 价值化连接"></a>5. 价值化连接</h2><hr><p>有一项拿的出手的本事，进行价值互换。问世界要什么之前，先想想我有什么，因此能换到什么。</p><p>对人一块一，对物九毛九（从PPT定制得到的启示）。一件东西值一块钱砍到九毛九，东西品质不会变，如果一个人的服务值，1.1砍到0.99，虽然成交了，得到的服务却可能变了（启示：应该给予应有的价值肯定）</p><p><strong>「我有什么！」→ 「我要有粉丝量！」</strong></p><p>提到自己用PPT技能、书籍，通过在微博课堂开课，转发打卡，达到一定量换书的形式吸引粉丝，随后成功勾搭到秋叶大叔的例子。</p><p><strong>「我有什么！」→ 「我要进华艺！」</strong></p><p>讲述自己进入华艺之前和在华艺工作的经历。进入华艺之前，通过一条微博读书笔记PPT（老杜出的一本书），成功勾搭到老杜，求职成功！在华艺工作，想学营销的知识，没人教，主动要求帮公司们做PPT（沟通、旁听学习）。</p><p>进了华艺工作之后，发现每天的主要工作就是做PPT。但老秦不满足于这样的现状，他想学关于营销市场方面的知识。但是没有人会主动教你的。所以他再次借用了自己会PPT的这个技能，主动帮同事做PPT。那做ppt的话，需要了解一些关于这个领域的知识，所以老秦就以此为缘由，参加这些同事的会议啊什么的，一开始就是旁听，后来懂得多了也能帮助做一些事情。</p><p>护宇：这里面有些细节挺有意思。老秦在读书笔记做完之后，并不是简单地发出去，@然后就完了。他@的人都是有选择的，要么跟老杜有关，要么跟这本书有关（比如这本书是湛庐文化出的，他也@了），而且粉丝量选择在5万以下（大V你是撬不动的，别人根本看不到你的互动）。</p><p><strong>「我有什么！」→ 「我要扩圈子！」</strong></p><p>护宇：老秦之前上过TED，TED里面有个教练组，他就说自己能够提供思维和PPT制作方面的东西，就加入进去了。每个去TED演讲的人，都要经过教练组的培训，借此机会认识了各行各业的精英。</p><p><strong>总结：工具用到极致就是神器，自身价值方为连接底气。</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/457829/1633863461284-31d21177-f938-49e8-ac34-1c898eecb4f6.png" alt="img"></p><h2 id="6-迭代化精进"><a href="#6-迭代化精进" class="headerlink" title="6. 迭代化精进"></a>6. 迭代化精进</h2><hr><p><strong>如何提高不断迭代进步的「动力」？</strong></p><p>1）<strong>兴趣爱好</strong></p><p>2）为一个目标找到<strong>多重意义</strong>（动力 ↑，回报↑）</p><p>3）不服，是人类进步的意义（<strong>不服精神</strong>）</p><p>4）承诺，倒逼自己成长（<strong>承诺倒逼</strong>）</p><p>5）某些经历带来的思维习惯（<strong>思维习惯</strong>）</p><p>6）<strong>建加油站</strong>（找些东西激励自己）</p><p><strong>举例：讲述自己出书的过程</strong></p><p>打印了一本自己的自传 → 整理者 → 20页 → 秋叶 秦阳 → 秦阳 秋叶 → ？</p><p>写书最大的经验：快写慢改（建立全局观）。</p><p>护宇：比如老秦会在一周内把这个书全部写一遍，之后带着问题去吸收和借鉴自己所需要的东西。其实我帮老秦做事情也是啊。一开始在小密圈因为写东西逻辑性还可以，就开始写推文，之后接到修改《微信营销与运营》第2版修改这样的角色（可惜聊天记录没有了……以后还是要记得及时截图保存啊），现在是“时间管理”图书的整理者这样的角色，也许未来我也可以出一本自己的书呢，我觉得老秦会给我这样的机会的！</p><p><strong>总结：持续复盘，积累复利</strong>（不断积累，获得充裕回报）每天进步一点点，每次接近一丢丢。</p><h2 id="7-通用化延伸"><a href="#7-通用化延伸" class="headerlink" title="7. 通用化延伸"></a>7. 通用化延伸</h2><hr><p><strong>从哪些角度进行延伸？</strong></p><p>横、纵、深</p><p><strong>横向：</strong></p><p><strong>举例1：PPT</strong><br>PPT → PS、AI、CDR……（不同的软件存在相似功能）</p><p>PPT：店铺装修、海报……（都涉及到版式等内容，不一定要用PS来呈现）</p><p>结构化思维、视觉化表达</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/457829/1633863681554-4dd4b819-b656-4ca3-ab8c-274fd88d7646.png" alt="img"></p><p><strong>举例2：微博</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/457829/1633863710040-de5c1fbd-aee2-4629-9dd8-4d74735ddfd1.png" alt="img"></p><p><strong>举例3：公众号</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/457829/1633863747167-32500887-d159-4947-b40d-7f7396979fdb.png" alt="img"></p><p><strong>如何扩大自己的知识域？</strong></p><p>1）增加知识点的连接次数（积极思考）</p><p>2）扩大知识点的储藏个数（拒绝单一思维）</p><p><strong>如何成为一个斜杠青年？</strong></p><p>成为斜杠青年最快的方法：深挖一个领域，延伸出很多的应用场景，然后进行交错。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/457829/1633863598104-cc8e0ff5-7c03-4691-9f07-3b83e9baed64.png" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/457829/1633863616622-9c8d48a4-52b9-4c87-a70a-67ce045a0279.png" alt="img"></p><p><strong>总结：从点到面，纵横交错。</strong>挖掘背后支撑的底层逻辑，找到多元通用的应用场景</p><p><strong>护宇：关于通用化延伸，更详细的说明</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/457829/1633863572174-ec2509bd-dc41-464a-9683-17d60ce766a8.png" alt="img"></p><p><strong>1、具体内容</strong></p><p>延伸具体包括三个方面：横向 深向 纵向</p><p>1）横向：同类型的、类似的选题</p><p>2）深向：同选题的继续深挖，创作出更多的深度和高度</p><p>3）纵向：与其他领域进行碰撞，找到另外的跨界角度</p><p><strong>总结：看到一个点，延伸出线，进而成为很多面。</strong></p><p><strong>2、案例展示（By 伟崇）</strong></p><p><strong>原选题：《PPT七大搞笑操作，你挨了几枪？》</strong></p><p>横向：《Word七大搞笑操作，你又挨了几枪？》</p><p>深向：《PPT动画四大搞笑操作，你挨了几枪？》</p><p><strong>原选题：《目录页万能设计公式》</strong></p><p>横向：《封面页万能设计公式》、《转场页万能设计公式》、《结束页万能设计公式》</p><p>深向：《商务风目录页如何制作》、《学术风目录页设计大全》、《政党风目录页设计》</p><p>纵向：《跟网站学目录页的制作》、《从地铁海报学习到的目录页技巧》</p><p><strong>原选题：《PPT图片4大处理细节》</strong></p><p>横向：《PPT图标3大细节处理》、《PPT文字4大处理细节》、地图，表格，图表…..</p><p>纵向：《跟发布会学习图片处理》</p><h2 id="8-百分化体验"><a href="#8-百分化体验" class="headerlink" title="8. 百分化体验"></a>8. 百分化体验</h2><hr><p>1）好的开始带动后续一连串的“好事情”</p><p>2）目标越高，所需时间越长，根据实际需求，制定合理目标</p><p>护宇：比如你只是想在工作中更顺手的使用PPT，那么几十个小时的学习完全够了，但是如果你想卖模板，或者接定制，那么你需要付出更多的努力</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/457829/1633863507649-2cfacdaf-d3b7-4fe6-877f-58fae19ee65b.png" alt="img"></p><p><strong>1%的意义何在？</strong></p><p><strong>最小行动</strong>。尝试1%，觉得可行，继续；不行，放弃；这是一个试错的过程</p><p><strong>过去发生的一切都是今天的铺垫。</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/457829/1633863531027-2658cccb-7d3c-479b-b065-2c9269d52279.png" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/457829/1633863551172-1cc7eda7-7273-429d-9c6f-cce3a14840a3.png" alt="img"></p><p><strong>总结：走着走着，花就开了。</strong>对眼前的事全力以赴，顺其自然呈现下一步</p><h2 id="9-平台化整合"><a href="#9-平台化整合" class="headerlink" title="9. 平台化整合"></a>9. 平台化整合</h2><p><strong>可能是工具的整合，人脉的整合、平台的整合</strong></p><p>护宇：就像我写论文，会用到Excel、Word、知网、谷歌、印象笔记等。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>马丁路德金演讲</title>
      <link href="/archives/b2b34ea4.html"/>
      <url>/archives/b2b34ea4.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>I am happy to join with you today in what will go down in history as the greatest demonstration for freedom in the history of our nation.</p><p>Five score years ago, a great American, in whose symbolic shadow we stand today, signed the Emancipation Proclamation. This momentous decree came as a great beacon light of hope to millions of Negro slaves who had been seared in the flames of withering injustice. It came as a joyous daybreak to end the long night of bad captivity.</p><p>一百年前，一位伟大的美国人签署了《解放黑奴宣言》，今天我们就是在他的雕像前集会。这一庄严宣言犹如灯塔的光芒，给千百万在那摧残生命的不义之火中受煎熬的黑奴带来了希望。它之到来犹如欢乐的黎明，结束了束缚黑人的漫长之夜。</p><span id="more"></span><p>But one hundred years later, the Negro still is not free. One hundred years later, the life of the Negro is still sadly crippled by the manacles of segregation and the chains of discrimination. One hundred years later, the Negro lives on a lonely island of poverty in the midst of a vast ocean of material prosperity. One hundred years later, the Negro is still languished in the corners of American society and finds himself an exile in his own land. And so we’ve come here today to dramatize a shameful condition.</p><p>然而一百年后的今天，我们必须正视黑人还没有得到自由这一悲惨的事实。一百年后的今天，在种族隔离的镣铐和种族歧视的枷锁下，黑人的生活备受压榨；一百年后的今天，黑人仍生活在物质充裕的海洋中一个穷困的孤岛上；一百年后的今天，黑人仍然萎缩在美国社会的角落里，并且，意识到自己是故土家园中的流亡者。今天我们在这里集会，就是要把这种骇人听闻的情况公之于众。</p><p>In a sense we’ve come to our nation’s capital to cash a check. When the architects of our republic wrote the magnificent words of the Constitution and the Declaration of Independence, they were signing a promissory note to which every American was to fall heir. This note was a promise that all men, yes, black men as well as white men, would be guaranteed the “unalienable Rights” of “Life, Liberty and the pursuit of Happiness.” It is obvious today that America has defaulted on this promissory note, insofar as her citizens of color are concerned. Instead of honoring this sacred obligation, America has given the Negro people a bad check, a check which has come back marked “insufficient funds.”</p><p>就某种意义而言，今天我们是为了要求兑现诺言而汇集到我们国家的首都来的。我们共和国的缔造者草拟宪法和独立宣言时，曾以气壮山河的词句向每一个美国人许下了诺言，他们承诺给予所有的人以不可剥夺的生存、自由和追求幸福的权。就有色公民而论，美国显然没有实践她的诺言。美国没有履行这项神圣的义务，只是给黑人开了一张空头支票，支票上盖上“资金不足”的戳子后便退了回来。</p><p>But we refuse to believe that the bank of justice is bankrupt. We refuse to believe that there are insufficient funds in the great vaults of opportunity of this nation. And so, we’ve come to cash this check, a check that will give us upon demand the riches of freedom and the security of justice.</p><p>但是我们不相信正义的银行已经破产，我们不相信，在这个国家巨大的机会之库里已没有足够的储备。因此今天我们要求将支票兑现这张支票——将给予我们宝贵的自由和正义的保障。</p><p>We have also come to this hallowed spot to remind America of the fierce urgency of Now. This is no time to engage in the luxury of cooling off or to take the tranquilizing drug of gradualism. Now is the time to make real the promises of democracy. Now is the time to rise from the dark and desolate valley of segregation to the sunlit path of racial justice. Now is the time to lift our nation from the quicksands of racial injustice to the solid rock of brotherhood. Now is the time to make justice a reality for all of God’s children.</p><p>我们来到这个圣地也是为了提醒美国，现在是非常急迫的时刻。现在决非侈谈冷静下来或服用渐进主义的镇静剂的时候。现在是实现民主的诺言的时候。现在是从种族隔离的荒凉阴暗的深谷攀登种族平等的光明大道的时候，现在是向上帝所有的儿女开放机会之门的时候。</p><p>It would be fatal for the nation to overlook the urgency of the moment. <strong>This sweltering summer of the Negro’s legitimate discontent will not pass until there is an invigorating autumn of freedom and equality.</strong> Nineteen sixty-three is not an end, but a beginning. And those who hope that the Negro needed to blow off steam and will now be content will have a rude awakening if the nation returns to business as usual. And there will be neither rest nor tranquility in America until the Negro is granted his citizenship rights. The whirlwinds of revolt will continue to shake the foundations of our nation until the bright day of justice emerges.</p><p>如果美国忽视时间的迫切性和低估黑人的决心，那么，这对美国来说，将是致命伤。<strong>自由和平等的爽朗秋天如不到来，黑人义愤填膺的酷暑就不会过去。</strong>1963年并不意味着斗争的结束，而是开始。有人希望，黑人只要撒撒气就会满足；如果国家安之若素，毫无反应，这些人必会大失所望的。黑人得不到公民的权利，美国就不可能有安宁或平静；正义的光明的一天不到来，叛乱的旋风就将继续动摇这个国家的基础。</p><p>But there is something that I must say to my people, who stand on the warm threshold which leads into the palace of justice: In the process of gaining our rightful place, we must not be guilty of wrongful deeds. <strong>Let us not seek to satisfy our thirst for freedom by drinking from the cup of bitterness and hatred. We must forever conduct our struggle on the high plane of dignity and discipline. We must not allow our creative protest to degenerate into physical violence. Again and again, we must rise to the majestic heights of meeting physical force with soul force.</strong></p><p>但是对于等候在正义之宫门口的心急如焚的人们，有些话我是必须说的。在争取合法地位的过程中，我们不要采取错误的做法。<strong>我们不要为了满足对自由的渴望而抱着敌对和仇恨之杯痛饮。我们斗争时必须求远举止得体，纪律严明。我们不能容许我们的具有崭新内容的抗议蜕变为暴力行动。我们要不断地升华到以精神力量对付物质力量的崇高境界中去。</strong></p><p>The marvelous new militancy which has engulfed the Negro community must not lead us to a distrust of all white people, for many of our white brothers, as evidenced by their presence here today, have come to realize that their destiny is tied up with our destiny. And they have come to realize that their freedom is inextricably bound to our freedom.We cannot walk alone.</p><p>现在黑人社会充满着了不起的新的战斗精神，但是我们却不能因此而不信任所有的白人。因为我们的许多白人兄弟已经认识到，他们的命运与我们的命运是紧密相连的，他们今天参加游行集会就是明证；他们的自由与我们的自由是息息相关的。我们不能单独行动。</p><p>And as we walk, we must make the pledge that we shall always march ahead.We cannot turn back.</p><p>当我们行动时，我们必须保证向前进。我们不能倒退。</p><p>There are those who are asking the devotees of civil rights, “When will you be satisfied?” We can never be satisfied as long as the Negro is the victim of the unspeakable horrors of police brutality. We can never be satisfied as long as our bodies, heavy with the fatigue of travel, cannot gain lodging in the motels of the highways and the hotels of the cities. We cannot be satisfied as long as the Negro’s basic mobility is from a smaller ghetto to a larger one. We can never be satisfied as long as our children are stripped of their selfhood and robbed of their dignity by signs stating “for whites only.” We cannot be satisfied as long as a Negro in Mississippi cannot vote and a Negro in New York believes he has nothing for which to vote. No, no, we are not satisfied, and we will not be satisfied until “justice rolls down like waters, and righteousness like a mighty stream.”</p><p>现在有人问热心民权运动的人，“你们什么时候才能满足？<strong>只要黑人仍然遭受警察难以形容的野蛮迫害，我们就绝不会满足。只要我们在外奔波而疲乏的身躯不能在公路旁的汽车旅馆和城里的旅馆找到住宿之所，我们就绝不会满足。只要黑人的基本活动范围只是从少数民族聚居的小贫民区转移到大贫民区，我们就绝不会满足。只要密西西比仍然有一个黑人不能参加选举，只要纽约有一个黑人认为他投票无济于事，我们就绝不会满足。不！我们现在并不满足，我们将来也不满足，除非正义和公正犹如江海之波涛，汹涌澎湃，滚滚而来。</strong></p><p>I am not unmindful that some of you have come here out of great trials and tribulations. Some of you have come fresh from narrow jail cells. And some of you have come from areas where your quest – quest for freedom left you battered by the storms of persecution and staggered by the winds of police brutality. You have been the veterans of creative suffering. Continue to work with the faith that unearned suffering is redemptive. Go back to Mississippi, go back to Alabama, go back to South Carolina, go back to Georgia, go back to Louisiana, go back to the slums and ghettos of our northern cities, knowing that somehow this situation can and will be changed.</p><p>我并非没有注意到，参加今天集会的人中，有些受尽苦难和折磨；有些刚刚走出窄小的牢房，有些由于寻求自由，曾在居住地惨遭疯狂迫害的打击，并在警察暴行的旋风中摇摇欲坠。你们是人为痛苦的长期受难者。坚持下去吧，要坚决相信，忍受不应得的痛苦是一种赎罪。让我们回到密西西比去，回到阿拉巴马去，回到南卡罗来纳去，回到佐治亚去，回到路易斯安那去，回到我们北方城市中的贫民区和少数民族居住区去，要心中有数，这种状况是能够也必将改变的。</p><p>Let us not wallow in the valley of despair, I say to you today, my friends.And so even though we face the difficulties of today and tomorrow, I still have a dream. It is a dream deeply rooted in the American dream.</p><p>我们不要陷入绝望而不克自拔。朋友们，今天我对你们说，在现在和未来，我们虽然遭受种种困难和挫折，我仍然有一个梦想。这个梦想是深深扎根于美国的梦想中的。</p><p>I have a dream that one day this nation will rise up and live out the true meaning of its creed: “We hold these truths to be self-evident, that all man are created equal.”</p><p><strong>我梦想有一天，这个国家会站立起来，真正实现其信条的真谛：“我们认为这些真理是不言而喻的——人人生而平等。”</strong></p><p>I have a dream that one day on the red hills of Georgia, the sons of former slaves and the sons of former slave owners will be able to sit down together at the table of brotherhood.</p><p>我梦想有一天，在佐治亚的红山上，昔日奴隶的儿子将能够和昔日奴隶主的儿子坐在一起，共叙兄弟情谊。</p><p>I have a dream that one day even the state of Mississippi, a state sweltering with the heat of injustice, sweltering with the heat of oppression, will be transformed into an oasis of freedom and justice.</p><p>我梦想有一天，甚至连密西西比州这个正义匿迹，压迫成风的地方，也将变成自由和正义的绿洲。</p><p>I have a dream that my four little children will one day live in a nation where they will not be judged by the color of their skin but by the content of their character.</p><p>我梦想有一天，我的四个孩子将在一个不是以他们的肤色，而是以他们的品格优劣来评价他们的国度里生活。</p><p>I have a dream today!</p><p>我今天有一个梦想。</p><p>I have a dream that one day, down in Alabama, with its vicious racists, with its governor having his lips dripping with the words of “interposition” and “nullification” – one day right there in Alabama little black boys and black girls will be able to join hands with little white boys and white girls as sisters and brothers.</p><p>我梦想有一天，亚拉巴马州能够有所转变，尽管该州州长现在仍然满口异议，反对联邦法令，但有朝一日，那里的黑人男孩和女孩将能与白人男孩和女孩情同骨肉，携手并进。</p><p>I have a dream today!</p><p>我今天有一个梦想。</p><p>I have a dream that one day every valley shall be exalted, and every hill and mountain shall be made low, the rough places will be made plain, and the crooked places will be made straight; “and the glory of the Lord shall be revealed and all flesh shall see it together.”</p><p>我梦想有一天，幽谷上升，高山下降，坎坷曲折之路成坦途，圣光披露，满照人间。</p><p>This is our hope, and this is the faith that I go back to the South with.</p><p>With this faith, we will be able to hew out of the mountain of despair a stone of hope. With this faith, we will be able to transform the jangling discords of our nation into a beautiful symphony of brotherhood.</p><p>With this faith, we will be able to work together, to pray together, to struggle together, to go to jail together, to stand up for freedom together, knowing that we will be free one day.</p><p>这就是我们的希望。我怀着这种信念回到南方。</p><p>有了这个信念，我们将能从绝望之嶙劈出一块希望之石。</p><p>有了这个信念，我们将能把这个国家刺耳争吵的声，改变成为一支洋溢手足之情的优美交响曲。</p><p>有了这个信念，我们将能一起工作，一起祈祷，一起斗争，一起坐牢，一起维护自由；因为我们知道，终有一天，我们是会自由的。</p><p>And this will be the day – this will be the day when all of God’s children will be able to sing with new meaning:</p><p>在自由到来的那一天，上帝的所有儿女们将以新的含义高唱这支歌：“我的祖国，美丽的自由之乡，我为您歌唱。您是父辈逝去的地方，您是最初移民的骄傲，让自由之声响彻每个山冈。”　</p><p>My country ‘tis of thee, sweet land of liberty, of thee I sing.</p><p>Land where my fathers died, land of the Pilgrim’s pride,</p><p>From every mountainside, let freedom ring!</p><p>And if America is to be a great nation, this must become true.</p><p>And so let freedom ring from the prodigious hilltops of New Hampshire.</p><p>Let freedom ring from the mighty mountains of New York.</p><p>Let freedom ring from the heightening Alleghenies of</p><p>Pennsylvania.</p><p>Let freedom ring from the snow-capped Rockies of Colorado.</p><p>Let freedom ring from the curvaceous slopes of California.</p><p>But not only that:</p><p>Let freedom ring from Stone Mountain of Georgia.</p><p>Let freedom ring from Lookout Mountain of Tennessee.</p><p>Let freedom ring from every hill and molehill of Mississippi.</p><p>From every mountainside, let freedom ring.</p><p>如果美国要成为一个伟大的国家，这个梦想必须实现。让自由之声从新罕布什尔州的巍峨峰巅响起来！让自由之声从纽约州的崇山峻岭响起来！让自由之声从宾夕法尼亚州阿勒格尼山的顶峰响起来！</p><p>And when this happens, when we allow freedom ring, when we let it ring from every village and every hamlet, from every state and every city, we will be able to speed up that day when all of God’s children, black men and white men, Jews and Gentiles, Protestants and Catholics, will be able to join hands and sing in the words of the old Negro spiritual:</p><p>Free at last! Free at last!</p><p>Thank God Almighty, we are free at last!</p>]]></content>
      
      
      <categories>
          
          <category> 演讲 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>乔布斯：Stay hungry ，Stay foolish</title>
      <link href="/archives/4b19815b.html"/>
      <url>/archives/4b19815b.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>史蒂夫 · 乔布斯2005年斯坦福毕业典礼演讲<br>Stay hungry ，Stay foolish<br>史蒂夫 · 乔布斯</p><p><img src="/C:/Users\86185\AppData\Roaming\Typora\typora-user-images\image-20221013003430554.png" alt="image-20221013003430554"> <span id="more"></span><br>Thank you. I am honored to be with you today at your commencement from one of the finest universities in the world. Truth be told, I never graduated from college. This is the closest I’ve ever gotten to a college graduation. Today I want to tell you three stories from my life. That’s it. No big deal. Just three stories.<br>很荣幸和大家一道参加这所世界上最好的一座大学的毕业典礼。我大学没毕业，说实话，这是我第一次离大学毕业典礼这么近。今天我想给大家讲三个我自己的故事，不讲别的，也不讲大道理，就讲三个故事。</p><p>The first story is about connecting the dots. I dropped out of Reed College after the first 6 months, but then stayed around as a drop-in for another 18 months or so before I really quit. So why did I drop out?<br>第一个故事讲的是点与点之间的关系。我在里德学院(Reed College)只读了六个月就退学了，此后便在学校里旁听，又过了大约一年半，我彻底离开。那么，我为什么退学呢?</p><p>It started before I was born. My biological mother was a young, unwed college graduate student, and she decided to put me up for adoption. She felt very strongly that I should be adopted by college graduates, so everything was all set for me to be adopted at birth by a lawyer and his wife.<br>这得从我出生前讲起。我的生母是一名年轻的未婚在校研究生，她决定将我送给别人收养。她非常希望收养我的是有大学学历的人，所以把一切都安排好了，我一出生就交给一对律师夫妇收养。</p><p>Except that when I popped out they decided at the last minute that they really wanted a girl. So my parents, who were on a waiting list, got a call in the middle of the night asking: “We have an unexpected baby boy; do you want him?” They said: “Of course.”<br>没想到我落地的霎那间，那对夫妇却决定收养一名女孩。就这样，我的养父母─当时他们还在登记册上排队等着呢─半夜三更接到一个电话: “我们这儿有一个没人要的男婴，你们要么?”“当然要”他们回答。</p><p>My biological mother later found out that my mother had never graduated from college and that my father had never graduated from high school. She refused to sign the final adoption papers. She only relented a few months later when my parents promised that I would someday go to college.<br>但是，我的生母后来发现我的养母不是大学毕业生，我的养父甚至连中学都没有毕业，所以她拒绝在最后的收养文件上签字。不过，没过几个月她就心软了，因为我的养父母许诺日后一定送我上大学。</p><p>And 17 years later I did go to college. But I naively chose a college that was almost as expensive as Stanford, and all of my working-class parents’ savings were being spent on my college tuition.<br>17 年后，我真的进了大学。当时我很天真，选了一所学费几乎和斯坦福大学一样昂贵的学校，当工人的养父母倾其所有的积蓄为我支付了大学学费。</p><p>After six months, I couldn’t see the value in it. I had no idea what I wanted to do with my life and no idea how college was going to help me figure it out. And here I was spending all of the money my parents had saved their entire life.<br>读了六个月后，我却看不出上学有什么意义。我既不知道自己这一生想干什么，也不知道大学是否能够帮我弄明白自己想干什么。这时，我就要花光父母一辈子节省下来的钱了。</p><p>So I decided to drop out and trust that it would all work out OK. It was pretty scary at the time, but looking back it was one of the best decisions I ever made. The minute I dropped out I could stop taking the required classes that didn’t interest me, and begin dropping in on the ones that looked interesting。<br>所以，我决定退学，并且坚信日后会证明我这样做是对的。当年做出这个决定时心里直打鼓，但现在回想起来，这还真是我有生以来做出的最好的决定之一。从退学那一刻起，我就可以不再选那些我毫无兴趣的必修课，开始旁听一些看上去有意思的课。</p><p>It wasn’t all romantic. I didn’t have a dorm room, so I slept on the floor in friends’ rooms, I returned coke bottles for the 5? deposits to buy food with, and I would walk the 7 miles across town every Sunday night to get one good meal a week at the Hare Krishna temple. I loved it. And much of what I stumbled into by following my curiosity and intuition turned out to be priceless later on. Let me give you one example:<br>那些日子一点儿都不浪漫。我没有宿舍，只能睡在朋友房间的地板上。我去退还可乐瓶，用那五分钱的押金来买吃的。每个星期天晚上我都要走七英里，到城那头的黑尔-科里施纳礼拜堂去，吃每周才能享用一次的美餐。我喜欢这样。我凭著好奇心和直觉所干的这些事情，有许多后来都证明是无价之宝。我给大家举个例子:</p><p>Reed College at that time offered perhaps the best calligraphy instruction in the country. Throughout the campus every poster, every label on every drawer, was beautifully hand calligraphed. Because I had dropped out and didn’t have to take the normal classes, I decided to take a calligraphy class to learn how to do this.<br>当时，里德学院的书法课大概是全国最好的。校园里所有的公告栏和每个抽屉标签上的字都写得非常漂亮。当时我已经退学，不用正常上课，所以我决定选一门书法课，学学怎么写好字。</p><p>I learned about serif and san serif typefaces, about varying the amount of space between different letter combinations, about what makes great typography great. It was beautiful, historical, artistically subtle in a way that science can’t capture, and I found it fascinating.<br>我学习写带短截线和不带短截线的印刷字体，根据不同字母组合调整其间距，以及怎样把版式调整得好上加好。这门课太棒了，既有历史价值，又有艺术造诣，这一点科学就做不到，而我觉得它妙不可言。</p><p>None of this had even a hope of any practical application in my life. But ten years later, when we were designing the first Macintosh computer, it all came back to me. And we designed it all into the Mac.<br>当时我并不指望书法在以后的生活中能有什么实用价值。但是，十年之后，我们在设计第一台 Macintosh 计算机时，它一下子浮现在我眼前。于是，我们把这些东西全都设计进了计算机中。</p><p>It was the first computer with beautiful typography. If I had never dropped in on that single course in college, the Mac would have never had multiple typefaces or proportionally spaced fonts. And since Windows just copied the Mac, its likely that no personal computer would have them.<br>这是第一台有这么漂亮的文字版式的计算机。要不是我当初在大学里偶然选了这么一门课，Macintosh 计算机绝不会有那么多种印刷字体或间距安排合理的字号。要不是 Windows 照搬了 Macintosh，个人电脑可能不会有这些字体和字号。</p><p>If I had never dropped out, I would have never dropped in on this calligraphy class, and personal computers might not have the wonderful typography that they do. Of course it was impossible to connect the dots looking forward when I was in college. But it was very, very clear looking backwards ten years later.<br>要不是退了学，我决不会碰巧选了这门书法课，个人电脑也可能不会有现在这些漂亮的版式了。当然，我在大学里不可能从这一点上看到它与将来的关系。十年之后再回头看，两者之间的关系就非常、非常清楚了。</p><p>Again, you can’t connect the dots looking forward; you can only connect them looking backwards. So you have to trust that the dots will somehow connect in your future. You have to trust in something - your gut, destiny, life, karma, whatever. This approach has never let me down, and it has made all the difference in my life.<br>你们同样不可能从现在这个点上看到将来;只有回头看时，才会发现它们之间的关系。所以，要相信这些点迟早会连接到一起。你们必须信赖某些东西─直觉、归宿、生命，还有业力，等等。这样做从来没有让我的希望落空过，而且还彻底改变了我的生活。</p><p>My second story is about love and loss. I was lucky - I found what I loved to do early in life. Woz and I started Apple in my parents garage when I was 20. We worked hard, and in 10 years Apple had grown from just the two of us in a garage into a $2 billion company with over 4000 employees.<br>我的第二个故事是关于好恶与得失。幸运的是，我在很小的时候就发现自己喜欢做什么。我在 20 岁时和沃兹在我父母的车库里办起了苹果公司。我们干得很卖力，十年后，苹果公司就从车库里我们两个人发展成为一个拥有 20 亿元资产、4,000 名员工的大企业。</p><p>We had just released our finest creation - the Macintosh - a year earlier, and I had just turned 30. And then I got fired. How can you get fired from a company you started? Well, as Apple grew we hired someone who I thought was very talented to run the company with me, and for the first year or so things went well.<br>那时，我们刚刚推出了我们最好的产品─ Macintosh 电脑─那是在第 9 年，我刚满 30 岁。可后来，我被解雇了。你怎么会被自己办的公司解雇呢?是这样，随著苹果公司越做越大，我们聘了一位我认为非常有才华的人与我一道管理公司。在开始的一年多里，一切都很顺利。</p><p>But then our visions of the future began to diverge and eventually we had a falling out. When we did, our Board of Directors sided with him. So at 30 I was out. And very publicly out. What had been the focus of my entire adult life was gone, and it was devastating.<br>可是，随后我俩对公司前景的看法开始出现分歧，最后我俩反目了。这时，董事会站在了他那一边，所以在 30 岁那年，我离开了公司，而且这件事闹得满城风雨。我成年后的整个生活重心都没有了，这使我心力交瘁。</p><p>Ireally didn’t know what to do for a few months. I felt that I had let the previous generation of entrepreneurs down - that I had dropped the baton as it was being passed to me. I met with David Packard and Bob Noyce and tried to apologize for screwing up so badly. I was a very public failure, and I even thought about running away from the valley.<br>一连几个月，我真的不知道应该怎么办。我感到自己给老一代的创业者丢了脸─因为我扔掉了交到自己手里的接力棒。我去见了戴维帕卡德和鲍勃.诺伊斯，想为把事情搞得这么糟糕说声道歉。这次失败弄得沸沸扬扬的，我甚至想过逃离硅谷。</p><p>But something slowly began to dawn on me - I still loved what I did. The turn of events at Apple had not changed that one bit. I had been rejected, but I was still in love. And so I decided to start over.<br>但是，渐渐地，我开始有了一个想法─我仍然热爱我过去做的一切。在苹果公司发生的这些风波丝毫没有改变这一点。我虽然被拒之门外，但我仍然深爱我的事业。于是，我决定从头开始。</p><p>Ididn’t see it then, but it turned out that getting fired from Apple was the best thing that could have ever happened to me. The heaviness of being successful was replaced by the lightness of being a beginner again, less sure about everything. It freed me to enter one of the most creative periods of my life.<br>虽然当时我并没有意识到，但事实证明，被苹果公司炒鱿鱼是我一生中碰到的最好的事情。尽管前景未卜，但从头开始的轻松感取代了保持成功的沉重感。这使我进入了一生中最富有创造力的时期之一。</p><p>During the next five years, I started a company named NeXT, another company named Pixar, and fell in love with an amazing woman who would become my wife. Pixar went on to create the worlds first computer animated feature film, Toy Story, and is now the most successful animation studio in the world.<br>在此后的五年里，我开了一家名叫 NeXT 的公司和一家叫皮克斯的公司，我还爱上一位了不起的女人，后来娶了她。皮克斯公司推出了世界上第一部用电脑制作的动画片《玩具总动员》(Toy Story)，它现在是全球最成功的动画制作室。</p><p>In a remarkable turn of events, Apple bought NeXT, I retuned to Apple, and the technology we developed at NeXT is at the heart of Apple’s current renaissance. And Laurene and I have a wonderful family together.<br>世道轮回，苹果公司买下 NeXT 后，我又回到了苹果公司，我们在 NeXT 公司开发的技术成了苹果公司这次重新崛起的核心。我和劳伦娜(Laurene)也建立了美满的家庭。</p><p>I’m pretty sure none of this would have happened if I hadn’t been fired from Apple. It was awful tasting medicine, but I guess the patient needed it. Sometimes life hits you in the head with a brick. Don’t lose faith. I’m convinced that the only thing that kept me going was that I loved what I did.<br>我确信，如果不是被苹果公司解雇，这一切决不可能发生。这是一剂苦药，可我认为苦药利于病。有时生活会当头给你一棒，但不要灰心。我坚信让我一往无前的唯一力量就是我热爱我所做的一切。</p><p>You’ve got to find what you love. And that is as true for your work as it is for your lovers. Your work is going to fill a large part of your life, and the only way to be truly satisfied is to do what you believe is great work. And the only way to do great work is to love what you do.<br>所以，一定得知道自己喜欢什么，选择爱人时如此，选择工作时同样如此。工作将是生活中的一大部分，让自己真正满意的唯一办法，是做自己认为是有意义的工作;做有意义的工作的唯一办法，是热爱自己的工作。</p><p>If you haven’t found it yet, keep looking. Don’t settle. As with all matters of the heart, you’ll know when you find it. And, like any great relationship, it just gets better and better as the years roll on. So keep looking until you find it. Don’t settle.<br>你们如果还没有发现自己喜欢什么，那就不断地去寻找，不要急于做出决定。就像一切要凭着感觉去做的事情一样，一旦找到了自己喜欢的事，感觉就会告诉你。就像任何一种美妙的东西，历久弥新。所以说，要不断地寻找，直到找到自己喜欢的东西。不要半途而废。</p><p>My third story is about death. When I was 17, I read a quote that went something like: “If you live each day as if it was your last, someday you’ll most certainly be right.” It made an impression on me, and since then, for the past 33 years, I have looked in the mirror every morning and asked myself: “If today were the last day of my life, would I want to do what I am about to do today?” And whenever the answer has been “No” for too many days in a row, I know I need to change something.<br>我的第三个故事与死亡有关。17 岁那年，我读到过这样一段话，大意是:“如果把每一天都当作生命的最后一天，总有一天你会如愿以偿。”我记住了这句话，从那时起，33 年过去了，我每天早晨都对着镜子自问: “假如今天是生命的最后一天，我还会去做今天要做的事吗?”如果一连许多天我的回答都是“不”，我知道自己应该有所改变了。</p><p>Remembering that I’ll be dead soon is the most important tool I’ve ever encountered to help me make the big choices in life. Because almost everything - all external expectations, all pride, all fear of embarrassment or failure - these things just fall away in the face of death, leaving only what is truly important. Remembering that you are going to die is the best way I know to avoid the trap of thinking you have something to lose. You are already naked. There is no reason not to follow your heart.<br>让我能够做出人生重大抉择的最主要办法是，记住生命随时都有可能结束。因为几乎所有的东西─所有对自身之外的希求、所有的尊严、所有对困窘和失败的恐惧─在死亡来临时都将不复存在，只剩下真正重要的东西。记住自己随时都会死去，这是我所知道的防止患得患失的最好方法。你已经一无所有了，还有什么理由不跟着自己的感觉走呢。</p><p>About a year ago I was diagnosed with cancer. I had a scan at 7:30 in the morning, and it clearly showed a tumor on my pancreas. I didn’t even know what a pancreas was. The doctors told me this was almost certainly a type of cancer that is incurable, and that I should expect to live no longer than three to six months.<br>大约一年前，我被诊断患了癌症。那天早上七点半，我做了一次扫描检查，结果清楚地表明我的胰腺上长了一个瘤子，可那时我连胰腺是什么还不知道呢!医生告诉我说，几乎可以确诊这是一种无法治愈的恶性肿瘤，我最多还能活 3 到 6 个月。</p><p>My doctor advised me to go home and get my affairs in order, which is doctor’s code for prepare to die. It means to try to tell your kids everything you thought you’d have the next 10 years to tell them in just a few months. It means to make sure everything is buttoned up so that it will be as easy as possible for your family. It means to say your goodbyes.<br>医生建议我回去把一切都安排好，其实这是在暗示“准备后事”。也就是说，把今后十年要跟孩子们说的事情在这几个月内嘱咐完;也就是说，把一切都安排妥当，尽可能不给家人留麻烦;也就是说，去跟大家诀别。</p><p>Ilived with that diagnosis all day. Later that evening I had a biopsy, where they stuck an endoscope down my throat, through my stomach and into my intestines, put a needle into my pancreas and got a few cells from the tumor. I was sedated, but my wife, who was there, told me that when they viewed the cells under a microscope the doctors started crying because it turned out to be a very rare form of pancreatic cancer that is curable with surgery. I had the surgery and I’m fine now.<br>那一整天里，我的脑子一直没离开这个诊断。到了晚上，我做了一次组织切片检查，他们把一个内窥镜通过喉咙穿过我的胃进入肠子，用针头在胰腺的瘤子上取了一些细胞组织。当时我用了麻醉剂，陪在一旁的妻子后来告诉我，医生在显微镜里看了细胞之后叫了起来，原来这是一种少见的可以通过外科手术治愈的恶性肿瘤。我做了手术，现在好了。</p><p>This was the closest I’ve been to facing death, and I hope its the closest I get for a few more decades. Having lived through it, I can now say this to you with a bit more certainty than when death was a useful but purely intellectual concept:No one wants to die. Even people who want to go to heaven don’t want to die to get there. And yet death is the destination we all share.<br>这是我和死神离得最近的一次，我希望也是今后几十年里最近的一次。有了这次经历之后，现在我可以更加实在地和你们谈论死亡，而不是纯粹纸上谈兵，那就是: 谁都不愿意死。就是那些想进天堂的人也不愿意死后再进。然而，死亡是我们共同的归宿，没人能摆脱。</p><p>No one has ever escaped it. And that is as it should be, because Death is very likely the single best invention of Life. It is Life’s change agent. It clears out the old to make way for the new. Right now the new is you, but someday not too long from now, you will gradually become the old and be cleared away. Sorry to be so dramatic, but it is quite true.<br>我们注定会死，因为死亡很可能是生命最好的一项发明。它推进生命的变迁，旧的不去，新的不来。现在，你们就是新的，但在不久的将来，你们也会逐渐成为旧的，也会被淘汰。对不起，话说得太过分了，不过这是千真万确的。</p><p>Your time is limited, so don’t waste it living someone else’s life. Don’t be trapped by dogma - which is living with the results of other people’s thinking. Don’t let the noise of others’ opinions drown out your own inner voice. And most important, have the courage to follow your heart and intuition. They somehow already know what you truly want to become. Everything else is secondary.<br>你们的时间都有限，所以不要按照别人的意愿去活，这是浪费时间。不要囿于成见，那是在按照别人设想的结果而活。不要让别人观点的聒噪声淹没自己的心声。最主要的是，要有跟着自己感觉和直觉走的勇气。无论如何，感觉和直觉早就知道你到底想成为什么样的人，其他都是次要的。</p><p>When I was young, there was an amazing publication called The Whole Earth Catalog, which was one of the bibles of my generation. It was created by a fellow named Stewart Brand not far from here in Menlo Park, and he brought it to life with his poetic touch.<br>我年轻时有一本非常好的刊物，叫《全球概览》，这是我那代人的宝书之一，创办人名叫斯图尔特布兰德，就住在离这儿不远的门洛帕克市。他用诗一般的语言把刊物办得生动活泼。</p><p>This was in the late 1960’s, before personal computers and desktop publishing, so it was all made with typewriters, scissors, and polaroid cameras. It was sort of like Google in paperback form, 35 years before Google came along: it was idealistic, and overflowing with neat tools and great notions.<br>那是 20 世纪 60 年代末，还没有个人电脑和桌面印刷系统，全靠打字机、剪刀和宝丽莱照相机。它就像一种纸质的 Google，却比 Google 早问世了 35 年。这份刊物太完美了，查阅手段齐备、构思不凡。</p><p>Stewart and his team put out several issues of The Whole Earth Catalog, and then when it had run its course, they put out a final issue. It was the mid-1970s, and I was your age.<br>斯图尔特和他的同事们出了好几期《全球概览》，到最后办不下去时，他们出了最后一期。那是 20 世纪 70 年代中期，我也就是你们现在的年纪。</p><p>On the back cover of their final issue was a photograph of an early morning country road, the kind you might find yourself hitchhiking on if you were so adventurous. Beneath it were the words: “Stay Hungry. Stay Foolish.” It was their farewell message as they signed off. Stay Hungry. Stay Foolish. And I have always wished that for myself.<br>最后一期的封底上是一张清晨乡间小路的照片，就是那种爱冒险的人等在那儿搭便车的那种小路。照片下面写道: 求知若饥、虚心若愚。那是他们停刊前的告别语。求知若渴，大智若愚。这也是我一直想做到的。</p><p>And now, as you graduate to begin anew, I wish that for you. Stay Hungry. Stay Foolish.<br>眼下正值诸位大学毕业、开始新生活之际，我同样愿大家:求知若饥、虚心若愚。</p>]]></content>
      
      
      <categories>
          
          <category> 演讲 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>停止精神内耗的九种方法</title>
      <link href="/archives/736b0ae5.html"/>
      <url>/archives/736b0ae5.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol><li>停止活在他人眼里–<strong>生活说到底，是取悦自己的过程。</strong></li><li>停止后悔–<strong>与其沉湎于不能改变的过去，不如坦然放下。</strong></li><li>停止苛求完美–《道德经》中说：<strong>“大成若缺，其用不弊。”</strong></li><li>停止思虑过度–<strong>本来没什么，就是因为想太多，才让一切变得复杂。人生的幸福，有时候就在于放空。</strong></li><li>停止陷入消极–<strong>保持微笑，凡事看淡，好运才会与你不期而遇。</strong></li><li>停止设限–<strong>生命的意义在于开拓而不是固守，无论什么时候我们都不应该失去前行的勇气。对于有追求的人来说，生命的每个阶段，都是新鲜，有活力的，拥有着无限的可能。</strong></li><li>停止反复犹豫–<strong>很多事情，你不果断尝试，永远都不会知道结果会是怎样。</strong></li><li>停止自我攻击–<strong>最难也最重要的课程，就是和自己和解。从今天起，不要再自我贬低。</strong></li><li>停止拖延–<strong>今日事，今日毕，永远不要把问题拖到明天再处理。你所渴望的改变，需要从现在开始改变。</strong></li></ol>]]></content>
      
      
      <categories>
          
          <category> 摘录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>社会本质</title>
      <link href="/archives/177b3178.html"/>
      <url>/archives/177b3178.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p> 这30个社会规则，看到最后希望你不会怀疑人生</p><h2 id="一、社会规则"><a href="#一、社会规则" class="headerlink" title="一、社会规则"></a>一、社会规则</h2><p> 1、动上层的利益如同夺他们的生命，改底层的观念如同掘他们的祖坟。而底层观念正是上层利益的来源，试图说透这一切的人，是双方共同的敌人。</p><p> 2、很少有男人把外貌当成资本，如果说女人的世界里，年龄和容貌是最残酷的事，那么在男人的世界里就是金钱。</p><p> 3、没感觉就是嫌你丑，不合适就是嫌你穷，没什么道理可讲，做事情之前先看看自己手上的筹码。</p><p> 4、听精神病院的医生说，男病人都想干大事，女病人都想被人爱。</p><p> 5、在人际关系方面，全世界都是帮亲不帮理的，过分追求理想、客观、公平，很容易陷入孤立无援的困境。</p><p> 6、狼与狼之间再怎么撕咬，对羊的态度是一致的。</p><p> 7、很现实的是所有人都会喜欢你，直到你成了他们的竞争者动了他们的利益。</p><span id="more"></span><p> 8、越是和你亲近的人，越是受不了你突然的变好。</p><p> 9、在很多时候，客气不是用来表达礼貌和修养的，而是用来制造距离的。</p><p> 10、重蹈覆辙的下场就是自取其辱，失而复得的东西根本回不到当初。重读一本书可能会有新的感悟，但不会有新的结局。</p><p> 11、能量不比神佛大的人，不要轻易让卖惨的人接近自己。 </p><p> 12、没有人能抵挡利益的诱惑。如果有，那就是因为利益还不够大。</p><p> 13、 钱包和镜子，能回答生活中大部分的“为什么”和“凭什么”。</p><p> 14、一束光照进房间，房间里的肮脏龌龊被显现，这束光便有了罪。 </p><p> 15、江湖的规矩就是人走茶凉，默契散场。不要问，问就是不懂规矩。</p><p> 16、建立稳固合作的基础是有稳定的利益基础。人品保证不了稳定合作，与其相信人品，不如相信人性。</p><p> 17、关系越近，越觉得对方没什么了不起，距离才能产生神秘感和崇拜感。</p><p> 18、当你的见识与见解超过大多数人的时候，你绝对不会是一个很受欢迎的人。</p><p> 19、所有的人脉都是假象，想要和老板做朋友，必须拥有同等的财富和同频的智慧。</p><p> 20、天底下只有一种方法，可以让别人心甘情愿听你的话，那就是给到他想要的利益。</p><p> 21、好为人师是一种炫耀，潜意识告诉别人你比他强，这种姿态只要一出来，别人的反感就会生出来。</p><p> 22、酒桌上不用和主角敬酒的人，一般都是主角的亲信。</p><p> 23、抱着交易的本质去接触人和事，结局都不会差。而用陪伴、唠嗑堆积出来的感情，一旦跟利益挂钩，立刻就会分崩离析，原形毕露，不信你试试看。</p><p> 24、社会默认规则就是嚣张跋扈的大多不长久。所以优秀的人大多低调而谨慎，平和而理性，越活越保守。因为是既得利益者，不小心的话早就被人盯上了。</p><p> 25、永远不要指望学校会教你搞钱的学问。搞钱的学问，要么有贵人带，要么自己开悟。这两个的大前提都是要多接触外面的世界，多跟别人交流，不要沉浸在自己的小圈子里。</p><p> 26、不要轻易把自嘲当幽默，更不要在蠢人面前自嘲，他会当真。</p><p> 27、有时候你只能看着身边的人误入歧途却无可奈何。试图伸出援手不但费力不讨好，反而容易招致仇恨。最终你会发现，你什么都做不了，你能做的只有过好自己的生活。</p><p> 28、精明的人，会在亲朋好友面前低调，而不是炫耀。明明工作很好、收入很高，却把自己的工作说得一无是处：白加黑、无双休、不是人干的，只有这样才能让自己不被嫉妒和算计。</p><p> 29、要克制自己想去纠正别人的念头，成年人只能筛选不能教育。伴侣、朋友、合伙人皆是如此。收起自己改造他人的执着，人教人教不会，事教人一次就够。因为人是叫不醒的，人只能被痛醒。</p><p> 30 一个人不容易动怒，说明他手里的王牌比较多。相反，如果一个人动不动就发脾气，说明他手里已经没有什么王牌了，也就只剩下发脾气这一点能耐了。人之所以会情绪激动发脾气，那都是因为没办法后的无奈之举。 </p><h2 id="二、关于送礼"><a href="#二、关于送礼" class="headerlink" title="二、关于送礼"></a>二、关于送礼</h2><p> 没有送礼的格局，怎么会有赚钱的机会？</p><p> 我们盖房，领导说我们没手续，不要盖了。我们给领导包了个红包，领导说：你找谁谁试试。我又给领导包了红包，说：要不，你帮我找找，我这人不会说话。领导捏了捏我的红包，说：我试试。我千恩万谢，说谢谢了，拜托了。</p><p> 开始他拒绝我，我去了10次100次以后，我们成了最好的朋友。现在他的资源就是我的资源，我的资源就是他的资源。什么都是坚持出来的，只要不放弃，永远就还有机会。</p><p> 我以前跟你一样，瞧不起走歪门邪道的人。人啊，是金子总会发光。10年过去了，我手下的小弟都立起来了，我还在原地踏步走。我开始怀疑：九年义务教育是不是骗人的……</p><p> 我原以为我们是最好的朋友，我们一起吃饭，一起喝酒。我原以为他会提拔我当主任，谁知道他提拔了另一个人。他退休了，才对我说：感情靠不住，习惯性送礼，才有机会冒头。你啊，光用嘴表达感情，太二了。</p><p> 为了孩子转学，我找了他几次，他都不方便，我帮了交了一年的物业费。他要我找谁谁谁，我去找谁谁谁。谁谁谁说：这事儿简单啊，你的资料给我。我把资料给他，他用铅笔在上面画了两个圈，说走正常程序就行了。额，果然还是“走正常程序”牛逼！</p><p> 人跟人做链接，说白了，就是买票上车。上车了，车一直走。打开窗户，看到哪里儿好玩，直接在哪里儿下车。没有人知道自己想要什么，坐车多了，看到的风景多了，才会眼前一亮：哦，我梦寐以求的东西，原来就在眼前，以前怎么没发现呀。</p><p> 人生是一个觉悟的过程，而不是说年龄大了，什么事能自然而然领悟的到，就比如当你求人办事送礼时你会怎么说呢？不妨参考一下以下的说辞：</p><p> 1、把送礼的话头推到对方的孩子身上，比方说：“东西是给孩子买的，和您没关系。别说是来找您办事，就是没这事，随便来串门还不一样应该给孩子买点东西吗?”</p><p> 2、把送礼的话头推到对方老人身上，比方说：“你不用客气，这东西是给老爷子买的。老爷子身体最近还行吧?你方便时把东西给老爷子拎过去得了，我就不再过去专门看他了。”</p><p> 3、把送礼的话头推到托办事的朋友身上，比方说：“这东西是我朋友给你买的，我也没花钱。咱把事给他办了，就啥都有了，咱也不用太跟他客气。”</p><p> 4、把送礼的话头推到对方可能存在的损失上，比方说：“您帮着办事就劳心了，难道还能让您搭钱破费?这钱您先拿着，必要时替我打点打点，不够用时我再拿。”</p><p> 5、把送给对方的钱说成是暂存在对方手里的，比方说：“我知道，咱们之间办事用不着钱，但万一出点啥岔头需要打点，我也未必赶得过来，所以这钱先放你这里，用上了就用，用不上到时候再给我不是一样吗?”</p><p> 一件事，花钱可能3分钟就能知道答案，不花钱，可能要等3年或10年才知道答案。没有送礼的格局，怎么会有赚钱的机会？天天待客不穷，夜夜做贼不富。会花钱，又养成了花钱的习惯，此后便过上了幸福的生活……</p><h2 id="三、关于人生感悟"><a href="#三、关于人生感悟" class="headerlink" title="三、关于人生感悟"></a>三、关于人生感悟</h2><p> 1、人和人之间的竞争，表面上看是房子、车子、票子、面子的竞争，其核心的竞争是能力、资源、人脉、圈子的竞争，但归根到底的竞争是思维、认知、价值、人品的竞争。</p><p> 2、30岁后最好不要让自己活的太忙，要学会做减法，人的时间精力毕竟有限，想要有所成就，一定要先学会放弃某些东西。聪明的人知道自己要什么，而智慧的人知道要放弃什么。</p><p> 3、人际关系的本质是各取所需，所以我们不必刻意讨好谁，唯有自己强大了，所谓的人脉会自动找上门的。</p><p> 4、在没有实现财富自由前，一定要努力赚钱，虽说钱并不都是万能的，但钱确实可以解决人生中遇到的80%以上的烦恼，包括情感。</p><p> 5、收入并不是和你的劳动时间成正比，而是和你的劳动的不可替代性成正比，所以我们要努力成为公司那个不可或缺的唯一。</p><p> 6、一切关系的破裂，本质是起因于利益的破裂。不要寄望身边的人会因你而改变，他们只会因你的口袋带给他们的利益而自动改变。</p><p> 7、看一个人有没有能力，就看这个人能不能把这项能力转化成支票，不然其他的都是扯蛋。</p><p> 8、很多时候我们所有的焦虑和担忧，都是因为能力配不上野心。当你不能解决问题的时候，你就会成为问题。所以我们身陷局中的时候，需要的是破局能力，而不是原地踏步的努力。</p><p> 9、想要快速进入一个圈子，最简单的办法就是模仿。如果你连模仿都不会，还谈何创新呢？</p><p> 10、万不得已不要轻易借钱给别人，借钱给别人就要做好收不回来的准备，千万不要试着去揣测人性，人性往往是经不起考验的。</p><p> 11、任何时候做事都要有自己的原则和底线，这样别人才不会轻易践踏，人都是欺软怕硬的。</p><p> 12、工作中时刻琢磨三件事：我怎么为公司创造价值？我怎么为客户创造价值？我怎么为自己创造价值？为公司创造高价值—公司才会重用你；为客户创造高价值—客户才会黏着你，为自己创造高价值—人脉才会主动找上你。</p><p> 13、做好一件事件没有别的捷径，都是通过不停地对标-模仿-试错-总结来提高的。试着每天下班后复盘总结，时间久了，你会慢慢发现自己成长地特别快。</p><p> 14、年轻的时候越早做职业规划，能让你往后的日子少遭一些罪，越早想清楚这一点，就能少走好几年弯路。比如20多岁的时候多看一些书，多锻炼身体，多学一些技能，好给自己日后的生活提前做准备，不然到了35岁处处是危机。</p><p> 15、想要赚钱之前不如好好想想：你能在什么领域，用什么方式，帮什么人，解决什么问题。要是能把这个研究琢磨透了，赚钱也就顺其自然的事了。</p><p> 16、同事朋友间羞于谈钱，谈钱伤感情，才真的会让你没钱。嘴上说着不要，身体却很诚实，我们既然爱钱，何不直接纯粹一点。</p><p> 17、成功虽说不可复制，但跟着成功的人至少可以少走很多弯路。这个社会遵循二八定律，你只有和周围的人不一样，并且干的方向是正确的，你才有可能成为那一拨极少数的人。</p><p> 18、30岁后最好给自己和家人买一点保险防身，有时候一场突如其来的大病往往就能轻易拖垮一个家庭的经济，未雨绸缪总要比突如其来的好。另外我们平时一定要多锻炼身体，要是健康没了，其他一切为零。</p><p> 19、工作内容不等同于工作业绩，你每天做了多少事情跟你对公司的贡献是两码事，不要沉迷于没有功劳也有苦劳那一套，我们要想在公司走得更远，一定要倒逼自己做出业绩，挺直腰板就用自己的业绩来说活。</p><p> 20、在职场中，老板看中的往往的不是你的专业能力，而是你搞定人的能力。很多时候，你只有把人搞定了，才有做事的机会。说实在这社会有能力的人很多，但有机会去做事的人却很少。</p><h2 id="四、关于职场规则"><a href="#四、关于职场规则" class="headerlink" title="四、关于职场规则"></a>四、关于职场规则</h2><p> 这25个职场规则，看到最后希望你不会怀疑人生！</p><p> 1、白天按教员的方法办事，晚上躺床上按教员的方法复盘是进步最快的方法没有之一。</p><p> 2、当个好官的前提是你得是个官，有格局的前提是你在那个位置上；不是个官没资格当好官，没在那个位置上的格局屁用没有。</p><p> 3、30岁以下绝大多数人不会涉及到站队的问题，很多时候或许你连站队的资格都没有。</p><p> 4、不好拒绝别人的事情多拖一下，拖着拖着就不了了之了。</p><p> 5、面对稀缺资源永远不要看没有它的人如何评价，而要关注没有它的人反对的是否激烈，如果激烈用尽一切手段去争取。</p><p> 6、不能变现只能表现的能力没有任何用处，不能写进简历里的能力也没有什么用处。</p><p> 7、没有人会拒绝有能力忠诚度高的下属的拜访，送礼也是一样，注意我说的是送礼。</p><p> 8、谁都愿意和靠谱的人打交道，靠谱是利益交换的基础；至于你有没有值得交换的利益，那是后面的事。</p><p> 9、旅游很多时候并不能让你见世面，但是经常做超出你当前能力的事情并且加班可以，不信你可以试试！</p><p> 10、只会模仿确实不能超越，但是对于能力素质差距过大的情况，模仿是最能“把事办成”的方法。</p><p> 11、卷不卷是累不累的事，饿不饿是死不死的事，要学会区分轻重缓急；同样的，躺不躺是自己选择的事，但是后果要自己负责。</p><p> 12、世界观方法论是工作中的学习率，有人是正的，有人是负的；有人大，有人小。以结果作为调参依据，而非个人喜好，你会发现你成长的越来越快。</p><p> 13、远离自我评价“老实”的人，主动向领导评价“老实”的人请教，第一种人绝大多数能力素质极差，第二种能不能晋升不知道，但是能力素质绝对不差而且你可以放心大胆请教他不必担心被坑。</p><p> 14、对上不发语音，要发文字；对下不打电话，要写通知；平级不写信息，多打电话。</p><p> 15、对上负责比对下负责有用的多。每次和领导汇报，先想想自己是不是都明白了，被领导问住答不上来很不好。</p><p> 16、一个人成熟的标志是不与幼稚的人讨论问题，费时费力还不讨好，“你是对的”“这样想你开心那你就这样想”解决一切问题。</p><p> 17、如果你相对一个人可评价的能力素质全面占优，而你觉得他是三百，那么他就是三百，离他远点；如果不全面占优，通过结果判断你和他谁是三百，如果自己不幸是三百，记得调参，对自身错误决策的倔强不但蠢，而且浪费时间。</p><p> 18、判断一个领导是不是三百的方法并不是他的做法是否符合你的利益，而是思考自己如果在他的位置会不会做相同的事情，如果会，那么他不是三百。</p><p> 19、在你不知道1+1等于几的时候至少听三个人的答案再下结论，在你不知道说对不对的时候问问你的师傅（而不是领导）对不对。</p><p> 20、对待《为首长服务的艺术》这本书的态度能看出一个人的为人处世水平。</p><p> 21、把事办成的能力比讨论“对不对”和“好不好”的能力重要的多。</p><p> 22、选择既有对错，也有好坏，只是如果你每次选择都经过了深思熟虑，那么无论结果怎样都不值得你后悔。</p><p> 23、运气很重要，但是也没那么重要；能力很重要，但是也没那么重要；关系很重要，但是也没那么重要。</p><p> 24、体制内的工作是为人民服务，做不到是你的问题，不是体制的问题。</p><p> 25、对于绝大多数人来说，钱都是靠攒下来的，至少对于看我这个回答的人来说，是这样。</p><h2 id="五、关于人际交往"><a href="#五、关于人际交往" class="headerlink" title="五、关于人际交往"></a>五、关于人际交往</h2><p> 这30条成年人交往的潜规则，看到最后希望你不会怀疑人生</p><p> 1 原单位离职后，尽量不要回去看望老同事。你说过得好，人家认为你炫耀；你说过得不好，人家当面同情你，背后笑话你。 </p><p> 2 你总关心别人怎么看你，但狼从来不理会一只羊的意见。</p><p> 3 任何一次选择，都有它对应的筹码，愿赌服输&gt;是一个成年人应该具有的品质。</p><p> 4 你想给别人讲道理，就要比对方混得好。让人闭嘴的，往往不是道理，而是身份或者地位。</p><p> 5 这个世界上有很多事情都可以努力，但人与人之间不行。能走到最后的，其实一开始就是同路人。</p><p> 6 想要喜怒形于色，很多时候是需要资本的。</p><p> 7 人和人之间想要保持长久舒适的关系，靠的是共性和吸引。而不是一味的付出和道德绑架式的自我感动。</p><p> 8 想要跟别人借钱，先掂量一下你们的交情值多少钱。支付宝给你的额度，大概就是别人愿意借给你的额度。 </p><p> 9 最简单的社交技巧是长得好看，最有用的省钱技巧是赚得多。</p><p> 10 青春能掩盖很多问题：穷，丑，胖，脾气差，毒舌，都可以接受，毕竟年龄还小。但是等“青春”这块遮羞布拿开之后，一切缺点都会被无限放大。</p><p> 11 当实力悬殊、竞争的规则已经不公平的时候，妥协是保存实力的最好方式。</p><p> 12 男人当然喜欢年轻漂亮的女子，但男人尊重的，永远是那些刻苦勤奋的女性。慕强，永远刻在每一个人的骨髓里。</p><p> 13 高级的人独处，不是因为他想要孤独，而是周围找不到他的同类。</p><p> 14 关系越近，越觉得对方没什么了不起，距离才能产生神秘感和崇拜感。</p><p> 15 社交之所以累，是因为每个人都试图表现出自己其实并不具备的品质。</p><p> 16 所有的人脉都是假象，想要和老板做朋友，必须拥有同等的财富和同频的智慧。</p><p> 17 人情世故就是让别人爽，让对方觉得你值得信赖。只要他爽了一次，就会想第二次。</p><p> 18 任何人的底气都来源于经济实力，有钱能治愈一切自卑，光有善良没用，你要优秀才行。</p><p> 19 成年人不必谁说服谁，各存己见、各说各话就好，我的地盘我做主，你的地盘你做主。</p><p> 20 好看的人都是无情的，有钱的人都是冷酷的。因为如果他们不这么做，早就被人坑死了。</p><p> 21 有时候，对一个人的怜悯，等同于贬低他。一个成年人被怜悯，可能会产生被羞辱的感觉。 </p><p> 22和人在一起做100件好事，可能不如和人在一起做一件坏事建立起来的感情关系来得深厚。</p><p> 23 不要对任何人抱有道德上的洁癖，在这个世界上，每个灵魂都半人半鬼，凑近谁都没法看。</p><p> 24 没感觉就是嫌你丑，不合适就是嫌你穷，没什么道理可讲，做事情之前先看看自己手上的筹码。</p><p> 25 被拒绝的时候，就想想别人凭什么要帮你。</p><p> 26 世界上没有一个人必须永远都爱一个人，因为爱不是一种义务，也不是一种责任，爱是一种权利。</p><p> 27 如果没有价值交换的基础，非要用曾经的共情关系去撬动社交关系，换来的只能是勉为其难的施舍。 </p><p> 28 尊重人性，才能坦荡活着。啥是人性？三个字：不可控。所以要理解恩将仇报、背信弃义、不守承诺。</p><p> 29 一个人成熟的标志之一就是，明白每天发生在自己身上的99%的事情，对于别人而言，根本毫无意义。</p><p> 30 所谓有趣的灵魂，不过是这个人的信息密度和知识层面都远高于你，并愿意俯下身去听你说那毫无营养的废话和你交流，提出了一些你没有听过的观点，颠覆了你短浅的想象力及三观。</p><h2 id="六、关于爱情"><a href="#六、关于爱情" class="headerlink" title="六、关于爱情"></a>六、关于爱情</h2><p> 1、那个离开你的人，永远别原谅他。他想离开你的瞬间，必定做了利益的权衡，离开你，才符合他更大的利益。</p><p> 2、失恋可以哭，但爱人的心不要死。记住：这世上所有的前任都是为了给真爱铺路！</p><p> 3、这女人啊，就像一辆总想出轨的火车，可到最后呢，总得找到一个像轨道一样的丈夫，她剩下的那点要求就是要按时进站，定点发车。</p><p> 4、伤害你的不是对方的绝情，而是你心存幻想的坚持。无法许下承诺也无法兑现承诺的男人，就要去接受女人随时离开的结局。</p><p> 5、默契的一对，不是凑到一起有说不完的话，而是即使有一天一个字也不说也不会觉得尴尬。</p><p> 6、我从小就树立了正确的人生观：爱情来得快去得也快，只有猪肉卷是永恒的！</p><p> 7、大张旗鼓的离开其实都是试探，真正的离开是没有告别的。</p><p> 8、嘴上说着爱你，行动全是伤害。婚姻是两个人的经营，不是一个人的坐享其成。</p><p> 9、这世上最廉价的就是一贫如洗的真心和一事无成的温柔。给过对方太多特殊，她都视而不见，任何事情都有可能被原谅，唯独背叛只有零次和无数次，既然她没有认真，你也没必要当真。</p><p> 10、千万不要用你以为对人好的方式对她好，那只是道德式的自我感动罢了，到最后啥也没得到，只换回来一句：你是个好人！</p><p> 11、女生口中的随便，并非真正的随便。而是你把可供选择的选项告诉她，她随便选。</p><p> 12、人走茶凉伤感吗？不伤感！真正伤感的是：人走了，却把你的纸杯也骗走了！</p><p> 13、是你的谁也带不走，能带走的，那就证明根本就不是你的！</p><p> 14、能改变自己的都是神，想着去改变别人的都是神经病。成年人的世界，只筛选，不教育。</p><p> 15、女人的床如果容易上的话，恐怕都太不好下。</p>]]></content>
      
      
      <categories>
          
          <category> 摘录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拼搏的意义</title>
      <link href="/archives/c3445602.html"/>
      <url>/archives/c3445602.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="故事第一则–美国"><a href="#故事第一则–美国" class="headerlink" title="故事第一则–美国"></a>故事第一则–美国</h2><p>  奶奶五十岁才来的美国，身无分文，也没有一技之长，随身携带的只有长年辛勤劳作留下的一身病根。</p><p>  那是九十年代初，她去了唐人街的扎花厂上班，每天工作十个小时以上，一年工作三百六十五天。</p><p>  扎花按件算钱，她眼神虽然不好，却比谁扎得都快。</p><p>  有人弹吉他磨出了茧，有人搬砖头磨出了茧，她被针头扎出了茧。</p><p>  回国看我的时候，她给我带了费列罗巧克力，翘胡子薯片，Jif花生酱。</p><p>  她给我买好看的小西装，给我买一斤几十元的黄螺。</p><p>  她带我去动物园，游乐园，森林公园，带我去北京看长城，看天安门，看毛主席。</p><p>  “奶奶，美国比北京还好吗？”</p><p>  她用最朴实的语言向我描述纽约的繁华，告诉我美国好极了，一切都在等着我。</p><p>  知乎上经常讨论富养女孩，我有一个男孩被富养的故事。</p><p>  有一年，我的巧克力吃完了，薯片吃完了，花生酱吃完了，奶奶还是没有回来。</p><p>  那是我第一个不愿意知道的生活真相，她中风了，瘫了半边身子。</p>  <span id="more"></span><p>  奶奶移民美国时带去了三个未成年的儿子，二叔，三叔，四叔。</p><p>  二叔和三叔在登陆美国的第二天就打工去了，年幼的四叔读了几年书后也离开了学校。</p><p>  他们在亲戚家的餐馆打工，每天工作十二个小时，每周工作六天。</p><p>  餐馆一年营业三百六十四天，只在感恩节那天歇业。</p><p>  奶奶瘫痪后，叔叔们轮流回国，给我带好吃的，带我出去玩。</p><p>  我喜欢打乒乓球，二叔给我买了乒乓球，乒乓球拍，乒乓球桌。</p><p>  有一年流行四驱车，三叔给我买了一辆遥控越野车，助我碾压所有的小伙伴。</p><p>  四叔年少风流，出门把妹的时候总不忘带上我，要把我培养成下一代情圣。</p><p>  他们绝口不提在美国生存的艰辛，那是大人们的秘密，和我无关。</p><p>  奶奶出国五年后，爸妈也去了美国。</p><p>  怎一个落魄了得？夫妻俩连属于自己的房间都没有。</p><p>  扎花已经被时代淘汰，只有重活可以干。我爸当过屠夫，货柜工人，货运司机。</p><p>  细节不必赘述，无非就是 12小时 x 365天的陈词滥调。</p><p>  后来，他们四兄弟聚首，在密西根州开了一家小超市，一家餐馆，后来又开了第二家小超市，第二家餐馆。</p><p>  钱赚得越来越多，老家伙们拼命工作的老毛病却没有得到丝毫缓解。</p><p>  爸妈出国五年后，我也来了美国，看清了生活本来的面目。</p><p>  我在纽约生活了几个月，带着半身不遂的奶奶看遍了世界之都的繁华。</p><p>  在这之前，她几乎没有走出过唐人街的范围，以前对我描绘纽约时一半是转述，一半靠想象。</p><p>  后来，我去了密西根州投奔我爸，结束了长达五年的骨肉分离。</p><p>  我爸来车站接我，把我带到了一栋小别墅前，很得意地告诉我：“这是我们家，知道你要来，刚买的。”</p><p>  我去过奶奶刚来美国时住过的那个阴暗破旧的小公寓楼，也去过爸妈栖身过的那个散发着霉味的地下室，我知道我在密西根州会有一张床，应该也会有一个房间，但我没想到，我会有一个别墅，一个前院，一个后院，一整个铺垫好的未来。</p><p>  人这一生为什么要努力？</p><p>  奶奶的答案是我，爸妈的答案是我，我的答案是他们，以及把身家性命托付于我的媳妇和孩子。</p><p>  对于我来说，长大了，责任多了，自然而然地想要努力，不是为了赚很多很多钱，而是为了过上自己想要的生活，过上奶奶和父母不曾拥有过的生活。他们替我吃完了所有的苦，帮我走了九十九步，我自己只需再走一步，哪敢迟疑？</p><p>  从外曾祖父母算起，我们家族四代八十多口人已经在美国奋斗了半个多世纪。我们人人都在努力，我们一代好过一代。</p><p>  如果你的人生起点不高，不曾有人为你走过人生百步中的任何一步，不打紧，你尽管努力，多出来的步数不会被浪费掉，总有你在乎的人用得着，而你迟早会遇到你在乎的人。</p><p>  与诸君共勉。</p><h2 id="故事第二则–代价"><a href="#故事第二则–代价" class="headerlink" title="故事第二则–代价"></a>故事第二则–代价</h2><p>我有一个朋友，三本毕业，找了个男朋友是个检察官，人人羡慕那种。她捡了一只小狗，花了好些钱治病，千辛万苦养下来，他男朋友看见了，嫌脏叫她丟出去，她一声不吭，把狗丟出去了。如果这就是“嫁的好”的代价，我还是pass好了。</p><p>凡事都有代价，比如想要财务自由意志自由，就要多读书多工作比较辛苦，想要不花力气就有钱，就必须放弃很多东西，凡是与金主意志相违背的就必须修正。就看你觉得哪个比较容易了。</p><p>另外，如果一个二十多岁的女生，自己努力工作，基本可以预见四十岁的她大概是个什么样子，甚至六十岁什么样。如果一个二十多岁的女生，以嫁的好为目标，就很难推测四十岁的她是什么样子了。这是风险，需要自担。</p>]]></content>
      
      
      <categories>
          
          <category> 摘录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring MVC 执行流程</title>
      <link href="/archives/97d582dd.html"/>
      <url>/archives/97d582dd.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p> <img src="https://img2022.cnblogs.com/blog/1951916/202207/1951916-20220707091601372-1645370005.png" alt="img"></p> <span id="more"></span>![img](https://img2022.cnblogs.com/blog/1951916/202207/1951916-20220707091627677-20323056.png)]]></content>
      
      
      <categories>
          
          <category> springmvc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 29 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于链表中结构体typedef</title>
      <link href="/archives/e1a862bd.html"/>
      <url>/archives/e1a862bd.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文将以单链表和静态链表的初始化代码(c++)为例，具体分析了结构体中<code>typedef struct LNode{....} LNode, *LinkList, SLinkList[MaxSize];</code>的相关问题，并补充了C++中<strong>引用类型</strong>的一点知识。</p><span id="more"></span><h4 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h4><p>首先给出单链表的初始化代码：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef struct LNode {    ElemType data;    struct LNode *next;} LNode, *LinkList;bool InitList(LinkList &amp;L) {    L = (LNode *) malloc(sizeof(LNode));    if (L == NULL) {        return false;    }    L -&gt; next = NULL;    return true;}int main() {    LinkList L;    InitList(L);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从以上代码中，我们看到在定义结构体时，将struct LNode重定义为两个名字：<code>LNode</code>和<code>*LinkList</code></p><p>之所以这样命名，有助于我们后面对代码的理解。我们使用<code>LNode</code>来定义结构体变量并统一指代链表中的一个结点，使用<code>LinkList</code>定义指向结构体的指针并代表整个链表。</p><p>⭐上述表示定义了结构体<code>struct LNode</code>，并且<code>struct LNode</code>等价于<code>LNode</code>，<code>struct LNode *</code>等价于<code>LinkList</code>。所以定义结构体变量可以采用<code>struct LNode L</code>或者<code>LNode L</code>；定义结构体指针变量时可以采用<code>struct LNode *L</code>或者<code>LNode *L</code>或者<code>LinkList L</code></p><h4 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h4><p>现在有一个问题是为什么<code>InitList()</code>函数的形参为<code>LinkList &amp;L</code>？这对于不了解c++的我来说确实引发了一阵困惑。</p><p>⭐其实，在c++中<code>LinkList &amp;L</code>这种格式声明的是一种特殊的类型—-&gt;引用类型，它直接以按引用调用的方式调用变量（有点类似于指针，但并不相同）。</p><p>举个例子：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void swap1(int a, int b) {    int temp = a;    a = b;    b = temp;}void swap2(int *a, int *b) {    int temp = *a;    *a = *b;    *b = temp;}void swap3(int &amp;a, int &amp;b) {    int temp = a;    a = b;    b = temp;}int main() {    int a = 1, b = 2;    swap1(a, b); // 按值调用 其结果仍然是a = 1, b = 2;    swap2(&amp;a, &amp;b); // 通过指针模拟按引用调用，其结果为a = 2, b = 1;    swap3(a, b); // 按引用调用，其结果为a = 2, b = 1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过以上的解释，我们就可以理解<code>InitList(LinkList &amp;L)</code>实际上是按引用调用了链表指针，这样就可以将函数内对指针的修改带回到主函数中。</p><p>那么，如果我们不用这种方式，我们该怎么做呢？</p><p>此时，我们就需要使用双指针，代码如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef struct LNode {    ElemType data;    struct LNode *next;} LNode, *LinkList;bool InitList(LNode **L) { // 或者 InitList(LinkList *L)    (*L) = (LNode *) malloc(sizeof(LNode));    if ((*L) == NULL) {        return false;    }    (*L) -&gt; next = NULL;    return true;}int main() {    LinkList L;    InitList(&amp;L);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>到此为止，我们就解释了<code>LNode</code>和<code>LinkList</code>的具体使用情况（LNode声明结构体变量，LinkList声明结构体指针）以及C++中的引用类型。</strong></p><h4 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a>第三部分</h4><p>下面我们在举一个静态链表中的例子，深入理解一下。</p><p>先上代码：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define MaxSize 10typedef struct SNode{    ElemType data;    int next;} SLinkList[MaxSize];void testSLinkList() {    SLinkList a;    // 其他代码}---------------------------------// 等价于---------------------------------# define MaxSize 10struct SNode{    ElemType data;    int next;};void testSLinkList() {    struct SNode a[MaxSize];    // 后续代码}// 也就是说 struct Node a[MaxSize] &lt;==&gt; SLinkList a;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面我们总结出如下结论：</p><ol><li><code>typedef .... *LinkList;</code>可以使简化后续声明结构体指针的过程，<code>LinkList</code>就指代了一个结构体指针类型</li><li><code>typedef ..... LinkList[MaxSize];</code>可以使简化后续声明结构体数组的过程，<code>LinkList</code>就指代了一个结构体数组类型</li></ol><p>也就是说，我们通过<code>typedef</code>生成了一个简化版的新的数据类型。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> typedef、链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线索二叉树的构造及前驱后继的查找</title>
      <link href="/archives/cd5c56d7.html"/>
      <url>/archives/cd5c56d7.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在本文中，我将介绍三种线索二叉树的构造方法，包括中序线索二叉树、先序线索二叉树以及后序线索二叉树。在介绍过程中，首先我会给出构造的基本思路，然后说明其中几点注意事项，最后我将给出代码示例。之后，我会针对每一种线索二叉树，给出其查找某节点p的前驱和后继结点的方法。最后我将做一个小小的对比总结，以便清楚地展现出不同线索二叉树在构造过程中以及查找前驱后继结点上的区别。</p><p>下面我们就开始吧！</p><span id="more"></span><h2 id="1-二叉树的线索化"><a href="#1-二叉树的线索化" class="headerlink" title="1. 二叉树的线索化"></a>1. 二叉树的线索化</h2><h3 id="1-1-中序线索二叉树"><a href="#1-1-中序线索二叉树" class="headerlink" title="1.1 中序线索二叉树"></a>1.1 中序线索二叉树</h3><p><strong>中序线索二叉树的定义：</strong> 一个二叉树通过如下的方法“穿起来”：所有原本为空的右(孩子)指针改为指向该节点在中序序列中的后继，所有原本为空的左(孩子)指针改为指向该节点的中序序列的前驱。</p><p><a href="https://xiaotong-sun2.oss-cn-beijing.aliyuncs.com/typora/DataStructure/image-20220509174728805.png"><img src="https://xiaotong-sun2.oss-cn-beijing.aliyuncs.com/typora/DataStructure/image-20220509174728805.png" alt="img"></a></p><h4 id="1-1-1-朴素方法找中序前驱和后继"><a href="#1-1-1-朴素方法找中序前驱和后继" class="headerlink" title="1.1.1 朴素方法找中序前驱和后继"></a>1.1.1 朴素方法找中序前驱和后继</h4><p>首先我们来思考如何用一种简单的方法来寻找中序遍历中某个结点的前驱和后继呢？</p><p>我们在遍历二叉树的时候，总是依次获取后继结点的，那么我们就不难想到，我们只要能够在遍历的过程中不断记录当前结点的前一个结点，那么就能够很方便的找到目标结点的前驱结点，为此只需额外设置一个pre指针来记录当前结点的前一个结点即可。下图给出了这个思想的示例：</p><p><a href="https://xiaotong-sun2.oss-cn-beijing.aliyuncs.com/typora/DataStructure/2022591728.jpg"><img src="https://xiaotong-sun2.oss-cn-beijing.aliyuncs.com/typora/DataStructure/2022591728.jpg" alt="img"></a></p><p>当指针q和目标结点p重合时，pre指针指向的结点即为目标结点的前驱结点。当然，利用这种方法我们也可以找到目标结点的后继结点，只需要让pre指针与p指针重合，此时q指针指向的就是后继结点（但是需要对最后一个结点的后继结点进行特殊处理）。</p><p><strong>代码：</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void findPre(BiTree T) {    if (T == NULL) {        return;    }    findPre(T -&gt; lchild);    visit(T);    findPre(T -&gt; rchild);}void visit(BiTNode *q) {    if (q == p) {        final = pre;    } else {        pre = q;    }}BiTNode *p; // p指向目标结点BiTNode *pre = NULL; // 指向当前结点的前驱结点BiTNode *final = NULL; // 记录最终结果<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-1-2-中序线索化"><a href="#1-1-2-中序线索化" class="headerlink" title="1.1.2 中序线索化"></a>1.1.2 中序线索化</h4><p><strong>中序线索化的基本思想：</strong> 本质上就是借助1.1.1的思想，借助pre指针来记录前一个结点，若当前结点p的左孩子为空，则让其左指针指向pre使其成为前驱线索(需要借助<code>ltag=1</code>进行标记)，若pre指向的结点的右孩子为空，则让其右指针指向当前结点p使其成为后继线索(需要借助<code>rtag=1</code>进行标记)。</p><p><a href="https://xiaotong-sun2.oss-cn-beijing.aliyuncs.com/typora/DataStructure/2022592013.jpg"><img src="https://xiaotong-sun2.oss-cn-beijing.aliyuncs.com/typora/DataStructure/2022592013.jpg" alt="img"></a></p><p><strong>注意事项：</strong></p><ul><li>pre参数需要是<strong>引用类型</strong>，因为在程序运行中，pre的指向在不断进行更新。</li><li>处理中序遍历的最后一个结点时，可以不用判断rchild是否为NULL，因为中序遍历的最后一个结点的rchild必然为NULL否则就会继续遍历下去。但是，为了和其他线索二叉树统一起来，建议对最后一个结点进行一个非空判断。</li></ul><p><strong>代码：</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef struct ThreadNode {    ElemType data;    struct ThreadNode *lchild, *rchild;    int ltag, rtag;} ThreadNode, *ThreadTree;void InThread(ThreadTree p, ThreadTree &amp;pre) {    if (p == NULL) return;    InThread(p-&gt;lchild, pre); // 递归线索化左子树    if (p-&gt;lchild == NULL) { // 左子树为空，建立前驱线索        p-&gt;lchild = pre;        p-&gt;ltag = 1;    }    if (pre != NULL &amp;&amp; pre-&gt;rchild == NULL) { // 建立前驱结点的后继线索        pre-&gt;rchild = p;        pre-&gt;rtag = 1;    }    pre = p;    InThread(p-&gt;rchild, pre); // 递归线索化右子树}void CreatInThread(ThreadTree T) {    ThreadNode *pre = NULL;    if (T != NULL) {        InThread(T, pre);        if (pre-&gt;rchild == NULL) { // 处理最后一个结点            pre-&gt;rtag = 1;        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-先序线索二叉树"><a href="#1-2-先序线索二叉树" class="headerlink" title="1.2 先序线索二叉树"></a>1.2 先序线索二叉树</h3><p><strong>先序线索二叉树的定义：</strong> 一个二叉树通过如下的方法“穿起来”：所有原本为空的右(孩子)指针改为指向该节点在先序序列中的后继，所有原本为空的左(孩子)指针改为指向该节点的先序序列的前驱。</p><p><a href="https://xiaotong-sun2.oss-cn-beijing.aliyuncs.com/typora/DataStructure/image-20220509195726029.png"><img src="https://xiaotong-sun2.oss-cn-beijing.aliyuncs.com/typora/DataStructure/image-20220509195726029.png" alt="img"></a></p><h4 id="1-2-1-先序线索化"><a href="#1-2-1-先序线索化" class="headerlink" title="1.2.1 先序线索化"></a>1.2.1 先序线索化</h4><p>先序线索化的基本思想与中序线索化的思想相同，在这里不做过多赘述。</p><p><a href="https://xiaotong-sun2.oss-cn-beijing.aliyuncs.com/typora/DataStructure/2022592232.jpg"><img src="https://xiaotong-sun2.oss-cn-beijing.aliyuncs.com/typora/DataStructure/2022592232.jpg" alt="img"></a></p><p><strong>注意事项：</strong></p><ul><li><p>先序线索化过程中有一个需要格外注意的问题就是“转圈”问题，如下图所示的情况：当对d结点的左孩子线索化之后，由于先序遍历的规则，我们接下来应该遍历的是d的左子树也就是b，这样就导致了“转圈”问题。为了避免这个问题，我们就需要借助<code>ltag</code>判断左孩子是否为前驱线索。</p></li><li><p>处理先序遍历的最后一个结点时，其实也可以不用判断rchild是否为NULL，因为先序遍历的最后一个结点的rchild必然为NULL否则就会继续遍历下去。</p><p><a href="https://xiaotong-sun2.oss-cn-beijing.aliyuncs.com/typora/DataStructure/image-20220509202135408.png"><img src="https://xiaotong-sun2.oss-cn-beijing.aliyuncs.com/typora/DataStructure/image-20220509202135408.png" alt="img"></a></p></li></ul><p><strong>代码：</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef struct ThreadNode {    ElemType data;    struct ThreadNode *lchild, *rchild;    int ltag, rtag;} ThreadNode, *ThreadTree;void PreThread(ThreadTree p, ThreadTree &amp;pre) {    if (p == NULL) return;    if (p-&gt;lchild == NULL) { // 左子树为空，建立前驱线索        p-&gt;lchild = pre;        p-&gt;ltag = 1;    }    if (pre != NULL &amp;&amp; pre-&gt;rchild == NULL) { // 建立前驱结点的后继线索        pre-&gt;rchild = p;        pre-&gt;rtag = 1;    }    pre = p;    if (p -&gt; ltag == 0) { // 避免转圈问题        PreThread(p-&gt;lchild, pre); // 递归线索化左子树    }    PreThread(p-&gt;rchild, pre); // 递归线索化右子树}void CreatPreThread(ThreadTree T) {    ThreadNode *pre = NULL;    if (T != NULL) {        PreThread(T, pre);        if (pre-&gt;rchild == NULL) { // 处理最后一个结点            pre-&gt;rtag = 1;        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-3-后序线索二叉树"><a href="#1-3-后序线索二叉树" class="headerlink" title="1.3 后序线索二叉树"></a>1.3 后序线索二叉树</h3><p><strong>后序线索二叉树的定义：</strong> 一个二叉树通过如下的方法“穿起来”：所有原本为空的右(孩子)指针改为指向该节点在后序序列中的后继，所有原本为空的左(孩子)指针改为指向该节点的后序序列的前驱。</p><p><a href="https://xiaotong-sun2.oss-cn-beijing.aliyuncs.com/typora/DataStructure/image-20220509195922943.png"><img src="https://xiaotong-sun2.oss-cn-beijing.aliyuncs.com/typora/DataStructure/image-20220509195922943.png" alt="img"></a></p><h4 id="1-3-1-后序线索化"><a href="#1-3-1-后序线索化" class="headerlink" title="1.3.1 后序线索化"></a>1.3.1 后序线索化</h4><p>后序线索化的基本思想与中序线索化的思想相同，在这里不做过多赘述。</p><p><a href="https://xiaotong-sun2.oss-cn-beijing.aliyuncs.com/typora/DataStructure/2022592325.jpg"><img src="https://xiaotong-sun2.oss-cn-beijing.aliyuncs.com/typora/DataStructure/2022592325.jpg" alt="img"></a></p><p><strong>注意事项：</strong></p><ul><li>后序线索化过程中不会出现“转圈”问题</li><li>但是，处理后序遍历的最后一个结点时，需要进行额外的判断，确定最后一个结点的右孩子是否为空。</li></ul><p><strong>代码：</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef struct ThreadNode {    ElemType data;    struct ThreadNode *lchild, *rchild;    int ltag, rtag;} ThreadNode, *ThreadTree;void PostThread(ThreadTree p, ThreadTree &amp;pre) {    if (p == NULL) return;    PostThread(p-&gt;lchild, pre); // 递归线索化左子树    PostThread(p-&gt;rchild, pre); // 递归线索化右子树    if (p-&gt;lchild == NULL) { // 左子树为空，建立前驱线索        p-&gt;lchild = pre;        p-&gt;ltag = 1;    }    if (pre != NULL &amp;&amp; pre-&gt;rchild == NULL) { // 建立前驱结点的后继线索        pre-&gt;rchild = p;        pre-&gt;rtag = 1;    }    pre = p;}void CreatPreThread(ThreadTree T) {    ThreadNode *pre = NULL;    if (T != NULL) {        PostThread(T, pre);        if (pre-&gt;rchild == NULL) { // 处理最后一个结点            pre-&gt;rtag = 1;        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-线索二叉树找前驱-x2F-后继"><a href="#2-线索二叉树找前驱-x2F-后继" class="headerlink" title="2. 线索二叉树找前驱/后继"></a>2. 线索二叉树找前驱/后继</h2><h3 id="2-1-中序线索二叉树找后继"><a href="#2-1-中序线索二叉树找后继" class="headerlink" title="2.1 中序线索二叉树找后继"></a>2.1 中序线索二叉树找后继</h3><p>在中序线索二叉树中找到指定结点p的中序后继next</p><ol><li><p>若<code>p-&gt;rtag==1</code>，则<code>next=p-&gt;rchild</code></p></li><li><p>若<code>p-&gt;rtag==0</code>，则说明p一定有右孩子，此时<code>next=p的右子树中最左下结点</code></p><p><a href="https://xiaotong-sun2.oss-cn-beijing.aliyuncs.com/typora/DataStructure/image-20220512094730279.png"><img src="https://xiaotong-sun2.oss-cn-beijing.aliyuncs.com/typora/DataStructure/image-20220512094730279.png" alt="img"></a></p></li></ol><p><strong>代码：</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ThreadNode *Firstnode(ThreadNode *p) { // 找最左下结点    while (p -&gt; ltag == 0) {        p = p -&gt; lchild;    }    return p;}ThreadNode *Nextnode(ThreadNode *p) { // 判断p是否有右子树    if (p -&gt; rtag == 0) {        return Firstnode(p -&gt; rchild);    } else {        return p -&gt; rchild;    }}void InOrder(ThreadNode *T) { // 利用线索二叉树实现非递归的中序遍历    for (ThreadNode *p = Firstnode(T); p != NULL; p = Nextnode(p)) {        visit(p);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-中序线索二叉树找前驱"><a href="#2-2-中序线索二叉树找前驱" class="headerlink" title="2.2 中序线索二叉树找前驱"></a>2.2 中序线索二叉树找前驱</h3><p>在中序线索二叉树中找到指定结点p的中序前驱pre</p><ol><li><p>若<code>p-&gt;ltag==1</code>，则<code>pre=p-&gt;lchild</code></p></li><li><p>若<code>p-&gt;ltag==0</code>，则说明p一定有左孩子，此时<code>pre=p的左子树中最右下结点</code></p><p><a href="https://xiaotong-sun2.oss-cn-beijing.aliyuncs.com/typora/DataStructure/image-20220512095201562.png"><img src="https://xiaotong-sun2.oss-cn-beijing.aliyuncs.com/typora/DataStructure/image-20220512095201562.png" alt="img"></a></p></li></ol><p><strong>代码：</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ThreadNode *Lastnode(ThreadNode *p) { // 找最左下结点    while (p -&gt; rtag == 0) {        p = p -&gt; rchild;    }    return p;}ThreadNode *Prenode(ThreadNode *p) { // 判断p是否有右子树    if (p -&gt; ltag == 0) {        return Lastnode(p -&gt; lchild);    } else {        return p -&gt; lchild;    }}void RevInOrder(ThreadNode *T) { // 利用线索二叉树实现非递归的逆向中序遍历    for (ThreadNode *p = Lastnode(T); p != NULL; p = Prenode(p)) {        visit(p);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-先序线索二叉树找后继"><a href="#2-3-先序线索二叉树找后继" class="headerlink" title="2.3 先序线索二叉树找后继"></a>2.3 先序线索二叉树找后继</h3><p>在先序线索二叉树中找到指定结点p的先序后继next</p><ol><li><p>若<code>p-&gt;rtag==1</code>，则<code>next=p-&gt;rchild</code></p></li><li><p>若<code>p-&gt;rtag==0</code>，则说明p一定有右孩子，此时又分为两种情况：</p><ol><li>若p有左孩子，则<code>next=p-&gt;lchild</code></li><li>若p没有左孩子，则<code>next=p-&gt;rchild</code></li></ol><p><a href="https://xiaotong-sun2.oss-cn-beijing.aliyuncs.com/typora/DataStructure/image-20220512100443404.png"><img src="https://xiaotong-sun2.oss-cn-beijing.aliyuncs.com/typora/DataStructure/image-20220512100443404.png" alt="img"></a></p></li></ol><p><strong>代码：</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ThreadNode *Nextnode(ThreadNode *p) {    if (p -&gt; rtag == 1) {        return p -&gt; rchild;    } else if (p -&gt; rtag == 0 &amp;&amp; p -&gt; ltag == 0) {        return p -&gt; lchild;    } else if (p -&gt; rtag == 0 &amp;&amp; p -&gt; ltag == 1) {        return p -&gt; rchild;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-4-先序线索二叉树找前驱"><a href="#2-4-先序线索二叉树找前驱" class="headerlink" title="2.4 先序线索二叉树找前驱"></a>2.4 先序线索二叉树找前驱</h3><p>在先序线索二叉树中找到指定结点p的先序前驱pre</p><ol><li><p>若<code>p-&gt;ltag==1</code>，则<code>pre=p-&gt;lchild</code></p></li><li><p>若<code>p-&gt;ltag==0</code>，由于先序遍历的特性，p的左右子树不可能为其先序前驱，且先序前驱只可能存在于上层结点中。因此普通的二叉链表除非从头遍历否则是无法找到其先序前驱的，我们需要借助三叉链表才能实现。</p><p><a href="https://xiaotong-sun2.oss-cn-beijing.aliyuncs.com/typora/DataStructure/image-20220512101754989.png"><img src="https://xiaotong-sun2.oss-cn-beijing.aliyuncs.com/typora/DataStructure/image-20220512101754989.png" alt="img"></a><br><strong>对情况3的额外说明</strong><br><a href="https://xiaotong-sun2.oss-cn-beijing.aliyuncs.com/typora/DataStructure/image-20220512102021866.png"><img src="https://xiaotong-sun2.oss-cn-beijing.aliyuncs.com/typora/DataStructure/image-20220512102021866.png" alt="img"></a></p></li></ol><h3 id="2-5-后序线索二叉树找后继"><a href="#2-5-后序线索二叉树找后继" class="headerlink" title="2.5 后序线索二叉树找后继"></a>2.5 后序线索二叉树找后继</h3><p>在后序线索二叉树中找到指定结点p的后序后继next</p><ol><li><p>若<code>p-&gt;rtag==1</code>，则<code>next=p-&gt;rchild</code></p></li><li><p>若<code>p-&gt;rtag==0</code>，由于后序遍历的特性，p的左右子树不可能为其后序后继，且后序后后继只可能存在于上层结点中。因此普通的二叉链表除非从头遍历否则是无法找到其后序后继的，我们需要借助三叉链表才能实现。</p><p><a href="https://xiaotong-sun2.oss-cn-beijing.aliyuncs.com/typora/DataStructure/image-20220512103336642.png"><img src="https://xiaotong-sun2.oss-cn-beijing.aliyuncs.com/typora/DataStructure/image-20220512103336642.png" alt="img"></a><br><strong>对情况3的额外说明</strong><br><a href="https://xiaotong-sun2.oss-cn-beijing.aliyuncs.com/typora/DataStructure/image-20220512103718289.png"><img src="https://xiaotong-sun2.oss-cn-beijing.aliyuncs.com/typora/DataStructure/image-20220512103718289.png" alt="img"></a></p></li></ol><h3 id="2-6-后序线索二叉树找前驱"><a href="#2-6-后序线索二叉树找前驱" class="headerlink" title="2.6 后序线索二叉树找前驱"></a>2.6 后序线索二叉树找前驱</h3><p>在后序线索二叉树中找到指定结点p的后序前驱pre</p><ol><li><p>若<code>p-&gt;ltag==1</code>，则<code>pre=p-&gt;lchild</code></p></li><li><p>若<code>p-&gt;ltag==0</code>，则说明p一定有左孩子，此时又分为两种情况：</p><ol><li>若p有右孩子，则<code>next=p-&gt;rchild</code></li><li>若p没有右孩子，则<code>next=p-&gt;lchild</code></li></ol><p><a href="https://xiaotong-sun2.oss-cn-beijing.aliyuncs.com/typora/DataStructure/image-20220512102923688.png"><img src="https://xiaotong-sun2.oss-cn-beijing.aliyuncs.com/typora/DataStructure/image-20220512102923688.png" alt="img"></a></p></li></ol><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><table><thead><tr><th align="left"></th><th align="center">中序线索化</th><th align="center">先序线索化</th><th align="center">后序线索化</th></tr></thead><tbody><tr><td align="left"><strong>转圈问题</strong></td><td align="center">无</td><td align="center">有</td><td align="center">无</td></tr><tr><td align="left"><strong>最后一个结点的后继</strong></td><td align="center">直接赋值null</td><td align="center">直接赋值null</td><td align="center">需要判断</td></tr></tbody></table><hr><table><thead><tr><th align="left"></th><th align="center">中序线索二叉树</th><th align="center">先序线索二叉树</th><th align="center">后序线索二叉树</th></tr></thead><tbody><tr><td align="left"><strong>找前驱</strong></td><td align="center">√</td><td align="center">×</td><td align="center">√</td></tr><tr><td align="left"><strong>找后继</strong></td><td align="center">√</td><td align="center">√</td><td align="center">×</td></tr></tbody></table><p><a href="https://www.cnblogs.com/xiaotong-sun/p/16261584.html#tid-pyMPna">1. 二叉树的线索化</a><a href="https://www.cnblogs.com/xiaotong-sun/p/16261584.html#tid-Rks4m4">  1.1 中序线索二叉树</a><a href="https://www.cnblogs.com/xiaotong-sun/p/16261584.html#tid-A5Aaym">    1.1.1 朴素方法找中序前驱和后继</a><a href="https://www.cnblogs.com/xiaotong-sun/p/16261584.html#tid-KNcQFG">    1.1.2 中序线索化</a><a href="https://www.cnblogs.com/xiaotong-sun/p/16261584.html#tid-Y83njF">  1.2 先序线索二叉树</a><a href="https://www.cnblogs.com/xiaotong-sun/p/16261584.html#tid-nb5r8A">    1.2.1 先序线索化</a><a href="https://www.cnblogs.com/xiaotong-sun/p/16261584.html#tid-6GeC5D">  1.3 后序线索二叉树</a><a href="https://www.cnblogs.com/xiaotong-sun/p/16261584.html#tid-c7pAxE">    1.3.1 后序线索化</a><a href="https://www.cnblogs.com/xiaotong-sun/p/16261584.html#tid-JWXz3e">2. 线索二叉树找前驱/后继</a><a href="https://www.cnblogs.com/xiaotong-sun/p/16261584.html#tid-dkkEpX">  2.1 中序线索二叉树找后继</a><a href="https://www.cnblogs.com/xiaotong-sun/p/16261584.html#tid-bZPdBf">  2.2 中序线索二叉树找前驱</a><a href="https://www.cnblogs.com/xiaotong-sun/p/16261584.html#tid-2n7KRt">  2.3 先序线索二叉树找后继</a><a href="https://www.cnblogs.com/xiaotong-sun/p/16261584.html#tid-8mr2Xc">  2.4 先序线索二叉树找前驱</a><a href="https://www.cnblogs.com/xiaotong-sun/p/16261584.html#tid-4PTD2a">  2.5 后序线索二叉树找后继</a><a href="https://www.cnblogs.com/xiaotong-sun/p/16261584.html#tid-aT8xmY">  2.6 后序线索二叉树找前驱</a><a href="https://www.cnblogs.com/xiaotong-sun/p/16261584.html#tid-zmfrQx">3. 小结</a></p><p><strong>EOF</strong></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线索二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git学习笔记</title>
      <link href="/archives/a91eaa72.html"/>
      <url>/archives/a91eaa72.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>以下内容只是一些基本的git命令和操作，具体内容和具体操作参考：<a href="https://www.liaoxuefeng.com/wiki/896043488029600/896202815778784">https://www.liaoxuefeng.com/wiki/896043488029600/896202815778784</a></strong></p><hr><h3 id="一：git简介"><a href="#一：git简介" class="headerlink" title="一：git简介"></a>一：git简介</h3><ul><li>git是目前世界上最先进的<strong>分布式版本控制系统</strong></li><li>版本控制系统：可以储存一个文件在不同时间的版本，记录<strong>每次文件的改动</strong>，可以根据需要，随时<strong>切换到之前的版本</strong>。</li><li>分布式VS集中式：</li></ul><table><thead><tr><th align="center"></th><th align="center">中央服务器</th><th align="center">是否需要联网</th><th align="center">安全性</th></tr></thead><tbody><tr><td align="center">集中式</td><td align="center">需要</td><td align="center">需要</td><td align="center">低</td></tr><tr><td align="center">分布式</td><td align="center">不需要</td><td align="center">不需要</td><td align="center">高</td></tr></tbody></table><span id="more"></span><h3 id="二：安装git"><a href="#二：安装git" class="headerlink" title="二：安装git"></a>二：安装git</h3><ol><li>在Linux上安装<br>终端输入：</li></ol><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby">$ sudo apt install git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>在Windows上安装git<br>在Windows上使用Git，可以从Git官网直接下载安装程序，然后按默认选项安装即可。<br>安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！</li></ol><ul><li>安装完成后，需要在终端进行设置</li></ul><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog">$ git <span class="token keyword">config</span> <span class="token operator">--</span>global user<span class="token punctuation">.</span>name <span class="token string">"Your name"</span><span class="token kernel-function property">$git</span> <span class="token keyword">config</span> <span class="token operator">--</span>global user<span class="token punctuation">.</span>email <span class="token string">"email@example.com"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>--global</code>是一个全局变量参数</p><h3 id="三：创建版本库"><a href="#三：创建版本库" class="headerlink" title="三：创建版本库"></a>三：创建版本库</h3><ol><li>首先，选择一个合适的地方，创建一个空目录：</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">mkdir</span> learngit $ <span class="token builtin class-name">cd</span> learngit$ <span class="token builtin class-name">pwd</span> /Users/michael/learngit<span class="token builtin class-name">pwd</span><span class="token variable"><span class="token variable">`</span>命令用于显示当前目录。在我的电脑上，这个仓库位于<span class="token variable">`</span></span>/Users/michael/learngit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>通过<code>git init</code>命令把这个目录变成Git可以管理的仓库：</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> initInitialized empty Git repository <span class="token keyword">in</span> /Users/michael/learngit/.git/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">创建完成后会在当前目录下出现一个<span class="token string">`.git`</span>文件，若没有看见是因为这个目录默认为隐藏文件，用<span class="token string">`ls -ah`</span>命令就可以看见<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>把文件添加到版本库:<br>用命令 <code>vim a.txt</code> 在git仓库中编写一个文件<br>　把一个文件放到Git仓库只需要两步</li></ol><p>第一步，用命令<code>git add</code>告诉Git，把文件添加到仓库:</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">$ git <span class="token keyword">add</span> a<span class="token punctuation">.</span>txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第二步，用命令git commit告诉Git，把文件提交到仓库：</p><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby">$ git commit <span class="token operator">-</span>m <span class="token string-literal"><span class="token string">"wrote a readme file"</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>简单解释一下<code>git commit命令</code>，<code>-m</code>后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p><h3 id="四：版本退回"><a href="#四：版本退回" class="headerlink" title="四：版本退回"></a>四：版本退回</h3><ol><li>　<code>git status</code>–&gt;让我们掌握仓库当前的状态</li><li>　<code>git diff &lt; file &gt;</code>–&gt;查看文件当前的改动</li><li>　<code>git reset --hard HEAD^</code>–&gt;返回上次提交的版本</li><li>　<code>git reset --hard &lt; commit id &gt;</code>–&gt;返回你想返回的文件版本</li><li>　<code>git log --pretty=oneline</code>–&gt;查看commit id</li><li>　<code>git reflog </code>–&gt;用来记录每一次的命令</li></ol><h3 id="五：管理修改"><a href="#五：管理修改" class="headerlink" title="五：管理修改"></a>五：管理修改</h3><p>每次修改如果不用<code>git add</code>到暂存区,就不会加入到commit中<code>git diff HEAD -- &lt;file&gt;</code>可以查看工作区和版本库里最新版本的区别。</p><h3 id="六：撤销修改"><a href="#六：撤销修改" class="headerlink" title="六：撤销修改"></a>六：撤销修改</h3><p><code>git checkout -- file</code> 可以把工作区的修改全部撤销掉:<br><strong>两种情况:</strong><br>一种是readme.txt自修改后还没有被放到暂存区,现在,撤销修改就回到和版本库一模一样的状态;<br>一种是readme.txt已经添加到暂存区后,又作了修改,现在,撤销修改就回到添加到暂存区后的状态。<br><code>git reset HEAD file</code>可以把暂存区的修改撤销掉,重新放到工作区中。<code>HEAD</code>表示最新版本</p><h3 id="七：文件删除"><a href="#七：文件删除" class="headerlink" title="七：文件删除"></a>七：文件删除</h3><p><code>rm file</code>将工作区文件删掉。 #仅删除工作区<br><code>git rm file </code>从版本库将文件删掉,并且需要<code>git commit</code>  #删除工作区,并删除版本库<br>若是误删,用<code>git checkout -- file</code>将文件恢复到最新版。仅对rm有效</p><h3 id="八：添加远程库"><a href="#八：添加远程库" class="headerlink" title="八：添加远程库"></a>八：添加远程库</h3><p>第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：</p><pre class="line-numbers language-perl" data-language="perl"><code class="language-perl">$ ssh<span class="token operator">-</span>keygen <span class="token operator">-t</span> rsa <span class="token operator">-C</span> <span class="token string">"youremail@example.com"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。<br>如果一切顺利的话，可以在用户主目录里找到<code>.ssh</code>目录，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p><p>第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：<br>然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容：</p><p><a href="https://xiaotong-sun.oss-cn-beijing.aliyuncs.com/0.png"><img src="https://xiaotong-sun.oss-cn-beijing.aliyuncs.com/0.png" alt="img"></a></p><p>点＂Add Key”，你就应该看到已经添加的key:</p><p><a href="https://xiaotong-sun.oss-cn-beijing.aliyuncs.com/hh.png"><img src="https://xiaotong-sun.oss-cn-beijing.aliyuncs.com/hh.png" alt="img"></a></p><p><strong>使本地仓库和远程库关联起来:</strong><br><code>git remote add origin git@github.com:xiaotong-sun/xxxx.git</code><br>Origin 是远程库的名字,可以改成别的。 改名命令:<code>git remote rename origin xx</code></p><p><strong>第一次</strong>把本地库的所有内容推送到远程库上时的操作:<br><code>git push -u origin master</code><br>此后每次提交使用:<code>git push origin master</code></p><h3 id="九：从远程库克隆"><a href="#九：从远程库克隆" class="headerlink" title="九：从远程库克隆"></a>九：从远程库克隆</h3><p>已有远程库,使用命令克隆一个本地库:<br><code>git clone git@github.com:xiaotong-sun/xxxxx.git</code></p><h3 id="十：分支管理"><a href="#十：分支管理" class="headerlink" title="十：分支管理"></a>十：分支管理</h3><ol><li>创建分支:<code>git checkout -b dev</code> (dev为分支的名字,你可以随便起)<br><code>git checkout</code> + <code>-b </code>表示创建并切换—&gt;相当于—&gt;<code>git branch dev</code>&amp;&amp; <code>git checkout dev</code>两条命令<br><code>git switch -c dev</code>—&gt;也可以用来创建并切换新的分支<br><code>git branch</code>—&gt;可以用来查看当前分支</li><li>删除分支:<br><code>git branch -d dev</code></li><li>合并分支:合并某分支到当前分支:<br><code>git merge &lt; file &gt;</code></li><li>解决冲突:<br>当主分支和次分支都修改了部分内容,此时将无法快速合并这时可以直接查看,并将冲突修改后方可合并<br><code>git log --graph --pretty=oneline --abbrev-commit</code>—&gt;将提交版本整理成图形</li><li>分支管理策略:<br><code>git merge file </code>是一种fast forward合并,这种合并看不出来曾经做过合并<br><code>git merge --no-ff -m “”</code> ➕<code>dev</code> 是一种普通的合并,能看出合并历史。</li><li>bug分支:<br>用<code>git stash </code>将手头进行的工作现场储存下来,之后就可以放心的去修bug了<br>修bug时,要首先跳到bug所在分支,并在那个分支上创建一个分支用来修bug,修完之后将其合并。<br>返回原来干活的分支,<code>git stash list</code>查看存放的工作现场。<br><code>git stash apply</code>恢复,但stash内容不删除。<br>用<code>git stash drop</code>来删除<br>而<code>git stash pop </code>在恢复的同时也将<strong>stash内容删除了</strong><br>若存放了多个现场,用<code>git stash apply stash@{0}</code>来指定恢复<br>若主分支和次分支同时存在相同的bug,那么可用<code>git cherry-pick (序列号)</code>来复制这个bug的修改</li><li>feature 分支<br>开发一个新的feature,最好新建一个分支;如果要丢弃一个没有被合并过的分支可以通过<code>git branch -D file</code> 强行删除</li><li>多人协作<br><code>git remote</code>查看远程库信息,<code>git remote -v</code>来显示更详细的信息;<br>推送分支<code>git push origin master</code>推送主分支<br><code>git push origin dev</code>推其他分支<br><code>git clone</code> 只能克隆master分支,要想把其他分支也整到本地则需<br><code>git checkout -b dev origin/dev</code><br>git pull用来抓取,若git pull 失败请仔细看git给的提示<br>用<code> git branch --set-upstream (branch-name) origin/(branch name)</code>建立关联</li><li>rebase<br><code>git rebase branch-name</code>操作可以把本地未push的分支提交历史整理成直线<br>rebase的目的是是我们在 查看历史提交的变化时更容易</li></ol><h3 id="十一：标签管理"><a href="#十一：标签管理" class="headerlink" title="十一：标签管理"></a>十一：标签管理</h3><ol><li>打标签<br><code>git tag &lt;name&gt;</code>就可以打一个标签<br><code>git tag name commit-id</code>–&gt;对特定的提交打标<br><code>git tag </code>查看标签<br><code>git show name</code>查看标签信息<br><code>git tag -a name -m “” commit-id</code>创建带有说明的标签</li><li>删除标签<br><code>git tag -d name</code> 这能删除本地标签<br><code>git push origin :refs/tags/tag-name</code></li><li>推送标签<br><code>git push origin &lt;tag-name&gt;</code><br>一次性推送所有标签:<code>git push origin --tags</code></li></ol>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典设计原则 - SOLID</title>
      <link href="/archives/5760774.html"/>
      <url>/archives/5760774.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>SOLID 设计原则包含以下 5 种原则：</p><ul><li><p>单一职责原则（Single Responsibility Principle, SRP）</p></li><li><p>开闭原则（Open Closed Principle, OCP）</p></li><li><p>里式替换原则（Liskov Substitution Principle, LSP）</p></li><li><p>接口隔离原则（Interface Segregation Principle, ISP）</p></li><li><p>依赖反转原则（Dependency Inversion Principle, DIP）</p><span id="more"></span></li></ul><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>单一职责原则的描述是，一个类或者模块只负责完成一个职责（或功能）。当然，单一职责原则不止是可以针对于模块或类，对于很多粒度都有效果，如函数、类、接口、模块等等，模块通常由多个类组成。</p><p>职责可以指模块变化的原因，从这个角度理解，单一职责原则表示不要存在超过一个导致模块变更的原因。</p><p>需要注意的是，不同的应用场景、不同阶段的需求背景、不同的业务层面，对同一个类的职责是否单一，可能会有不同的判定结果。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>遵循单一职责原则，将会有以下的优点：</p><ul><li>提高代码的可维护性：职责越少，复杂度越低，可读性更好，可维护性就更高</li><li>降低代码变更的风险：职责越多，代码变更的可能性就越高，变更带来的风险也就越大</li></ul><h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><p>在实际开发中，出现以下现象有可能违反了单一职责原则：</p><ul><li>模块的变量、属性或代码行数过多</li><li>模块的内部对外部依赖过多</li><li>模块的私有方法过多</li><li>难以给模块取一个合理的名称</li><li>模块的大部分操作只针对几个属性</li></ul><p>如出现上述情况，则需要判断是否对代码做职责分离，以遵循单一职责原则，最终应以提高内聚、降低耦合、保证代码的可维护性为主。</p><h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><h3 id="理解-1"><a href="#理解-1" class="headerlink" title="理解"></a>理解</h3><p>开闭原则的描述是，软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”。</p><p>详细的解释就是，添加一个新的功能时，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）。更宽松的理解是以最小的修改代码的代价来完成新功能的开发。</p><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><p>遵循开闭原则，将会有以下的优点：</p><ul><li>减少测试范围：修改的代码范围越小，涉及的测试范围越小，未改动的测试代码仍能正常运行</li><li>降低维护成本：软件规模越大、寿命越长，则软件的维护成本越高</li></ul><h3 id="最佳实践-1"><a href="#最佳实践-1" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>若要做到“对扩展开发、对修改关闭”，有以下几点需要注意：</p><ul><li>时刻具备扩展意识、抽象意识、封装意识，多花时间设计代码结构，事先留好扩展点</li><li>大部分经典设计模式都是为了解决代码的扩展性问题而总结出来的，开闭原则是它们一个重要的评价依据</li></ul><h3 id="里式替换原则"><a href="#里式替换原则" class="headerlink" title="里式替换原则"></a>里式替换原则</h3><h3 id="理解-2"><a href="#理解-2" class="headerlink" title="理解"></a>理解</h3><p>里式替换原则的描述是，子类对象能够替换程序中父类对象出现的任何地方，并且保证原来程序的逻辑行为不变及正确性不被破坏。</p><p>从代码实现上看，面向对象的多态和里式替换原则有点类似，但是它们的关注点不一样：里式替换原则是用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性。</p><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><p>遵循里式替换原则，将会有以下的优点：</p><ul><li>实现有意义的继承：保证了父类的复用性，也降低了系统出错误的故障，防止误操作，同时也不会破坏继承的机制</li><li>增强程序的健壮性：不同的子类可以完成不同的业务逻辑，即使增加子类也能保持非常好的兼容性</li></ul><h4 id="最佳实践-2"><a href="#最佳实践-2" class="headerlink" title="最佳实践"></a>最佳实践</h4><p>通常，需要注意以下违反里式替换原则的代码：</p><ul><li>子类违背父类声明要实现的功能，如将加法改成减法</li><li>子类违背父类对输入、输出、异常的约定，如同一情况抛出的异常不同等</li><li>子类违背父类注释中所罗列的任何特殊声明</li></ul><h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><h3 id="理解-3"><a href="#理解-3" class="headerlink" title="理解"></a>理解</h3><p>接口隔离原则的描述是，接口的调用者或使用者不应该被强迫依赖它不需要的接口。</p><p>通过对接口的理解不同，接口隔离原则有以下三种理解：</p><p>1、如果把“接口”理解成一组接口集合，可以是某个微服务的接口，也可以是某个类库的接口等。如果存在部分接口只被部分调用者使用，就需要将这部分接口隔离出来，单独给这部分调用者使用，而不强迫其他调用者也依赖其他不会用到的接口。</p><p>2、如果把“接口”理解成单个 API 接口或函数，部分调用者只需要其中的部分功能，则需要将这个函数拆分成更细粒度的多个函数，让调用者只依赖它需要的那个细粒度函数。</p><p>3、如果把“接口”理解成 OOP 中的接口，也可以理解成为面向对象编程语言中的接口语法，那接口的设计要尽量单一，不要让接口的实现类和调用者依赖不需要的接口函数。</p><p>接口隔离原则和单一职责原则有点类似，但接口隔离原则更侧重于接口的设计，通常是通过调用者如何使用接口来定义这个接口的设计是否足够职责单一。</p><h3 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h3><p>遵循接口隔离原则，将会有以下的优点：</p><ul><li>高内聚，低耦合：拆分成更小粒度的接口，减少对外的交互，预防外来的变更，提高系统的灵活性和可维护性</li><li>可读性高，易于维护：合理的接口拆分粒度能保证系统的稳定性，减少项目工程的代码冗余</li></ul><h3 id="最佳实践-3"><a href="#最佳实践-3" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>采用接口隔离原则对接口进行约束时，要注意以下几点：</p><ul><li>接口尽量小，但是要有限度。定义过小，则会造成接口数量过多，使设计复杂化；定义多大，灵活性降低</li><li>每个项目和产品都有选定的环境因素，环境不同，接口拆分的标准就不同，深入了解业务逻辑</li></ul><h3 id="依赖反转原则"><a href="#依赖反转原则" class="headerlink" title="依赖反转原则"></a>依赖反转原则</h3><h3 id="理解-4"><a href="#理解-4" class="headerlink" title="理解"></a>理解</h3><p>依赖反转原则也被叫作依赖倒置原则，其含义是：高层模块不要依赖底层模块，高层模块和底层模块应该通过抽象来互相依赖；抽象不要依赖具体实现细节，具体实现细节依赖抽象。</p><p>Tomcat 是运行 Java Web 应用程序的容器，编写的 Web 应用程序代码只需要部署在 Tomcat 容器中下，便可被 Tomcat 容器调用执行。在这里，Tomcat 容器就是高层模块，Web 应用程序就是底层模块。Tomcat 容器和 Web 应用程序没有直接的依赖关系，而是通过 Servlet 规范实现互相依赖，而 Servlet 规范也不会依赖具体的实现细节，而是 Tomcat 和 Web 应用程序依赖 Servlet 规范。</p><h3 id="控制反转"><a href="#控制反转" class="headerlink" title="控制反转"></a>控制反转</h3><p>控制反转（Inversion Of Control, IoC）指的是将程序员自己对程序执行流程的控制反转成通过框架控制。控制反转并不是一种具体的设计技巧，而是一种笼统的设计思想，一般用来指导框架层面的设计。</p><p>实现控制反转主要有两种方式：依赖注入和依赖查找。两者的区别在于，前者是被动的接收对象，在类 A 的实例创建过程中即创建了依赖的 B 对象，通过类型或名称来判断将不同的对象注入到不同的属性中，而后者是主动索取相应类型的对象，获得依赖对象的时间也可以在代码中自由控制。</p><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>依赖注入（Dependency Injection, DI）是一种具体的编码技巧。</p><p>其详细概括就是：不通过 new 的方式在类的内部创建依赖对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。</p><p>一个简单的依赖注入代码例子如下：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">package</span> cn<span class="token punctuation">.</span>fatedeity<span class="token punctuation">.</span>designpattern<span class="token punctuation">.</span>philosophy<span class="token punctuation">;</span><span class="token comment">/** * 依赖注入案例 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DependencyInjectionCase</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> MessageSender messageSender<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">DependencyInjectionCase</span><span class="token punctuation">(</span>MessageSender messageSender<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>messageSender <span class="token operator">=</span> messageSender<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sendMessage</span><span class="token punctuation">(</span>String phone<span class="token punctuation">,</span> String message<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>messageSender<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>phone<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        MessageSender smsSender <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SmsSender</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        DependencyInjectionCase dependencyInjectionCase0 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DependencyInjectionCase</span><span class="token punctuation">(</span>smsSender<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// SmsSender sms send sms message</span>        dependencyInjectionCase0<span class="token punctuation">.</span><span class="token function">sendMessage</span><span class="token punctuation">(</span><span class="token string">"sms"</span><span class="token punctuation">,</span> <span class="token string">"sms message"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        MessageSender inboxSender <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InboxSender</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        DependencyInjectionCase dependencyInjectionCase1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DependencyInjectionCase</span><span class="token punctuation">(</span>smsSender<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// SmsSender inbox send inbox message</span>        dependencyInjectionCase1<span class="token punctuation">.</span><span class="token function">sendMessage</span><span class="token punctuation">(</span><span class="token string">"inbox"</span><span class="token punctuation">,</span> <span class="token string">"inbox message"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">InboxSender</span> <span class="token keyword">implements</span> <span class="token class-name">MessageSender</span> <span class="token punctuation">{</span>    <span class="token decorator"><span class="token at operator">@</span><span class="token function">Override</span></span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">send</span><span class="token punctuation">(</span>String phone<span class="token punctuation">,</span> String message<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"InboxSender "</span> <span class="token operator">+</span> phone <span class="token operator">+</span> <span class="token string">" send "</span><span class="token operator">+</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">SmsSender</span> <span class="token keyword">implements</span> <span class="token class-name">MessageSender</span> <span class="token punctuation">{</span>    <span class="token decorator"><span class="token at operator">@</span><span class="token function">Override</span></span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">send</span><span class="token punctuation">(</span>String phone<span class="token punctuation">,</span> String message<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"SmsSender "</span> <span class="token operator">+</span> phone <span class="token operator">+</span> <span class="token string">" send "</span><span class="token operator">+</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">interface</span> <span class="token class-name">MessageSender</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">send</span><span class="token punctuation">(</span>String phone<span class="token punctuation">,</span> String message<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h3><p>遵循依赖反转原则，将会有以下的优点：</p><ul><li>查询依赖和应用代码分离，大量降低工厂类和单例类的数量，代码层次更加清晰</li><li>没有侵入性，无须依赖容器的 API，也无须实现一些特殊接口</li></ul><h3 id="最佳实践-4"><a href="#最佳实践-4" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>通过依赖注入提供的扩展点，简单配置一下所有需要的类及其类之间依赖关系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等功能。</p><p>现成的依赖注入创建有很多，比如 Google Guide、Java Spring、Pico Container、Butterfly Container 等。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot2.0配置</title>
      <link href="/archives/d7eba49.html"/>
      <url>/archives/d7eba49.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本章内容</p><ol><li>自定义属性快速入门</li><li>外化配置</li><li>自动配置</li><li>自定义创建 Starter 组件</li></ol><p>摘录：读书是读完这些文字还要好好用心去想想，写书也一样，做任何事也一样</p><p><img src="http://springforall.ufile.ucloud.com.cn/static/img/9ebfd97b481d9bda2623e4c80a1746601515130" alt="img"></p><p>图 2 第二章目录结构图</p><span id="more"></span><h1 id="第-2-章-Spring-Boot-配置"><a href="#第-2-章-Spring-Boot-配置" class="headerlink" title="第 2 章 Spring Boot 配置"></a>第 2 章 Spring Boot 配置</h1><p>Spring Boot 配置，包括自动配置和外化配置。本章先实现自定义属性工程，将属性外化配置在 application.properties 应用配置文件，然后在工程中获取该属性值。接着会详细介绍属性的获取方式、外化配置和自动配置。最后会介绍利用自动配置自定义 Start 组件。</p><h2 id="2-1-快速入门工程"><a href="#2-1-快速入门工程" class="headerlink" title="2.1 快速入门工程"></a>2.1 快速入门工程</h2><p>第一章的 <code>HelloBookController</code> 控制层中，在代码中以硬编码的方式使用字符串表示书信息。下面把书的信息作为属性，外化配置在 application.properties 。好处是将应用参数、业务参数或第三方参数等统一配置在应用配置文件中，避免配置侵入业务代码，达到可配置的方式，方便及时调整修改。</p><h3 id="2-1-1-配置属性"><a href="#2-1-1-配置属性" class="headerlink" title="2.1.1 配置属性"></a>2.1.1 配置属性</h3><p>新建工程命名为 chapter-2-spring-boot-config ，在 application.properties 中配置书名和作者，配置如下：</p><pre class="line-numbers language-none"><code class="language-none">## 书信息demo.book.name=[Spring Boot 2.x Core Action]demo.book.writer=BYSocket<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>.properties 文件的每行参数被存储为一对字符串，即一个存储参数名称，被称为键；另一个为值。一般称为键值对配置。井号（#）或者英文状态下的叹号（!）作为第一行中第一个非空字符来表示该行的文本为注释。另外，反斜杠（\）用于转义字符。</p><p>Spring Boot 支持并推荐使用 YAML 格式的配置文件，将 application.properties 文件替换成 application.yml 文件，并配置相同的属性，配置如下：</p><pre class="line-numbers language-none"><code class="language-none">## 书信息demo:    book:        name: 《Spring Boot 2.x 核心技术实战 - 上 基础篇》        writer: 泥瓦匠BYSocket<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>YAML 是一个可读性高，用来表达数据序列的格式。表示键值对格式时，注意键和值由冒号及空白字符分开。强调下，空白字符是必须的，IDE 一般也会提示。两种配置方式都非常便捷，在开发中选择 .properties 或 .yml 文件配置。但如果两种配置文件同时存在的时候，默认优先使用 .properties 配置文件。YAML 与 .properties 配置文件对比如图 2-1 所示：</p><p><img src="http://springforall.ufile.ucloud.com.cn/static/img/3ed365aaf6a3e0dbdf1be557a87708391515130" alt="img"></p><p>图 2-1 YAML 与 .properties 配置文件对比</p><p>注意：</p><p>在 application.properties 配置中文值，读取时会出现中文乱码问题。因为 Java .properties 文件默认编码方式是 iso-8859 ，Spring Boot 应用以 UTF-8 的编码方式读取，就导致出现乱码问题。</p><p>官方 Issue 中的解决方法是，将 .properties 文件中配置的中文值转义成 Unicode 编码形式。例如 <code>demo.book.writer=泥瓦匠</code> 应该配置成 <code>demo.book.writer=\u6ce5\u74e6\u5320</code> 。利用 IDEA properties 插件 或利用 Java 文件转码工具 native2ascii 来快速地进行转义。该工具有在线版实现，地址如下：<br><a href="https://javawind.net/tools/native2ascii.jsp">https://javawind.net/tools/native2ascii.jsp</a></p><h3 id="2-1-2-创建属性类"><a href="#2-1-2-创建属性类" class="headerlink" title="2.1.2 创建属性类"></a>2.1.2 创建属性类</h3><p>在工程中新建包目录 <code>demo.springboot.config</code> ，并在目录中创建名为 BookProperties 的属性类，代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Value</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span></span><span class="token class-name">Component</span></span><span class="token punctuation">;</span><span class="token comment">/** * 书属性 */</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BookProperties</span> <span class="token punctuation">{</span>    <span class="token comment">/**     * 书名     */</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${demo.book.name}"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token comment">/**     * 作者     */</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${demo.book.writer}"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> writer<span class="token punctuation">;</span>    <span class="token comment">// ... 省略 getter / setter 方法</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>利用 <code>@Component</code> 注解定义了书的属性 Bean，并通过 <code>@Value</code> 注解为该 Bean 的成员变量（或者方法参数）自动注入 application.properties 文件的属性值。<code>@Value</code> 注解是通过 “${propName}” 的形式引用属性，propName 表示属性名称。</p><p>核心注解的知识点：</p><ul><li>@Component 注解：<br><code>@Component</code> 对类进行标注，职责是泛指组件 Bean ，应用启动时会被容器加载并加入容器管理。常见的 <code>@Controller</code>、<code>@Service</code> 、<code>@Repository</code> 是 <code>@Component</code> 的分类细化组件，分别对应控制层、服务层、持久层的 Bean。</li><li>@Value 注解：<br><code>@Value</code> 对 Bean 的字段或者方法参数进行标注，职责是基于表达式给字段或方法参数设置默认属性值。通常格式是注解 + SpEL 表达式，如 <code>@Value("SpEL 表达式")</code>。</li></ul><p>使用 <code>@Vlaue</code> 注解来引用属性值时，确保所引用的属性值在 application.properties 文件存在并且相对应匹配，否则会造成 Bean 的创建错误，引发 <code>java.lang.IllegalArgumentException</code> 非法参数异常。</p><h3 id="2-1-3-获取属性"><a href="#2-1-3-获取属性" class="headerlink" title="2.1.3 获取属性"></a>2.1.3 获取属性</h3><p>修改原有的 <code>HelloBookController</code> 类，通过注入的方式获取书属性 Bean 并返回。代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">demo<span class="token punctuation">.</span>springboot<span class="token punctuation">.</span>config<span class="token punctuation">.</span></span><span class="token class-name">BookProperties</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Autowired</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">GetMapping</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">RestController</span></span><span class="token punctuation">;</span><span class="token annotation punctuation">@RestController</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloBookController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token class-name">BookProperties</span> bookProperties<span class="token punctuation">;</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/book/hello"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Hello， "</span> <span class="token operator">+</span> bookProperties<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" is writing "</span>                <span class="token operator">+</span> bookProperties<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" ！"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过 <code>@Autowired</code> 注解标记在 <code>BookProperties</code> 字段，控制层自动装配属性 Bean 并使用。默认情况下要求被注解的 Bean 必须存在，需要允许 NULL 值，可以设置其 required 属性为 false： <code>@Autowired(required = false)</code>。</p><h3 id="2-1-4-运行工程"><a href="#2-1-4-运行工程" class="headerlink" title="2.1.4 运行工程"></a>2.1.4 运行工程</h3><p>执行 <code>ConfigApplication</code> 类启动，在控制台看到成功运行的输出后，打开浏览器访问 /book/hello 地址，可以看到如图 2-2 所示的返回结果：</p><p><img src="http://springforall.ufile.ucloud.com.cn/static/img/d9aea1949788d79ea24568536856e3c51515130" alt="img"></p><p>图 2-2 Hello Book 页面</p><p>也可以通过单元测试的方式验证属性获取是否成功，单元测试具体相关的会在第 9 章节介绍。单元测试代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">demo<span class="token punctuation">.</span>springboot<span class="token punctuation">.</span>config<span class="token punctuation">.</span></span><span class="token class-name">BookProperties</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span></span><span class="token class-name">Assert</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span></span><span class="token class-name">Test</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>runner<span class="token punctuation">.</span></span><span class="token class-name">RunWith</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Autowired</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>test<span class="token punctuation">.</span>context<span class="token punctuation">.</span></span><span class="token class-name">SpringBootTest</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>test<span class="token punctuation">.</span>context<span class="token punctuation">.</span>junit4<span class="token punctuation">.</span></span><span class="token class-name">SpringRunner</span></span><span class="token punctuation">;</span><span class="token annotation punctuation">@RunWith</span><span class="token punctuation">(</span><span class="token class-name">SpringRunner</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@SpringBootTest</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConfigApplicationTests</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token class-name">BookProperties</span> bookProperties<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testBookProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token function">assertEquals</span><span class="token punctuation">(</span>bookProperties<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"'Spring Boot 2.x Core Action'"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token function">assertEquals</span><span class="token punctuation">(</span>bookProperties<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"BYSocket"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-2-配置属性的获取方式"><a href="#2-2-配置属性的获取方式" class="headerlink" title="2.2 配置属性的获取方式"></a>2.2 配置属性的获取方式</h2><p>配置属性的常用获取方式有基于 <code>@Value</code> 和 <code>@ConfigurationProperties</code> 注解两种方式。两种方式适合的场景不同，下面具体介绍其使用方法和场景。</p><h3 id="2-2-1-Value-注解"><a href="#2-2-1-Value-注解" class="headerlink" title="2.2.1 @Value 注解"></a>2.2.1 @Value 注解</h3><p><code>@Value</code> 注解对 Bean 的变量或者方法参数进行标注，职责是基于表达式给字段或方法参数设置默认属性值。通常格式是注解 + SpEL 表达式，如 <code>@Value("SpEL 表达式")</code>，并标注在对应的字段或者方法上方，且必须对变量一一标注。这种方式适用于小而不复杂的属性结构。属性结构复杂，字段很多的情况下，这种方式会比较繁琐，应该考虑使用 <code>@ConfigurationProperties</code> 注解。</p><p>另外通过 <code>@PropertySource</code> 注解引入对应路径的其他 .properties 文件。将书信息重新配置在 classpath 下新的 book.properties 配置文件后，读取新配置文件的代码如下：</p><pre class="line-numbers language-none"><code class="language-none">import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.PropertySource;import org.springframework.stereotype.Component;/** * 书属性 */@Component@PropertySource("classpath:book.properties")public class BookProperties {    /**     * 书名     */    @Value("${demo.book.name}")    private String name;    /**     * 作者     */    @Value("${demo.book.writer}")    private String writer;    // ... 省略 getters / setters 方法}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-2-ConfigurationProperties-注解"><a href="#2-2-2-ConfigurationProperties-注解" class="headerlink" title="2.2.2 @ConfigurationProperties 注解"></a>2.2.2 @ConfigurationProperties 注解</h3><p>在包目录 <code>demo.springboot.config</code> 中创建名为 BookComponent 的属性类，并使用 <code>@ConfigurationProperties</code> 注解获取属性，代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>context<span class="token punctuation">.</span>properties<span class="token punctuation">.</span></span><span class="token class-name">ConfigurationProperties</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span></span><span class="token class-name">Component</span></span><span class="token punctuation">;</span><span class="token comment">/** * 书属性 * */</span><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"demo.book"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BookComponent</span> <span class="token punctuation">{</span>    <span class="token comment">/**     * 书名     */</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token comment">/**     * 作者     */</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> writer<span class="token punctuation">;</span>    <span class="token comment">// ... 省略 getters / setters 方法</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类似 <code>@Value</code> 注解方式，使用 <code>@ConfigurationProperties(prefix = "demo.book")</code> 注解标注在类上方可以达到相同的效果。 <code>@ConfigurationProperties</code> 注解的 prefix 是指定属性的参数名称。会匹配到配置文件中 “ demo.book. <em>” 结构的属性，星号 “</em> ” 是指会一一对应匹配 <code>BookComponent</code> 类的字段名。例如，字段 name 表示书名，会匹配到 <code>demo.book.name</code> 属性值。</p><p><code>@Value</code> 注解方式强制字段必须对应在配置文件， <code>@ConfigurationProperties</code> 注解方式则不是必须的。一般情况下，所有字段应该保证一一对应在配置文件。如果没有属性值对应的话，该字段默认为空， <code>@ConfigurationProperties</code> 注解方式也不会引发任何异常，Spring Boot 推荐使用 <code>@ConfigurationProperties</code> 注解方式获取属性。</p><p>同样使用单元测试验证获取属性是否成功。单元测试代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Autowired</span><span class="token class-name">BookComponent</span> bookComponent<span class="token punctuation">;</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testBookComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token function">assertEquals</span><span class="token punctuation">(</span>bookComponent<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"'Spring Boot 2.x Core Action'"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token function">assertEquals</span><span class="token punctuation">(</span>bookComponent<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"BYSocket"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="API-org-springframework-boot-context-properties-ConfigurationProperties-注解参数"><a href="#API-org-springframework-boot-context-properties-ConfigurationProperties-注解参数" class="headerlink" title="API org.springframework.boot.context.properties.ConfigurationProperties 注解参数"></a>API org.springframework.boot.context.properties.ConfigurationProperties 注解参数</h5><ul><li>prefix<br>字符串值，绑定该名称前缀的属性对象。</li><li>value<br>字符串值，功能同 prefix 参数。</li><li>ignoreInvalidFields<br>布尔值，默认 false。绑定对象时，忽略无效字段。</li><li>ignoreUnknownFields<br>布尔值，默认 true。绑定对象时，忽略未知字段。</li></ul><h3 id="2-2-3-ConfigurationProperties-数据验证"><a href="#2-2-3-ConfigurationProperties-数据验证" class="headerlink" title="2.2.3 @ConfigurationProperties 数据验证"></a>2.2.3 @ConfigurationProperties 数据验证</h3><p><code>@ConfigurationProperties</code> 注解方式支持验证功能，即当属性类被 <code>@Validated</code> 注解标注时，Spring Boot 初始化时会验证类的字段。在类的字段上添加 JSR-303 约束注解，进行数据验证。下面为书属性字段添加非 NULL 和字符串非空约束，代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>context<span class="token punctuation">.</span>properties<span class="token punctuation">.</span></span><span class="token class-name">ConfigurationProperties</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span></span><span class="token class-name">Component</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>validation<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Validated</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">javax<span class="token punctuation">.</span>validation<span class="token punctuation">.</span>constraints<span class="token punctuation">.</span></span><span class="token class-name">NotEmpty</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">javax<span class="token punctuation">.</span>validation<span class="token punctuation">.</span>constraints<span class="token punctuation">.</span></span><span class="token class-name">NotNull</span></span><span class="token punctuation">;</span><span class="token comment">/** * 书属性 * */</span><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"demo.book"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Validated</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BookComponent</span> <span class="token punctuation">{</span>    <span class="token comment">/**     * 书名     */</span>    <span class="token annotation punctuation">@NotEmpty</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token comment">/**     * 作者     */</span>    <span class="token annotation punctuation">@NotNull</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> writer<span class="token punctuation">;</span>    <span class="token comment">// ... 省略 getters / setters 方法</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过 <code>@Validated</code> 注解开启对 <code>BookComponent </code>类字段的数据验证，如果 name 字段为 NULL 或者为空字符串时，会引发 <code>BindValidationException</code> 绑定数据验证异常。数据验证常用在邮箱格式或者有长度限制的属性字段。另外，验证嵌套属性的值，必须在嵌套对象字段上方标注 <code>@Valid</code> 注解，用来触发其验证。例如，在书属性中新增嵌套对象出版社 <code>Publishing</code>，就需要在该对象上方标注 <code>@Valid</code> 注解，来开启对 <code>Publishing</code> 对象的数据验证。综上，两种属性获取方式各有优缺点，对比如图 2-3 所示：</p><p><img src="http://springforall.ufile.ucloud.com.cn/static/img/9ab13554345f8baada0ff0fae9d226881515130" alt="img"></p><p>图 2-3 @ConfigurationPropertiesd vs @Value</p><h2 id="2-3-外化配置"><a href="#2-3-外化配置" class="headerlink" title="2.3 外化配置"></a>2.3 外化配置</h2><p>Spring Boot 可以将配置外部化，即分离存储在 classpath 之外，这种模式叫做 “外化配置”。常用在不同环境中，将配置从代码中分离外置，只要简单地修改下外化配置，可以依旧运行相同的应用代码。外化配置表现形式不单单是 .properties 和 .yml 属性文件，还可以使用环境变量和命令行参数等来实现。那么，多处配置了相同属性时，Spring Boot 是通过什么方式来控制外化配置的冲突呢？答案是外化配置优先级。</p><h3 id="2-3-1-外化配置优先级"><a href="#2-3-1-外化配置优先级" class="headerlink" title="2.3.1 外化配置优先级"></a>2.3.1 外化配置优先级</h3><p>用命令行配置去覆盖 .properties 文件配置方法很简单。正常情况下利用 Java 命令运行工程，代码如下：</p><pre class="line-numbers language-none"><code class="language-none">// chapter-2-spring-boot-config 目录下运行java -jar target/chapter-2-spring-boot-config-1.0.jar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>下面将书的作者信息 BYSocket 改成 Jeff ， 通过命令行配置覆盖属性，代码如下：</p><pre class="line-numbers language-none"><code class="language-none">java -jar target/chapter-2-spring-boot-config-1.0.jar --demo.book.writer=Jeff<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在命令行配置中，设置属性值的格式是用两个连续的减号 “–”标志属性。在控制台看到成功运行的输出后，打开浏览器，访问 /book/hello 地址，可以看到如图 2-4 所示的返回结果：</p><p><img src="http://springforall.ufile.ucloud.com.cn/static/img/b5f58da0340ed3f9218ed1d117c31b581515130" alt="img"></p><p>图 2-4 书信息被覆盖页面</p><p>通过命令行配置覆盖属性提供了非常大的作用与便利性，常见于使用 shell 脚本运行工程时，可以方便地修改工程运行的配置。</p><p>但是这就引发了一个问题，岂不让工程很有侵入性，如果开放这个功能，导致未知的安全问题。所以 Spring Boot 提供了屏蔽命令行属性值设置，在应用启动类中设置 <code>setAddCommandLineProperties</code> 方法为 <code>false</code> ，用于关闭命令行配置功能，代码如下：</p><pre class="line-numbers language-none"><code class="language-none">SpringApplication.setAddCommandLineProperties(false);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>命令行配置属性的优先级是第四。外化配置获取属性时，会按优先级从高到低获取。如果高优先级存在属性，则返回属性，并忽略优先级低的属性。优先级如下：</p><ol><li>本地 Devtools 全局配置</li><li>测试时 <code>@TestPropertySource</code> 注解配置</li><li>测试时 <code>@SpringBootTest</code> 注解的 properties 配置</li><li>命令行配置</li><li>SPRING_APPLICATION_JSON 配置</li><li><code>ServletConfig</code> 初始化参数配置</li><li><code>ServletContext</code> 初始化参数配置</li><li>Java 环境的 JNDI 参数配置</li><li>Java 系统的属性配置</li><li>OS 环境变量配置</li><li>只能随机属性的 <code>RandomValuePropertySource</code> 配置</li><li>工程 jar 之外的多环境配置文件（application- {profile}.properties 或 YAML）</li><li>工程 jar 之内的多环境配置文件（application- {profile}.properties 或 YAML）</li><li>工程 jar 之外的应用配置文件（application.properties 或 YAML）</li><li>工程 jar 之内的应用配置文件（application.properties 或 YAML）</li><li><code>@Configuration</code> 类中的 @PropertySource 注解配置</li><li>默认属性配置（<code>SpringApplication.setDefaultProperties</code> 指定）</li></ol><h3 id="2-3-2-属性引用"><a href="#2-3-2-属性引用" class="headerlink" title="2.3.2 属性引用"></a>2.3.2 属性引用</h3><p>在 application.properties 中配置属性时，属性之间可以直接通过 “${propName}” 的形式引用其他属性。比如新增书的描述 description 属性，代码如下：</p><pre class="line-numbers language-none"><code class="language-none">## 书信息demo.book.name=[Spring Boot 2.x Core Action]demo.book.writer=BYSocketdemo.book.description=${demo.book.writer}'s${demo.book.name}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>demo.book.description 属性引用了前面定义的 demo.book.name 和 demo.book.writer 属性，其值为 BYSocket’s[Spring Boot 2.x Core Action] 。一方面可以使相同配置可以复用，另一方面增强了配置的阅读性。</p><h3 id="2-3-3-使用随机数"><a href="#2-3-3-使用随机数" class="headerlink" title="2.3.3 使用随机数"></a>2.3.3 使用随机数</h3><p>在 application.properties 中配置属性时，可以使用随机数配置，例如注入某些密钥、UUID 或者测试用例，需要每次不是一个固定的值。<code>RandomValuePropertySource</code> 类随机提供整形、长整形数、UUID 或者字符串。使用代码如下：</p><pre class="line-numbers language-none"><code class="language-none">my.secret=${random.value}my.number=${random.int}my.bignumber=${random.long}my.uuid=${random.uuid}my.number.less.than.ten=${random.int(10)}my.number.in.range=${random.int[1024,65536]}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-4-多环境配置"><a href="#2-3-4-多环境配置" class="headerlink" title="2.3.4 多环境配置"></a>2.3.4 多环境配置</h3><p>多环境是指不同配置的生产服务器使用同一工程代码部署，比如：开发环境、测试环境、预发环境、生产环境等。各个环境的工程端口、数据库配置、Redis 配置、日志配置等都会不同，传统模式下需要修改配置，工程重新编译打包，并部署到指定环境服务器。结果是容易发生配置错误，导致开发部署效率低下。Spring Boot 使用多环境配置去解决这个问题。</p><p>多环境配置，类似 Maven 构建配置文件的思路，即配置多个不同环境的配置文件，再通过 <code>spring.profiles.active</code> 命令去指定读取特定配置文件的属性。多环境配置文件是不同于 application.properties 应用配置文件。多环境配置文件的约定命名格式为 application-{profile}.properties。多环境配置功能默认为激活状态，如果其他配置未被激活，则 {profile} 默认为 default，会加载 application-default.properties 默认配置文件，没有该文件就会加载 application.properties 应用配置文件。</p><p>多环境配置文件的属性读取方式和从 application.properties 应用配置文件读取方式一致。不管多环境配置文件在工程 jar 包内还是包外，按照配置优先级覆盖其他配置文件。在微服务实践开发中，经常会使用一个类似 deploy 工程去管理配置文件和打包其他业务工程。</p><p>在 application.properties 同级目录中，新建 application-dev.properties 作为开发环境配置文件，配置如下：</p><pre class="line-numbers language-none"><code class="language-none">## 书信息demo.book.name=[Spring Boot 2.x Core Action]  From Devdemo.book.writer=BYSocket<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>新建 application-prod.properties 作为生产环境配置文件，代码如下：</p><pre class="line-numbers language-none"><code class="language-none">## 书信息demo.book.name=&lt;Spring Boot 2.x Core Action Dev&gt; From Proddemo.book.writer=BYSocket<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>通过命令行指定读取 dev 环境配置文件并运行工程，代码如下：</p><pre class="line-numbers language-none"><code class="language-none">java -jar target/chapter-2-spring-boot-config-1.0.jar --spring.profiles.active=dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在多个环境配置中，通过命令 <code>--spring.profiles.active=dev</code> 指定读取某个配置文件，将 dev 更改成 prod ，轻松切换读取生产环境配置。也可以在控制台的日志中确定配置读取来自 dev ：</p><pre class="line-numbers language-none"><code class="language-none">2017-11-09 12:10:52.978  INFO 72450 --- [           main] demo.springboot.ConfigApplication        : The following profiles are active: dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最后打开浏览器，访问 /book/hello 地址，可以看到如图 2-5 所示的返回结果：</p><p><img src="http://springforall.ufile.ucloud.com.cn/static/img/80fccafce0c406fca72b95064513f7ad1515130" alt="img"></p><p>图 2-5 dev 环境书信息页面</p><h2 id="2-4-自动配置"><a href="#2-4-自动配置" class="headerlink" title="2.4 自动配置"></a>2.4 自动配置</h2><p>Spring Boot <code>spring-boot-autoconfigure</code> 依赖实现了默认的配置项，即应用默认值。这种模式叫做 “自动配置”。Spring Boot 自动配置会根据添加的依赖，自动加载依赖相关的配置属性并启动依赖。例如默认用的内嵌式容器是 Tomcat ，端口默认设置为 8080。</p><p>为什么需要自动配置？顾名思义，自动配置的意义是利用这种模式代替了配置 XML 繁琐模式。以前使用 Spring MVC ，需要进行配置组件扫描、调度器、视图解析器等，使用 Spring Boot 自动配置后，只需要添加 MVC 组件即可自动配置所需要的 Bean。所有自动配置的实现都在 <code>spring-boot-autoconfigure</code> 依赖中，包括 Spring MVC 、Data 和其它框架的自动配置。</p><h3 id="2-4-1-spring-boot-autoconfigure-依赖"><a href="#2-4-1-spring-boot-autoconfigure-依赖" class="headerlink" title="2.4.1 spring-boot-autoconfigure 依赖"></a>2.4.1 spring-boot-autoconfigure 依赖</h3><p><code>spring-boot-autoconfigure</code> 依赖，是 Spring Boot 实现自动配置的核心 Starter 组件。其实现源码包结构如图 2-6 所示：</p><p><img src="http://springforall.ufile.ucloud.com.cn/static/img/20baaeb5e57f7a44e1722c50a92ccc9c1515130" alt="img"></p><p>图 2-6 spring-boot-autoconfigure 依赖包目录</p><p>从图中可以看出，其中常见核心的包如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigureorg<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>data<span class="token punctuation">.</span>jpaorg<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>thymeleaforg<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>web<span class="token punctuation">.</span>servletorg<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>web<span class="token punctuation">.</span>reactive<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> 省略<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在各自包目录下有对应的自动配置类，代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">JpaRepositoriesAutoConfiguration</span> <span class="token class-name">ThymeleafAutoConfiguration</span><span class="token class-name">WebMvcAutoConfiguration</span><span class="token class-name">WebFluxAutoConfiguration</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> 省略<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面自动配置类依次是 Jpa 自动配置类、Thymeleaf 自动配置类、Web MVC 自动配置类和 WebFlux 自动配置类。WebFlux 响应式框架会在第 3 章 详细介绍使用。</p><p><code>spring-boot-autoconfigure</code> 职责是通过 <code>@EnableAutoConfiguration</code> 核心注解，扫描 ClassPath 目录中自动配置类对应依赖，并按一定规则获取默认配置并自动初始化所需要的 Bean。在 application.properties 配置文件也可以修改默认配置项，常用配置清单地址如下：</p><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html">https://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html</a></p><h3 id="2-4-2-EnableAutoConfiguration-注解"><a href="#2-4-2-EnableAutoConfiguration-注解" class="headerlink" title="2.4.2 @EnableAutoConfiguration 注解"></a>2.4.2 @EnableAutoConfiguration 注解</h3><p>自动配置工作机制是通过 <code>@EnableAutoConfiguration</code> 注解中 <code>@Import</code> 的 <code>AutoConfigurationImportSelector</code> 自动配置导入选择器类实现的。查阅源码可得具体流程如下：</p><ul><li><code>AutoConfigurationImportSelector</code> 通过 <code>SpringFactoriesLoader.loadFactoryNames()</code> 核心方法读取 ClassPath 目录下面的 META-INF/spring.factories 文件。</li><li>spring.factories 文件中配置的 Spring Boot 自动配置类，例如常见的 <code>WebMvcAutoConfiguration</code> Web MVC 自动配置类和<code>ServletWebServerFactoryAutoConfiguration</code> 容器自动配置类 。</li><li>spring.factories 文件和 application.properties 文件都属于配置文件，配置的格式均为键值对。里面配置的每个自动配置类都会定义相关 Bean 的实例配置，也会定义什么条件下自动配置和哪些 Bean 被实例化。</li><li>当 pom.xml 添加某 Starter 依赖组件的时候，就会自动触发该依赖的默认配置。</li></ul><p>例如添加 <code>spring-boot-starter-web</code> 依赖后，启动应用会触发容器自动配置类。容器自动配置类 <code>ServletWebServerFactoryAutoConfiguration</code> 的部分代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>web<span class="token punctuation">.</span>servlet</span><span class="token punctuation">;</span><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@ConditionalOnClass</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token class-name">ServletRequest</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@ConditionalOnWebApplication</span><span class="token punctuation">(</span>    type <span class="token operator">=</span> <span class="token class-name">Type</span><span class="token punctuation">.</span>SERVLET<span class="token punctuation">)</span><span class="token annotation punctuation">@EnableConfigurationProperties</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token class-name">ServerProperties</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token class-name">ServletWebServerFactoryAutoConfiguration<span class="token punctuation">.</span>BeanPostProcessorsRegistrar</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServletWebServerFactoryAutoConfiguration</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> 省略<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码中，<code>@ConditionalOnClass</code> 注解表示对应的 <code>ServletRequest</code> 类在 ClassPath 目录下面存在，并且 <code>@ConditionalOnWebApplication</code> 注解表示该应用是 Servlet Web 应用时，才会去启动容器自动配置，并通过 ServerProperties 类默认设置了端口为 8080。Type.SERVLET 枚举代表 Servlet Web 应用，Type.REACTIVE 枚举代表响应式 WebFlux 应用。</p><p>自动配置，是一把双刃剑。用好了就像天下武功唯快不破一样。但要注意一些自动化配置造成的问题。常见的问题有：</p><ul><li>Spring Boot 工程添加某些 Starter 组件依赖，又不需要触发组件自动配置</li><li>Spring Boot 配置多个不同数据源配置时，使用 XML 配置多数据源，但其默认数据源配置会触发自动配置出现问题。</li></ul><p>类似场景下，解决方式是通过 exclude 属性指定并排除自动配置类，代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span><span class="token punctuation">(</span>exclude <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token class-name">DataSourceAutoConfiguration</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也等价于配置 <code>@EnableAutoConfiguration</code> 注解，代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span><span class="token annotation punctuation">@EnableAutoConfiguration</span><span class="token punctuation">(</span>exclude <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token class-name">DataSourceAutoConfiguration</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>自动配置会最大的智能化，只有配置了 exclude 属性时，Spring Boot 优先初始化用户定义的 Bean ，然后再进行自动配置。</p><h3 id="2-4-3-利用自动配置自定义-Starter-组件"><a href="#2-4-3-利用自动配置自定义-Starter-组件" class="headerlink" title="2.4.3 利用自动配置自定义 Starter 组件"></a>2.4.3 利用自动配置自定义 Starter 组件</h3><p>当公司需要共享或者开源 Spring Boot Starter 组件依赖包，就可以利用自动配置自定义 Starter 组件。一个完整的 Starter 组件包括以下两点：</p><ul><li>提供自动配置功能的自动配置模块。</li><li>提供依赖关系管理功能的组件模块，即封装了组件所有功能，开箱即用。</li></ul><p>实现自定义 Starter 组件，并不会将这两点严格区分，可以将自动配置功能和依赖管理结合在一起实现。下面利用自动配置实现自定义 Starter 组件：spring-boot-starter-swagger 组件是用来快速生成 API 文档，简化原生使用 Swagger2 。</p><p>spring-boot-starter-swagger 组件为 Spring For All 社区（spring4all.com）开源项目，源代码地址是 <a href="https://github.com/SpringForAll/spring-boot-starter-swagger%E3%80%82">https://github.com/SpringForAll/spring-boot-starter-swagger。</a></p><h5 id="什么是-Swagger2"><a href="#什么是-Swagger2" class="headerlink" title="什么是 Swagger2"></a>什么是 Swagger2</h5><p>Swagger2 是 API 最大的开发框架，基于 OpenAPI 规范（OAS），管理了 API 整个生命周期，即从 API 设计到文档，从测试到部署。具体更多了解见其官网，<a href="https://swagger.io/">https://swagger.io</a>。</p><h5 id="spring-boot-starter-swagger-组件依赖"><a href="#spring-boot-starter-swagger-组件依赖" class="headerlink" title="spring-boot-starter-swagger 组件依赖"></a>spring-boot-starter-swagger 组件依赖</h5><p>创建一个新的 Spring Boot 工程，命名为 spring-boot-starter-swagger。在 pom.xml 配置相关</p><pre class="line-numbers language-none"><code class="language-none">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;        &lt;optional&gt;true&lt;/optional&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;        &lt;optional&gt;true&lt;/optional&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;io.springfox&lt;/groupId&gt;        &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;        &lt;version&gt;${version.swagger}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;io.springfox&lt;/groupId&gt;        &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;        &lt;version&gt;${version.swagger}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;io.springfox&lt;/groupId&gt;        &lt;artifactId&gt;springfox-bean-validators&lt;/artifactId&gt;        &lt;version&gt;${version.swagger}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;        &lt;artifactId&gt;lombok&lt;/artifactId&gt;        &lt;version&gt;1.16.12&lt;/version&gt;        &lt;scope&gt;provided&lt;/scope&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置中添加了 <code>spring-boot-starter</code> 组件依赖用于自动配置特性，<code>springfox-swagger2</code> 依赖是 Swagger2 框架。</p><h4 id="Swagger2-属性配置类-SwaggerProperties"><a href="#Swagger2-属性配置类-SwaggerProperties" class="headerlink" title="Swagger2 属性配置类 SwaggerProperties"></a>Swagger2 属性配置类 SwaggerProperties</h4><p>新建名为 <code>SwaggerProperties</code> Swagger2 属性配置类，包含了所有默认属性值。使用该组件时，可以在 application.properties 配置文件配置对应属性项，进行覆盖默认配置。代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">lombok<span class="token punctuation">.</span></span><span class="token class-name">Data</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">lombok<span class="token punctuation">.</span></span><span class="token class-name">NoArgsConstructor</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>context<span class="token punctuation">.</span>properties<span class="token punctuation">.</span></span><span class="token class-name">ConfigurationProperties</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">springfox<span class="token punctuation">.</span>documentation<span class="token punctuation">.</span>schema<span class="token punctuation">.</span></span><span class="token class-name">ModelRef</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">ArrayList</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">LinkedHashMap</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">List</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Map</span></span><span class="token punctuation">;</span><span class="token annotation punctuation">@Data</span><span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span><span class="token string">"swagger"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SwaggerProperties</span> <span class="token punctuation">{</span>    <span class="token comment">/**是否开启swagger**/</span>    <span class="token keyword">private</span> <span class="token class-name">Boolean</span> enabled<span class="token punctuation">;</span>    <span class="token comment">/**标题**/</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> title <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token comment">/**描述**/</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> description <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token comment">/**版本**/</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> version <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token comment">/**许可证**/</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> license <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token comment">/**许可证URL**/</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> licenseUrl <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token comment">/**服务条款URL**/</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> termsOfServiceUrl <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Contact</span> contact <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Contact</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/**swagger会解析的包路径**/</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> basePackage <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token comment">/**swagger会解析的url规则**/</span>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> basePath <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/**在basePath基础上需要排除的url规则**/</span>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> excludePath <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/**分组文档**/</span>    <span class="token keyword">private</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">DocketInfo</span><span class="token punctuation">&gt;</span></span> docket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/**host信息**/</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> host <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token comment">/**全局参数配置**/</span>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">GlobalOperationParameter</span><span class="token punctuation">&gt;</span></span> globalOperationParameters<span class="token punctuation">;</span>     <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> 省略，具体代码见 <span class="token class-name">GitHub</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用 <code>@ConfigurationProperties(prefix = "swagger")</code> 标注在类上方是指定属性的参数名称为 swagger。会对应匹配到配置文件中 “ swagger.* ” 结构的属性，例如，字段标题 title 表示标题，会匹配到 <code>swagger.title</code> 属性值。</p><h4 id="Swagger2-自动配置类-SwaggerAutoConfiguration"><a href="#Swagger2-自动配置类-SwaggerAutoConfiguration" class="headerlink" title="Swagger2 自动配置类 SwaggerAutoConfiguration"></a>Swagger2 自动配置类 SwaggerAutoConfiguration</h4><p>新建名为 <code>SwaggerAutoConfiguration </code>Swagger2 自动配置类，提供 Swagger2 依赖关系管理功能和自动配置功能。代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Bean</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Configuration</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Import</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>condition<span class="token punctuation">.</span></span><span class="token class-name">ConditionalOnMissingBean</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>condition<span class="token punctuation">.</span></span><span class="token class-name">ConditionalOnProperty</span></span><span class="token punctuation">;</span><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@ConditionalOnProperty</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"swagger.enabled"</span><span class="token punctuation">,</span> matchIfMissing <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        <span class="token class-name">Swagger2DocumentationConfiguration</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span>        <span class="token class-name">BeanValidatorPluginsConfiguration</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SwaggerAutoConfiguration</span> <span class="token keyword">implements</span> <span class="token class-name">BeanFactoryAware</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">BeanFactory</span> beanFactory<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token annotation punctuation">@ConditionalOnMissingBean</span>    <span class="token keyword">public</span> <span class="token class-name">SwaggerProperties</span> <span class="token function">swaggerProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SwaggerProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token annotation punctuation">@ConditionalOnMissingBean</span>    <span class="token annotation punctuation">@ConditionalOnProperty</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"swagger.enabled"</span><span class="token punctuation">,</span> matchIfMissing <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Docket</span><span class="token punctuation">&gt;</span></span> <span class="token function">createRestApi</span><span class="token punctuation">(</span><span class="token class-name">SwaggerProperties</span> swaggerProperties<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> 省略，具体代码见 <span class="token class-name">GitHub</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setBeanFactory</span><span class="token punctuation">(</span><span class="token class-name">BeanFactory</span> beanFactory<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>beanFactory <span class="token operator">=</span> beanFactory<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码实现流程如下：</p><ol><li><code>@Configuration</code> 注解标注在类上方，表明该类为配置类。</li><li><code>@Import</code> 注解引入 Swagger2 提供的配置类 <code>Swagger2DocumentationConfiguration</code> 和 Bean 数据验证插件配置类 <code>BeanValidatorPluginsConfiguration</code>。</li><li><code>@ConditionalOnMissingBean</code> 注解标注了两处方法，当 Bean 没有被创建时会执行被标注的初始化方法。第一处被标记方法是 <code>swaggerProperties()</code> ，用来实例化属性配置类 <code>SwaggerProperties</code>;第二处被标记方法是 <code>createRestApi()</code>， 用来实例化 Swagger2 API 映射的 Docket 列表对象。</li><li><code>@ConditionalOnProperty</code> 注解标注在 <code>createRestApi()</code> 方法，name 属性会去检查环境配置项 <code>swagger.enabled</code> 。默认情况下，属性存在且不是 <code>false</code> 的情况下，会触发该初始化方法。matchIfMissing 属性默认值为 <code>false</code> ，这里设置为 <code>true</code>，表示如果环境配置项没被设置，也会触发。</li></ol><h5 id="Swagger2-启动注解类-EnableSwagger2Doc"><a href="#Swagger2-启动注解类-EnableSwagger2Doc" class="headerlink" title="Swagger2 启动注解类 EnableSwagger2Doc"></a>Swagger2 启动注解类 EnableSwagger2Doc</h5><p>新建名为 <code>EnableSwagger2Doc </code>Swagger2 启动注解类，用于开关 spring-boot-starter-swagger 组件依赖。代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span>TYPE<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Inherited</span><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token class-name">SwaggerAutoConfiguration</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">EnableSwagger2Doc</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码 <code>@Import</code> 注解引入 Swagger2 自动配置类 <code>SwaggerAutoConfiguration</code>。当将该注解配置在应用启动类上方，即可开启 Swagger2 自动配置及其功能。</p><h5 id="使用-spring-boot-starter-swagger-组件依赖"><a href="#使用-spring-boot-starter-swagger-组件依赖" class="headerlink" title="使用 spring-boot-starter-swagger 组件依赖"></a>使用 spring-boot-starter-swagger 组件依赖</h5><p>上面简单介绍了spring-boot-starter-swagger 组件的核心代码实现，同样使用方式也很简单。在 chapter-2-spring-boot-config 工程的 Maven 配置中添加对应的依赖配置，目前支持 1.5.0.RELEASE 以上版本，配置如下：</p><pre class="line-numbers language-none"><code class="language-none">&lt;!-- 自定义 swagger2 Starter 组件依赖 --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.spring4all&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-swagger&lt;/artifactId&gt;    &lt;version&gt;2.0&lt;/version&gt;&lt;/dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另外，需要在 ConfigApplication 应用启动类上方配置启动注解类 <code>EnableSwagger2Doc</code>，代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>spring4all<span class="token punctuation">.</span>swagger<span class="token punctuation">.</span></span><span class="token class-name">EnableSwagger2Doc</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span></span><span class="token class-name">SpringApplication</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span></span><span class="token class-name">SpringBootApplication</span></span><span class="token punctuation">;</span><span class="token annotation punctuation">@EnableSwagger2Doc</span> <span class="token comment">// 开启 Swagger</span><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConfigApplication</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">ConfigApplication</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行 <code>ConfigApplication</code> 类启动，在控制台看到成功运行的输出后，打开浏览器访问 localhost:8080/swagger-ui.html 地址，可以看到自动生成的 Swagger API 文档，如图 2-7 所示：</p><p><img src="http://springforall.ufile.ucloud.com.cn/static/img/3e86b26eaa67a2e766dac6292f3487f61515130" alt="img"></p><p>图 2-7 Swagger API 文档</p><h5 id="API-org-springframework-boot-autoconfigure-EnableAutoConfiguration-注解参数"><a href="#API-org-springframework-boot-autoconfigure-EnableAutoConfiguration-注解参数" class="headerlink" title="API org.springframework.boot.autoconfigure.EnableAutoConfiguration 注解参数"></a>API org.springframework.boot.autoconfigure.EnableAutoConfiguration 注解参数</h5><ul><li>exclude：<br>Class 数组，排除特定的自动配置类。</li><li>excludeName：<br>字符串数组，排除特定名称的自动配置类。</li></ul><h5 id="API-org-springframework-boot-autoconfigure-ConditionalOnProperty-注解参数"><a href="#API-org-springframework-boot-autoconfigure-ConditionalOnProperty-注解参数" class="headerlink" title="API org.springframework.boot.autoconfigure.ConditionalOnProperty 注解参数"></a>API org.springframework.boot.autoconfigure.ConditionalOnProperty 注解参数</h5><ul><li>havingValue：<br>字符串，属性期望值是否匹配。</li><li>matchIfMissing：<br>布尔值，如果该属性值未设置，则匹配。</li><li>name：<br>字符串数组，要测试的属性名。</li><li>prefix：<br>字符串，属性前缀名。</li><li>value：<br>字符串，功能同 name。</li></ul><h5 id="API-org-springframework-boot-autoconfigure-ConditionalOnClass-注解参数"><a href="#API-org-springframework-boot-autoconfigure-ConditionalOnClass-注解参数" class="headerlink" title="API org.springframework.boot.autoconfigure.ConditionalOnClass 注解参数"></a>API org.springframework.boot.autoconfigure.ConditionalOnClass 注解参数</h5><ul><li>name：<br>字符串数组，类名必须存在。</li><li>value：<br>Class 数组，类必须存在。</li></ul><h5 id="API-org-springframework-boot-autoconfigure-ConditionalOnMissingBean-注解参数"><a href="#API-org-springframework-boot-autoconfigure-ConditionalOnMissingBean-注解参数" class="headerlink" title="API org.springframework.boot.autoconfigure.ConditionalOnMissingBean 注解参数"></a>API org.springframework.boot.autoconfigure.ConditionalOnMissingBean 注解参数</h5><ul><li>annotation：<br>注解 Class 数组，匹配注解装饰的 Bean。</li><li>ignored：<br>Class 数组，匹配时，忽略该类型的 Bean。</li><li>ignoredType：<br>字符串数组，匹配时，忽略该类型名称的 Bean。</li><li>name：<br>字符串数组，匹配要检查的 Bean 名称。</li><li>search：<br>SearchStrategy 对象，通过 SearchStrategy 来决定程序的上下文策略。</li><li>type：<br>字符串史胡族，匹配要检查的 Bean 类型名称。</li><li>value：<br>Class 数组，匹配要检查的 Bean 类型。</li></ul><h5 id="API-org-springframework-boot-autoconfigure-ConditionalOnWebApplication-注解参数"><a href="#API-org-springframework-boot-autoconfigure-ConditionalOnWebApplication-注解参数" class="headerlink" title="API org.springframework.boot.autoconfigure.ConditionalOnWebApplication 注解参数"></a>API org.springframework.boot.autoconfigure.ConditionalOnWebApplication 注解参数</h5><ul><li>type：<br>ConditionalOnWebApplication.Type 对象，匹配对应的 Web 应用程序类型。</li></ul><h2 id="2-5-本章小结"><a href="#2-5-本章小结" class="headerlink" title="2.5 本章小结"></a>2.5 本章小结</h2><p>本章从自定义属性快速入门工程出发，介绍了两种配置文件以及属性的获取方式，然后讲解了外化配置的优先级、属性引用、随机式使用和多环境配置，最后讲解了自动配置的原理、核心注解以及利用自动配置实现了自定义 Starter 组件。下一章介绍 Spring Boot Web 开发相关。</p><p>本章示例代码地址：<a href="https://github.com/JeffLi1993/springboot-core-action-book-demo/tree/master/chapter-2-spring-boot-config">https://github.com/JeffLi1993/springboot-core-action-book-demo/tree/master/chapter-2-spring-boot-config</a></p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图解九种常见的设计模式</title>
      <link href="/archives/dc2c9a78.html"/>
      <url>/archives/dc2c9a78.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在软件工程中，设计模式（Design Pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。根据模式的目的来划分的话，GoF（Gang of Four）设计模式可以分为以下 3 种类型：</p><p><img src="https://segmentfault.com/img/bVcfO3r" alt="image"></p><span id="more"></span><p>1、创建型模式：用来描述 “如何创建对象”，它的主要特点是 “将对象的创建和使用分离”。包括单例、原型、工厂方法、抽象工厂和建造者 5 种模式。</p><p>2、结构型模式：用来描述如何将类或对象按照某种布局组成更大的结构。包括代理、适配器、桥接、装饰、外观、享元和组合 7 种模式。</p><p>3、行为型模式：用来识别对象之间的常用交流模式以及如何分配职责。包括模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录和解释器 11 种模式。</p><p>接下来阿宝哥将结合一些生活中的场景并通过精美的配图，来向大家介绍 9 种常用的设计模式。</p><h3 id="一、建造者模式"><a href="#一、建造者模式" class="headerlink" title="一、建造者模式"></a>一、建造者模式</h3><p>建造者模式（Builder Pattern）将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</p><p>一辆小汽车 🚗 通常由 <strong>发动机、底盘、车身和电气设备</strong> 四大部分组成。汽车电气设备的内部构造很复杂，简单起见，我们只考虑三个部分：引擎、底盘和车身。</p><p><img src="https://segmentfault.com/img/bVcfQ3q" alt="image"></p><p>在现实生活中，小汽车也是由不同的零部件组装而成，比如上图中我们把小汽车分成引擎、底盘和车身三大部分。下面我们来看一下如何使用建造者模式来造车子。</p><h5 id="1-1-实现代码"><a href="#1-1-实现代码" class="headerlink" title="1.1 实现代码"></a>1.1 实现代码</h5><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">Car</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>    <span class="token keyword">public</span> engine<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span>    <span class="token keyword">public</span> chassis<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span>     <span class="token keyword">public</span> body<span class="token operator">:</span> <span class="token builtin">string</span>  <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">CarBuilder</span> <span class="token punctuation">{</span>  engine<span class="token operator">!</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> <span class="token comment">// 引擎</span>  chassis<span class="token operator">!</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> <span class="token comment">// 底盘</span>  body<span class="token operator">!</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> <span class="token comment">// 车身</span>  <span class="token function">addChassis</span><span class="token punctuation">(</span>chassis<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>chassis <span class="token operator">=</span> chassis<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">addEngine</span><span class="token punctuation">(</span>engine<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>engine <span class="token operator">=</span> engine<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">addBody</span><span class="token punctuation">(</span>body<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>body <span class="token operator">=</span> body<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Car</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>engine<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>chassis<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>body<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在以上代码中，我们定义一个 <code>CarBuilder</code> 类，并提供了 <code>addChassis</code>、<code>addEngine</code> 和 <code>addBody</code> 3 个方法用于组装车子的不同部位，当车子的 3 个部分都组装完成后，调用 <code>build</code> 方法就可以开始造车。</p><h5 id="1-2-使用示例"><a href="#1-2-使用示例" class="headerlink" title="1.2 使用示例"></a>1.2 使用示例</h5><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> car <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CarBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">addEngine</span><span class="token punctuation">(</span><span class="token string">'v12'</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">addBody</span><span class="token punctuation">(</span><span class="token string">'镁合金'</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">addChassis</span><span class="token punctuation">(</span><span class="token string">'复合材料'</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-3-应用场景及案例"><a href="#1-3-应用场景及案例" class="headerlink" title="1.3 应用场景及案例"></a>1.3 应用场景及案例</h5><ul><li>需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。</li><li>需要生成的产品对象的属性相互依赖，需要指定其生成顺序。</li><li>隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。</li><li><a href="https://link.segmentfault.com/?enc=DaW3M6bhub96v4n4lrqeJQ==.OKh+kPqhtEhkqqWpCmGZwOzUA7q1+vzZRUL3Dcp+dfEaPlsHX0A2pd6GcsV+es0a">Github - node-sql-query</a>：<a href="https://link.segmentfault.com/?enc=0LHN0g8kBcsL3Xvgs3a72w==.IL8FNkyg7sGDHFwi0ACtCNhlobsllv5O8L3BPNwDGp+CJAslw24Rcgw63dfhXPre">https://github.com/dresende/n...</a></li></ul><h3 id="二、工厂模式"><a href="#二、工厂模式" class="headerlink" title="二、工厂模式"></a>二、工厂模式</h3><p>在现实生活中，工厂是负责生产产品的，比如牛奶、面包或礼物等，这些产品满足了我们日常的生理需求。</p><p><img src="https://segmentfault.com/img/bVbK5q2" alt="image"></p><p>在众多设计模式当中，有一种被称为工厂模式的设计模式，它提供了创建对象的最佳方式。工厂模式可以分为：<strong>简单工厂模式、工厂方法模式和抽象工厂模式</strong>。</p><h4 id="2-1-简单工厂"><a href="#2-1-简单工厂" class="headerlink" title="2.1 简单工厂"></a>2.1 简单工厂</h4><p>简单工厂模式又叫 <strong>静态方法模式</strong>，因为工厂类中定义了一个静态方法用于创建对象。简单工厂让使用者不用知道具体的参数就可以创建出所需的 ”产品“ 类，即使用者可以直接消费产品而不需要知道产品的具体生产细节。</p><p><img src="https://segmentfault.com/img/bVbMu1o" alt="image"></p><p>在上图中，阿宝哥模拟了用户购车的流程，小王和小秦分别向 BMW 工厂订购了 BMW730 和 BMW840 型号的车型，接着工厂会先判断用户选择的车型，然后按照对应的模型进行生产并在生产完成后交付给用户。</p><p>下面我们来看一下如何使用简单工厂来描述 BMW 工厂生产指定型号车子的过程。</p><h5 id="2-1-1-实现代码"><a href="#2-1-1-实现代码" class="headerlink" title="2.1.1 实现代码"></a>2.1.1 实现代码</h5><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name"><span class="token constant">BMW</span></span> <span class="token punctuation">{</span>  <span class="token keyword">abstract</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name"><span class="token constant">BMW730</span></span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">BMW</span></span> <span class="token punctuation">{</span>  <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"BMW730 发动咯"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name"><span class="token constant">BMW840</span></span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">BMW</span></span> <span class="token punctuation">{</span>  <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"BMW840 发动咯"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">BMWFactory</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token function">produceBMW</span><span class="token punctuation">(</span>model<span class="token operator">:</span> <span class="token string">"730"</span> <span class="token operator">|</span> <span class="token string">"840"</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">BMW</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>model <span class="token operator">===</span> <span class="token string">"730"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token constant">BMW730</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token constant">BMW840</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在以上代码中，我们定义一个 <code>BMWFactory</code> 类，该类提供了一个静态的 <code>produceBMW()</code> 方法，用于根据不同的模型参数来创建不同型号的车子。</p><h5 id="2-1-2-使用示例"><a href="#2-1-2-使用示例" class="headerlink" title="2.1.2 使用示例"></a>2.1.2 使用示例</h5><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> bmw730 <span class="token operator">=</span> BMWFactory<span class="token punctuation">.</span><span class="token function">produceBMW</span><span class="token punctuation">(</span><span class="token string">"730"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> bmw840 <span class="token operator">=</span> BMWFactory<span class="token punctuation">.</span><span class="token function">produceBMW</span><span class="token punctuation">(</span><span class="token string">"840"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>bmw730<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>bmw840<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-1-3-应用场景"><a href="#2-1-3-应用场景" class="headerlink" title="2.1.3 应用场景"></a>2.1.3 应用场景</h5><ul><li>工厂类负责创建的对象比较少：由于创建的对象比较少，不会造成工厂方法中业务逻辑过于复杂。</li><li>客户端只需知道传入工厂类静态方法的参数，而不需要关心创建对象的细节。</li></ul><h4 id="2-2-工厂方法"><a href="#2-2-工厂方法" class="headerlink" title="2.2 工厂方法"></a>2.2 工厂方法</h4><p>工厂方法模式（Factory Method Pattern）又称为工厂模式，也叫多态工厂（Polymorphic Factory）模式，它属于类创建型模式。</p><p>在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象， <strong>这样做的目的是将产品类的实例化操作延迟到工厂子类中完成</strong>，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。</p><p><img src="https://segmentfault.com/img/bVbK5q5" alt="image"></p><p>在上图中，阿宝哥模拟了用户购车的流程，小王和小秦分别向 BMW 730 和 BMW 840 工厂订购了 BMW730 和 BMW840 型号的车子，接着工厂按照对应的模型进行生产并在生产完成后交付给用户。</p><p>同样，我们来看一下如何使用工厂方法来描述 BMW 工厂生产指定型号车子的过程。</p><h5 id="2-2-1-实现代码"><a href="#2-2-1-实现代码" class="headerlink" title="2.2.1 实现代码"></a>2.2.1 实现代码</h5><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">BMWFactory</span> <span class="token punctuation">{</span>  <span class="token keyword">abstract</span> <span class="token function">produceBMW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">BMW</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">BMW730Factory</span> <span class="token keyword">extends</span> <span class="token class-name">BMWFactory</span> <span class="token punctuation">{</span>  <span class="token function">produceBMW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">BMW</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token constant">BMW730</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">BMW840Factory</span> <span class="token keyword">extends</span> <span class="token class-name">BMWFactory</span> <span class="token punctuation">{</span>  <span class="token function">produceBMW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">BMW</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token constant">BMW840</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在以上代码中，我们分别创建了 <code>BMW730Factory</code> 和 <code>BMW840Factory</code> 两个工厂类，然后使用这两个类的实例来生产不同型号的车子。</p><h5 id="2-2-2-使用示例"><a href="#2-2-2-使用示例" class="headerlink" title="2.2.2 使用示例"></a>2.2.2 使用示例</h5><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> bmw730Factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BMW730Factory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> bmw840Factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BMW840Factory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> bmw730 <span class="token operator">=</span> bmw730Factory<span class="token punctuation">.</span><span class="token function">produceBMW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> bmw840 <span class="token operator">=</span> bmw840Factory<span class="token punctuation">.</span><span class="token function">produceBMW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>bmw730<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>bmw840<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-2-3-应用场景"><a href="#2-2-3-应用场景" class="headerlink" title="2.2.3 应用场景"></a>2.2.3 应用场景</h5><ul><li>一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。</li><li>一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。</li></ul><blockquote><p>继续阅读：<a href="https://link.segmentfault.com/?enc=i1S7fOuHJsLkrdBkIDjZaA==.7RDJ6krHj8sX1tAWx63qMU58a1MT9pAudE9oq6pUexNuXVsGFMfvpt46r3kpDfwOfxYNa4BCtzp3zXFJcLD42w==">Typescript 设计模式之工厂方法</a></p></blockquote><h4 id="2-3-抽象工厂"><a href="#2-3-抽象工厂" class="headerlink" title="2.3 抽象工厂"></a>2.3 抽象工厂</h4><p>抽象工厂模式（Abstract Factory Pattern），提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。</p><p>在工厂方法模式中具体工厂负责生产具体的产品，每一个具体工厂对应一种具体产品，工厂方法也具有唯一性，一般情况下，一个具体工厂中只有一个工厂方法或者一组重载的工厂方法。 <strong>但是有时候我们需要一个工厂可以提供多个产品对象，而不是单一的产品对象。</strong></p><p><img src="https://segmentfault.com/img/bVbK5q4" alt="image"></p><p>在上图中，阿宝哥模拟了用户购车的流程，小王向 BMW 工厂订购了 BMW730，工厂按照 730 对应的模型进行生产并在生产完成后交付给小王。而小秦向同一个 BMW 工厂订购了 BMW840，工厂按照 840 对应的模型进行生产并在生产完成后交付给小秦。</p><p>下面我们来看一下如何使用抽象工厂来描述上述的购车过程。</p><h5 id="2-3-1-实现代码"><a href="#2-3-1-实现代码" class="headerlink" title="2.3.1 实现代码"></a>2.3.1 实现代码</h5><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">BMWFactory</span> <span class="token punctuation">{</span>  <span class="token keyword">abstract</span> <span class="token function">produce730BMW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">BMW730</span><span class="token punctuation">;</span>  <span class="token keyword">abstract</span> <span class="token function">produce840BMW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">BMW840</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">ConcreteBMWFactory</span> <span class="token keyword">extends</span> <span class="token class-name">BMWFactory</span> <span class="token punctuation">{</span>  <span class="token function">produce730BMW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">BMW730</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token constant">BMW730</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">produce840BMW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">BMW840</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token constant">BMW840</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-3-2-使用示例"><a href="#2-3-2-使用示例" class="headerlink" title="2.3.2 使用示例"></a>2.3.2 使用示例</h5><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> bmwFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteBMWFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> bmw730 <span class="token operator">=</span> bmwFactory<span class="token punctuation">.</span><span class="token function">produce730BMW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> bmw840 <span class="token operator">=</span> bmwFactory<span class="token punctuation">.</span><span class="token function">produce840BMW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>bmw730<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>bmw840<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-3-3-应用场景"><a href="#2-3-3-应用场景" class="headerlink" title="2.3.3 应用场景"></a>2.3.3 应用场景</h5><ul><li>一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。</li><li>系统中有多于一个的产品族，而每次只使用其中某一产品族。</li><li>系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。</li></ul><blockquote><p>继续阅读：<a href="https://link.segmentfault.com/?enc=8fjPqNhqaI9X703cjJe4Xg==.1LGBUbrvYOqrL7FELIw0h4mvIziab9L6e9Ey1SD0gSBQaXv6I32tTxZzW5+XsK1zXkrH9wDceK1hOXg1jsOWrQ==">创建对象的最佳方式是什么？</a></p></blockquote><h3 id="三、单例模式"><a href="#三、单例模式" class="headerlink" title="三、单例模式"></a>三、单例模式</h3><p>单例模式（Singleton Pattern）是一种常用的模式，有一些对象我们往往只需要一个，比如全局缓存、浏览器中的 window 对象等。单例模式用于保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p><img src="https://segmentfault.com/img/bVcgWLd" alt="image"></p><p>在上图中，阿宝哥模拟了借车的流程，小王临时有急事找阿宝哥借车子，阿宝哥家的车子刚好没用，就借给小王了。当天，小秦也需要用车子，也找阿宝哥借车，因为阿宝哥家里只有一辆车子，所以就没有车可借了。</p><p>对于车子来说，它虽然给生活带来了很大的便利，但养车也需要一笔不小的费用（车位费、油费和保养费等），所以阿宝哥家里只有一辆车子。在开发软件系统时，如果遇到创建对象时耗时过多或耗资源过多，但又经常用到的对象，我们就可以考虑使用单例模式。</p><p>下面我们来看一下如何使用 TypeScript 来实现单例模式。</p><h5 id="3-1-实现代码"><a href="#3-1-实现代码" class="headerlink" title="3.1 实现代码"></a>3.1 实现代码</h5><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>  <span class="token comment">// 定义私有的静态属性，来保存对象实例</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> singleton<span class="token operator">:</span> Singleton<span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token comment">// 提供一个静态的方法来获取对象实例</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Singleton <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Singleton<span class="token punctuation">.</span>singleton<span class="token punctuation">)</span> <span class="token punctuation">{</span>      Singleton<span class="token punctuation">.</span>singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> Singleton<span class="token punctuation">.</span>singleton<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3-2-使用示例"><a href="#3-2-使用示例" class="headerlink" title="3.2 使用示例"></a>3.2 使用示例</h5><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">let</span> instance1 <span class="token operator">=</span> Singleton<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> instance2 <span class="token operator">=</span> Singleton<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance1 <span class="token operator">===</span> instance2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3-3-应用场景"><a href="#3-3-应用场景" class="headerlink" title="3.3 应用场景"></a>3.3 应用场景</h5><ul><li>需要频繁实例化然后销毁的对象。</li><li>创建对象时耗时过多或耗资源过多，但又经常用到的对象。</li><li>系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器或资源管理器，或者需要考虑资源消耗太大而只允许创建一个对象。</li></ul><blockquote><p>继续阅读：<a href="https://link.segmentfault.com/?enc=3cO+a1/HEXwbRl3ESTnvfg==.mNypTKWe9aZfjK0xFdh477XCRZEOXTuetostIw9k9cB+9ARqKMw+lZnuLuChujuYinBt7P5/VPkvCSs6dToD+w==">TypeScript 设计模式之单例模式</a></p></blockquote><h3 id="四、适配器模式"><a href="#四、适配器模式" class="headerlink" title="四、适配器模式"></a>四、适配器模式</h3><p>在实际生活中，也存在适配器的使用场景，比如：港式插头转换器、电源适配器和 USB 转接口。<strong>而在软件工程中，适配器模式的作用是解决两个软件实体间的接口不兼容的问题。</strong> 使用适配器模式之后，原本由于接口不兼容而不能工作的两个软件实体就可以一起工作。</p><p><img src="https://segmentfault.com/img/bVbCDtT" alt="image"></p><h5 id="4-1-实现代码"><a href="#4-1-实现代码" class="headerlink" title="4.1 实现代码"></a>4.1 实现代码</h5><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">Logger</span> <span class="token punctuation">{</span>  <span class="token function">info</span><span class="token punctuation">(</span>message<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">&gt;</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">interface</span> <span class="token class-name">CloudLogger</span> <span class="token punctuation">{</span>  <span class="token function">sendToServer</span><span class="token punctuation">(</span>message<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> type<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">&gt;</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">AliLogger</span> <span class="token keyword">implements</span> <span class="token class-name">CloudLogger</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">async</span> <span class="token function">sendToServer</span><span class="token punctuation">(</span>message<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> type<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">'This Message was saved with AliLogger'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">CloudLoggerAdapter</span> <span class="token keyword">implements</span> <span class="token class-name">Logger</span> <span class="token punctuation">{</span>  <span class="token keyword">protected</span> cloudLogger<span class="token operator">:</span> CloudLogger<span class="token punctuation">;</span>  <span class="token function">constructor</span> <span class="token punctuation">(</span>cloudLogger<span class="token operator">:</span> CloudLogger<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>cloudLogger <span class="token operator">=</span> cloudLogger<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">async</span> <span class="token function">info</span><span class="token punctuation">(</span>message<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>    <span class="token keyword">await</span> <span class="token keyword">this</span><span class="token punctuation">.</span>cloudLogger<span class="token punctuation">.</span><span class="token function">sendToServer</span><span class="token punctuation">(</span>message<span class="token punctuation">,</span> <span class="token string">'info'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">NotificationService</span> <span class="token punctuation">{</span>  <span class="token keyword">protected</span> logger<span class="token operator">:</span> Logger<span class="token punctuation">;</span>    <span class="token function">constructor</span> <span class="token punctuation">(</span>logger<span class="token operator">:</span> Logger<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>logger <span class="token operator">=</span> logger<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">async</span> <span class="token function">send</span><span class="token punctuation">(</span>message<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>    <span class="token keyword">await</span> <span class="token keyword">this</span><span class="token punctuation">.</span>logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Notification sended: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>message<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在以上代码中，因为 <code>Logger</code> 和 <code>CloudLogger</code> 这两个接口不匹配，所以我们引入了 <code>CloudLoggerAdapter</code> 适配器来解决兼容性问题。</p><h5 id="4-2-使用示例"><a href="#4-2-使用示例" class="headerlink" title="4.2 使用示例"></a>4.2 使用示例</h5><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> aliLogger <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AliLogger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> cloudLoggerAdapter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CloudLoggerAdapter</span><span class="token punctuation">(</span>aliLogger<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> notificationService <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NotificationService</span><span class="token punctuation">(</span>cloudLoggerAdapter<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">await</span> notificationService<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">'Hello semlinker, To Cloud'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="4-3-应用场景及案例"><a href="#4-3-应用场景及案例" class="headerlink" title="4.3 应用场景及案例"></a>4.3 应用场景及案例</h5><ul><li>以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。</li><li>使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。</li><li><a href="https://link.segmentfault.com/?enc=TB4SZliXdKMQ2bmk2dNoyg==.fz2RP5y49HWXiy6GOpWtdQ/i6lRAP3sqNOYF+8mcemW92EDoJ03c01X4MF0p6Yup">Github - axios-mock-adapter</a>：<a href="https://link.segmentfault.com/?enc=6MHtfwzx9VFY25cxhH867A==.8tPIfY7UnxeFkuoqkwhRbiXxQroVAikllkoou80rs0dO/cDbcWvXguPkJvPtKfTL">https://github.com/ctimmerm/a...</a></li></ul><blockquote><p>继续阅读：<a href="https://link.segmentfault.com/?enc=wyEQ29is1Rr/4klTj0uM+g==.OHQjXrc1ax0tgtnpBd8ORK4Ge/MFD3sC90KsWAUUgX/xR7n3i8ddotcwWJOFgg3hJWZMF4b33EBsPA7yazuD7g==">TypeScript 设计模式之适配器模式</a></p></blockquote><h3 id="五、观察者模式-amp-发布订阅模式"><a href="#五、观察者模式-amp-发布订阅模式" class="headerlink" title="五、观察者模式 &amp; 发布订阅模式"></a>五、观察者模式 &amp; 发布订阅模式</h3><h4 id="5-1-观察者模式"><a href="#5-1-观察者模式" class="headerlink" title="5.1 观察者模式"></a>5.1 观察者模式</h4><p>观察者模式，它定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使得它们能够自动更新自己。</p><p>在观察者模式中有两个主要角色：Subject（主题）和 Observer（观察者）。</p><p><img src="https://segmentfault.com/img/bVbLW2d" alt="image"></p><p>在上图中，Subject（主题）就是阿宝哥的 TS 专题文章，而观察者就是小秦和小王。由于观察者模式支持简单的广播通信，当消息更新时，会自动通知所有的观察者。</p><p>下面我们来看一下如何使用 TypeScript 来实现观察者模式。</p><h5 id="5-1-1-实现代码"><a href="#5-1-1-实现代码" class="headerlink" title="5.1.1 实现代码"></a>5.1.1 实现代码</h5><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span>  notify<span class="token operator">:</span> <span class="token builtin">Function</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">ConcreteObserver</span> <span class="token keyword">implements</span> <span class="token class-name">Observer</span><span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">private</span> name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> has been notified.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Subject</span> <span class="token punctuation">{</span>   <span class="token keyword">private</span> observers<span class="token operator">:</span> Observer<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token function">addObserver</span><span class="token punctuation">(</span>observer<span class="token operator">:</span> Observer<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>observer<span class="token punctuation">,</span> <span class="token string">"is pushed!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>observers<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>observer<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token function">deleteObserver</span><span class="token punctuation">(</span>observer<span class="token operator">:</span> Observer<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"remove"</span><span class="token punctuation">,</span> observer<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> n<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>observers<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>observer<span class="token punctuation">)</span><span class="token punctuation">;</span>    n <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>observers<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token function">notifyObservers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"notify all the observers"</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>observers<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>observers<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>observer <span class="token operator">=&gt;</span> observer<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="5-1-2-使用示例"><a href="#5-1-2-使用示例" class="headerlink" title="5.1.2 使用示例"></a>5.1.2 使用示例</h5><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> subject<span class="token operator">:</span> Subject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Subject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> xiaoQin <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteObserver</span><span class="token punctuation">(</span><span class="token string">"小秦"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> xiaoWang <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteObserver</span><span class="token punctuation">(</span><span class="token string">"小王"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>subject<span class="token punctuation">.</span><span class="token function">addObserver</span><span class="token punctuation">(</span>xiaoQin<span class="token punctuation">)</span><span class="token punctuation">;</span>subject<span class="token punctuation">.</span><span class="token function">addObserver</span><span class="token punctuation">(</span>xiaoWang<span class="token punctuation">)</span><span class="token punctuation">;</span>subject<span class="token punctuation">.</span><span class="token function">notifyObservers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>subject<span class="token punctuation">.</span><span class="token function">deleteObserver</span><span class="token punctuation">(</span>xiaoQin<span class="token punctuation">)</span><span class="token punctuation">;</span>subject<span class="token punctuation">.</span><span class="token function">notifyObservers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="5-1-3-应用场景及案例"><a href="#5-1-3-应用场景及案例" class="headerlink" title="5.1.3 应用场景及案例"></a>5.1.3 应用场景及案例</h5><ul><li>一个对象的行为依赖于另一个对象的状态。或者换一种说法，当被观察对象（目标对象）的状态发生改变时 ，会直接影响到观察对象的行为。</li><li><a href="https://link.segmentfault.com/?enc=jNYWRpdRjnGnMhZrVdsOrg==.fql/6w3ypERtvk4SZjh/Lgn08vCT4Cp7mSbslc7gLylU/0LsiLp4o/fO3ZapeEXDx143zMKsunItcm7qd3Wjw+2gUkPR6nsqNXOQ3z/6XiU=">RxJS Subject</a>：<a href="https://link.segmentfault.com/?enc=4cPjok8lgJEMVqVatlYNbA==.9JP/GqxSPrNj9VrGA3m2pDAVkXaMKahlZwwv6rPpo8IYeRIyeliV5P1yY8oTenw7qCUFl17UqAuEZoXQD1AyOnEggNWXYqiOm9M6Ao6joA4=">https://github.com/ReactiveX/...</a></li><li><a href="https://link.segmentfault.com/?enc=LvHq/Tn2Oa0CUjYCMMYsjQ==.L8PDmjzOCAYVMAKJlSUQRyo3o6+KmHgbxM0fJgm8a24=">RxJS Subject 文档</a>：<a href="https://link.segmentfault.com/?enc=Mdy5XCisnFcqxy+vNmdyBw==.TlA6VxHhuvlNUiyagkePMs/4Dx85+cllZF3rbhC12VA=">https://rxjs.dev/guide/subject</a></li></ul><blockquote><p>继续阅读：<a href="https://link.segmentfault.com/?enc=M3jlPo0yHSDnKsMfguR9mQ==.f6WrNgVooSProdlyxIc6W6F28BeMx8wvbP3mB6naTWPw3oft10zlCBGigo7iLQCeXRDA9OvOlcRyGFgPAwWf7w==">TypeScript 设计模式之观察者模式</a></p></blockquote><h4 id="5-2-发布订阅模式"><a href="#5-2-发布订阅模式" class="headerlink" title="5.2 发布订阅模式"></a>5.2 发布订阅模式</h4><p>在软件架构中，发布/订阅是一种消息范式，<strong>消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者）。而是将发布的消息分为不同的类别，然后分别发送给不同的订阅者。</strong> 同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者存在。</p><p>在发布订阅模式中有三个主要角色：Publisher（发布者）、 Channels（通道）和 Subscriber（订阅者）。</p><p><img src="https://segmentfault.com/img/bVbLW2i" alt="image"></p><p>在上图中，Publisher（发布者）是阿宝哥，Channels（通道）中 Topic A 和 Topic B 分别对应于 TS 专题和 Deno 专题，而 Subscriber（订阅者）就是小秦、小王和小池。</p><p>下面我们来看一下如何使用 TypeScript 来实现发布订阅模式。</p><h5 id="5-2-1-实现代码"><a href="#5-2-1-实现代码" class="headerlink" title="5.2.1 实现代码"></a>5.2.1 实现代码</h5><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">EventHandler</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">any</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">EventEmitter</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> EventHandler<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 订阅指定的主题</span>  <span class="token function">subscribe</span><span class="token punctuation">(</span>topic<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token operator">...</span>handlers<span class="token operator">:</span> EventHandler<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> topics <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>c<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>topic<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>topics<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>c<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>topic<span class="token punctuation">,</span> topics <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    topics<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">...</span>handlers<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment">// 取消订阅指定的主题</span>  <span class="token function">unsubscribe</span><span class="token punctuation">(</span>topic<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> handler<span class="token operator">?</span><span class="token operator">:</span> EventHandler<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>c<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>topic<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">const</span> topics <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>c<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>topic<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>topics<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">const</span> index <span class="token operator">=</span> topics<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>handler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    topics<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>topics<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>c<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>topic<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment">// 为指定的主题发布消息</span>  <span class="token function">publish</span><span class="token punctuation">(</span>topic<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> topics <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>c<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>topic<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>topics<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> topics<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>handler <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>      <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">handler</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="5-2-2-使用示例"><a href="#5-2-2-使用示例" class="headerlink" title="5.2.2 使用示例"></a>5.2.2 使用示例</h5><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> eventEmitter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EventEmitter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>eventEmitter<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">"ts"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>msg<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">收到订阅的消息：</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>msg<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>eventEmitter<span class="token punctuation">.</span><span class="token function">publish</span><span class="token punctuation">(</span><span class="token string">"ts"</span><span class="token punctuation">,</span> <span class="token string">"TypeScript发布订阅模式"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>eventEmitter<span class="token punctuation">.</span><span class="token function">unsubscribe</span><span class="token punctuation">(</span><span class="token string">"ts"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>eventEmitter<span class="token punctuation">.</span><span class="token function">publish</span><span class="token punctuation">(</span><span class="token string">"ts"</span><span class="token punctuation">,</span> <span class="token string">"TypeScript发布订阅模式"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="5-2-3-应用场景"><a href="#5-2-3-应用场景" class="headerlink" title="5.2.3 应用场景"></a>5.2.3 应用场景</h5><ul><li>对象间存在一对多关系，一个对象的状态发生改变会影响其他对象。</li><li>作为事件总线，来实现不同组件间或模块间的通信。</li><li><a href="https://link.segmentfault.com/?enc=JqaLKWx5IcW5MVM9cszaGA==.Cs3UCybA5AwIYWn5+glStYxTYCmb2sBKvo/qI56sFLeJqwdVZH4O69Q7NJZ6hYuat9SapFXc2chAlHhIPDTapN9jpu/OjTM1LVnrjzvTqIkXqcUMYc72eQlZJHN9/XBC">BetterScroll - EventEmitter</a>：<a href="https://link.segmentfault.com/?enc=9BO94xSeI7S+wa+f+HT/nA==.Y4L8LLn8UmgxVzr+uvJ3EUQXnFQyliV9ZIB8cE9P3BR+nGmb8MAMCoUajVmzfoV1xe9fY4miGkpcPYD+BC7bLO+STrRCfaSKxTKjarOjkPmoJHAHUfm1e0Unlp+mqy3K">https://github.com/ustbhuangy...</a></li><li><a href="https://link.segmentfault.com/?enc=LSHDzkHzRfPE5oasgWDc/w==.1Gh+863EX1OPxJyE+uy8cS8uxAhpy+n4FAt9vL937E3ivtFz2RVFb06yCIJNhsDprN1nBZMvpVCs2tksEeq3VQ==">EventEmitter 在插件化架构的应用</a>：<a href="https://link.segmentfault.com/?enc=ZdTJEzaH9AopM0StkQrXOQ==.CWE7l1SpGSRu4CARp5ER5/xAzNZBWUY7Klru7eYIYjn2sfNCzSspg31PqzUUuZMgNvsZxjKpKvFMFvnrAR/q1w==">https://mp.weixin.qq.com/s/N4...</a></li></ul><blockquote><p>继续阅读：<a href="https://link.segmentfault.com/?enc=5nNhJEL/xof/stx4JL+b9g==.9F9vgkG1VUVmGnBhxnk6fv1DJjBHVzf+tlctK61gGBktolKoWXWKLE8AChdQswhmtg4Idj8IkLS7ibh1OgIUMA==">如何优雅的实现消息通信？</a></p></blockquote><h3 id="六、策略模式"><a href="#六、策略模式" class="headerlink" title="六、策略模式"></a>六、策略模式</h3><p>策略模式（Strategy Pattern）定义了一系列的算法，把它们一个个封装起来，并且使它们可以互相替换。策略模式的重心不是如何实现算法，而是如何组织、调用这些算法，从而让程序结构更灵活、可维护、可扩展。</p><p><img src="https://segmentfault.com/img/bVcglbR" alt="image"></p><p>目前在一些主流的 Web 站点中，都提供了多种不同的登录方式。比如账号密码登录、手机验证码登录和第三方登录。为了方便维护不同的登录方式，我们可以把不同的登录方式封装成不同的登录策略。</p><p>下面我们来看一下如何使用策略模式来封装不同的登录方式。</p><h5 id="6-1-实现代码"><a href="#6-1-实现代码" class="headerlink" title="6.1 实现代码"></a>6.1 实现代码</h5><p>为了更好地理解以下代码，我们先来看一下对应的 UML 类图：</p><p><img src="https://segmentfault.com/img/bVcgnhV" alt="image"></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">Strategy</span> <span class="token punctuation">{</span>  <span class="token function">authenticate</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Authenticator</span> <span class="token punctuation">{</span>  strategy<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">;</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>strategy <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">setStrategy</span><span class="token punctuation">(</span>strategy<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>strategy <span class="token operator">=</span> strategy<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">authenticate</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>strategy<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'尚未设置认证策略'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>strategy<span class="token punctuation">.</span><span class="token function">authenticate</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">WechatStrategy</span> <span class="token keyword">implements</span> <span class="token class-name">Strategy</span> <span class="token punctuation">{</span>  <span class="token function">authenticate</span><span class="token punctuation">(</span>wechatToken<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>wechatToken <span class="token operator">!==</span> <span class="token string">'123'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'无效的微信用户'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'微信认证成功'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">LocalStrategy</span> <span class="token keyword">implements</span> <span class="token class-name">Strategy</span> <span class="token punctuation">{</span>  <span class="token function">authenticate</span><span class="token punctuation">(</span>username<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> password<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>username <span class="token operator">!==</span> <span class="token string">'abao'</span> <span class="token operator">&amp;&amp;</span> password <span class="token operator">!==</span> <span class="token string">'123'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'账号或密码错误'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'账号和密码认证成功'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="6-2-使用示例"><a href="#6-2-使用示例" class="headerlink" title="6.2 使用示例"></a>6.2 使用示例</h5><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> auth <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Authenticator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>auth<span class="token punctuation">.</span><span class="token function">setStrategy</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">WechatStrategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>auth<span class="token punctuation">.</span><span class="token function">authenticate</span><span class="token punctuation">(</span><span class="token string">'123456'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>auth<span class="token punctuation">.</span><span class="token function">setStrategy</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LocalStrategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>auth<span class="token punctuation">.</span><span class="token function">authenticate</span><span class="token punctuation">(</span><span class="token string">'abao'</span><span class="token punctuation">,</span> <span class="token string">'123'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="6-3-应用场景及案例"><a href="#6-3-应用场景及案例" class="headerlink" title="6.3 应用场景及案例"></a>6.3 应用场景及案例</h5><ul><li>一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。</li><li>多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。</li><li>一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。</li><li><a href="https://link.segmentfault.com/?enc=ehTXUmhCSUVHOUAiVBfEpg==.B/55SaQRjbYkf8ikL7zRwN8S2emFandAVB6al2Px+F7RpswpNoEaGg9HAioAFZ/3">Github - passport-local</a>：<a href="https://link.segmentfault.com/?enc=9RfNr6JhRPLV1hVQrFmqWg==.wFLfyaZKnJBwnEUqP13R7g51C5PaG2J1Ms1XrO1WOEO+LAdBu9zmfqV3nHJYGVAw">https://github.com/jaredhanso...</a></li><li><a href="https://link.segmentfault.com/?enc=r+3D6c2c7U2ndCUjU5UgJw==.RoUKjFV1dKQ9wWbH1if5PXHI4GeOJGwPvktlZsD3/YsLYCj2dzss9WAUfOumgQ/9">Github - passport-oauth2</a>：<a href="https://link.segmentfault.com/?enc=OnyFv1HcmKNbwZpsech3UQ==.2dFGI+Ko20hu0CmdTHVHpqhL7uE3ueYyncGU/4GKzp8dhG3vPFCdnCaEcmnP87zM">https://github.com/jaredhanso...</a></li><li><a href="https://link.segmentfault.com/?enc=bnfuHhcMgicq/u7KrnXEYw==.bSo4TvWGAr/EoaFjvHt2z1KUp5trRFIQfK8Mp3PEzJxlIgnaegNfIM8D6tlSlaj1RZFHR3Wkksw3tNFAwKkF9Q==">Github - zod</a>：<a href="https://link.segmentfault.com/?enc=wbtfAGsmiKuc8kkFV2yODQ==.+27cXo4NSDhA5lSX9mm3aEEsRL1u8ha7ViD81FeAVM/Zkb48l90fmgxsK3/Wc2hK6vGcXrSm11mYQ5n8lFAtlA==">https://github.com/vriad/zod/...</a></li></ul><h3 id="七、职责链模式"><a href="#七、职责链模式" class="headerlink" title="七、职责链模式"></a>七、职责链模式</h3><p>职责链模式是使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。在职责链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。</p><p><img src="https://segmentfault.com/img/bVcgqnX" alt="image"></p><p>在公司中不同的岗位拥有不同的职责与权限。以上述的请假流程为例，当阿宝哥请 1 天假时，只要组长审批就可以了，不需要流转到主管和总监。如果职责链上的某个环节无法处理当前的请求，若含有下个环节，则会把请求转交给下个环节来处理。</p><p>在日常的软件开发过程中，对于职责链来说，一种常见的应用场景是中间件，下面我们来看一下如何利用职责链来处理请求。</p><h5 id="7-1-实现代码"><a href="#7-1-实现代码" class="headerlink" title="7.1 实现代码"></a>7.1 实现代码</h5><p>为了更好地理解以下代码，我们先来看一下对应的 UML 类图：</p><p><img src="https://segmentfault.com/img/bVcgrCF" alt="image"></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">IHandler</span> <span class="token punctuation">{</span>  <span class="token function">addMiddleware</span><span class="token punctuation">(</span>h<span class="token operator">:</span> IHandler<span class="token punctuation">)</span><span class="token operator">:</span> IHandler<span class="token punctuation">;</span>  <span class="token function">get</span><span class="token punctuation">(</span>url<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token function-variable function">callback</span><span class="token operator">:</span> <span class="token punctuation">(</span>data<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractHandler</span> <span class="token keyword">implements</span> <span class="token class-name">IHandler</span> <span class="token punctuation">{</span>  next<span class="token operator">!</span><span class="token operator">:</span> IHandler<span class="token punctuation">;</span>  <span class="token function">addMiddleware</span><span class="token punctuation">(</span>h<span class="token operator">:</span> IHandler<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> h<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>next<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">get</span><span class="token punctuation">(</span>url<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token function-variable function">callback</span><span class="token operator">:</span> <span class="token punctuation">(</span>data<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>next<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// 定义Auth中间件</span><span class="token keyword">class</span> <span class="token class-name">Auth</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractHandler</span> <span class="token punctuation">{</span>  isAuthenticated<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>username<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> password<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>isAuthenticated <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>username <span class="token operator">===</span> <span class="token string">'abao'</span> <span class="token operator">&amp;&amp;</span> password <span class="token operator">===</span> <span class="token string">'123'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>isAuthenticated <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token function">get</span><span class="token punctuation">(</span>url<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token function-variable function">callback</span><span class="token operator">:</span> <span class="token punctuation">(</span>data<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>isAuthenticated<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'Not Authorized'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// 定义Logger中间件</span><span class="token keyword">class</span> <span class="token class-name">Logger</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractHandler</span> <span class="token punctuation">{</span>  <span class="token function">get</span><span class="token punctuation">(</span>url<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token function-variable function">callback</span><span class="token operator">:</span> <span class="token punctuation">(</span>data<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'/GET Request to: '</span><span class="token punctuation">,</span> url<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Route</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractHandler</span> <span class="token punctuation">{</span>  URLMaps<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">[</span>key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>URLMaps <span class="token operator">=</span> <span class="token punctuation">{</span>      <span class="token string-property property">'/api/todos'</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span> title<span class="token operator">:</span> <span class="token string">'learn ts'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> title<span class="token operator">:</span> <span class="token string">'learn react'</span> <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">,</span>      <span class="token string-property property">'/api/random'</span><span class="token operator">:</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">get</span><span class="token punctuation">(</span>url<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token function-variable function">callback</span><span class="token operator">:</span> <span class="token punctuation">(</span>data<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>URLMaps<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">callback</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>URLMaps<span class="token punctuation">[</span>url<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="7-2-使用示例"><a href="#7-2-使用示例" class="headerlink" title="7.2 使用示例"></a>7.2 使用示例</h5><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> route <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Route</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>route<span class="token punctuation">.</span><span class="token function">addMiddleware</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Auth</span><span class="token punctuation">(</span><span class="token string">'abao'</span><span class="token punctuation">,</span> <span class="token string">'123'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addMiddleware</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Logger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>route<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'/api/todos'</span><span class="token punctuation">,</span> data <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span><span class="token punctuation">{</span> data <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>route<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'/api/random'</span><span class="token punctuation">,</span> data <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="7-3-应用场景"><a href="#7-3-应用场景" class="headerlink" title="7.3 应用场景"></a>7.3 应用场景</h5><ul><li>可处理一个请求的对象集合应被动态指定。</li><li>想在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。</li><li>有多个对象可以处理一个请求，哪个对象处理该请求运行时自动确定，客户端只需要把请求提交到链上即可。</li></ul><h3 id="八、模板方法模式"><a href="#八、模板方法模式" class="headerlink" title="八、模板方法模式"></a>八、模板方法模式</h3><p>模板方法模式由两部分结构组成：抽象父类和具体的实现子类。<strong>通常在抽象父类中封装了子类的算法框架，也包括实现一些公共方法以及封装子类中所有方法的执行顺序</strong>。子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法。</p><p><img src="https://segmentfault.com/img/bVcgt1W" alt="image"></p><p>在上图中，阿宝哥通过使用不同的解析器来分别解析 CSV 和 Markup 文件。虽然解析的是不同的类型的文件，但文件的处理流程是一样的。这里主要包含读取文件、解析文件和打印数据三个步骤。针对这个场景，我们就可以引入模板方法来封装以上三个步骤的处理顺序。</p><p>下面我们来看一下如何使用模板方法来实现上述的解析流程。</p><h5 id="8-1-实现代码"><a href="#8-1-实现代码" class="headerlink" title="8.1 实现代码"></a>8.1 实现代码</h5><p>为了更好地理解以下代码，我们先来看一下对应的 UML 类图：</p><p><img src="https://segmentfault.com/img/bVcgvri" alt="image"></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> fs <span class="token keyword">from</span> <span class="token string">'fs'</span><span class="token punctuation">;</span><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">DataParser</span> <span class="token punctuation">{</span>  data<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>  out<span class="token operator">:</span> <span class="token builtin">any</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token comment">// 这就是所谓的模板方法</span>  <span class="token function">parse</span><span class="token punctuation">(</span>pathUrl<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span>pathUrl<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">doParsing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">printData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">readFile</span><span class="token punctuation">(</span>pathUrl<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span>pathUrl<span class="token punctuation">,</span> <span class="token string">'utf8'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">abstract</span> <span class="token function">doParsing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>    <span class="token function">printData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">CSVParser</span> <span class="token keyword">extends</span> <span class="token class-name">DataParser</span> <span class="token punctuation">{</span>  <span class="token function">doParsing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>out <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">MarkupParser</span> <span class="token keyword">extends</span> <span class="token class-name">DataParser</span> <span class="token punctuation">{</span>  <span class="token function">doParsing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>out <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">&lt;\w+&gt;.*&lt;\/\w+&gt;</span><span class="token regex-delimiter">/</span><span class="token regex-flags">gim</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="8-2-使用示例"><a href="#8-2-使用示例" class="headerlink" title="8.2 使用示例"></a>8.2 使用示例</h5><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> csvPath <span class="token operator">=</span> <span class="token string">'./data.csv'</span><span class="token punctuation">;</span><span class="token keyword">const</span> mdPath <span class="token operator">=</span> <span class="token string">'./design-pattern.md'</span><span class="token punctuation">;</span><span class="token keyword">new</span> <span class="token class-name">CSVParser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>csvPath<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">new</span> <span class="token class-name">MarkupParser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>mdPath<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="8-3-应用场景"><a href="#8-3-应用场景" class="headerlink" title="8.3 应用场景"></a>8.3 应用场景</h5><ul><li>算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。</li><li>当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进行扩展。</li></ul><h3 id="九、参考资源"><a href="#九、参考资源" class="headerlink" title="九、参考资源"></a>九、参考资源</h3><ul><li><a href="https://link.segmentfault.com/?enc=4uPKEFy+RE19xWLtrMGVEw==.1sV8lEVXmMrWx6TvcPA+n7Y9NK20OqFlaUXQ9WXYuMkhplEiPI9bnIHGH4BxsnlaVqLZYc+B5Ybx0FJX0sBQGsQB6+Xg0N4rgbsyDkuhql769Jx5uZcOPXRywG0nSw0Z">维基百科 - 设计模式</a>)</li><li><a href="https://link.segmentfault.com/?enc=o8Zmd+NVWEHSU/PnJKAMUQ==.cK9VwOdi2BNNLlY3gx8LKmS59Z9FZdfOIlBsGQII3IhG/9fcJkIAy1EUJ7AtDLHk">Java设计模式：23种设计模式全面解析</a></li><li><a href="https://link.segmentfault.com/?enc=iEP23Qu+9Nt05GL6ZBd79w==.ozdsmLLKwrM//NmuJqi7hvPYs5vcuf1lVrQrC2yCVDnCVgdYlSp6SgWZN0RkKGKNmz0VBjf1xDSfgvdZuPjVZw==">Design Patterns Everyday</a></li></ul><p>原文链接：<a href="https://segmentfault.com/a/1190000030850326">https://segmentfault.com/a/1190000030850326</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring bean生命周期</title>
      <link href="/archives/8af63304.html"/>
      <url>/archives/8af63304.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天我们来说一说 Spring Bean 的生命周期，小伙伴们应该在面试中经常遇到，这是正常现象。因为 Spring Bean 的生命周期是除了 IoC、AOP 几个核心概念之外最重要概念。可 Spring 源代码又比较复杂，跟着跟着就不知道跟到哪里去了，不太好拿下呀。这倒是真的，而且网上一上来就各种贴流程源码，对初学者来说是真的一脸懵逼，就像字都看的懂，但连在一块就不知道意思了，太绕了。</p><p>本文试着讲的通俗易懂些，让更多的小伙伴们轻松的读懂 Spring Bean 的生命周期，并有对它有继续研究学习的想法，那此文的目的也就达到了。</p><span id="more"></span><p>我们讲 Spring Bean 的生命周期之前先来了解两个概念：</p><p><strong>1.1 什么是 Bean</strong></p><p>我们来看下 Spring Framework 的官方文档：</p><blockquote><p>In Spring, the objects that form the backbone of your application and that are managed by the Spring IoC container are called beans. A bean is an object that is instantiated, assembled, and otherwise managed by a Spring IoC container. Otherwise, a bean is simply one of many objects in your application. Beans, and the dependencies among them, are reflected in the configuration metadata used by a container.</p></blockquote><p>简而言之，bean 是由 Spring IoC 容器实例化、组装和管理的对象。</p><p><strong>1.2 什么是 Spring Bean 的生命周期</strong></p><p>对于普通的 Java 对象，当 new 的时候创建对象，然后该对象就能够使用了。一旦该对象不再被使用，则由 Java 自动进行垃圾回收。</p><p>而 Spring 中的对象是 bean，bean 和普通的 Java 对象没啥大的区别，只不过 Spring 不再自己去 new 对象了，而是由 IoC 容器去帮助我们实例化对象并且管理它，我们需要哪个对象，去问 IoC 容器要即可。IoC 其实就是解决对象之间的耦合问题，Spring Bean 的生命周期完全由容器控制。</p><h2 id="二、Spring-Bean-的生命周期"><a href="#二、Spring-Bean-的生命周期" class="headerlink" title="二、Spring Bean 的生命周期"></a>二、Spring Bean 的生命周期</h2><p>这里必须要提一下，这里我们说的 Spring Bean 的生命周期主要指的是 singleton bean，对于 prototype 的 bean ，Spring 在创建好交给使用者之后则不会再管理后续的生命周期。</p><p>我们也来复习下 Spring 中的 bean 的作用域有哪些?</p><ul><li><code>singleton</code> : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。</li><li><code>prototype</code> : 每次请求都会创建一个新的 bean 实例。</li><li><code>request</code> : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。</li><li><code>session</code> : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。</li><li><code>global-session</code>： 全局 session 作用域，仅仅在基于 Portlet 的 web 应用中才有意义，Spring5 已经没有了。Portlet 是能够生成语义代码（例如：HTML）片段的小型 Java Web 插件。它们基于 portlet 容器，可以像 servlet 一样处理 HTTP 请求。但是，与 servlet 不同，每个 portlet 都有不同的会话。</li></ul><p>我们知道对于普通的 Java 对象来说，它们的生命周期就是：</p><ul><li>实例化</li><li>该对象不再被使用时通过垃圾回收机制进行回收</li></ul><p>而对于 Spring Bean 的生命周期来说：</p><ul><li>实例化 Instantiation</li><li>属性赋值 Populate</li><li>初始化 Initialization</li><li>销毁 Destruction</li></ul><p>实例化 -&gt; 属性赋值 -&gt; 初始化 -&gt; 销毁</p><p>只有四个步骤，这样拆解的话是不是感觉也不难？不像其他人写的那样直接一上来就各种 BeanPostProcessor、BeanFactoryPostProcessor 全部怼进流程里去，别说读者看着头大，自己写的可能短时间内还记得流程，隔个一段时间，你可能都不知道自己写了个啥。</p><p>本来想通过 Bean 创建流程入口<br>AbstractApplicationContext#refresh() 方法的 finishBeanFactoryInitialization(beanFactory) 处带大家跟一下源码，想了想还是不带入过多的代码进来，直接给到最终的主要逻辑。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token class-name">Object</span> <span class="token function">doCreateBean</span><span class="token punctuation">(</span><span class="token class-name">String</span> beanName<span class="token punctuation">,</span> <span class="token class-name">RootBeanDefinition</span> mbd<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeanCreationException</span> <span class="token punctuation">{</span>    <span class="token class-name">BeanWrapper</span> instanceWrapper <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">isSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        instanceWrapper <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">BeanWrapper</span><span class="token punctuation">)</span><span class="token keyword">this</span><span class="token punctuation">.</span>factoryBeanInstanceCache<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>instanceWrapper <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 实例化阶段</span>        instanceWrapper <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">createBeanInstance</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token class-name">Object</span> exposedObject <span class="token operator">=</span> bean<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment">// 属性赋值阶段</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">populateBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> instanceWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 初始化阶段</span>        exposedObject <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">initializeBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> exposedObject<span class="token punctuation">,</span> mbd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> var18<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>至于销毁，是在容器关闭时调用的，详见 <code>ConfigurableApplicationContext#close()</code></p><p>是不是很清爽了？至于 BeanPostProcessor、BeanFactoryPostProcessor 以及其他的类，在老周看来，只不过是对主流程四个步骤的一系列扩展点而已。</p><h2 id="三、Spring-Bean-的生命周期的扩展点"><a href="#三、Spring-Bean-的生命周期的扩展点" class="headerlink" title="三、Spring Bean 的生命周期的扩展点"></a>三、Spring Bean 的生命周期的扩展点</h2><p>Spring Bean 的生命周期的扩展点超级多，老周这里不可能全部列出来，只说核心的扩展点。这也就是为什么 Spring 的扩展性很好的原因，开了很多的口子，尽可能让某个功能高内聚松耦合，用户需要哪个功能就用哪个，而不是直接来一个大而全的东西。</p><p><strong>3.1 Bean 自身的方法</strong></p><p>比如构造函数、getter/setter 以及 init-method 和 destory-method 所指定的方法等，也就对应着上文说的实例化 -&gt; 属性赋值 -&gt; 初始化 -&gt; 销毁四个阶段。</p><p><img src="https://segmentfault.com/img/remote/1460000040365133" alt="在这里插入图片描述"><br><strong>3.2 容器级的方法（BeanPostProcessor 一系列接口）</strong></p><p>主要是后处理器方法，比如下图的 <code>InstantiationAwareBeanPostProcessor</code>、<code>BeanPostProcessor</code> 接口方法。这些接口的实现类是独立于 Bean 的，并且会注册到 Spring 容器中。在 Spring 容器创建任何 Bean 的时候，这些后处理器都会发生作用。</p><p><img src="https://segmentfault.com/img/remote/1460000040365134" alt="在这里插入图片描述"><br><strong>3.2.1 InstantiationAwareBeanPostProcessor 源码分析</strong></p><p>我们翻一下源码发现 InstantiationAwareBeanPostProcessor 是继承了 BeanPostProcessor</p><p><img src="https://segmentfault.com/img/remote/1460000040365135" alt="在这里插入图片描述"><br><img src="https://segmentfault.com/img/remote/1460000040365136" alt="在这里插入图片描述"></p><ul><li><code>InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation</code> 调用点</li></ul><blockquote><p>Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName)<br>返回值：如果返回的不为null，那么后续的Bean的创建流程【实例化、初始化afterProperties】都不会执行，而是直接使用返回的快捷Bean，此时的正常执行顺序如下：<br>InstantiationAwareBeanPostProcessor接口中的postProcessBeforeInstantiation，在实例化之前调用。<br>BeanPostProcessor接口中的postProcessAfterInitialization，在实例化之后调用。</p></blockquote><p><img src="https://segmentfault.com/img/remote/1460000040365137" alt="在这里插入图片描述"><br><img src="https://segmentfault.com/img/remote/1460000040365138" alt="在这里插入图片描述"><br><img src="https://segmentfault.com/img/remote/1460000040365139" alt="在这里插入图片描述"><br><img src="https://segmentfault.com/img/remote/1460000040365140" alt="在这里插入图片描述"><br>总之，postProcessBeforeInstantiation 在 doCreateBean 之前调用，也就是在 bean 实例化之前调用的，英文源码注释解释道该方法的返回值会替换原本的 Bean 作为代理，这也是 AOP 等功能实现的关键点。</p><ul><li><code>InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation</code> 调用点</li></ul><blockquote><p>boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException<br>正常情况下在实例化之后在执行populateBean之前调用<br>返回值：如果有指定的bean的时候返回false，那么后续的属性填充和属性依赖注入【populateBean】将不会执行，同时后续的postProcessPropertyValues将不会执行,但是初始化和BeanPostProcessor的仍然会执行。</p></blockquote><p><img src="https://segmentfault.com/img/remote/1460000040365141" alt="在这里插入图片描述"></p><blockquote><p>public PropertyValues postProcessPropertyValues(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)<br>实例化之后调用，在方法applyPropertyValues【属性填充】之前<br>返回值：如果返回null，那么将不会进行后续的属性填充，比如依赖注入等，如果返回的pvs额外的添加了属性，那么后续会填充到该类对应的属性中。<br>pvs：PropertyValues对象，用于封装指定类的对象，简单来说就是PropertyValue的集合，里面相当于以key-value形式存放类的属性和值。<br>pds：PropertyDescriptor对象数组，PropertyDescriptor相当于存储类的属性，不过可以调用set，get方法设置和获取对应属性的值。</p></blockquote><p><img src="https://segmentfault.com/img/remote/1460000040365142" alt="在这里插入图片描述"><br><strong>3.2.2 BeanPostProcessor 源码分析</strong></p><blockquote><p>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean</p></blockquote><p><img src="https://segmentfault.com/img/remote/1460000040365143" alt="在这里插入图片描述"><br>进入初始化接口：</p><p><img src="https://segmentfault.com/img/remote/1460000040365144" alt="在这里插入图片描述"><br>我们先来看</p><blockquote><p>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsBeforeInitialization</p></blockquote><p><img src="https://segmentfault.com/img/remote/1460000040365145" alt="在这里插入图片描述"></p><ul><li>首先获取到所有的后置处理器 getBeanPostProcessors()</li><li>在 for 循环中依次调用后置处理器的方法 <code>processor.postProcessBeforeInitialization(result, beanName);</code></li><li>进入 postProcessBeforeInitialization 方法</li></ul><blockquote><p>org.springframework.context.support.ApplicationContextAwareProcessor#postProcessBeforeInitialization</p></blockquote><p><img src="https://segmentfault.com/img/remote/1460000040365146" alt="在这里插入图片描述"></p><p>进入 <code>invokeAwareInterfaces(bean);</code> 方法，当前 bean 实现了 ApplicationContextAware 接口。</p><p><img src="https://segmentfault.com/img/remote/1460000040365147" alt="在这里插入图片描述"></p><ul><li><code>ApplicationContextAwareProcessor#postProcessBeforeInitialization</code> 首先判断此 bean 是不是各种的Aware，如果是它列举的那几个 Aware 就获取 Bean 工厂的权限，可以向容器中导入相关的上下文环境，目的是为了 Bean 实例能够获取到相关的上下文，如果不是它列举的几个 Aware，那就调用 <code>invokeAwareInterfaces(bean)</code>，向容器中添加相关接口的上下文环境。</li></ul><p><strong>3.3 工厂后处理器方法（BeanFactoryProcessor 一系列接口）</strong></p><p>包括 <code>AspectJWeavingEnabler</code>、<code>CustomAutowireConfigurer</code>、<code>ConfigurationClassPostProcessor</code> 等。这些都是 Spring 框架中已经实现好的 BeanFactoryPostProcessor，用来实现某些特定的功能。</p><p>我们知道 Spring IoC 容器初始化的关键环节就在 <code>org.springframework.context.support.AbstractApplicationContext#refresh</code> 方法中 ，容器创建的主体流程都在这个方法里面，这个方法是真的重要！！！</p><p>对于工厂后处理器方法老周这里直接带你看 <code>invokeBeanFactoryPostProcessors(beanFactory);</code> 方法，这个方法处理的是 <code>BeanFactoryPostProcessor</code> 接口的 Bean。调用方法如下：</p><p><img src="https://segmentfault.com/img/remote/1460000040365148" alt="在这里插入图片描述"><br>跟到最重要的方法里去，代码虽长，但逻辑中规中矩。</p><p><code>BeanFactoryPostProcessor</code>：一切处理 BeanFactory 的父接口<br><code>BeanDefinitionRegistryPostProcessor</code>：实现了 BeanFactoryPostProcessor 接口的接口</p><p><img src="https://segmentfault.com/img/remote/1460000040365149" alt="在这里插入图片描述"><br>流程说明：</p><ul><li>调用 BeanDefinitionRegistryPostProcessor#postProcessBeanDefinitionRegistry(registry) 方法。参数 beanFactoryPostProcessors 传入的优先处理掉。然后获取容器注册的，对于这些 Bean 按照 PriorityOrdered 接口、Ordered、没有排序接口的实例分别进行处理。</li><li>调用 BeanFactoryPostProcessor#postProcessBeanFactory(beanFactory) 方法。备注：BeanDefinitionRegistryPostProcessor 属于 BeanFactoryPostProcessor 子接口。先处理属于 BeanDefinitionRegistryPostProcessor 接口实例的 postProcessBeanFactory(beanFactory) 方法，然后获取容器注册的。对于这些 Bean 按照 PriorityOrdered 接口、Ordered、没有排序接口的实例分别进行处理。</li></ul><p><strong>3.4 Bean 级生命周期方法</strong></p><p>可以理解为 Bean 类直接实现接口的方法，比如 <code>BeanNameAware</code>、<code>BeanFactoryAware</code>、<code>ApplicationContextAware</code>、<code>InitializingBean</code>、<code>DisposableBean</code> 等方法，这些方法只对当前 Bean 生效。</p><p><strong>3.4.1 Aware 类型的接口</strong></p><p>Aware 类型的接口的作用就是让我们能够拿到 Spring 容器中的一些资源。基本都能够见名知意，Aware 之前的名字就是可以拿到什么资源，例如 BeanNameAware 可以拿到 BeanName，以此类推。调用时机需要注意：所有的 Aware 方法都是<code>在初始化阶段之前调用的</code>。</p><p>Aware 接口众多，这里同样通过分类的方式帮助大家记忆。Aware 接口具体可以分为两组，至于为什么这么分，详见下面的源码分析。如下排列顺序同样也是 Aware 接口的执行顺序，能够见名知意的接口不再解释。</p><p><strong>Aware Group1</strong></p><ul><li><code>BeanNameAware</code></li><li><code>BeanClassLoaderAware</code></li><li><code>BeanFactoryAware</code></li></ul><p><strong>Aware Group2</strong></p><ul><li><code>EnvironmentAware</code></li><li><code>EmbeddedValueResolverAware</code><br>这个知道的人可能不多，实现该接口能够获取 Spring EL 解析器，用户的自定义注解需要支持 SPEL 表达式的时候可以使用，非常方便。</li><li><code>ApplicationContextAware(ResourceLoaderAware/ApplicationEventPublisherAware/MessageSourceAware)</code><br>这几个接口可能让人有点懵，实际上这几个接口可以一起记，其返回值实质上都是当前的 ApplicationContext 对象，因为 ApplicationContext 是一个复合接口，如下：<br><img src="https://segmentfault.com/img/remote/1460000040365150" alt="在这里插入图片描述"></li></ul><p><strong>Aware 调用时机源码分析</strong></p><p><img src="https://segmentfault.com/img/remote/1460000040365151" alt="在这里插入图片描述"><br>可以看到并不是所有的 Aware 接口都使用同样的方式调用。Bean××Aware 都是在代码中直接调用的，而 ApplicationContext 相关的 Aware 都是通过 BeanPostProcessor#postProcessBeforeInitialization() 实现的。感兴趣的可以自己看一下 ApplicationContextAwareProcessor 这个类的源码，就是判断当前创建的 Bean 是否实现了相关的 Aware 方法，如果实现了会调用回调方法将资源传递给 Bean。</p><p>BeanPostProcessor 的调用时机也能在这里体现，包围住 invokeInitMethods 方法，也就说明了在初始化阶段的前后执行。</p><p>关于 Aware 接口的执行顺序，其实只需要记住第一组在第二组执行之前就行了。</p><p><strong>3.4.2 生命周期接口</strong></p><p>至于剩下的两个生命周期接口就很简单了，实例化和属性赋值都是 Spring 帮助我们做的，能够自己实现的有初始化和销毁两个生命周期阶段。</p><ul><li><code>InitializingBean</code> 对应生命周期的初始化阶段，在上面源码的 <code>invokeInitMethods(beanName, wrappedBean, mbd);</code>方法中调用。</li></ul><p>有一点需要注意，因为 Aware 方法都是执行在初始化方法之前，所以可以在初始化方法中放心大胆的使用 Aware 接口获取的资源，这也是我们自定义扩展 Spring 的常用方式。<br>除了实现 InitializingBean 接口之外还能通过注解或者 xml 配置的方式指定初始化方法，至于这几种定义方式的调用顺序其实没有必要记。因为这几个方法对应的都是同一个生命周期，只是实现方式不同，我们一般只采用其中一种方式。</p><ul><li><code>DisposableBean</code> 类似于 InitializingBean，对应生命周期的销毁阶段，以<code>ConfigurableApplicationContext#close()</code>方法作为入口，实现是通过循环取所有实现了 DisposableBean 接口的 Bean 然后调用其 destroy() 方法，感兴趣的可以自行跟一下源码。</li></ul><p><strong>3.5 Spring Bean 生命周期流程图</strong></p><p><img src="https://segmentfault.com/img/remote/1460000040365152" alt="在这里插入图片描述"></p><h2 id="四、常用接口说明"><a href="#四、常用接口说明" class="headerlink" title="四、常用接口说明"></a>四、常用接口说明</h2><p><strong>4.1 BeanNameAware</strong></p><p>该接口只有一个方法 <code>setBeanName(String name)</code>，用来获取 bean 的 <code>id 或者 name</code>。</p><p><strong>4.2 BeanFactoryAware</strong></p><p>该接口只有一个方法 <code>setBeanFactory(BeanFactory beanFactory)</code>，用来获取<code>当前环境中的 BeanFactory</code>。</p><p><strong>4.3 ApplicationContextAware</strong></p><p>该接口只有一个方法 <code>setApplicationContext(ApplicationContext applicationContext)</code>，用来获取<code>当前环境中的 ApplicationContext</code>。</p><p><strong>4.4 InitializingBean</strong></p><p>该接口只有一个方法 <code>afterPropertiesSet()</code>，在<code>属性注入完成后调用</code>。</p><p><strong>4.5 DisposableBean</strong></p><p>该接口只有一个方法 <code>destroy()</code>，在容器销毁的时候调用，在<code>用户指定的 destroy-method 之前调用</code>。</p><p><strong>4.6 BeanPostProcessor</strong></p><p>该接口有两个方法：</p><ul><li><code>postProcessBeforeInitialization(Object bean, String beanName)</code>：在<code>初始化之前</code>调用此方法</li><li><code>postProcessAfterInitialization(Object bean, String beanName)</code>：在<code>初始化之后</code>调用此方法</li></ul><p>通过方法签名我们可以知道，我们可以通过 beanName 来筛选出我们需要进行个性化定制的 bean。</p><p><strong>4.7 InstantiationAwareBeanPostProcessor</strong></p><p>该类是 BeanPostProcessor 的子接口，常用的有如下三个方法：</p><ul><li><code>postProcessBeforeInstantiation(Class beanClass, String beanName)</code>：在bean<code>实例化之前</code>调用</li><li><code>postProcessProperties(PropertyValues pvs, Object bean, String beanName)</code>：在bean<code>实例化之后、设置属性前</code>调用</li><li><code>postProcessAfterInstantiation(Class beanClass, String beanName)</code>：在bean<code>实例化之后</code>调用</li></ul><h2 id="五、代码演示"><a href="#五、代码演示" class="headerlink" title="五、代码演示"></a>五、代码演示</h2><p>思路：创建一个类 UserBean ，让其实现几个特殊的接口，并分别在接口实现的构造器、接口方法中断点，观察线程调用栈，分析出 Bean 对象创建和管理关键点的触发时机。</p><p><strong>5.1 UserBean 类</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserBean</span> <span class="token keyword">implements</span> <span class="token class-name">InitializingBean</span><span class="token punctuation">,</span> <span class="token class-name">BeanNameAware</span><span class="token punctuation">,</span> <span class="token class-name">DisposableBean</span><span class="token punctuation">,</span> <span class="token class-name">ApplicationContextAware</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">UserBean</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"2. 调用构造函数"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> id<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setId</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"5. 属性注入 id"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"5. 属性注入 name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setBeanName</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"6. 调用 BeanNameAware.setBeanName() 方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setApplicationContext</span><span class="token punctuation">(</span><span class="token class-name">ApplicationContext</span> applicationContext<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">{</span>        <span class="token class-name">UserBean</span> userBean <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">UserBean</span><span class="token punctuation">)</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"userBean"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>userBean<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"7. 调用 BeanNameAware.setBeanName() 方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterPropertiesSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"9. 调用 InitializingBean.afterPropertiesSet() 方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">myInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"10. 调用 init-method 方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"12. 调用 DisposableBean.destroy() 方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">myDestroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"13. 调用 destroy-method 方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"UserBean{"</span> <span class="token operator">+</span>                <span class="token string">"id="</span> <span class="token operator">+</span> id <span class="token operator">+</span>                <span class="token string">", name='"</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token char">'\''</span> <span class="token operator">+</span>                <span class="token char">'}'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>5.2 InstantiationAwareBeanPostProcessor 接口实现类</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyInstantiationAwareBeanPostProcessor</span> <span class="token keyword">implements</span> <span class="token class-name">InstantiationAwareBeanPostProcessor</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">postProcessBeforeInstantiation</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> beanClass<span class="token punctuation">,</span> <span class="token class-name">String</span> beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"userBean"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"1. 调用 InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation() 方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">postProcessAfterInstantiation</span><span class="token punctuation">(</span><span class="token class-name">Object</span> bean<span class="token punctuation">,</span> <span class="token class-name">String</span> beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"userBean"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">UserBean</span> userBean <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">UserBean</span><span class="token punctuation">)</span> bean<span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"3. 调用 InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation() 方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>userBean<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">PropertyValues</span> <span class="token function">postProcessProperties</span><span class="token punctuation">(</span><span class="token class-name">PropertyValues</span> pvs<span class="token punctuation">,</span> <span class="token class-name">Object</span> bean<span class="token punctuation">,</span> <span class="token class-name">String</span> beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"userBean"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"4. 调用 InstantiationAwareBeanPostProcessor.postProcessProperties() 方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>5.3 BeanPostProcessor 接口实现类</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyBeanPostProcessor</span> <span class="token keyword">implements</span> <span class="token class-name">BeanPostProcessor</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">postProcessBeforeInitialization</span><span class="token punctuation">(</span><span class="token class-name">Object</span> bean<span class="token punctuation">,</span> <span class="token class-name">String</span> beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"userBean"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"8. 调用 BeanPostProcessor.postProcessBeforeInitialization() 方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> bean<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">postProcessAfterInitialization</span><span class="token punctuation">(</span><span class="token class-name">Object</span> bean<span class="token punctuation">,</span> <span class="token class-name">String</span> beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"userBean"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"11. 调用 BeanPostProcessor.postProcessAfterInitialization() 方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> bean<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>5.4 BeanFactoryPostProcessor 接口实现类</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyBeanFactoryPostProcessor</span> <span class="token keyword">implements</span> <span class="token class-name">BeanFactoryPostProcessor</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">postProcessBeanFactory</span><span class="token punctuation">(</span><span class="token class-name">ConfigurableListableBeanFactory</span> beanFactory<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"0. 调用 BeanFactoryPostProcessor.postProcessBeanFactory() 方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>5.5 applicationContext.xml</strong></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>        http://www.springframework.org/schema/beans        https://www.springframework.org/schema/beans/spring-beans.xsd<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.riemann.test.MyInstantiationAwareBeanPostProcessor<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userBean<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.riemann.test.UserBean<span class="token punctuation">"</span></span> <span class="token attr-name">init-method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>myInit<span class="token punctuation">"</span></span> <span class="token attr-name">destroy-method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>myDestroy<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!-- 构造函数注入 --&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">index</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>int<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">&gt;</span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>constructor-arg</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">index</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>java.lang.String<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">&gt;</span></span>微信公众号【老周聊架构】<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>constructor-arg</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!-- setter方法注入 --&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>riemann<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.riemann.test.MyBeanPostProcessor<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.riemann.test.MyBeanFactoryPostProcessor<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>5.6 测试类</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BeanLifeCycleTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">ApplicationContext</span> applicationContext <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">"classpath:applicationContext.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">UserBean</span> user <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">UserBean</span><span class="token punctuation">)</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"userBean"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">AbstractApplicationContext</span><span class="token punctuation">)</span> applicationContext<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>5.7 控制台结果打印</strong></p><p><img src="https://segmentfault.com/img/remote/1460000040365153" alt="在这里插入图片描述"></p><p><a href="https://segmentfault.com/t/spring">spring</a></p><p>原文链接：<a href="https://segmentfault.com/a/1190000040365130">https://segmentfault.com/a/1190000040365130</a></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bean </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Springboot2.0入门</title>
      <link href="/archives/b528cfe0.html"/>
      <url>/archives/b528cfe0.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大家都知道，Spring Framework 是 Java/Spring 应用程序跨平台开发框架，也是 Java EE（Java Enterprise Edition） 轻量级框架，其 Spring 平台为 Java 开发者提供了全面的基础设施支持。 虽然 Spring 基础组件的代码是轻量级，但其配置依旧是重量级的。</p><p>那是怎么解决了呢？当然是 Spring Boot，Spring Boot 提供了新的编程模式，让开发 Spring 应用变得更加简单方便。本书将会由各个最佳实践工程出发，涉及 Spring Boot 开发相关的各方面。下面先了解下 Spring Boot 框架。</p><h2 id="1-1-Spring-Boot-是什么"><a href="#1-1-Spring-Boot-是什么" class="headerlink" title="1.1 Spring Boot 是什么"></a>1.1 Spring Boot 是什么</h2><p>Spring Boot （Boot 顾名思义，是引导的意思）框架是用于简化 Spring 应用从搭建到开发的过程。应用开箱即用，只要通过一个指令，包括命令行 <code>java -jar</code> 、<code>SpringApplication</code> 应用启动类 、 Spring Boot Maven 插件等，就可以启动应用了。另外，Spring Boot 强调只需要很少的配置文件，所以在开发生产级 Spring 应用中，让开发变得更加高效和简易。目前，Spring Boot 版本是 2.x 版本。</p><span id="more"></span><h3 id="1-1-1-Spring-Boot-2-x-特性"><a href="#1-1-1-Spring-Boot-2-x-特性" class="headerlink" title="1.1.1 Spring Boot 2.x 特性"></a>1.1.1 Spring Boot 2.x 特性</h3><p>Spring Boot 2.x 具有哪些生产的特性呢？常用特性如下：</p><ul><li>SpringApplication 应用类</li><li>自动配置</li><li>外化配置</li><li>内嵌容器</li><li>Starter 组件</li></ul><p>还有对日志、Web、消息、测试及扩展等支持。</p><h4 id="SpringApplication"><a href="#SpringApplication" class="headerlink" title="SpringApplication"></a>SpringApplication</h4><p><code>SpringApplication</code> 是 Spring Boot 应用启动类，在 <code>main()</code> 方法中调用 <code>SpringApplication.run()</code> 静态方法，即可运行一个 Spring Boot 应用。简单使用代码片段如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">QuickStartApplication</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Spring Boot 运行的应用是独立的一个 Jar 应用，实际上在运行时启动了应用内部的内嵌容器，容器初始化 Spring 环境及其组件并启动应用。也可以使用 Spring Boot 开发传统的应用，只要通过 Spring Boot Maven 插件将 Jar 应用转换成 War 应用即可。</p><h4 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h4><p>Spring Boot 在不需要任何配置情况下，就直接可以运行一个应用。实际上，Spring Boot 框架的 <code>spring-boot-autoconfigure</code> 依赖做了很多默认的配置项，即应用默认值。这种模式叫做 “自动配置”。Spring Boot 自动配置会根据添加的依赖，自动加载依赖相关的配置属性并启动依赖。例如，默认用的内嵌式容器是 Tomcat ，端口默认设置为 8080。</p><h4 id="外化配置"><a href="#外化配置" class="headerlink" title="外化配置"></a>外化配置</h4><p>Spring Boot 简化了配置，在 application.properties 文件配置常用的应用属性。Spring Boot 可以将配置外部化，这种模式叫做 “外化配置”。将配置从代码中分离外置，最明显的作用是只要简单地修改下外化配置文件，就可以在不同环境中，可以运行相同的应用代码。</p><h4 id="内嵌容器"><a href="#内嵌容器" class="headerlink" title="内嵌容器"></a>内嵌容器</h4><p>Spring Boot 启动应用，默认情况下是自动启动了内嵌容器 Tomcat，并且自动设置了默认端口为 8080。另外还提供了对 Jetty、Undertow 等容器的支持。开发者自行在添加对应的容器 Starter 组件依赖，即可配置并使用对应内嵌容器实例。</p><h4 id="Starter-组件"><a href="#Starter-组件" class="headerlink" title="Starter 组件"></a>Starter 组件</h4><p>Spring Boot 提供了很多 “开箱即用” 的 Starter 组件。Starter 组件是可被加载在应用中的 Maven 依赖项。只需要在 Maven 配置中添加对应的依赖配置，即可使用对应的 Starter 组件。例如，添加 <code>spring-boot-starter-web</code> 依赖，就可用于构建 REST API 服务，其包含了 Spring MVC 和 Tomcat 内嵌容器等。</p><p>开发中，很多功能是通过添加 Starter 组件的方式来进行实现。那么，Spring Boot 2.x 常用的 Starter 组件有哪些呢？</p><h3 id="1-1-2-Spring-Boot-2-x-Starter-组件"><a href="#1-1-2-Spring-Boot-2-x-Starter-组件" class="headerlink" title="1.1.2 Spring Boot 2.x Starter 组件"></a>1.1.2 Spring Boot 2.x Starter 组件</h3><p>Spring Boot 官方提供了很多 Starter 组件，涉及 Web、模板引擎、SQL 、NoSQL、缓存、验证、日志、测试、内嵌容器，还提供了事务、消息、安全、监控、大数据等支持。前面模块会在本书中一一介绍，后面这些模块本书不会涉及，如需自行请参看 Spring Boot 官方文档。</p><p>每个模块会有多种技术实现选型支持，来实现各种复杂的业务需求：</p><ul><li>Web：Spring Web、Spring WebFlux 等</li><li>模板引擎：Thymeleaf、FreeMarker、Groovy、Mustache 等</li><li>SQL：MySQL 、H2 等</li><li>NoSQL：Redis、MongoDB、Cassandra、Elasticsearch 等</li><li>验证框架：Hibernate Validator、Spring Validator 等</li><li>日志框架：Log4j2、Logback 等</li><li>测试：JUnit、Spring Boot Test、AssertJ、Mockito 等</li><li>内嵌容器：Tomcat、Jetty、Undertow 等</li></ul><p>另外，Spring WebFlux 框架目前支持 Servlet 3.1 以上的 Servlet 容器和 Netty，各种模块组成了 Spring Boot 2.x 的工作常用技术栈，如图 1-1 所示。</p><p><img src="http://springforall.ufile.ucloud.com.cn/static/img/b4716064c1af224fb8b1408ae6fdf7061515130" alt="img"></p><p>图 1-1 Spring Boot 技术架构</p><p>正如白猫黑猫，能抓住老鼠的就是好猫。在上述技术选型中，需要为公司业务的要求和团队技能选择最有效最合适的设计方案、架构和编程模型。</p><h3 id="1-1-3-Spring-Boot-应用场景"><a href="#1-1-3-Spring-Boot-应用场景" class="headerlink" title="1.1.3 Spring Boot 应用场景"></a>1.1.3 Spring Boot 应用场景</h3><p>Spring Boot 模块众多，代表着应用场景也非常广泛，包括 Web 应用、SOA 及微服务等。在 Web 应用中，Spring Boot 封装了 Spring MVC 即可以提供 MVC 模式开发传统的 Web，又可以开发 REST API ，来开发 Web、APP、Open API 各种应用。在 SOA 及微服务中，用 Spring Boot 可以包装每个服务，本身可以提供轻量级 REST API 服务接口。也可以整合流行的 RPC 框架（Dubbo 等），提供 RPC 服务接口，只要简单地加入对应的 Starter 组件即可。在微服务实战中，推荐使用 Spring Cloud，是一套基于 Spring Boot 实现分布式系统的工具，适用于构建微服务。</p><p>上面从组件和特性两方面介绍了 Spring Boot 2.x，下面快速入门去了解 Spring Boot 2.x 的基本用法。</p><h2 id="1-2-快速入门工程"><a href="#1-2-快速入门工程" class="headerlink" title="1.2 快速入门工程"></a>1.2 快速入门工程</h2><p>在搭建一个 Spring Boot 工程应用前，需要配置好开发环境及安装好开发工具：</p><ul><li>JDK 1.8+<br>Spring Boot 2.x 要求 JDK 1.8 环境及以上版本。另外，Spring Boot 2.x 只兼容 Spring Framework 5.0 及以上版本。</li><li>Maven 3.2+<br>为 Spring Boot 2.x 提供了相关依赖构建工具是 Maven，版本需要 3.2 及以上版本。使用 Gradle 则需要 1.12 及以上版本。本书使用 Maven 对 Spring Boot 工程进行依赖和构建管理。</li><li>IntelliJ IDEA<br>IntelliJ IDEA （简称 IDEA）是常用的开发工具，也是本书推荐使用的。同样使用 Eclipse IDE，也能完成本书的实践案例。另外，本书的工程都会在 GitHub 上开源，如需要请自行安装 Git 环境。</li></ul><p>注意：<br>JDK 安装、Maven 安装、Git 安装和 IntelliJ IDEA 开发工具安装详解，见附录 A</p><p>安装环境虽然耗时，但磨刀不误砍柴工。下面开发 “Hello Spring Boot” 工程，大致分下面三个步骤：</p><ul><li>创建工程</li><li>开发工程</li><li>运行工程</li></ul><h3 id="1-2-1-创建工程-“Hello-Spring-Boot”"><a href="#1-2-1-创建工程-“Hello-Spring-Boot”" class="headerlink" title="1.2.1 创建工程 “Hello Spring Boot”"></a>1.2.1 创建工程 “Hello Spring Boot”</h3><p>在 IDEA 中，利用 Spring Initializr 插件进行创建名为 chapter-1-spring-boot-quickstart 工程。具体工程创建方式可见 1.3.1 章节。<br>第一步，打开 IDEA，选择新建工程按钮，然后选择左侧栏 Spring Initializr 选项。默认选择 JDK 版本和 Spring Initializr 的网站地址。如果是封闭式内网开发，也可以搭建一个 Spring Initializr 的内网服务。如图 1-2 所示。</p><p><img src="http://springforall.ufile.ucloud.com.cn/static/img/8aed5d34e29153fdf1c55df3f54efb181515130" alt="img"></p><p>图 1-2 创建工程之选择使用 Spring Initializr</p><p>第二步，点击下一步，输入 Maven 工程信息。这里对应的 Maven 信息为：</p><ul><li>groupId：demo.springboot</li><li>artifactId：chapter-1-spring-boot-quickstart</li><li>version：1.0</li></ul><p>这里还可以设置工程的名称和描述等，如图 1-3 所示。</p><p><img src="http://springforall.ufile.ucloud.com.cn/static/img/105dd78b2d94fd04ac25402f6e92fcf21515130" alt="img"></p><p>图 1-3 创建工程之新建工程信息</p><p>第三步，点击下一步，在依赖选择可视化操作中，下拉选择 Spring Boot 版本号和勾选工程需要的 Starter 组件和其他依赖。这里选择 Web 依赖，为了去实现一个简单的 REST API 服务，即访问 GET:/hello 会返回 “Hello，Spring Boot！” 的字符串。如图 1-4 所示。</p><p><img src="http://springforall.ufile.ucloud.com.cn/static/img/c2e7a5fed358647677234733b2b345e21515130" alt="img"></p><p>图 1-4 创建工程之选择 Web 依赖</p><p>这样就创建好名为 chapter-1-spring-boot-quickstart 工程，使用 IDEA 提示打开工程即可。</p><h3 id="1-2-2-开发工程之-Pom-依赖"><a href="#1-2-2-开发工程之-Pom-依赖" class="headerlink" title="1.2.2 开发工程之 Pom 依赖"></a>1.2.2 开发工程之 Pom 依赖</h3><p>在 pom.xml 配置文件中，<code>parent</code> 节点配置是 Spring Boot 的 Parent 依赖，代码如下：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-parent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>2.0.0.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>relativePath</span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>spring-boot-starter-parent</code> 依赖，是 Spring Boot 提供的一个特殊的 Starter 组件，本身没有任何依赖。</p><p><code>spring-boot-starter-parent</code> 职责，一方面是用于提供 Maven 配置的默认值，即在 Spring Boot 2.x 中设置 JDK 1.8 为默认编译级别、设置 <code>UTF-8</code> 编码等。另一方面，其父依赖 <code>spring-boot-dependencies</code> 中的 <code>dependency-management</code> 节点提供了所有 Starter 组件依赖配置的缺省版本值，但不提供依赖本身的继承。这样的作用是使用各个组件依赖拿来即用，不需要指定 version 。</p><p>因为创建工程时，勾选 Web 依赖，Spring Initializr 会自动添加 Web 依赖，代码如下：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- Web 依赖 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正如上面所说，这里只需要加入 groupId 和 artifactId 即可，不需要配置 version。</p><h3 id="1-2-3-开发工程之应用启动类"><a href="#1-2-3-开发工程之应用启动类" class="headerlink" title="1.2.3 开发工程之应用启动类"></a>1.2.3 开发工程之应用启动类</h3><p>在工程 src 目录中，已经自动创建了包目录 <code>demo.springboot</code> ，其包下自动创建了 Spring Boot 应用启动类，代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">QuickStartApplication</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">QuickStartApplication</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Spring Boot 应用启动类，是可以用来启动 Spring Boot 应用。其包含了 <code>@SpringBootApplication </code>注解和 <code>SpringApplication</code> 类，并调用 <code>SpringApplication</code> 类的 <code>run()</code> 方法，就可以启动该应用。</p><h4 id="SpringBootApplication-注解"><a href="#SpringBootApplication-注解" class="headerlink" title="@SpringBootApplication 注解"></a>@SpringBootApplication 注解</h4><p><code>@SpringBootApplication</code> 注解用标注启动类，被标注的类为一个配置类，并会触发自动配置和 Starter 组件扫描。根据源码可得，该注解配置了 <code>@SpringBootConfiguration</code>、 <code>@EnableAutoConfiguration</code> 和 <code>@ComponentScan</code> 三个注解， <code>@SpringBootConfiguration</code> 注解又配置了 <code>@EnableAutoConfiguration</code> 。所以该注解的职责相当于结合了 <code>@Configuration</code>, <code>@EnableAutoConfiguration</code> 和 <code>@ComponentScan</code> 三个注解功能。</p><p><code>@SpringBootApplication</code> 注解的职责如下：</p><ul><li>在被该注解修饰的类中，可以用 <code>@Bean</code> 注解来配置多个 Bean 。应用启动时，Spring 容器会加载 Bean 并注入到 Spring 容器。</li><li>启动 Spring 上下文的自动配置。基于依赖和定义的 Bean 会自动配置需要的 Bean 和类。</li><li>扫描被 <code>@Configuration</code> 修饰的配置类。也会扫描 Starter 组件的配置类，并启动加载其默认配置</li></ul><h4 id="SpringApplication-类"><a href="#SpringApplication-类" class="headerlink" title="SpringApplication 类"></a>SpringApplication 类</h4><p>大多数情况下，在 <code>main</code> 方法中调用 <code>SpringApplication</code> 类的静态方法 <code>run(Class, String[])</code> ，用来引导启动 Spring 应用程序。默认情况下，该类的职责会执行如下步骤：</p><ul><li>创建应用上下文 <code>ApplicationContext</code> 实例</li><li>注册 <code>CommandLinePropertySource</code>，将命令行参数赋值到 Spring 属性</li><li>刷新应用上下文，加载所有单例</li><li>触发所有 <code>CommandLineRunner</code> Bean</li></ul><p>在实际开发中如果需要自定义创建高级的配置，可以通过 <code>run(Class, String[])</code> 方法的第二个参数，并以 String 数组的形式传入。这是 <code>run</code> 几个重载方法的 API 文档：</p><h5 id="API-org-springframework-boot-SpringApplication"><a href="#API-org-springframework-boot-SpringApplication" class="headerlink" title="API org.springframework.boot.SpringApplication"></a>API org.springframework.boot.SpringApplication</h5><ul><li><p>static run(Class&lt;?&gt;[] primarySources, String[] args)<br>返回正在运行的应用上下文 <code>ApplicationContext</code></p><p>参数：<br>primarySources 应用指定的主要类源，数组形式<br>args 应用参数</p></li><li><p>static run(Class&lt;?&gt; primarySource, String… args)<br>返回正在运行的应用上下文 <code>ApplicationContext</code></p><p>参数：<br>primarySource 应用指定的主要类源<br>args 应用参数</p></li><li><p>run(String… args)<br>返回正在运行的应用上下文 <code>ApplicationContext</code></p><p>参数：<br>args 应用参数</p></li></ul><h3 id="1-2-4-开发工程之-Hello-控制层类"><a href="#1-2-4-开发工程之-Hello-控制层类" class="headerlink" title="1.2.4 开发工程之 Hello 控制层类"></a>1.2.4 开发工程之 Hello 控制层类</h3><p>在工程中新建包目录 <code>demo.springboot.web</code> ，并在目录中创建名为 <code>HelloController</code> 的控制层类，代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span></span><span class="token class-name">Controller</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">RequestMapping</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">RequestMethod</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">ResponseBody</span></span><span class="token punctuation">;</span><span class="token annotation punctuation">@Controller</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/hello"</span><span class="token punctuation">,</span>method <span class="token operator">=</span> <span class="token class-name">RequestMethod</span><span class="token punctuation">.</span>GET<span class="token punctuation">)</span>    <span class="token annotation punctuation">@ResponseBody</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Hello，Spring Boot！"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面定义了简单的 REST API 服务，即 <code>GET:/hello</code>。表示该 Hello 控制层 <code>sayHello()</code> 方法会提供请求路径为 <code>/hello</code> 和请求方法为 GET 的 HTTP 服务接口。Spring 4.0 的注解 <code>@RestController</code> 支持实现 REST API 控制层。本质上，该注解结合了 <code>@Controller</code> 和 <code>@ResponseBody</code> 的功能。所以将上面 <code>HelloController </code>可以改造升级成 <code>HelloBookController</code>，代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">RequestMapping</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">RequestMethod</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">RestController</span></span><span class="token punctuation">;</span><span class="token annotation punctuation">@RestController</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloBookController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/book/hello"</span><span class="token punctuation">,</span>method <span class="token operator">=</span> <span class="token class-name">RequestMethod</span><span class="token punctuation">.</span>GET<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Hello，《Spring Boot 2.x 核心技术实战 - 上 基础篇》！"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上核心注解是 Spring MVC 框架的知识点：</p><ul><li>@Controller 注解<br><code>@Controller</code> 对控制层类进行标注，职责是使控制层可以处理 HTTP 请求，简单可以理解为，使控制层能接受请求，处理请求并响应。</li><li>@RequestMapping 注解<br><code>@RequestMapping</code> 对控制层类的方法进行标注，职责是标明方法对应的 HTTP 请求路由的关系映射。参数 value 主要请求映射地址，可接受多个地址。参数 method 标注 HTTP 方法，常用如： GET，POST，HEAD，OPTIONS，PUT，PATCH，DELETE，TRACE。默认是 GET HTTP 方法，在 GET 请求的情况下，可以缩写成 <code>@RequestMapping(value = "/book/hello")</code> 。Spring 4 支持直接使用 <code>XXXMapping</code> 形式的注解，比如上面代码可以写成 <code>@GetMapping("/book/hello")</code>。</li><li>@ResponseBody 注解<br><code>@ResponseBody</code> 对控制层类的方法进行标注，职责是指定响应体为方法的返回值。上面代码中，案例是以字符串的形式返回，自然可以使用其他复杂对象作为返回体。</li></ul><h3 id="1-2-5-运行工程"><a href="#1-2-5-运行工程" class="headerlink" title="1.2.5 运行工程"></a>1.2.5 运行工程</h3><p>一个简单的 Spring Boot 工程就开发完毕了，下面运行工程验证下。</p><h4 id="Maven-编译工程"><a href="#Maven-编译工程" class="headerlink" title="Maven 编译工程"></a>Maven 编译工程</h4><p>使用 IDEA 右侧工具栏，点击 Maven Project Tab ，点击使用下 Maven 插件的 <code>install</code> 命令。如图 1-5 所示：</p><p><img src="http://springforall.ufile.ucloud.com.cn/static/img/a16baca6300217d7a817774d55e35e411515130" alt="img"></p><p>图 1-5 IDEA Maven 工具栏</p><p>或者使用命令行的形式，在工程根目录下，执行 Maven 清理和安装工程的指令：</p><pre class="line-numbers language-none"><code class="language-none">cd chapter-1-spring-boot-quickstartmvn clean install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在 target 目录中看到 chapter-1-spring-boot-quickstart-1.0.jar 文件生成，或者在编译的控制台中看到成功的输出：</p><pre class="line-numbers language-none"><code class="language-none">... 省略[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 01:30 min[INFO] Finished at: 2017-10-15T10:00:54+08:00[INFO] Final Memory: 31M/174M[INFO] ------------------------------------------------------------------------<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面两种方式都可以成功编译工程。</p><h4 id="运行工程"><a href="#运行工程" class="headerlink" title="运行工程"></a>运行工程</h4><p>在 IDEA 中执行 <code>QuickStartApplication</code> 类启动，任意正常模式或者 Debug 模式。可以在控制台看到成功运行的输出：</p><pre class="line-numbers language-none"><code class="language-none">... 省略2017-10-15 10:05:19.994  INFO 17963 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http)2017-10-15 10:05:20.000  INFO 17963 --- [           main] demo.springboot.QuickStartApplication    : Started QuickStartApplication in 5.544 seconds (JVM running for 6.802)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>打开浏览器，访问 /hello 地址，会看到如图 1-6 所示的返回结果：</p><p><img src="http://springforall.ufile.ucloud.com.cn/static/img/be2a886052d74cc282ab26f0b2ed55911515130" alt="img"></p><p>图 1-6 Hello 页面</p><p>再访问 /book/hello 地址，会看到如图 1-7 所示的返回结果：</p><p><img src="http://springforall.ufile.ucloud.com.cn/static/img/61beed27cbe175b04be3e82ec6455ce01515130" alt="img"></p><p>图 1-7 Hello Book 页面</p><p>本章工程名为 chapter-1-spring-boot-quickstart，具体代码见本书对应的 GitHub。</p><h2 id="1-3-Spring-Boot-工程构建"><a href="#1-3-Spring-Boot-工程构建" class="headerlink" title="1.3 Spring Boot 工程构建"></a>1.3 Spring Boot 工程构建</h2><p>快速入门中还没有详细介绍 Spring Boot 工程构建。工程构建包括创建工程、工程结构和运行工程等。</p><h3 id="1-3-1-工程创建方式"><a href="#1-3-1-工程创建方式" class="headerlink" title="1.3.1 工程创建方式"></a>1.3.1 工程创建方式</h3><p>Spring Boot Maven 工程，就是普通的 Maven 工程，加入了对应的 Spring Boot 依赖即可。Spring Initializr 则是像代码生成器一样，自动就给你出来了一个 Spring Boot Maven 工程。Spring Initializr 有两种方式可以得到 Spring Boot Maven 骨架工程：</p><h4 id="start-spring-io-在线生成"><a href="#start-spring-io-在线生成" class="headerlink" title="start.spring.io 在线生成"></a>start.spring.io 在线生成</h4><p>Spring 官方提供了名为 Spring Initializr 的网站，去引导你快速生成 Spring Boot 应用。网站地址为：<a href="https://start.spring.io,操作步骤如下/">https://start.spring.io，操作步骤如下</a>：</p><p>第一步，选择 Maven 或者 Gradle 构建工具，开发语言 Java 、Kotlin 或者 Groovy，最后确定 Spring Boot 版本号。这里默认选择 Maven 构建工具、Java 开发语言和 Spring Boot 2.0.0。</p><p>第二步，输入 Maven 工程信息，即项目组 <code>groupId</code> 和名字 <code>artifactId</code>。这里对应 Maven 信息为：</p><ul><li>groupId：demo.springboot</li><li>artifactId：chapter-1-spring-boot-quickstart<br>这里默认版本号 version 为 0.0.1-SNAPSHOT 。三个属性在 Maven 依赖仓库是唯一标识的。</li></ul><p>第三步，选择工程需要的 Starter 组件和其他依赖。最后点击生成按钮，即可获得骨架工程压缩包。如图 1-8 所示。</p><p><img src="http://springforall.ufile.ucloud.com.cn/static/img/34fd99a52baf123dbba1a6cda0d9ceb41515130" alt="img"></p><p>图 1-8 Spring Initializr 在线生成</p><h4 id="IDEA-支持-Spring-Initializr-生成"><a href="#IDEA-支持-Spring-Initializr-生成" class="headerlink" title="IDEA 支持 Spring Initializr 生成"></a>IDEA 支持 Spring Initializr 生成</h4><p>IDEA 支持 Spring Initializr 生成，这对于开发来说更进一步的省事，也是推荐的创建工程方式。</p><p>第一步，打开 IDEA，选择新建工程按钮，然后选择左侧栏 Spring Initializr 选项。默认选择 JDK 版本和 Spring Initializr 的网站地址。如果是封闭式内网开发，也可以搭建一个 Spring Initializr 的内网服务。</p><p>第二步，点击下一步，输入 Maven 工程信息。这里对应的 Maven 信息为：</p><ul><li>groupId：demo.springboot</li><li>artifactId：chapter-1-spring-boot-quickstart</li><li>version：1.0</li></ul><p>这里还可以设置工程的名称和描述等。</p><p>第三步，点击下一步，在可视化操作中，下拉选择 Spring Boot 版本号和勾选工程需要的 Starter 组件和其他依赖。如图 1-9 所示。</p><p><img src="http://springforall.ufile.ucloud.com.cn/static/img/efa06d0d39c29f556f251424b8fd9c3e1515130" alt="img"></p><p>图 1-9 IDEA 支持 Spring Initializr 生成</p><h3 id="1-3-2-工程结构"><a href="#1-3-2-工程结构" class="headerlink" title="1.3.2 工程结构"></a>1.3.2 工程结构</h3><p>通过工程创建，得到的工程有默认的结构，其目录结构如下：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">├── pom.xml└── src    ├── main    │   ├── java    │   │   └── demo    │   │       └── springboot    │   │           └── QuickstartApplication.java    │   └── resources    │       ├── application.properties    │       ├── static    │       └── templates    └── test        └── java            └── demo                └── springboot                    └── QuickstartApplicationTests.java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是默认的工程结构，java 目录中是编写代码的源目录，比如三层模型大致会新建三个包目录，web 包负责 web 服务，service 包负责业务逻辑，domain 包数据源服务。对应 java 目录的是 test 目录，编写单元测试的目录。</p><p>resources 目录会有 application.properties 应用配置文件，还有默认生成的 static 和 templates 目录，static 用于存放静态资源文件，templates 用于存放模板文件。可以在 application.properties 中自定义配置资源和模板目录。</p><h3 id="1-3-3-工程运行方式"><a href="#1-3-3-工程运行方式" class="headerlink" title="1.3.3 工程运行方式"></a>1.3.3 工程运行方式</h3><p>上面使用应用启动类运行工程 “Hello Spring Boot”，这是其中一种工程运行方式。 Spring Boot 应用的运行方式很简单，下面介绍下这三种运行方式：</p><h4 id="1-使用应用启动类"><a href="#1-使用应用启动类" class="headerlink" title="1. 使用应用启动类"></a>1. 使用应用启动类</h4><p>在 IDEA 中直接执行应用启动类，来运行 Spring Boot 应用。日常开发中，会经常使用这种方式启动应用。常用的会有 Debug 启动模式，方便在开发中进行代码调试和 bug 处理。自然，Debug 启动模式会比正常模式稍微慢一些。</p><h4 id="2-使用-Maven-运行"><a href="#2-使用-Maven-运行" class="headerlink" title="2. 使用 Maven 运行"></a>2. 使用 Maven 运行</h4><p>通过 Maven 运行，需要配置 Spring Boot Maven 插件，在 pom.xml 配置文件中，新增 <code>build</code> 节点并配置插件 spring-boot-maven-plugin，代码如下：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!-- Spring Boot Maven 插件 --&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在工程根目录中，运行如下 Maven 命令来运行 Spring Boot 应用：</p><pre class="line-numbers language-none"><code class="language-none">mvn spring-boot:run<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>实际调用的是 pom.xml 配置的 Spring Boot Maven 插件 spring-boot-maven-plugin ，上面执行了插件提供的 run 指令。也可以在 IDEA 右侧工具栏的 Maven Project Tab 中，找到 Maven 插件的 spring-boot-maven-plugin，执行相应的指令。所有指令如下：</p><pre class="line-numbers language-none"><code class="language-none"># 生成构建信息文件spring-boot:build-info# 帮助信息spring-boot:help# 重新打包spring-boot:repackage# 运行工程spring-boot:run# 将工程集成到集成测试阶段，进行工程的声明周期管理spring-boot:startspring-boot:stop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-使用-Java-命令运行"><a href="#3-使用-Java-命令运行" class="headerlink" title="3. 使用 Java 命令运行"></a>3. 使用 Java 命令运行</h4><p>使用 Maven 或者 Gradle 安装工程，生成可执行的工程 jar 后，运行如下 Java 命令来运行 Spring Boot 应用：</p><pre class="line-numbers language-none"><code class="language-none">java -jar target/chapter-1-spring-boot-quickstart-1.0.jar <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里运行了 spring-boot-maven-plugin 插件编译出来的可执行 jar 文件。通过上述三种方式都可以成功运行 Spring Boot 工程，成功运行输出的控制台信息如图 1-10 所示。</p><p><img src="http://springforall.ufile.ucloud.com.cn/static/img/0f234db300ec389786b1a7e55b7bb5ec1515130" alt="img"></p><p>图 1-10 控制台成功信息</p><h2 id="1-4-安装使用-Spring-Boot"><a href="#1-4-安装使用-Spring-Boot" class="headerlink" title="1.4 安装使用 Spring Boot"></a>1.4 安装使用 Spring Boot</h2><p>在上面工程 “Hello Spring Boot” 中，使用了 Maven 方式去安装使用了 Spring Boot 。使用 Maven 或 Gradle 安装是推荐的方式。新的 Java 程序员或从未有过经验开发 Spring Boot 的开发者，推荐使用 Spring Boot CLI 安装学习更好。下面简单介绍下三种方式。</p><h3 id="1-4-1-Maven-方式"><a href="#1-4-1-Maven-方式" class="headerlink" title="1.4.1 Maven 方式"></a>1.4.1 Maven 方式</h3><p>Maven 是依赖管理的构建工具。类似其他依赖库使用一样，在 Maven 配置中加入 Spring Boot 相关依赖配置即可安装使用 Spring Boot 。Spring Boot 需要 Maven 3.2 及以上版本的支持。具体 Maven 安装介绍，详见官网 maven.apache.org。</p><p>Spring Boot 依赖使用 org.springframework.boot 作为其项目组 groupId 名称，Starter 组件的名字 artifactId 以 spring-boot-starter-xxx 形式命名。</p><p>注意，如果不想使用 spring-boot-starter-parent 父 Starter 组件，可以将 spring-boot-dependencies 作为工程依赖管理库，并指定 scope 为 import。代码如下：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencyManagement</span><span class="token punctuation">&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>2.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>type</span><span class="token punctuation">&gt;</span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>type</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">&gt;</span></span>import<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencyManagement</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-4-2-Gradle-方式"><a href="#1-4-2-Gradle-方式" class="headerlink" title="1.4.2 Gradle 方式"></a>1.4.2 Gradle 方式</h3><p>Gradle 是依赖管理的构建工具。类似 Maven 方式一样，Spring Boot 需要 Gradle 4 的支持。具体 Gradle 安装介绍，详见官网 <a href="http://www.gradle.org./">www.gradle.org。</a></p><h3 id="1-4-3-Spring-Boot-CLI"><a href="#1-4-3-Spring-Boot-CLI" class="headerlink" title="1.4.3 Spring Boot CLI"></a>1.4.3 Spring Boot CLI</h3><p>Spring Boot CLI 是 Spring Boot Commad Line 的缩写，是 Spring Boot 命令行工具。在 Spring Boot CLI 可以跑 Groovy 脚本，通过简单的 Java 语法就可以快速而又简单的学习 Spring Boot 原型。</p><h4 id="Spring-Boot-CLI-安装"><a href="#Spring-Boot-CLI-安装" class="headerlink" title="Spring Boot CLI 安装"></a>Spring Boot CLI 安装</h4><p>打开 Spring Boot CLI 下载页面，地址：<a href="https://repo.spring.io/milestone/org/springframework/boot/spring-boot-cli%E3%80%82%E4%B8%8B%E8%BD%BD%E9%9C%80%E8%A6%81%E7%9A%84">https://repo.spring.io/milestone/org/springframework/boot/spring-boot-cli。下载需要的</a> spring-boot-cli-2.0.0-bin.zip 或者 spring-boot-cli-2.0.0-bin.tar.gz 依赖，并解压到安装目录，并指定其 bin 目录添加环境变量。<br>比如 Mac 环境下，代码如下：</p><pre class="line-numbers language-none"><code class="language-none">export PATH=${PATH}:/spring-boot-cli-2.0.0.RELEASE/bin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>比如 Windows 环境下，代码如下：</p><pre class="line-numbers language-none"><code class="language-none">set PATH=D:\spring-boot-cli-2.0.0.RELEASE\bin;%PATH%<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行下面指令能输出对应的版本，用来验证是否安装成功，代码如下：</p><pre class="line-numbers language-none"><code class="language-none">spring --version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在控制台中会出现成功的输出：</p><pre class="line-numbers language-none"><code class="language-none">Spring CLI v2.0.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>另外，也支持 Homebrew、MacPorts 进行安装。</p><h4 id="使用-Spring-Boot-CLI"><a href="#使用-Spring-Boot-CLI" class="headerlink" title="使用 Spring Boot CLI"></a>使用 Spring Boot CLI</h4><p>安装好 Spring Boot CLI 基础环境后，运行 “Hello Spring Boot” 就更加简单了，新建 hello.groovy 文件，代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/hello"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Hello，Spring Boot！"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后执行下面指令，进行编译运行应用：</p><pre class="line-numbers language-none"><code class="language-none">spring run hello.groovy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可以，通过 <code>-- </code>去外化配置属性值。比如配置端口号为 8081：<code>spring run hello.groovy -- --server.port=9000</code>。等控制台成功输出，打开浏览器，访问 /hello 地址，可以得到 “Hello，Spring Boot！” 的结果。</p><p>注意：<br>具体如何使用 Spring CLI，详见官方使用文档：docs.spring.io/spring-boot/docs/current/reference/html/cli-using-the-cli.html</p><h2 id="1-5-服务器部署方式"><a href="#1-5-服务器部署方式" class="headerlink" title="1.5 服务器部署方式"></a>1.5 服务器部署方式</h2><p>基础环境安装如上面说的，需要 JDK 环境、Maven 环境等</p><h3 id="1-5-1-Win-服务器"><a href="#1-5-1-Win-服务器" class="headerlink" title="1.5.1 Win 服务器"></a>1.5.1 Win 服务器</h3><p>推荐使用 AlwaysUp：</p><p><img src="http://springforall.ufile.ucloud.com.cn/static/img/91b7d3d4b629f5b7475b7b0d92f3db491516073" alt="img"></p><p>使用方式也很简单：</p><p><img src="http://springforall.ufile.ucloud.com.cn/static/img/24b98badfdad8d24bd5a1c46c3e012fd1516073" alt="img"></p><h3 id="1-5-2-Linux-服务器"><a href="#1-5-2-Linux-服务器" class="headerlink" title="1.5.2 Linux 服务器"></a>1.5.2 Linux 服务器</h3><p>推荐 yum 安装基础环境，比如安装 JDK：</p><pre class="line-numbers language-none"><code class="language-none">yum -y list java*yum -y install java-1.8.0-openjdk*java -version <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>安装 Maven：</p><pre class="line-numbers language-none"><code class="language-none">yum -y list apache-mavensudo wget http://repos.fedorapeople.org/repos/dchen/apache-maven/epel-apache-maven.repo -O /etc/yum.repos.d/epel-apache-maven.reposudo yum install -y apache-mavenmvn --v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Linux 使用 nohup 命令进行对后台程序的启动关闭。</p><p>关闭应用的脚本：stop.sh</p><p><img src="http://springforall.ufile.ucloud.com.cn/static/img/87aed0bf416fc6ed134bf324f744558b1516073" alt="img"></p><p>启动应用的脚本：start.sh</p><p><img src="http://springforall.ufile.ucloud.com.cn/static/img/c1b800203d816380d24b03c9b4f72a311516073" alt="img"></p><p>重启应用的脚本：stop.sh</p><p><img src="http://springforall.ufile.ucloud.com.cn/static/img/712242d8401da8fa9b9842628890ed2a1516073" alt="img"></p><h2 id="1-6-小结"><a href="#1-6-小结" class="headerlink" title="1.6 小结"></a>1.6 小结</h2><p>从 Spring Boot 介绍开始，包括特性、Starter 组件以及应用场景，又通过快速入门工程出发，讲解了开发 Spring Boot 应用涉及到的 Pom 依赖、应用启动类以及控制层，然后讲解了工程构建周期的创建、结构及运行方式，此外还总结了安装使用 Spring Boot 的三种方式。</p><p>示例代码地址：<a href="https://github.com/JeffLi1993/springboot-core-action-book-demo/tree/master/chapter-1-spring-boot-quickstart">https://github.com/JeffLi1993/springboot-core-action-book-demo/tree/master/chapter-1-spring-boot-quickstart</a></p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>本文示例读者可以通过查看下面仓库的中代码 ：</p><ul><li><a href="https://github.com/JeffLi1993/springboot-learning-example">GitHub（springboot-learning-example）</a></li><li><a href="https://gitee.com/jeff1993/springboot-learning-example">Gitee（springboot-learning-example）</a></li></ul><p>原文链接：<a href="https://www.bysocket.com/2019-03-02/spring-boot.html">Spring Boot 2.0 的快速入门（图文教程） - 程序员泥瓦匠 (bysocket.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>暑假尾声感想</title>
      <link href="/archives/b2baf42f.html"/>
      <url>/archives/b2baf42f.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/C:/Users\86185\AppData\Roaming\Typora\typora-user-images\image-20220819020015738.png" alt="image-20220819020015738"></p><p>夏蝉之鸣此起彼伏，炎炎夏日，烈日打开，在家空调吊着确实惬意，但今年这个暑假对我而言却非同一般，因为它是我最后一个学生时代的暑假了，我也在假期之初切身经历了身边的悲欢离合生离死别。因为变故，令我更懂亲友之情，也有这个阶段因为菜导致的迷茫，人生下一步的计划处于混沌状态，自己也无所事事不知所措，也因为此为大学最后一个暑假，即将步入大四，临门一脚便是社会大学，我没有了以前逍遥放纵的资本，只能全身心地投入到求职就业当中，要不然怕明年的我可能会沦落到某个偏僻的穷乡僻壤，干着让自己没有激情的活儿……</p><span id="more"></span><p>在上次经历一场惨烈尴尬的校园面试之后，我就意识到补充基础知识是多么的重要。以前瞎摸爬滚打，总是学到了哪里，想不明白时就谷歌一下，看看大神们的解释。当时理解归理解，但是没有系统的整理和进一步的消化吸收，所以不能说自己真的懂了。</p><p>以前只要没出什么大问题，我就不管了，我的要求只有一点，符合我的审美，能考虑到用户的各种细节。毕竟也是个人学习兴趣项目，一切率性而为……</p><p>现如今得考虑行业的形势和出路，经济也因疫情不景气，大厂裁员之闻不断，内卷之势倒逼我等必须严格要求自己。时势造英雄，没有这样的大气候与大环境，怎能出得了人才呢？人总要逼着自己才能进步，才能拥有向上奋发的激情和动力。</p><p>秋招近了，校招开始了，校招快要结束了。</p><p>在这个暑假的前奏，我没有再投多少简历乱面试，我怕再次遭遇上次滑铁卢般的尴尬，因此每走一步都小心翼翼。可能是害怕遭遇拒绝和经验不足对独立的惶恐，所以才想着慢慢来，但殊不知舒适圈常有，而勇敢踏出更为重要。</p><p>时代变了，你想着苟着学习后手精准投递，但是你投递的对象未必看得上你。你想着一直忍着憋着，总能遇到能够发掘自己的伯乐。但是古人也说了：“千里马常有，而伯乐不常有。”</p><p>你越不去展现自己，就越不受待见。</p><p>但也不能没有资本没有实力便妄自天马行空的认为天生我材必有用，一切都是基于自己有本事有实力的基础上才能够顺风顺水，</p><p>喜欢看历史、地理和书籍好玩的我，又何尝不知道这个道理呢？</p><p>人的这一生在茫茫宇宙的历史当中，只算毫厘，在如此这般“转瞬即逝”的时间里，不能尽自己所能，不能活得开心自在，不能引领潮流，那又有什么意义呢？淹没在人潮里的那一张张愁闷又抑郁的脸庞，其实随处可见，我的内心对此充满着排斥，但是却又担心起自己即将成为他们当中的一员。</p><p>自己也总是惫懒，不够自律，再加放假总更度假似的，三天打鱼五天晒网的学习进程，以前的假期总是许多计划胎死腹中，所以啊，有计划就要去实行，有梦想就要马上行动！</p><p>也许，这个暑假尾声可以多做出点转变，勿把问题与想法留待明天，马上落实想法，离梦想更近一点，总比原地踏步来得好吧？</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker基础</title>
      <link href="/archives/1d9fbb6a.html"/>
      <url>/archives/1d9fbb6a.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="什么是-Docker？"><a href="#什么是-Docker？" class="headerlink" title="什么是 Docker？"></a>什么是 Docker？</h2><p><code>Docker</code>的英文翻译是“搬运工”的意思，他搬运的东西就是我们常说的集装箱<code>Container</code>，Container 里面装的是任意类型的 App，我们的开发人员可以通过 Docker 将App 变成一种标准化的、可移植的、自管理的组件，我们可以在任何主流的操作系统中开发、调试和运行。</p><span id="more"></span><p>从概念上来看 Docker 和我们传统的虚拟机比较类似，只是更加轻量级，更加方便使，Docker 和虚拟机最主要的区别有以下几点：</p><ul><li><p>虚拟化技术依赖的是物理CPU和内存，是硬件级别的；而我们的 Docker 是构建在操作系统层面的，利用操作系统的容器化技术，所以 Docker 同样的可以运行在虚拟机上面。</p></li><li><p>我们知道虚拟机中的系统就是我们常说的操作系统镜像，比较复杂；而 Docker 比较轻量级，我们可以用 Docker 部署一个独立的 Redis，就类似于在虚拟机当中安装一个 Redis 应用，但是我们用 Docker 部署的应用是完全隔离的。</p></li><li><p>我们都知道传统的虚拟化技术是通过快照来保存状态的；而 Docker 引入了类似于源码管理的机制，将容器的快照历史版本一一记录下来，切换成本非常之低。</p></li><li><p>传统虚拟化技术在构建系统的时候非常复杂；而 Docker 可以通过一个简单的 Dockerfile 文件来构建整个容器，更重要的是 Dockerfile 可以手动编写，这样应用程序开发人员可以通过发布 Dockerfile 来定义应用的环境和依赖，这样对于持续交付非常有利。</p><p> <img src="https://www.qikqiak.com/k8s-book/docs/images/docker-what.png" alt="what-is-docker"></p></li></ul><h2 id="为啥要用容器"><a href="#为啥要用容器" class="headerlink" title="为啥要用容器?"></a>为啥要用容器?</h2><p>应用容器是个啥样子呢，一个做好的应用容器长得就像一个装好了一组特定应用的虚拟机一样，比如我现在想用 Redis，那我就找个装好了 Redis 的容器就可以了，然后运行起来，我就能直接使用了。</p><p>那为什么不能直接安装一个 Redis 呢？肯定是可行的，但是有的时候根据每个人电脑的不同，在安装的时候可能会报出各种各样的错误，万一你的机器中毒了，你的电脑挂了，你所有的服务都需要重新安装。但是有了 Docker 或者说有了容器就不一样了，你就相当于有了一个可以运行起来的虚拟机，只要你能运行容器，Redis 的配置就省了。而且如果你想换个电脑，没问题，很简单，直接把容器”端过来”就可以使用容器里面的服务了。</p><h2 id="Docker-Engine"><a href="#Docker-Engine" class="headerlink" title="Docker Engine"></a>Docker Engine</h2><p><code>Docker Engine</code>是一个<strong>C/S</strong>架构的应用程序，主要包含下面几个组件：</p><ul><li>常驻后台进程<code>Dockerd</code></li><li>一个用来和 Dockerd 交互的 REST API Server</li><li>命令行<code>CLI</code>接口，通过和 REST API 进行交互（我们经常使用的 docker 命令）</li></ul><p><img src="https://www.qikqiak.com/k8s-book/docs/images/docker-engine.png" alt="docker engine"></p><h2 id="Docker-架构"><a href="#Docker-架构" class="headerlink" title="Docker 架构"></a>Docker 架构</h2><p>Docker 使用 C/S （客户端/服务器）体系的架构，Docker 客户端与 Docker 守护进程通信，Docker 守护进程负责构建，运行和分发 Docker 容器。Docker 客户端和守护进程可以在同一个系统上运行，也可以将 Docker 客户端连接到远程 Docker 守护进程。Docker 客户端和守护进程使用 REST API 通过<code>UNIX</code>套接字或网络接口进行通信。 <img src="https://www.qikqiak.com/k8s-book/docs/images/docker-structrue.png" alt="docker structrue"></p><ul><li>Docker Damon：dockerd，用来监听 Docker API 的请求和管理 Docker 对象，比如镜像、容器、网络和 Volume。</li><li>Docker Client：docker，docker client 是我们和 Docker 进行交互的最主要的方式方法，比如我们可以通过 docker run 命令来运行一个容器，然后我们的这个 client 会把命令发送给上面的 Dockerd，让他来做真正事情。</li><li>Docker Registry：用来存储 Docker 镜像的仓库，Docker Hub 是 Docker 官方提供的一个公共仓库，而且 Docker 默认也是从 Docker Hub 上查找镜像的，当然你也可以很方便的运行一个私有仓库，当我们使用 docker pull 或者 docker run 命令时，就会从我们配置的 Docker 镜像仓库中去拉取镜像，使用 docker push 命令时，会将我们构建的镜像推送到对应的镜像仓库中。</li><li>Images：镜像，镜像是一个只读模板，带有创建 Docker 容器的说明，一般来说的，镜像会基于另外的一些基础镜像并加上一些额外的自定义功能。比如，你可以构建一个基于 Centos 的镜像，然后在这个基础镜像上面安装一个 Nginx 服务器，这样就可以构成一个属于我们自己的镜像了。</li><li>Containers：容器，容器是一个镜像的可运行的实例，可以使用 Docker REST API 或者 CLI 来操作容器，容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的<a href="https://en.wikipedia.org/wiki/Linux_namespaces">命名空间</a>。因此容器可以拥有自己的 <strong>root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间</strong>。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。</li><li>底层技术支持：Namespaces（做隔离）、CGroups（做资源限制）、UnionFS（镜像和容器的分层） the-underlying-technology Docker 底层架构分析</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>直接前往<a href="https://docs.docker.com/install/">官方文档</a>选择合适的平台安装即可，比如我们这里想要在<code>centos</code>系统上安装 Docker，这前往地址<a href="https://docs.docker.com/install/linux/docker-ce/centos/%E6%A0%B9%E6%8D%AE%E6%8F%90%E7%A4%BA%E5%AE%89%E8%A3%85%E5%8D%B3%E5%8F%AF%E3%80%82">https://docs.docker.com/install/linux/docker-ce/centos/根据提示安装即可。</a></p><p>安装依赖软件包：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> yum <span class="token function">install</span> -y yum-utils device-mapper-persistent-data lvm2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>添加软件仓库，我们这里使用稳定版 Docker，执行下面命令添加 yum 仓库地址：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> yum-config-manager <span class="token punctuation">\</span>    --add-repo <span class="token punctuation">\</span>    https://download.docker.com/linux/centos/docker-ce.repo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后直接安装即可：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> yum <span class="token function">install</span> docker-ce<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果要安装指定的版本，可以使用 yum list 列出可用的版本：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ yum list docker-ce --showduplicates <span class="token operator">|</span> <span class="token function">sort</span> -rdocker-ce.x86_64            <span class="token number">18.03</span>.0.ce-1.el7.centos             docker-ce-stable<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>比如这里可以安装<strong>18.03.0.ce</strong>版本：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> yum <span class="token function">install</span> docker-ce-18.03.0.ce<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>要启动 Docker 也非常简单：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> systemctl <span class="token builtin class-name">enable</span> <span class="token function">docker</span>$ <span class="token function">sudo</span> systemctl start <span class="token function">docker</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>另外一种安装方式是可以直接下载指定的软件包直接安装即可，前往地址：<a href="https://download.docker.com/linux/centos/7/x86_64/stable/Packages/">https://download.docker.com/linux/centos/7/x86_64/stable/Packages/</a> 找到合适的<code>.rpm</code>包下载，然后安装即可：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> yum <span class="token function">install</span> /path/to/package.rpm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><p>之前我们提到过 Docker 官方提供了一个公共的镜像仓库：<a href="https://hub.docker.com/explore/">Docker Hub</a>，我们就可以从这上面获取镜像，获取镜像的命令：docker pull，格式为：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> pull <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> <span class="token punctuation">[</span>Docker Registry 地址<span class="token punctuation">[</span>:端口<span class="token punctuation">]</span>/<span class="token punctuation">]</span>仓库名<span class="token punctuation">[</span>:标签<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>Docker 镜像仓库地址：地址的格式一般是 &lt;域名/IP&gt;[:端口号]，默认地址是 Docker Hub。</p></li><li><p>仓库名：这里的仓库名是两段式名称，即 &lt;用户名&gt;/&lt;软件名&gt;。对于 Docker Hub，如果不给出用户名，则默认为 library，也就是官方镜像。比如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> pull ubuntu:16.04<span class="token number">16.04</span>: Pulling from library/ubuntubf5d46315322: Pull complete9f13e0ac480c: Pull completee8988b5b3097: Pull complete40af181810e7: Pull completee6f7c7e5c03e: Pull completeDigest: sha256:147913621d9cdea08853f6ba9116c2e27a3ceffecf3b492983ae97c3d643fbbeStatus: Downloaded newer image <span class="token keyword">for</span> ubuntu:16.04<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub 获取镜像。而镜像名称是 ubuntu:16.04，因此将会获取官方镜像 library/ubuntu 仓库中标签为 16.04 的镜像。 从下载过程中可以看到我们之前提及的分层存储的概念，镜像是由多层存储所构成。下载也是一层层的去下载，并非单一文件。下载过程中给出了每一层的 ID 的前 12 位。并且下载结束后，给出该镜像完整的</p><pre class="line-numbers language-none"><code class="language-none">sha256<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>的摘要，以确保下载一致性。</p></li></ul><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>有了镜像后，我们就能够以这个镜像为基础启动并运行一个容器。以上面的 ubuntu:16.04 为例，如果我们打算启动里面的 bash 并且进行交互式操作的话，可以执行下面的命令。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> run -it --rm <span class="token punctuation">\</span>    ubuntu:16.04 <span class="token punctuation">\</span>    /bin/bashroot@e7009c6ce357:/<span class="token comment"># cat /etc/os-release</span><span class="token assign-left variable">NAME</span><span class="token operator">=</span><span class="token string">"Ubuntu"</span><span class="token assign-left variable">VERSION</span><span class="token operator">=</span><span class="token string">"16.04.4 LTS, Trusty Tahr"</span><span class="token assign-left variable">ID</span><span class="token operator">=</span>ubuntu<span class="token assign-left variable">ID_LIKE</span><span class="token operator">=</span>debian<span class="token assign-left variable">PRETTY_NAME</span><span class="token operator">=</span><span class="token string">"Ubuntu 16.04.4 LTS"</span><span class="token assign-left variable">VERSION_ID</span><span class="token operator">=</span><span class="token string">"16.04"</span><span class="token assign-left variable">HOME_URL</span><span class="token operator">=</span><span class="token string">"http://www.ubuntu.com/"</span><span class="token assign-left variable">SUPPORT_URL</span><span class="token operator">=</span><span class="token string">"http://help.ubuntu.com/"</span><span class="token assign-left variable">BUG_REPORT_URL</span><span class="token operator">=</span><span class="token string">"http://bugs.launchpad.net/ubuntu/"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>docker run</code>就是运行容器的命令，具体格式我们会在后面的课程中进行详细讲解，我们这里简要的说明一下上面用到的参数。</p><ul><li>-it：这是两个参数，一个是 -i：交互式操作，一个是 -t 终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。</li><li>–rm：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用<code>--rm</code>可以避免浪费空间。</li><li>ubuntu:16.04：这是指用 ubuntu:16.04 镜像为基础来启动容器。</li><li>bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 bash。</li></ul><p>进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。这里，我们执行了<code>cat /etc/os-release</code>，这是 Linux 常用的查看当前系统版本的命令，从返回的结果可以看到容器内是 Ubuntu 16.04.4 LTS 系统。最后我们通过 <code>exit</code> 退出了这个容器。</p><h2 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> image <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>列表包含了<strong>仓库名、标签、镜像 ID、创建时间以及所占用的空间</strong>。镜像 ID 则是镜像的唯一标识，一个镜像可以对应多个标签。</p><h2 id="镜像大小"><a href="#镜像大小" class="headerlink" title="镜像大小"></a>镜像大小</h2><p>如果仔细观察，会注意到，这里标识的所占用空间和在 Docker Hub 上看到的镜像大小不同。比如，ubuntu:16.04 镜像大小，在这里是 127 MB，但是在<a href="https://hub.docker.com/r/library/ubuntu/tags/">Docker Hub</a>显示的却是 43 MB。这是因为 Docker Hub 中显示的体积是压缩后的体积。在镜像下载和上传过程中镜像是保持着压缩状态的，因此 Docker Hub 所显示的大小是网络传输中更关心的流量大小。而<code>docker image ls</code>显示的是镜像下载到本地后，展开的大小，准确说，是展开后的各层所占空间的总和，因为镜像到本地后，查看空间的时候，更关心的是本地磁盘空间占用的大小。</p><p>另外一个需要注意的问题是，<code>docker image ls</code>列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于 Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 Docker 使用<code>Union FS</code>，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。你可以通过以下命令来便捷的查看镜像、容器、数据卷所占用的空间。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> system <span class="token function">df</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="新建并启动"><a href="#新建并启动" class="headerlink" title="新建并启动"></a>新建并启动</h2><p>所需要的命令主要为<code>docker run</code>。 例如，下面的命令输出一个 “Hello World”，之后终止容器。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> run ubuntu:16.04 /bin/echo <span class="token string">'Hello world'</span>Hello world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这跟在本地直接执行<code>/bin/echo 'hello world'</code>几乎感觉不出任何区别。下面的命令则启动一个 bash 终端，允许用户进行交互。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> run -t -i ubuntu:16.04 /bin/bashroot@af8bae53bdd3:/<span class="token comment">#</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其中，<code>-t</code>选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上，<code>-i</code>则让容器的标准输入保持打开。 在交互模式下，用户可以通过所创建的终端来输入命令，例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@af8bae53bdd3:/<span class="token comment"># pwd</span>/root@af8bae53bdd3:/<span class="token comment"># ls</span>bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>当利用<code>docker run</code>来创建容器时，Docker 在后台运行的标准操作包括：</p><ul><li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li><li>从地址池配置一个 ip 地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止</li></ul><h2 id="启动已终止容器"><a href="#启动已终止容器" class="headerlink" title="启动已终止容器"></a>启动已终止容器</h2><p>可以利用<code>docker container start</code>命令，直接将一个已经终止的容器启动运行。</p><p>容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。可以在伪终端中利用 ps 或 top 来查看进程信息。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@ba267838cc1b:/<span class="token comment"># ps</span>  PID TTY          TIME CMD    <span class="token number">1</span> ?        00:00:00 <span class="token function">bash</span>   <span class="token number">11</span> ?        00:00:00 <span class="token function">ps</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可见，容器中仅运行了指定的 bash 应用。这种特点使得 Docker 对资源的利用率极高，是货真价实的轻量级虚拟化。</p><h2 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h2><p>更多的时候，需要让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加<code>-d</code>参数来实现。下面举两个例子来说明一下。</p><p>如果不使用<code>-d</code>参数运行容器。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> run ubuntu:16.04 /bin/sh -c <span class="token string">"while true; do echo hello world; sleep 1; done"</span>hello worldhello worldhello worldhello world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>容器会把输出的结果 (STDOUT) 打印到宿主机上面。如果使用了<code>-d</code>参数运行容器。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> run -d ubuntu:16.04 /bin/sh -c <span class="token string">"while true; do echo hello world; sleep 1; done"</span>77b2dc01fe0f3f1265df143181e7b9af5e05279a884f4776ee75350ea9d8017a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>此时容器会在后台运行并不会把输出的结果 (STDOUT) 打印到宿主机上面(输出结果可以用 docker logs 查看)。</p><blockquote><p>注： 容器是否会长久运行，是和 docker run 指定的命令有关，和 -d 参数无关。</p></blockquote><p>使用<code>-d</code>参数启动后会返回一个唯一的 id，也可以通过<code>docker container ls</code>命令来查看容器信息。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> container <span class="token function">ls</span>CONTAINER ID  IMAGE         COMMAND               CREATED        STATUS       PORTS NAMES77b2dc01fe0f  ubuntu:16.04  /bin/sh -c 'while <span class="token function">tr</span>  <span class="token number">2</span> minutes ago  Up <span class="token number">1</span> minute        agitated_wright要获取容器的输出信息，可以通过 <span class="token function">docker</span> container logs 命令。$ <span class="token function">docker</span> container logs <span class="token punctuation">[</span>container ID or NAMES<span class="token punctuation">]</span>hello worldhello worldhello world<span class="token builtin class-name">.</span> <span class="token builtin class-name">.</span> <span class="token builtin class-name">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h2><p>可以使用<code>docker container stop</code>来终止一个运行中的容器。此外，当 Docker 容器中指定的应用终结时，容器也自动终止。</p><p>例如对于上一章节中只启动了一个终端的容器，用户通过 exit 命令或 Ctrl+d 来退出终端时，所创建的容器立刻终止。终止状态的容器可以用<code>docker container ls -a</code> 命令看到。例如</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> container <span class="token function">ls</span> -aCONTAINER ID        IMAGE                    COMMAND                CREATED             STATUS                          PORTS               NAMESba267838cc1b        ubuntu:16.04             <span class="token string">"/bin/bash"</span>            <span class="token number">30</span> minutes ago      Exited <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> About a minute ago                       trusting_newton<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>处于终止状态的容器，可以通过<code>docker container start</code>命令来重新启动。</p><p>此外，<code>docker container restart</code>命令会将一个运行态的容器终止，然后再重新启动它。</p><h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><p>在使用<code>-d</code>参数时，容器启动后会进入后台。某些时候需要进入容器进行操作：<strong>exec 命令 -i -t 参数</strong>。</p><p>只用<code>-i</code>参数时，由于没有分配伪终端，界面没有我们熟悉的<code>Linux</code>命令提示符，但命令执行结果仍然可以返回。 当<code>-i -t</code>参数一起使用时，则可以看到我们熟悉的 <code>Linux</code>命令提示符。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> run -dit ubuntu:16.0469d137adef7a8a689cbcb059e94da5489d3cddd240ff675c640c8d96e84fe1f6$ <span class="token function">docker</span> container <span class="token function">ls</span>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES69d137adef7a        ubuntu:16.04       <span class="token string">"/bin/bash"</span>         <span class="token number">18</span> seconds ago      Up <span class="token number">17</span> seconds                           zealous_swirles$ <span class="token function">docker</span> <span class="token builtin class-name">exec</span> -i 69d1 <span class="token function">bash</span><span class="token function">ls</span>binbootdev<span class="token punctuation">..</span>.$ <span class="token function">docker</span> <span class="token builtin class-name">exec</span> -it 69d1 <span class="token function">bash</span>root@69d137adef7a:/<span class="token comment">#</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果从这个 stdin 中 exit，不会导致容器的停止。这就是为什么推荐大家使用<code>docker exec</code>的原因。</p><blockquote><p>更多参数说明请使用<code>docker exec --help</code>查看。</p></blockquote><h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><p>可以使用<code>docker container rm</code>来删除一个处于终止状态的容器。例如:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> container <span class="token function">rm</span>  trusting_newtontrusting_newton<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>也可用使用<code>docker rm</code>容器名来删除，如果要删除一个运行中的容器，可以添加<code>-f</code>参数。Docker 会发送 <code>SIGKILL</code>信号给容器。</p><p>用<code>docker container ls -a (或者docker ps -a)</code>命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用下面的命令可以清理掉所有处于终止状态的容器。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> container prune<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> <span class="token function">ps</span> -aq<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="删除本地镜像"><a href="#删除本地镜像" class="headerlink" title="删除本地镜像"></a>删除本地镜像</h2><p>如果要删除本地的镜像，可以使用`docker image rm·命令，其格式为：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> image <span class="token function">rm</span> <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> <span class="token operator">&lt;</span>镜像<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span> <span class="token punctuation">[</span><span class="token operator">&lt;</span>镜像<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span> <span class="token punctuation">..</span>.<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> rmi 镜像名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者用 ID、镜像名、摘要删除镜像 其中，&lt;镜像&gt; 可以是 镜像短 ID、镜像长 ID、镜像名 或者 镜像摘要。 比如我们有这么一些镜像：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> image <span class="token function">ls</span>REPOSITORY                  TAG                 IMAGE ID            CREATED             SIZEcentos                      latest              0584b3d2cf6d        <span class="token number">3</span> weeks ago         <span class="token number">196.5</span> MBredis                       alpine              501ad78535f0        <span class="token number">3</span> weeks ago         <span class="token number">21.03</span> MB<span class="token function">docker</span>                      latest              cf693ec9b5c7        <span class="token number">3</span> weeks ago         <span class="token number">105.1</span> MBnginx                       latest              e43d811ce2f4        <span class="token number">5</span> weeks ago         <span class="token number">181.5</span> MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以用镜像的完整 ID，也称为 长 ID，来删除镜像。使用脚本的时候可能会用长 ID，但是人工输入就太累了，所以更多的时候是用 短 ID 来删除镜像。<code>docker image ls</code>默认列出的就已经是短 ID 了，一般取前3个字符以上，只要足够区分于别的镜像就可以了。</p><p>比如这里，如果我们要删除<strong>redis:alpine</strong>镜像，可以执行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> image <span class="token function">rm</span> <span class="token number">501</span>Untagged: redis:alpineUntagged: redis@sha256:f1ed3708f538b537eb9c2a7dd50dc90a706f7debd7e1196c9264edeea521a86dDeleted: sha256:501ad78535f015d88872e13fa87a828425117e3d28075d0c117932b05bf189b7Deleted: sha256:96167737e29ca8e9d74982ef2a0dda76ed7b430da55e321c071f0dbff8c2899bDeleted: sha256:32770d1dcf835f192cafd6b9263b7b597a1778a403a109e2cc2ee866f74adf23Deleted: sha256:127227698ad74a5846ff5153475e03439d96d4b1c7f2a449c7a826ef74a2d2faDeleted: sha256:1333ecc582459bac54e1437335c0816bc17634e131ea0cc48daa27d32c75eab3Deleted: sha256:4fc455b921edf9c4aea207c51ab39b10b06540c8b4825ba57b3feed1668fa7c7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们也可以用镜像名，也就是 &lt;仓库名&gt;:&lt;标签&gt;，来删除镜像。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> image <span class="token function">rm</span> centosUntagged: centos:latestUntagged: centos@sha256:b2f9d1c0ff5f87a4743104d099a3d561002ac500db1b9bfa02a783a46e0d366cDeleted: sha256:0584b3d2cf6d235ee310cf14b54667d889887b838d3f3d3033acd70fc3c48b8aDeleted: sha256:97ca462ad9eeae25941546209454496e1d66749d53dfa2ee32bf1faabd239d38<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="docker-commit定制镜像"><a href="#docker-commit定制镜像" class="headerlink" title="docker commit定制镜像"></a>docker commit定制镜像</h2><p>镜像是容器的基础，每次执行<code>docker run</code>的时候都会指定哪个镜像作为容器运行的基础。在之前的例子中，我们所使用的都是来自于 Docker Hub 的镜像。直接使用这些镜像是可以满足一定的需求，而当这些镜像无法直接满足需求时，我们就需要定制这些镜像。接下来的几节就将讲解如何定制镜像。</p><p>回顾一下之前我们学到的知识，镜像是多层存储，每一层是在前一层的基础上进行的修改；而容器同样也是多层存储，是在以镜像为基础层，在其基础上加一层作为容器运行时的存储层。</p><p>现在让我们以定制一个 Web 服务器为例子，来讲解镜像是如何构建的。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> run --name webserver -d -p <span class="token number">80</span>:80 nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这条命令会用 nginx 镜像启动一个容器，命名为 webserver，并且映射了 80 端口，这样我们可以用浏览器去访问这个 nginx 服务器。</p><p>如果是在 Linux 本机运行的 Docker，或者如果使用的是 Docker for Mac、Docker for Windows，那么可以直接访问：<a href="http://localhost;如果使用的是/">http://localhost；如果使用的是</a> Docker Toolbox，或者是在虚拟机、云服务器上安装的 Docker，则需要将 localhost 换为虚拟机地址或者实际云服务器地址。</p><p>直接用浏览器访问的话，我们会看到默认的 Nginx 欢迎页面。</p><p>现在，假设我们非常不喜欢这个欢迎页面，我们希望改成欢迎 Docker 的文字，我们可以使用 docker exec命令进入容器，修改其内容。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> <span class="token builtin class-name">exec</span> -it webserver <span class="token function">bash</span>root@3729b97e8226:/<span class="token comment"># echo '&lt;h1&gt;Hello, Docker!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html</span>root@3729b97e8226:/<span class="token comment"># exit</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我们以交互式终端方式进入 webserver 容器，并执行了 bash 命令，也就是获得一个可操作的 Shell。 然后，我们用<code>&lt;h1&gt;Hello, Docker!&lt;/h1&gt;</code>覆盖了 <strong>/usr/share/nginx/html/index.html</strong>的内容。 现在我们再刷新浏览器的话，会发现内容被改变了。</p><p>我们修改了容器的文件，也就是改动了容器的存储层。我们可以通过<code>docker diff</code>命令看到具体的改动。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> <span class="token function">diff</span> webserverC /rootA /root/.bash_historyC /runC /usrC /usr/shareC /usr/share/nginxC /usr/share/nginx/htmlC /usr/share/nginx/html/index.htmlC /varC /var/cacheC /var/cache/nginxA /var/cache/nginx/client_tempA /var/cache/nginx/fastcgi_tempA /var/cache/nginx/proxy_tempA /var/cache/nginx/scgi_tempA /var/cache/nginx/uwsgi_temp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在我们定制好了变化，我们希望能将其保存下来形成镜像。</p><p>要知道，当我们运行一个容器的时候（如果不使用卷的话），我们做的任何文件修改都会被记录于容器存储层里。而 Docker 提供了一个<code>docker commit</code>命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。</p><p>我们可以用下面的命令将容器保存为镜像：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> commit <span class="token punctuation">\</span>    --author <span class="token string">"海马学院"</span> <span class="token punctuation">\</span>    --message <span class="token string">"修改了默认首页"</span> <span class="token punctuation">\</span>    webserver <span class="token punctuation">\</span>    nginx:v2sha256:07e33465974800ce65751acc279adc6ed2dc5ed4e0838f8b86f0c87aa1795214<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中<code>--author</code>是指定修改的作者，而<code>--message</code>则是记录本次修改的内容。这点和 git 版本控制相似，不过这里这些信息可以省略留空。</p><p>我们可以在<code>docker image ls</code>中看到这个新定制的镜像：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> image <span class="token function">ls</span> nginxREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEnginx               v2                  07e334659748        <span class="token number">9</span> seconds ago       <span class="token number">181.5</span> MBnginx               <span class="token number">1.11</span>                05a60462f8ba        <span class="token number">12</span> days ago         <span class="token number">181.5</span> MBnginx               latest              e43d811ce2f4        <span class="token number">4</span> weeks ago         <span class="token number">181.5</span> MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们还可以用<code>docker history</code>具体查看镜像内的历史记录，如果比较 nginx:latest 的历史记录，我们会发现新增了我们刚刚提交的这一层。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> <span class="token function">history</span> nginx:v2IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT07e334659748        <span class="token number">54</span> seconds ago      nginx -g daemon off<span class="token punctuation">;</span>                            <span class="token number">95</span> B                修改了默认网页e43d811ce2f4        <span class="token number">4</span> weeks ago         /bin/sh -c <span class="token comment">#(nop)  CMD ["nginx" "-g" "daemon    0 B</span><span class="token operator">&lt;</span>missing<span class="token operator">&gt;</span>           <span class="token number">4</span> weeks ago         /bin/sh -c <span class="token comment">#(nop)  EXPOSE 443/tcp 80/tcp        0 B</span><span class="token operator">&lt;</span>missing<span class="token operator">&gt;</span>           <span class="token number">4</span> weeks ago         /bin/sh -c <span class="token function">ln</span> -sf /dev/stdout /var/log/nginx/   <span class="token number">22</span> B<span class="token operator">&lt;</span>missing<span class="token operator">&gt;</span>           <span class="token number">4</span> weeks ago         /bin/sh -c apt-key adv --keyserver hkp://pgp.   <span class="token number">58.46</span> MB<span class="token operator">&lt;</span>missing<span class="token operator">&gt;</span>           <span class="token number">4</span> weeks ago         /bin/sh -c <span class="token comment">#(nop)  ENV NGINX_VERSION=1.11.5-1   0 B</span><span class="token operator">&lt;</span>missing<span class="token operator">&gt;</span>           <span class="token number">4</span> weeks ago         /bin/sh -c <span class="token comment">#(nop)  MAINTAINER NGINX Docker Ma   0 B</span><span class="token operator">&lt;</span>missing<span class="token operator">&gt;</span>           <span class="token number">4</span> weeks ago         /bin/sh -c <span class="token comment">#(nop)  CMD ["/bin/bash"]            0 B</span><span class="token operator">&lt;</span>missing<span class="token operator">&gt;</span>           <span class="token number">4</span> weeks ago         /bin/sh -c <span class="token comment">#(nop) ADD file:23aa4f893e3288698c   123 MB</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>新的镜像定制好后，我们可以来运行这个镜像。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> run --name webserv2 -d -p <span class="token number">81</span>:80 nginx:v2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里我们命名为新的服务为 webserv2，并且映射到 81 端口。如果是 Docker for Mac/Windows 或 Linux 桌面的话，我们就可以直接访问 <a href="http://localhost:81/">http://localhost:81</a> 看到结果，其内容应该和之前修改后的 webserver 一样。</p><p>至此，我们第一次完成了定制镜像，使用的是<code>docker commit</code>命令，手动操作给旧的镜像添加了新的一层，形成新的镜像，对镜像多层存储应该有了更直观的感觉。</p><h1 id="Dockerfile-定制镜像"><a href="#Dockerfile-定制镜像" class="headerlink" title="Dockerfile 定制镜像"></a>Dockerfile 定制镜像</h1><p>从前面一节的<code>docker commit</code>的学习中，我们可以了解到，镜像的定制实际上就是定制每一层所添加的配置、文件等信息，但是命令毕竟只是命令，每次定制都得去重复执行这个命令，而且还不够直观，如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么这些问题不就都可以解决了吗？对的，这个脚本就是我们说的<code>Dockerfile</code>。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p><p>还以之前定制 nginx 镜像为例，这次我们使用 Dockerfile 来定制。在一个空白目录中，建立一个文本文件，并命名为 Dockerfile：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">mkdir</span> mynginx$ <span class="token builtin class-name">cd</span> mynginx$ <span class="token function">touch</span> Dockerfile<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其内容为：</p><pre class="line-numbers language-docker" data-language="docker"><code class="language-docker"><span class="token instruction"><span class="token keyword">FROM</span> nginx</span><span class="token instruction"><span class="token keyword">RUN</span> echo <span class="token string">'&lt;h1&gt;Hello, Docker!&lt;/h1&gt;'</span> &gt; /usr/share/nginx/html/index.html</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，FROM 和 RUN。</p><h2 id="FROM-指定基础镜像"><a href="#FROM-指定基础镜像" class="headerlink" title="FROM 指定基础镜像"></a>FROM 指定基础镜像</h2><p>所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个 nginx 镜像的容器，再进行修改一样，基础镜像是必须指定的。而<code>FROM</code>就是指定基础镜像，因此一个 Dockerfile 中 FROM 是必备的指令，并且必须是第一条指令。</p><p>在<a href="https://store.docker.com/">Docker Store</a>上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如 nginx、redis、mongo、mysql、httpd、php、tomcat 等；也有一些方便开发、构建、运行各种语言应用的镜像，如 node、openjdk、python、ruby、golang 等。可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。</p><p>如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如 ubuntu、debian、centos、fedora、alpine 等，这些操作系统的软件库为我们提供了更广阔的扩展空间。</p><p>除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为<code>scratch</code>。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。</p><pre class="line-numbers language-docker" data-language="docker"><code class="language-docker"><span class="token instruction"><span class="token keyword">FROM</span> scratch</span>...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果你以<code>scratch</code>为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。有的同学可能感觉很奇怪，没有任何基础镜像，我怎么去执行我的程序呢，其实对于 Linux 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接<code>FROM scratch</code>会让镜像体积更加小巧。使用 Go 语言 开发的应用很多会使用这种方式来制作镜像，这也是为什么有人认为 Go 是特别适合容器微服务架构的语言的原因之一。</p><h2 id="RUN-执行命令"><a href="#RUN-执行命令" class="headerlink" title="RUN 执行命令"></a>RUN 执行命令</h2><p><code>RUN</code>指令是用来执行命令行命令的。由于命令行的强大能力，<code>RUN</code>指令在定制镜像时是最常用的指令之一。其格式有两种：</p><ul><li><p>shell 格式：RUN &lt;命令&gt;，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 RUN 指令就是这种格式。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">RUN <span class="token builtin class-name">echo</span> <span class="token string">'&lt;h1&gt;Hello, Docker!&lt;/h1&gt;'</span> <span class="token operator">&gt;</span> /usr/share/nginx/html/index.html<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>exec 格式：RUN [“可执行文件”, “参数1”, “参数2”]，这更像是函数调用中的格式。 既然 RUN 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每个命令对应一个 RUN 呢？比如这样：</p><pre class="line-numbers language-docker" data-language="docker"><code class="language-docker"><span class="token instruction"><span class="token keyword">FROM</span> debian:jessie</span><span class="token instruction"><span class="token keyword">RUN</span> apt-get update</span><span class="token instruction"><span class="token keyword">RUN</span> apt-get install -y gcc libc6-dev make</span><span class="token instruction"><span class="token keyword">RUN</span> wget -O redis.tar.gz <span class="token string">"http://download.redis.io/releases/redis-3.2.5.tar.gz"</span></span><span class="token instruction"><span class="token keyword">RUN</span> mkdir -p /usr/src/redis</span><span class="token instruction"><span class="token keyword">RUN</span> tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1</span><span class="token instruction"><span class="token keyword">RUN</span> make -C /usr/src/redis</span><span class="token instruction"><span class="token keyword">RUN</span> make -C /usr/src/redis install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>之前说过，Dockerfile 中每一个指令都会建立一层，RUN 也不例外。每一个 RUN 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，commit 这一层的修改，构成新的镜像。</p><p>而上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。 这是很多初学 Docker 的人常犯的一个错误。</p><blockquote><p>Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层。</p></blockquote><p>上面的 Dockerfile 正确的写法应该是这样：</p><pre class="line-numbers language-docker" data-language="docker"><code class="language-docker"><span class="token instruction"><span class="token keyword">FROM</span> debian:jessie</span><span class="token instruction"><span class="token keyword">RUN</span> buildDeps=<span class="token string">'gcc libc6-dev make'</span> <span class="token operator">\</span>    &amp;&amp; apt-get update <span class="token operator">\</span>    &amp;&amp; apt-get install -y <span class="token variable">$buildDeps</span> <span class="token operator">\</span>    &amp;&amp; wget -O redis.tar.gz <span class="token string">"http://download.redis.io/releases/redis-3.2.5.tar.gz"</span> <span class="token operator">\</span>    &amp;&amp; mkdir -p /usr/src/redis <span class="token operator">\</span>    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 <span class="token operator">\</span>    &amp;&amp; make -C /usr/src/redis <span class="token operator">\</span>    &amp;&amp; make -C /usr/src/redis install <span class="token operator">\</span>    &amp;&amp; rm -rf /var/lib/apt/lists/* <span class="token operator">\</span>    &amp;&amp; rm redis.tar.gz <span class="token operator">\</span>    &amp;&amp; rm -r /usr/src/redis <span class="token operator">\</span>    &amp;&amp; apt-get purge -y --auto-remove <span class="token variable">$buildDeps</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 RUN 对一一对应不同的命令，而是仅仅使用一个 RUN 指令，并使用<code>&amp;&amp;</code>将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。</p><p>并且，这里为了格式化还进行了换行。Dockerfile 支持 Shell 类的行尾添加<code>\</code>的命令换行方式，以及行首<code>#</code>进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。</p><p>此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 apt 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。 很多人初学 Docker 制作出了很臃肿的镜像的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。</p><h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><p>好了，让我们再回到之前定制的 nginx 镜像的 Dockerfile 来。现在我们明白了这个 <code>Dockerfile</code>的内容，那么让我们来构建这个镜像吧。在 Dockerfile 文件所在目录执行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> build -t nginx:v3 <span class="token builtin class-name">.</span>Sending build context to Docker daemon <span class="token number">2.048</span> kBStep <span class="token number">1</span> <span class="token builtin class-name">:</span> FROM nginx ---<span class="token operator">&gt;</span> e43d811ce2f4Step <span class="token number">2</span> <span class="token builtin class-name">:</span> RUN <span class="token builtin class-name">echo</span> <span class="token string">'&lt;h1&gt;Hello, Docker!&lt;/h1&gt;'</span> <span class="token operator">&gt;</span> /usr/share/nginx/html/index.html ---<span class="token operator">&gt;</span> Running <span class="token keyword">in</span> 9cdc27646c7b ---<span class="token operator">&gt;</span> 44aa4490ce2cRemoving intermediate container 9cdc27646c7bSuccessfully built 44aa4490ce2c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从命令的输出结果中，我们可以清晰的看到镜像的构建过程。在 Step 2 中，如同我们之前所说的那样，RUN 指令启动了一个容器 9cdc27646c7b，执行了所要求的命令，并最后提交了这一层 44aa4490ce2c，随后删除了所用到的这个容器 9cdc27646c7b。这里我们使用了 <code>docker build</code>命令进行镜像构建。其格式为：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> build <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> <span class="token operator">&lt;</span>上下文路径/URL/-<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在这里我们指定了最终镜像的名称 -t nginx:v3，构建成功后，我们可以像之前运行 nginx:v2 那样来运行这个镜像，其结果会和 nginx:v2 一样。</p><h2 id="镜像构建上下文（Context）"><a href="#镜像构建上下文（Context）" class="headerlink" title="镜像构建上下文（Context）"></a>镜像构建上下文（Context）</h2><p>如果注意，会看到 docker build 命令最后有一个<code>.</code>。<code>.</code>表示当前目录，而 Dockerfile 就在当前目录，因此不少初学者以为这个路径是在指定 Dockerfile 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定上下文路径。那么什么是上下文呢？</p><p>首先我们要理解 docker build 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 Docker Remote API，而如 docker 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 docker 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C/S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。</p><p>当我们进行镜像构建的时候，并非所有定制都会通过 RUN 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 COPY 指令、ADD 指令等。而 docker build 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？</p><p>这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，docker build 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。如果在 Dockerfile 中这么写：</p><pre class="line-numbers language-docker" data-language="docker"><code class="language-docker"><span class="token instruction"><span class="token keyword">COPY</span> ./package.json /app/</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这并不是要复制执行 docker build 命令所在的目录下的 package.json，也不是复制 Dockerfile 所在目录下的 package.json，而是复制 上下文（context） 目录下的 package.json。</p><p>因此，<code>COPY</code>这类指令中的源文件的路径都是相对路径。这也是初学者经常会问的为什么 COPY ../package.json /app 或者 COPY /opt/xxxx /app 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。</p><p>现在就可以理解刚才的命令<code>docker build -t nginx:v3 .</code>中的这个<code>.</code>，实际上是在指定上下文的目录，docker build 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像。</p><p>如果观察 docker build 输出，我们其实已经看到了这个发送上下文的过程：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> build -t nginx:v3 <span class="token builtin class-name">.</span>Sending build context to Docker daemon <span class="token number">2.048</span> kB<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>理解构建上下文对于镜像构建是很重要的，可以避免犯一些不应该的错误。比如有些初学者在发现 COPY /opt/xxxx /app 不工作后，于是干脆将 Dockerfile 放到了硬盘根目录去构建，结果发现 docker build 执行后，在发送一个几十 GB 的东西，极为缓慢而且很容易构建失败。那是因为这种做法是在让 docker build 打包整个硬盘，这显然是使用错误。</p><p>一般来说，应该会将 Dockerfile 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 .gitignore 一样的语法写一个<code>.dockerignore</code>，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。</p><p>那么为什么会有人误以为 <strong>.</strong> 是指定 Dockerfile 所在目录呢？这是因为在默认情况下，如果不额外指定 Dockerfile 的话，会将上下文目录下的名为 Dockerfile 的文件作为 Dockerfile。</p><p>这只是默认行为，实际上 Dockerfile 的文件名并不要求必须为 Dockerfile，而且并不要求必须位于上下文目录中，比如可以用<code>-f ../Dockerfile.php</code>参数指定某个文件作为 Dockerfile。</p><p>当然，一般大家习惯性的会使用默认的文件名 Dockerfile，以及会将其置于镜像构建上下文目录中。</p><h2 id="迁移镜像"><a href="#迁移镜像" class="headerlink" title="迁移镜像"></a>迁移镜像</h2><p>Docker 还提供了<code>docker load</code>和<code>docker save</code>命令，用以将镜像保存为一个 tar 文件，然后传输到另一个位置上，再加载进来。这是在没有 Docker Registry 时的做法，现在已经不推荐，镜像迁移应该直接使用 Docker Registry，无论是直接使用 Docker Hub 还是使用内网私有 Registry 都可以。</p><p>使用<code>docker save</code>命令可以将镜像保存为归档文件。比如我们希望保存这个 alpine 镜像。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> image <span class="token function">ls</span> alpineREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEalpine              latest              baa5d63471ea        <span class="token number">5</span> weeks ago         <span class="token number">4.803</span> MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>保存镜像的命令为：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> save alpine <span class="token operator">|</span> <span class="token function">gzip</span> <span class="token operator">&gt;</span> alpine-latest.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后我们将 alpine-latest.tar.gz 文件复制到了到了另一个机器上，可以用下面这个命令加载镜像：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> load -i alpine-latest.tar.gzLoaded image: alpine:latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果我们结合这两个命令以及 ssh 甚至 pv 的话，利用 Linux 强大的管道，我们可以写一个命令完成从一个机器将镜像迁移到另一个机器，并且带进度条的功能：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> save <span class="token operator">&lt;</span>镜像名<span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token function">bzip2</span> <span class="token operator">|</span> <span class="token function">pv</span> <span class="token operator">|</span> <span class="token function">ssh</span> <span class="token operator">&lt;</span>用户名<span class="token operator">&gt;</span>@<span class="token operator">&lt;</span>主机名<span class="token operator">&gt;</span> <span class="token string">'cat | docker load'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="私有镜像仓库"><a href="#私有镜像仓库" class="headerlink" title="私有镜像仓库"></a>私有镜像仓库</h1><p>这部分讲讲私有镜像仓库的使用。</p><h2 id="Docker-Hub"><a href="#Docker-Hub" class="headerlink" title="Docker Hub"></a>Docker Hub</h2><p>目前 Docker 官方维护了一个公共仓库<code>Docker Hub</code>，大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现。如果你觉得拉取 Docker Hub 的镜像比较慢的话，我们可以配置一个镜像加速器：<a href="http://docker-cn.com/%EF%BC%8C%E5%BD%93%E7%84%B6%E5%9B%BD%E5%86%85%E5%A4%A7%E9%83%A8%E5%88%86%E4%BA%91%E5%8E%82%E5%95%86%E9%83%BD%E6%8F%90%E4%BE%9B%E4%BA%86%E7%9B%B8%E5%BA%94%E7%9A%84%E5%8A%A0%E9%80%9F%E5%99%A8%EF%BC%8C%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE%E5%8D%B3%E5%8F%AF%E3%80%82">http://docker-cn.com/，当然国内大部分云厂商都提供了相应的加速器，简单配置即可。</a></p><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>你可以在 <a href="https://cloud.docker.com/">https://cloud.docker.com</a> 免费注册一个 Docker 账号。</p><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>通过执行<code>docker login</code>命令交互式的输入用户名及密码来完成在命令行界面登录 Docker Hub。</p><h3 id="注销"><a href="#注销" class="headerlink" title="注销"></a>注销</h3><p>你可以通过<code>docker logout</code>退出登录。 拉取镜像</p><h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><p>你可以通过<code>docker search</code>命令来查找官方仓库中的镜像，并利用<code>docker pull</code>命令来将它下载到本地。</p><p>例如以 centos 为关键词进行搜索：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> search centosNAME                                            DESCRIPTION                                     STARS     OFFICIAL   AUTOMATEDcentos                                          The official build of CentOS.                   <span class="token number">465</span>       <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>tianon/centos                                   CentOS <span class="token number">5</span> and <span class="token number">6</span>, created using rinse instea<span class="token punctuation">..</span>.   <span class="token number">28</span>blalor/centos                                   Bare-bones base CentOS <span class="token number">6.5</span> image                <span class="token number">6</span>                    <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>saltstack/centos-6-minimal                                                                      <span class="token number">6</span>                    <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>tutum/centos-6.4                                DEPRECATED. Use tutum/centos:6.4 instead. <span class="token punctuation">..</span>.   <span class="token number">5</span>                    <span class="token punctuation">[</span>OK<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到返回了很多包含关键字的镜像，其中包括镜像名字、描述、收藏数（表示该镜像的受关注程度）、是否官方创建、是否自动创建。</p><p>官方的镜像说明是官方项目组创建和维护的，<code>automated</code>资源允许用户验证镜像的来源和内容。</p><p>根据是否是官方提供，可将镜像资源分为两类。</p><ul><li>一种是类似 centos 这样的镜像，被称为基础镜像或根镜像。这些基础镜像由 Docker 公司创建、验证、支持、提供。这样的镜像往往使用单个单词作为名字。</li><li>还有一种类型，比如 tianon/centos 镜像，它是由 Docker 的用户创建并维护的，往往带有用户名称前缀。可以通过前缀<code>username/</code>来指定使用某个用户提供的镜像，比如 tianon 用户。</li></ul><p>另外，在查找的时候通过<code>--filter=stars=N</code>参数可以指定仅显示收藏数量为 N 以上的镜像。下载官方 centos 镜像到本地。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> pull centosPulling repository centos0b443ba03958: Download complete539c0211cd76: Download complete511136ea3c5a: Download complete7064731afe90: Download complete<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h3><p>用户也可以在登录后通过<code>docker push</code>命令来将自己的镜像推送到 Docker Hub。以下命令中的 username 请替换为你的 Docker 账号用户名。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> tag ubuntu:17.10 username/ubuntu:17.10$ <span class="token function">docker</span> image <span class="token function">ls</span>REPOSITORY                                               TAG                    IMAGE ID            CREATED             SIZEubuntu                                                   <span class="token number">17.10</span>                  275d79972a86        <span class="token number">6</span> days ago          <span class="token number">94</span>.6MBusername/ubuntu                                          <span class="token number">17.10</span>                  275d79972a86        <span class="token number">6</span> days ago          <span class="token number">94</span>.6MB$ <span class="token function">docker</span> push username/ubuntu:17.10$ <span class="token function">docker</span> search usernameNAME                      DESCRIPTION                                     STARS               OFFICIAL            AUTOMATEDusername/ubuntu<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="私有仓库"><a href="#私有仓库" class="headerlink" title="私有仓库"></a>私有仓库</h2><p>有时候使用 Docker Hub 这样的公共仓库可能不方便，用户可以创建一个本地仓库供私人使用。</p><p><code>docker-registry</code>是官方提供的工具，可以用于构建私有的镜像仓库。本文内容基于 docker-registry v2.x 版本。你可以通过获取官方 registry 镜像来运行。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> run -d -p <span class="token number">5000</span>:5000 --restart<span class="token operator">=</span>always --name registry registry<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这将使用官方的<code>registry</code>镜像来启动私有仓库。默认情况下，仓库会被创建在容器的<code>/var/lib/registry</code>目录下。你可以通过 -v 参数来将镜像文件存放在本地的指定路径。例如下面的例子将上传的镜像放到本地的 /opt/data/registry 目录。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> run -d <span class="token punctuation">\</span>    -p <span class="token number">5000</span>:5000 <span class="token punctuation">\</span>    -v /opt/data/registry:/var/lib/registry <span class="token punctuation">\</span>    registry<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="在私有仓库上传、搜索、下载镜像"><a href="#在私有仓库上传、搜索、下载镜像" class="headerlink" title="在私有仓库上传、搜索、下载镜像"></a>在私有仓库上传、搜索、下载镜像</h3><p>创建好私有仓库之后，就可以使用<code>docker tag</code>来标记一个镜像，然后推送它到仓库。例如私有仓库地址为 127.0.0.1:5000。先在本机查看已有的镜像。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> image <span class="token function">ls</span>REPOSITORY                        TAG                 IMAGE ID            CREATED             VIRTUAL SIZEubuntu                            latest              ba5877dc9bec        <span class="token number">6</span> weeks ago         <span class="token number">192.7</span> MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用<code>docker tag</code>将 ubuntu:latest 这个镜像标记为 127.0.0.1:5000/ubuntu:latest。 格式为 docker tag IMAGE[:TAG] [REGISTRY_HOST[:REGISTRY_PORT]/]REPOSITORY[:TAG]</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> tag ubuntu:latest <span class="token number">127.0</span>.0.1:5000/ubuntu:latest$ <span class="token function">docker</span> image <span class="token function">ls</span>REPOSITORY                        TAG                 IMAGE ID            CREATED             VIRTUAL SIZEubuntu                            latest              ba5877dc9bec        <span class="token number">6</span> weeks ago         <span class="token number">192.7</span> MB<span class="token number">127.0</span>.0.1:5000/ubuntu:latest      latest              ba5877dc9bec        <span class="token number">6</span> weeks ago         <span class="token number">192.7</span> MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<code>docker push</code>上传标记的镜像。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> push <span class="token number">127.0</span>.0.1:5000/ubuntu:latestThe push refers to repository <span class="token punctuation">[</span><span class="token number">127.0</span>.0.1:5000/ubuntu<span class="token punctuation">]</span>373a30c24545: Pusheda9148f5200b0: Pushedcdd3de0940ab: Pushedfc56279bbb33: Pushedb38367233d37: Pushed2aebd096e0e2: Pushedlatest: digest: sha256:fe4277621f10b5026266932ddf760f5a756d2facd505a94d2da12f4f52f71f5a size: <span class="token number">1568</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用<code>curl</code>查看仓库中的镜像。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">curl</span> <span class="token number">127.0</span>.0.1:5000/v2/_catalog<span class="token punctuation">{</span><span class="token string">"repositories"</span>:<span class="token punctuation">[</span><span class="token string">"ubuntu"</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这里可以看到 {“repositories”:[“ubuntu”]}，表明镜像已经被成功上传了。</p><p>先删除已有镜像，再尝试从私有仓库中下载这个镜像。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> image <span class="token function">rm</span> <span class="token number">127.0</span>.0.1:5000/ubuntu:latest$ <span class="token function">docker</span> pull <span class="token number">127.0</span>.0.1:5000/ubuntu:latestPulling repository <span class="token number">127.0</span>.0.1:5000/ubuntu:latestba5877dc9bec: Download complete511136ea3c5a: Download complete9bad880da3d2: Download complete25f11f5fb0cb: Download completeebc34468f71d: Download complete2318d26665ef: Download complete$ <span class="token function">docker</span> image <span class="token function">ls</span>REPOSITORY                         TAG                 IMAGE ID            CREATED             VIRTUAL SIZE<span class="token number">127.0</span>.0.1:5000/ubuntu:latest       latest              ba5877dc9bec        <span class="token number">6</span> weeks ago         <span class="token number">192.7</span> MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>如果你不想使用 127.0.0.1:5000 作为仓库地址，比如想让本网段的其他主机也能把镜像推送到私有仓库。你就得把例如 192.168.199.100:5000 这样的内网地址作为私有仓库地址，这时你会发现无法成功推送镜像。</p><p>这是因为 Docker 默认不允许非 HTTPS 方式推送镜像。我们可以通过 Docker 的配置选项来取消这个限制。</p><h3 id="Ubuntu-14-04-Debian-7-Wheezy"><a href="#Ubuntu-14-04-Debian-7-Wheezy" class="headerlink" title="Ubuntu 14.04, Debian 7 Wheezy"></a>Ubuntu 14.04, Debian 7 Wheezy</h3><p>对于使用 upstart 的系统而言，编辑<code>/etc/default/docker</code>文件，在其中的<code>DOCKER_OPTS</code>中增加如下内容：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">DOCKER_OPTS</span><span class="token operator">=</span><span class="token string">"--registry-mirror=https://registry.docker-cn.com --insecure-registries=192.168.199.100:5000"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>重新启动服务:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token function">service</span> <span class="token function">docker</span> restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Ubuntu-16-04-Debian-8-centos-7"><a href="#Ubuntu-16-04-Debian-8-centos-7" class="headerlink" title="Ubuntu 16.04+, Debian 8+, centos 7"></a>Ubuntu 16.04+, Debian 8+, centos 7</h3><p>对于使用 systemd 的系统，请在<code>/etc/docker/daemon.json</code>中写入如下内容（如果文件不存在请新建该文件）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">{</span>  <span class="token string">"registry-mirror"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>    <span class="token string">"https://registry.docker-cn.com"</span>  <span class="token punctuation">]</span>,  <span class="token string">"insecure-registries"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>    <span class="token string">"192.168.199.100:5000"</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：该文件必须符合<code>json</code>规范，否则 Docker 将不能启动。</p></blockquote><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>对于 Docker for Windows、Docker for Mac 在设置中编辑<code>daemon.json</code>增加和上边一样的字符串即可。</p><h1 id="数据共享与持久化"><a href="#数据共享与持久化" class="headerlink" title="数据共享与持久化"></a>数据共享与持久化</h1><p>这部分介绍如何在 Docker 内部以及容器之间管理数据，在容器中管理数据主要有两种方式：</p><ul><li>数据卷（Data Volumes）</li><li>挂载主机目录 (Bind mounts)</li></ul><h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><p><code>数据卷</code>是一个可供一个或多个容器使用的特殊目录，它绕过<code>UFS</code>，可以提供很多有用的特性：</p><ul><li>数据卷 可以在容器之间共享和重用</li><li>对 数据卷 的修改会立马生效</li><li>对 数据卷 的更新，不会影响镜像</li><li>数据卷 默认会一直存在，即使容器被删除</li></ul><blockquote><p>注意：数据卷 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会隐藏掉，能显示看的是挂载的 数据卷。</p></blockquote><p>选择 -v 还是 -–mount 参数： Docker 新用户应该选择<code>--mount</code>参数，经验丰富的 Docker 使用者对<code>-v</code>或者 <code>--volume</code>已经很熟悉了，但是推荐使用<code>--mount</code>参数。</p><p>创建一个数据卷：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> volume create my-vol<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看所有的 数据卷：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> volume <span class="token function">ls</span><span class="token builtin class-name">local</span>               my-vol<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在主机里使用以下命令可以查看指定 数据卷 的信息</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> volume inspect my-vol<span class="token punctuation">[</span>    <span class="token punctuation">{</span>        <span class="token string">"Driver"</span><span class="token builtin class-name">:</span> <span class="token string">"local"</span>,        <span class="token string">"Labels"</span><span class="token builtin class-name">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>,        <span class="token string">"Mountpoint"</span><span class="token builtin class-name">:</span> <span class="token string">"/var/lib/docker/volumes/my-vol/_data"</span>,        <span class="token string">"Name"</span><span class="token builtin class-name">:</span> <span class="token string">"my-vol"</span>,        <span class="token string">"Options"</span><span class="token builtin class-name">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>,        <span class="token string">"Scope"</span><span class="token builtin class-name">:</span> <span class="token string">"local"</span>    <span class="token punctuation">}</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>启动一个挂载数据卷的容器：在用<code>docker run</code>命令的时候，使用<code>--mount</code>标记来将 数据卷 挂载到容器里。在一次<code>docker run</code>中可以挂载多个 数据卷。下面创建一个名为 web 的容器，并加载一个 数据卷 到容器的 /webapp 目录。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> run -d -P <span class="token punctuation">\</span>    --name web <span class="token punctuation">\</span>    <span class="token comment"># -v my-vol:/wepapp \</span>    --mount <span class="token assign-left variable">source</span><span class="token operator">=</span>my-vol,target<span class="token operator">=</span>/webapp <span class="token punctuation">\</span>    training/webapp <span class="token punctuation">\</span>    python app.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看数据卷的具体信息：在主机里使用以下命令可以查看 web 容器的信息</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> inspect web<span class="token punctuation">..</span>.<span class="token string">"Mounts"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>        <span class="token string">"Type"</span><span class="token builtin class-name">:</span> <span class="token string">"volume"</span>,        <span class="token string">"Name"</span><span class="token builtin class-name">:</span> <span class="token string">"my-vol"</span>,        <span class="token string">"Source"</span><span class="token builtin class-name">:</span> <span class="token string">"/var/lib/docker/volumes/my-vol/_data"</span>,        <span class="token string">"Destination"</span><span class="token builtin class-name">:</span> <span class="token string">"/app"</span>,        <span class="token string">"Driver"</span><span class="token builtin class-name">:</span> <span class="token string">"local"</span>,        <span class="token string">"Mode"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,        <span class="token string">"RW"</span><span class="token builtin class-name">:</span> true,        <span class="token string">"Propagation"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>    <span class="token punctuation">}</span><span class="token punctuation">]</span>,<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>删除数据卷：</p><pre class="line-numbers language-none"><code class="language-none">$ docker volume rm my-vol<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>数据卷 是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除 数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 数据卷。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用<code>docker rm -v</code>这个命令。 无主的数据卷可能会占据很多空间，要清理请使用以下命令</p><pre class="line-numbers language-none"><code class="language-none">$ docker volume prune<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="挂载主机目录"><a href="#挂载主机目录" class="headerlink" title="挂载主机目录"></a>挂载主机目录</h2><p>选择 -v 还是 -–mount 参数： Docker 新用户应该选择 –mount 参数，经验丰富的 Docker 使用者对 -v 或者 –volume 已经很熟悉了，但是推荐使用 –mount 参数。</p><p>挂载一个主机目录作为数据卷：使用 <code>--mount</code> 标记可以指定挂载一个本地主机的目录到容器中去。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> run -d -P <span class="token punctuation">\</span>    --name web <span class="token punctuation">\</span>    <span class="token comment"># -v /src/webapp:/opt/webapp \</span>    --mount <span class="token assign-left variable">type</span><span class="token operator">=</span>bind,source<span class="token operator">=</span>/src/webapp,target<span class="token operator">=</span>/opt/webapp <span class="token punctuation">\</span>    training/webapp <span class="token punctuation">\</span>    python app.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的命令加载主机的 /src/webapp 目录到容器的 /opt/webapp目录。这个功能在进行测试的时候十分方便，比如用户可以放置一些程序到本地目录中，来查看容器是否正常工作。本地目录的路径必须是绝对路径，以前使用 -v 参数时如果本地目录不存在 Docker 会自动为你创建一个文件夹，现在使用 –mount 参数时如果本地目录不存在，Docker 会报错。</p><p>Docker 挂载主机目录的默认权限是 读写，用户也可以通过增加<code>readonly</code>指定为 只读。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> run -d -P <span class="token punctuation">\</span>    --name web <span class="token punctuation">\</span>    <span class="token comment"># -v /src/webapp:/opt/webapp:ro \</span>    --mount <span class="token assign-left variable">type</span><span class="token operator">=</span>bind,source<span class="token operator">=</span>/src/webapp,target<span class="token operator">=</span>/opt/webapp,readonly <span class="token punctuation">\</span>    training/webapp <span class="token punctuation">\</span>    python app.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>加了<code>readonly</code>之后，就挂载为 只读 了。如果你在容器内 /opt/webapp 目录新建文件，会显示如下错误:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/opt/webapp <span class="token comment"># touch new.txt</span>touch: new.txt: Read-only <span class="token function">file</span> system<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>查看数据卷的具体信息：在主机里使用以下命令可以查看 web 容器的信息</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> inspect web<span class="token punctuation">..</span>.<span class="token string">"Mounts"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>        <span class="token string">"Type"</span><span class="token builtin class-name">:</span> <span class="token string">"bind"</span>,        <span class="token string">"Source"</span><span class="token builtin class-name">:</span> <span class="token string">"/src/webapp"</span>,        <span class="token string">"Destination"</span><span class="token builtin class-name">:</span> <span class="token string">"/opt/webapp"</span>,        <span class="token string">"Mode"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,        <span class="token string">"RW"</span><span class="token builtin class-name">:</span> true,        <span class="token string">"Propagation"</span><span class="token builtin class-name">:</span> <span class="token string">"rprivate"</span>    <span class="token punctuation">}</span><span class="token punctuation">]</span>,<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>挂载一个本地主机文件作为数据卷：<code>--mount</code>标记也可以从主机挂载单个文件到容器中</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> run --rm -it <span class="token punctuation">\</span>   <span class="token comment"># -v $HOME/.bash_history:/root/.bash_history \</span>   --mount <span class="token assign-left variable">type</span><span class="token operator">=</span>bind,source<span class="token operator">=</span><span class="token environment constant">$HOME</span>/.bash_history,target<span class="token operator">=</span>/root/.bash_history <span class="token punctuation">\</span>   ubuntu:17.10 <span class="token punctuation">\</span>   <span class="token function">bash</span>root@2affd44b4667:/<span class="token comment"># history</span><span class="token number">1</span>  <span class="token function">ls</span><span class="token number">2</span>  diskutil list<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样就可以记录在容器输入过的命令了。</p><h1 id="Docker-的网络模式"><a href="#Docker-的网络模式" class="headerlink" title="Docker 的网络模式"></a>Docker 的网络模式</h1><h2 id="Bridge模式"><a href="#Bridge模式" class="headerlink" title="Bridge模式"></a>Bridge模式</h2><p>当<code>Docker</code>进程启动时，会在主机上创建一个名为<code>docker0</code>的虚拟网桥，此主机上启动的<code>Docker</code>容器会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。从<code>docker0</code>子网中分配一个 IP 给容器使用，并设置 docker0 的 IP 地址为容器的<strong>默认网关</strong>。在主机上创建一对虚拟网卡<code>veth pair</code>设备，Docker 将 veth pair 设备的一端放在新创建的容器中，并命名为<code>eth0</code>（容器的网卡），另一端放在主机中，以<code>vethxxx</code>这样类似的名字命名，并将这个网络设备加入到 docker0 网桥中。可以通过<code>brctl show</code>命令查看。</p><p><code>bridge</code>模式是 docker 的默认网络模式，不写<code>–net</code>参数，就是<code>bridge</code>模式。使用<code>docker run -p</code>时，docker 实际是在<code>iptables</code>做了<code>DNAT</code>规则，实现端口转发功能。可以使用<code>iptables -t nat -vnL</code>查看。<code>bridge</code>模式如下图所示：<img src="https://www.qikqiak.com/k8s-book/docs/images/docker-netework-bridge.jpeg" alt="bridge network"></p><p>演示：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> run -tid --net<span class="token operator">=</span>bridge --name docker_bri1 <span class="token punctuation">\</span>             ubuntu-base:v3             <span class="token function">docker</span> run -tid --net<span class="token operator">=</span>bridge --name docker_bri2 <span class="token punctuation">\</span>             ubuntu-base:v3 $ brctl show$ <span class="token function">docker</span> <span class="token builtin class-name">exec</span> -ti docker_bri1 /bin/bash$ <span class="token function">ifconfig</span> –a$ route –n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果你之前有 Docker 使用经验，你可能已经习惯了使用<code>--link</code>参数来使容器互联。</p><p>随着 Docker 网络的完善，强烈建议大家将容器加入自定义的 Docker 网络来连接多个容器，而不是使用 –link 参数。</p><p>下面先创建一个新的 Docker 网络。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> network create -d bridge my-net<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>-d</code>参数指定 Docker 网络类型，有 <code>bridge overlay</code>。其中 overlay 网络类型用于 Swarm mode，在本小节中你可以忽略它。</p><p>运行一个容器并连接到新建的 my-net 网络</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> run -it --rm --name busybox1 --network my-net busybox <span class="token function">sh</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>打开新的终端，再运行一个容器并加入到 my-net 网络</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> run -it --rm --name busybox2 --network my-net busybox <span class="token function">sh</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再打开一个新的终端查看容器信息</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> container <span class="token function">ls</span>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMESb47060aca56b        busybox             <span class="token string">"sh"</span>                <span class="token number">11</span> minutes ago      Up <span class="token number">11</span> minutes                           busybox28720575823ec        busybox             <span class="token string">"sh"</span>                <span class="token number">16</span> minutes ago      Up <span class="token number">16</span> minutes                           busybox1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面通过 ping 来证明 busybox1 容器和 busybox2 容器建立了互联关系。 在 busybox1 容器输入以下命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/ <span class="token comment"># ping busybox2</span>PING busybox2 <span class="token punctuation">(</span><span class="token number">172.19</span>.0.3<span class="token punctuation">)</span>: <span class="token number">56</span> data bytes<span class="token number">64</span> bytes from <span class="token number">172.19</span>.0.3: <span class="token assign-left variable">seq</span><span class="token operator">=</span><span class="token number">0</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">64</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">0.072</span> ms<span class="token number">64</span> bytes from <span class="token number">172.19</span>.0.3: <span class="token assign-left variable">seq</span><span class="token operator">=</span><span class="token number">1</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">64</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">0.118</span> ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>用 ping 来测试连接 busybox2 容器，它会解析成 172.19.0.3。 同理在 busybox2 容器执行 ping busybox1，也会成功连接到。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/ <span class="token comment"># ping busybox1</span>PING busybox1 <span class="token punctuation">(</span><span class="token number">172.19</span>.0.2<span class="token punctuation">)</span>: <span class="token number">56</span> data bytes<span class="token number">64</span> bytes from <span class="token number">172.19</span>.0.2: <span class="token assign-left variable">seq</span><span class="token operator">=</span><span class="token number">0</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">64</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">0.064</span> ms<span class="token number">64</span> bytes from <span class="token number">172.19</span>.0.2: <span class="token assign-left variable">seq</span><span class="token operator">=</span><span class="token number">1</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">64</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">0.143</span> ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这样，busybox1 容器和 busybox2 容器建立了互联关系。</p><p>如果你有多个容器之间需要互相连接，推荐使用<code>Docker Compose</code>。</p><h2 id="Host-模式"><a href="#Host-模式" class="headerlink" title="Host 模式"></a>Host 模式</h2><p>如果启动容器的时候使用<code>host</code>模式，那么这个容器将不会获得一个独立的<code>Network Namespace</code>，而是和宿主机共用一个 Network Namespace。容器将不会虚拟出自己的网卡，配置自己的 IP 等，而是使用宿主机的 IP 和端口。但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。 Host模式如下图所示：</p><p><img src="https://www.qikqiak.com/k8s-book/docs/images/docker-network-host.jpeg" alt="network host"></p><p>演示：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> run -tid --net<span class="token operator">=</span>host --name docker_host1 ubuntu-base:v3$ <span class="token function">docker</span> run -tid --net<span class="token operator">=</span>host --name docker_host2 ubuntu-base:v3$ <span class="token function">docker</span> <span class="token builtin class-name">exec</span> -ti docker_host1 /bin/bash$ <span class="token function">docker</span> <span class="token builtin class-name">exec</span> -ti docker_host1 /bin/bash$ <span class="token function">ifconfig</span> –a$ route –n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Container-模式"><a href="#Container-模式" class="headerlink" title="Container 模式"></a>Container 模式</h2><p>这个模式指定新创建的容器和已经存在的一个容器共享一个 Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过 lo 网卡设备通信。 Container模式示意图： <img src="https://www.qikqiak.com/k8s-book/docs/images/docker-network-container.jpeg" alt="network container">演示：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> run -tid --net<span class="token operator">=</span>container:docker_bri1 <span class="token punctuation">\</span>              --name docker_con1 ubuntu-base:v3$ <span class="token function">docker</span> <span class="token builtin class-name">exec</span> -ti docker_con1 /bin/bash$ <span class="token function">docker</span> <span class="token builtin class-name">exec</span> -ti docker_bri1 /bin/bash$ <span class="token function">ifconfig</span> –a$ route -n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="None模式"><a href="#None模式" class="headerlink" title="None模式"></a>None模式</h2><p>使用<code>none</code>模式，Docker 容器拥有自己的 Network Namespace，但是，并不为Docker 容器进行任何网络配置。也就是说，这个 Docker 容器没有网卡、IP、路由等信息。需要我们自己为 Docker 容器添加网卡、配置 IP 等。 None模式示意图: <img src="https://www.qikqiak.com/k8s-book/docs/images/docker-network-none.jpeg" alt="network none">演示：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker</span> run -tid --net<span class="token operator">=</span>none --name <span class="token punctuation">\</span>                docker_non1 ubuntu-base:v3$ <span class="token function">docker</span> <span class="token builtin class-name">exec</span> -ti docker_non1 /bin/bash$ <span class="token function">ifconfig</span> –a$ route -n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Docker 的跨主机通信我们这里就先暂时不讲解，我们在后面的<code>Kubernetes</code>课程当中会用到。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么你可以不读大学</title>
      <link href="/archives/ad8f62.html"/>
      <url>/archives/ad8f62.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><img src="/C:/Users\86185\AppData\Roaming\Typora\typora-user-images\image-20220819010927842.png" alt="image-20220819010927842"></p><p>作者：阮一峰<br>原文地址：<a href="http://www.ruanyifeng.com/survivor/collapse/university.html">为什么你可以不读大学(opens new window)</a></p></blockquote><p>1、</p><p>我一直相信，互联网教育是未来的方向。美国三个主要的在线教育网站—-Udacity，Coursera，可汗学院—-我都经常访问。</p><p>2016 年四月，Udacity 进入中国，推出了中文版“优达学城”，一下子引起了我的兴趣。因为它干了一件没有先例的事情：颁发网络文凭。它办了一个网上的“硅谷大学”，自己发文凭，名称是“纳米学位”。</p><blockquote><p>“纳米学位（Nanodegree）是优达学城此前与 Google、Facebook、亚马逊等互联网公司联合推出的学历认证项目。学员在线学习，所有项目考核合格之后即可获得纳米学位。”</p></blockquote><p>现在总共有 12 种纳米学位，包括机器学习、无人驾驶车开发、VR 开发这样非常前沿的领域。</p><span id="more"></span><p>官网这样介绍：</p><blockquote><p>“我们没有严格意义上的录取流程，对报名者唯一的要求是学习该纳米学位项目所必须的先修知识和技能。纳米学位项目采取自主学习模式，你可以按照你喜欢的速度完成项目。”</p></blockquote><p>该公司宣称，国内的许多互联网公司（比如滴滴出行、优酷土豆、京东、新浪）已经认可了纳米学位。</p><p>我忍不住想，会不会以后找工作，大家手里拿的不是大学文凭，而是网站颁发的文凭？如果雇主认可网络文凭，我们是否还需要大学文凭？</p><p>下面是我的一些思考。</p><p>2、</p><p>当代的大学起源于欧洲修道院的模式。学生要经过多年的苦修，经过考核，才能毕业。如果想成为高级僧侣，就必须再多熬几年。另外，还有导师作为监督人，防止你学到歪门邪说。</p><p>这种模式的两大弊端，演变到今天，已经越来越严重了：一个是传授的知识老化，另一个是极其浪费学生的时间。</p><p>3、</p><p>什么知识才是有用的知识？</p><p>农业社会，上一代人的知识可以一成不变地用在下一代。而在信息社会，前几年的知识，再过几年就不能用了。</p><p>举例来说，眼下就业前景最好的行业，我觉得有两个：区块链和 VR。它们在五年前都是不存在的，那时就业最好的是苹果 iOS 系统的应用开发，可是再往前推五年，它也是不存在的。伴随着它们的是，很多旧工作岗位的消失，比如塞班、黑莓、Windows Phone 的开发。</p><p>这种情况下，大学应该教什么，我们根本不知道。学生毕业后的行业，现在根本还没有出现。因此，大学只能重点教基础类课程，而且各个方向都必须教到，因为不知道学生将来会用到哪个方向的东西。这样就会耗费大量的时间，学习专业的各种基础知识，其中许多对人生来说是没用的。学生常常感叹，考试一结束，有些课程这辈子再没有用到的机会了。</p><p>更糟糕的是，学生的培养计划，都是一些二三十年前毕业、然后一直待在大学里、与社会生产实践脱节的人制定的。他们的知识和思维早已过时了。这样的人指定你应该学习的知识，很可能在你学的时候就已经过时了。</p><p>4、</p><p>退一步说，就算你在大学里能学到了真正的知识，那也不应该在那里待四年。如果只学最需要学习的东西，一年就够了。</p><p>四年时间足以让一个人在任何领域成为资深业者，甚至专家。可是我们的大学生呢，经过本科四年，不要说领域专家，甚至能力强的学生都寥寥无几。我们的大学制度用了四年时间，培养出了大量一无所长的、迷茫困惑的、市场滞销的年轻人。</p><p>18 岁是人生最有热情和精力投入一项事业的时候，但是，大学将你一连四年关在教室和图书馆里，把考试和绩点伪装成你奋斗的目标，人为将你与真实世界隔离，引导你去关注那些对未来人生毫不重要的事情。经过这样四年的歧途，等你真正走上社会、要跟全世界竞争的时候，你的竞争力不是变强了，而是变弱了。换句话说，四年制大学很可能是削弱你，而不是让你变得更强。</p><p>2014 年诺贝尔物理学奖得主中村修二，就曾经写过一篇长文，名字就叫《东亚教育浪费了太多的生命》。</p><p>世界著名程序员 Jamie Zawinski 曾经解释，为什么他只读了一个学期的大学就退学。</p><blockquote><p>“进了大学以后，每天 8 点就要起床，开始训练记忆力。有一门课我早就会了，想申请免修。教务长说不行，你必须上，这是政策。见鬼，我为什么要自己付钱，来这种地方。我就退学了，从来没后悔过。”</p></blockquote><p>我们时代的很多成功者—-乔布斯、比尔盖茨、扎克伯格等等—-都是退学生，这绝不是偶然的。不是他们在大学待不下去，而是他们发现，没必要在那个地方待四年。如果他们咬着牙忍受下去，熬到拿到文凭的那一天，苹果公司和微软公司可能都不会有了。</p><p>读大学，只是 18 岁时很多种选择中的一种，不是唯一的选择，更谈不上是最好的选择。校园是一个美丽的地方，但是如果一定要在里面待上四年，那还是算了吧。</p><p>5、</p><p>德国和瑞士的中学生毕业后，要选择走学术道路还是职业道路。只有不到 30%的人，会去读大学，其余的人都接受职业培训，为职业生涯做准备。</p><p>我认为，这才是更合理的制度。毕竟大多数人不会从事学术研究，而要靠某种职业谋生。你要知道，大学课程是为学术生涯打基础的，不是为职业生涯设计的。所以，你确定要投入某个职业，合理的选择不是先上大学，然后再找工作，而是一开始就接受职业培训，然后一边工作，一边学习各种对职业生涯有帮助的课程。</p><p>理论上，一个人只要接受了中等教育，就可以进社会了。大学的本意是为那些走学术生涯的人开设的，后来慢慢变味了，以至于现在社会上居然有一种说法，”大学是素质教育“。不是这样的，任何时间地点，你都有机会提高素质。</p><p>另外，从经济角度看，如果你不想走学术道路，却去读大学，将不利于你的收入。目前，技术工人的薪水，正在不断上升。比他人多几年职业经验，你早早就可以拿到高级技工或工程师的薪水。如果你大学毕业，从零开始就业，你的收入会比同龄人落后几年。如果你还欠了学生贷款，处境就更糟糕了。</p><p>6、</p><p>注意，我不是说知识无用，而是说知识（尤其是非学术的知识）不一定要通过大学获得，通过互联网一样可以接受高等教育，而且更高效和便宜。</p><p>技术已经成为人类社会发展的主导性力量，学习和教育变得比以往更重要、更关键。但是很不幸，我们的学习和教育制度已经完全过时，传授的知识有用的少，没用的多；传授方法仍然依靠灌输和记忆，而不是启发和理解，极其低效，浪费学生的时间，打击学习热情，磨灭对知识的兴趣；对年轻人的成长，正面影响少，负面影响大，而且看不到改变的希望。</p><p>以前，人生的选择很少，你不得不去读大学，因为没有其他地方可以接受高等教育。社会还把很多机会与文凭挂钩，先有文凭，然后才能有就业、职称、住房等等。</p><p>但是，时代已经变了，文凭正变得越来越不重要。那些与文凭挂钩的东西，正在一项项脱钩。</p><p>互联网将教育的自主权，交到了每个人自己手里。上什么课程、什么时间上，都完全由你决定。你可以一边工作，一边利用夜晚和周末，学习网络课程。这样的话，不仅早早就会有收入，而且只学那些对自己最有用、最感兴趣的内容，学习的效率很高。如果发现对学术有兴趣，将来再回大学，攻读更高的学位，也是完全可以的。</p><p>等到 22 岁，别人刚刚开始找工作，还在为归还学贷发愁，你已经有了四年工作经验和一些积蓄，认清了自己的人生道路，开始向事业的高峰冲刺了。</p><p>7、</p><p>对于那些正在大学里面苦苦努力、不知道方向何在的年轻人，我有一点建议。</p><p>大学课程是为了那些不知道学什么的人设计的，千万不要因为自己找不到方向，而被这些课程”画地为牢“限制住。你要主动去接触和学习，那些自己感兴趣的东西。引用一个网友的话，”你要做的就是自主、跨界、终身学习“。</p>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>png图片压缩原理</title>
      <link href="/archives/b35bf513.html"/>
      <url>/archives/b35bf513.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="什么是PNG"><a href="#什么是PNG" class="headerlink" title="什么是PNG"></a>什么是PNG</h2><p>PNG的全称叫便携式网络图型（Portable Network Graphics）是目前最流行的网络传输和展示的图片格式，原因有如下几点：</p><ul><li><p><code>无损压缩</code>：PNG图片采取了基于LZ77派生算法对文件进行压缩，使得它压缩比率更高，生成的文件体积更小，并且不损失数据。</p></li><li><p><code>体积小</code>：它利用特殊的编码方法标记重复出现的数据，使得同样格式的图片，PNG图片文件的体积更小。网络通讯中因受带宽制约，在保证图片清晰、逼真的前提下，优先选择PNG格式的图片。</p></li><li><p><code>支持透明效果</code>：PNG支持对原图像定义256个透明层次，使得图像的边缘能与任何背景平滑融合，这种功能是GIF和JPEG没有的。</p><span id="more"></span></li></ul><h2 id="PNG类型"><a href="#PNG类型" class="headerlink" title="PNG类型"></a>PNG类型</h2><p>PNG图片主要有三个类型，分别为 PNG 8/ PNG 24 / PNG 32。</p><ul><li><code>PNG 8</code>：PNG 8中的8，其实指的是8bits，相当于用2^8（2的8次方）大小来存储一张图片的颜色种类，2^8等于256，也就是说PNG 8能存储256种颜色，一张图片如果颜色种类很少，将它设置成PNG 8得图片类型是非常适合的。</li><li><code>PNG 24</code>：PNG 24中的24，相当于3乘以8 等于 24，就是用三个8bits分别去表示 R（红）、G（绿）、B（蓝）。R(0<del>255),G(0</del>255),B(0~255)，可以表达256乘以256乘以256=16777216种颜色的图片，这样PNG 24就能比PNG 8表示色彩更丰富的图片。但是所占用的空间相对就更大了。</li><li><code>PNG 32</code>：PNG 32中的32，相当于PNG 24 加上 8bits的透明颜色通道，就相当于R（红）、G（绿）、B（蓝）、A（透明）。R(0<del>255),G(0</del>255),B(0<del>255),A(0</del>255)。比PNG 24多了一个A（透明），也就是说PNG 32能表示跟PNG 24一样多的色彩，并且还支持256种透明的颜色，能表示更加丰富的图片颜色类型。</li></ul><p>怎么说呢，总的来说，PNG 8/ PNG 24 / PNG 32就相当于我们屌丝心中，把女神分为三类：</p><ul><li><code>一类女神 = PNG 8</code>：屌丝舔狗们见到第一类女神，顿时会觉得心情愉悦、笑逐颜开，屌丝发黑的印堂逐渐舒展，确认过眼神，是心动的感觉。</li><li><code>二类女神 = PNG 24</code>：第二类女神开始厉害了，会给屌丝们一种菊花一紧、振聋发聩的心弦震撼，接触多了第二类女神能让屌丝每天精神抖擞，延年益寿。</li><li><code>三类女神 = PNG 32</code>：在第三类女神面前，所有的语言都显得苍白无力。那是一种看了让屌丝上下通透、手眼通天的至尊级存在。超凡脱俗、天神下凡都不足以描摹她美色的二分之一。我曾经只有在梦里才见到过。</li></ul><p>哎。。。我的初恋，看着她现在的照片，应该是触及PNG 24这一等级了。</p><h2 id="PNG图片数据结构"><a href="#PNG图片数据结构" class="headerlink" title="PNG图片数据结构"></a>PNG图片数据结构</h2><p>PNG图片的数据结构其实跟http请求的结构很像，都是一个数据头，后面跟着很多的数据块，如下图所示：</p><p><img src="https://segmentfault.com/img/bVbp1Nb?w=340&amp;h=580" alt="图片描述"></p><p>如果你用vim的查看编码模式打开一张png图片，会是下面这个样子：</p><p><img src="https://segmentfault.com/img/bVbp1Nj?w=1000&amp;h=360" alt="图片描述"></p><p>握草，第一眼看到这一坨坨十六进制编码是不是感觉和女神的心思一样晦涩难懂？</p><p>老弟 莫慌，讲实话，如果撩妹纸有那一坨坨乱码那么简单，哥哥我早就妻妾成群啦。<br>接下来我就一一讲解这一堆十六进制编码的含义。</p><p><code>8950 4e47 0d0a 1a0a</code>：这个是PNG图片的头，所有的PNG图片的头都是这一串编码，图片软件通过这串编码判定这个文件是不是PNG格式的图片。</p><p><code>0000 000d</code>：是iHDR数据块的长度，为13。</p><p><code>4948 4452</code>：是数据块的type,为IHDR，之后紧跟着是data。</p><p><code>0000 02bc</code>：是图片的宽度。</p><p><code>0000 03a5</code>：是高度。</p><p>以此类推，每一段十六进制编码就代表着一个特定的含义。下面其他的就不一一分析了，太多了，小伙伴们自己去查吧。</p><h2 id="什么样的PNG图片更适合压缩"><a href="#什么样的PNG图片更适合压缩" class="headerlink" title="什么样的PNG图片更适合压缩"></a>什么样的PNG图片更适合压缩</h2><p>常规的png图片，颜色越单一，颜色值越少，压缩率就越大，比如下面这张图：</p><p><img src="https://segmentfault.com/img/bVbp1NC?w=208&amp;h=210" alt="图片描述"></p><p>它仅仅由红色和绿色构成，如果用0代表红色，用1代表绿色，那用数字表示这张图就是下面这个样子：</p><p>00000000000000000</p><p>00000000000000000</p><p>00000000000000000</p><p>1111111111111111111111111</p><p>1111111111111111111111111</p><p>1111111111111111111111111</p><p>我们可以看到，这张图片是用了大量重复的数字，我们可以将重复的数字去掉，直接用数组形式的[0, 1]就可以直接表示出这张图片了，仅仅用两个数字，就能表示出一张很大的图片，这样就极大的压缩了一张png图片。</p><p>所以！颜色越单一，颜色值越少，颜色差异越小的png图片，压缩率就越大，体积就越小。</p><h2 id="PNG的压缩"><a href="#PNG的压缩" class="headerlink" title="PNG的压缩"></a>PNG的压缩</h2><p>PNG图片的压缩，分两个阶段：</p><ul><li><code>预解析（Prediction）</code>：这个阶段就是对png图片进行一个预处理，处理后让它更方便后续的压缩。说白了，就是一个女神，在化妆前，会先打底，先涂乳液和精华，方便后续上妆、美白、眼影、打光等等。</li><li><code>压缩（Compression）</code>：执行Deflate压缩，该算法结合了 LZ77 算法和 Huffman 算法对图片进行编码。</li></ul><h3 id="预解析（Prediction）"><a href="#预解析（Prediction）" class="headerlink" title="预解析（Prediction）"></a>预解析（Prediction）</h3><p>png图片用差分编码（Delta encoding）对图片进行预处理，处理每一个的像素点中每条通道的值，差分编码主要有几种：</p><ul><li>不过滤</li><li>X-A</li><li>X-B</li><li>X-(A+B)/2(又称平均值)</li><li>Paeth推断（这种比较复杂）</li></ul><p>假设，一张png图片如下:</p><p><img src="https://segmentfault.com/img/bVbp1NL?w=454&amp;h=176" alt="图片描述"></p><p>这张图片是一个红色逐渐增强的渐变色图，它的红色从左到右逐渐加强，映射成数组的值为[1,2,3,4,5,6,7,8]，使用X-A的差分编码的话，那就是:</p><p>[2-1=1, 3-2=1, 4-3=1, 5-4=1, 6-5=1, 7-6=1, 8-7=1]</p><p>得到的结果为</p><p>[1,1,1,1,1,1,1]</p><p>最后的[1,1,1,1,1,1,1]这个结果出现了大量的重复数字，这样就非常适合进行压缩。</p><p>这就是为什么渐变色图片、颜色值变化不大并且颜色单一的图片更容易压缩的原理。</p><p>差分编码的目的，就是尽可能的将png图片数据值转换成一组重复的、低的值，这样的值更容易被压缩。</p><p>最后还要注意的是，差分编码处理的是每一个的像素点中每条颜色通道的值，R（红）、G（绿）、B（蓝）、A（透明）四个颜色通道的值分别进行处理。</p><h3 id="压缩（Compression）"><a href="#压缩（Compression）" class="headerlink" title="压缩（Compression）"></a>压缩（Compression）</h3><p>压缩阶段会将预处理阶段得到的结果进行Deflate压缩，它由 Huffman 编码 和 LZ77压缩构成。</p><p>如前面所说，Deflate压缩会标记图片所有的重复数据，并记录数据特征和结构，会得到一个压缩比最大的png图片 编码数据。</p><p>Deflate是一种压缩数据流的算法. 任何需要流式压缩的地方都可以用。</p><p>还有就是我们前面说过，一个png图片，是由很多的数据块构成的，但是数据块里面的一些信息其实是没有用的，比如用Photoshop保存了一张png图片，图片里就会有一个区块记录“这张图片是由photshop创建的”，很多类似这些信息都是无用的，如果用photoshop的“导出web格式”就能去掉这些无用信息。导出web格式前后对比效果如下图所示：</p><p><img src="https://segmentfault.com/img/bVbp1NN?w=624&amp;h=405" alt="图片描述"></p><p>可以看到，导出web格式，去除了很多无用信息后，图片明显小了很多。</p><h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
      
      
      <categories>
          
          <category> 广知 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> png </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端好文整理一</title>
      <link href="/archives/efe3ac5e.html"/>
      <url>/archives/efe3ac5e.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="JS篇"><a href="#JS篇" class="headerlink" title="JS篇"></a>JS篇</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul><li><p><a href="https://link.segmentfault.com/?enc=L31L1J+h5elYfmqMP/8Bpw==.Tqs+Qop+ebIxWrRogl1sHaJgCZci34CYwCSvbE6+MWonmyrQhMLgK2hQ3Iiide8567Gdi0Y6VnJJIPvelQbtSA==">JS基本数据类型和引用数据类型的区别及深浅拷贝</a></p></li><li><p><a href="https://link.segmentfault.com/?enc=4lrO2vl2Clqt7vPW6/Q9kg==.3z2JiNH50r5Wcw05JNU5qHzHMkDZIktevvfIO9ZS3TuF0IocjjvUfbaIpay7c+51">JS的第七种数据类型</a></p></li><li><p><a href="https://link.segmentfault.com/?enc=OO+jZXJZp8W6AxzW8Kazag==.bgNqMxQmM9E/5ou7LGzOT6dQfNtSKQDsMvmTcKaAlERIFugjcR+vSbc825XrtVf6ukoDiSPikVHuyy+UZO2QDA==">JS中typeof与instanceof的区别</a></p></li><li><p><a href="https://link.segmentfault.com/?enc=HdaZf0ONwMb2NjssCyVIPQ==.jEqhRah1jMI7OOj+/hk5jjV11waumxan3sjN4rC+rvPvfPXiIabH1Zh6ty33b/R65S98NG8uwFoUMcXSKve9UPviQK9bp4w2HLzFXCjmFm0=">typeof null 为什么等于 object?</a></p></li><li><p><a href="https://link.segmentfault.com/?enc=xdEOtFAI23/6cqwnzzfWdQ==.6vQdt7OyzD99a77S9/c1lDdwm2+qUSZm5aj7lgGNbtp0o9E7ejLRbOxxnRTBlmAb">为什么用Object.prototype.toString.call(obj)检测对象类型?</a></p></li><li><p><a href="https://link.segmentfault.com/?enc=GVpUof0fHm+LZtk01pcJ2g==.PskqnYB9nzSP5FLR66wERDcin2cUhmnoYfJe2OCZxCqrQeIGVh6wGQvmrQ6Z38fUpXnd3C100gWG7kN75E9TDQ==">JS显性数据类型转换和隐性数据类型转换</a></p></li><li><p><a href="https://segmentfault.com/a/1190000007434923">理解Object.defineProperty的作用</a></p><span id="more"></span></li></ul><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><ul><li><a href="https://segmentfault.com/a/1190000011194676#articleHeader13">深入理解 js this 绑定 ( 无需死记硬背，尾部有总结和面试题解析 )</a></li><li><a href="https://link.segmentfault.com/?enc=y6ffdOtimFOsumNsue2XCA==./vLjfCuk6N4TUMD0DKTBDkaSP1ME/b83UNtFZKkxgHId3zZ0mxn8RW0r+DWAx4R+">前端基础进阶（五）：全方位解读this</a></li><li><a href="https://link.segmentfault.com/?enc=P5gI9+8QaEfAeza0PLzBSQ==.nOuijH+0TRIaSYB1vPCxkfx5sDchT/yjPWYWGvttA+OqX1jhd/j0uaARGSURlK+S">this、apply、call、bind</a></li><li><a href="https://link.segmentfault.com/?enc=qm3eLmrQnmVO+sf/LAoWIg==.v7tDj4OJOT1WDYJuEo9CUEo+NofBvo1DccPa8/sJGfOVOI4qKsBhM9Bexx6JoNIx">JavaScript中的call、apply、bind深入理解</a></li></ul><h3 id="作用域链与闭包"><a href="#作用域链与闭包" class="headerlink" title="作用域链与闭包"></a>作用域链与闭包</h3><ul><li><a href="https://link.segmentfault.com/?enc=PYxFUXl0HYoNkNl8swtWgQ==.SP+tNM5gKs21462EmAYWSYj5yK5H6JbBa3qE4FiaXpFrCoEbZgH8y0Skl7a0K0h8ie0QILDs3NVam4+roE2eVw==">JavaScript中作用域和作用域链的简单理解（变量提升）</a></li><li><a href="https://link.segmentfault.com/?enc=E8MZ35kJFszz76bxqne6CA==.3Oiwc6PWBsXQRkE9kEMd7jkgQGF4bKeQlsCtWCbWva7z+n+cd0pxQYGu95K+AWVJoWPEqSSB/5p/+WtqERjhug==">JavaScript作用域、上下文、执行期上下文、作用域链、闭包</a></li><li><a href="https://link.segmentfault.com/?enc=juft67+B/MfUGFDN533Anw==.tj3idF2mMCl02xFLt8yu9XHvXq5MpaHXWWD7Cz77Km4GOZvo6nYDhPYVeB+hIvgu">前端基础进阶（四）：详细图解作用域链与闭包</a></li><li><a href="https://link.segmentfault.com/?enc=FY4XG6LKn1Bava67J9b4KA==.ojKH/8YWtihpRZDm5YBPhcFPGWQ//V8glzLj18/bxuB8NJG4pvOB54ILLycCsdHC">JavaScript 闭包入门（译文）</a></li><li><a href="https://link.segmentfault.com/?enc=6VpQsmcOc4K5pVKI6T9x/w==.rDGqL/LQEyMlUMUm3oX8nB4mU45QDKv0sU6D6I+OhGR2j0N9eZ92asANHw7o7HGS">JavaScript深入之闭包</a></li><li><a href="https://segmentfault.com/a/1190000006875662">JavaScript 闭包</a></li><li><a href="https://link.segmentfault.com/?enc=kPP/YlQwBIyf2l5EVU6+mQ==.uGqznX9f/gYZvoWzOeyHafhkHBmDJJfTChxmOXWAYNFCaww7rtY7tZJBpJsVFTyy">浏览器是怎么看闭包的。</a></li></ul><h3 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a>原型与原型链</h3><ul><li><a href="https://link.segmentfault.com/?enc=kvUMW7IO3rwgZSGUSu7k5Q==.BoXYUTWdFqrDR4xnziUi7Y4H60995hmAe8GCz7EAZwMAyMhvoqW2cQjppNBkX1CC">白话原型和原型链</a></li><li><a href="https://link.segmentfault.com/?enc=DUEO6J6uhP+7RYgLo7k0Ow==.p3NSKFEyj0DAgrXVWQk92xNYrCCHJ4pwd7YVsdMBrPARCI7I6iqJfsysK5Hz5XJt">前端基础进阶（九）：详解面向对象、构造函数、原型与原型链</a></li><li><a href="https://link.segmentfault.com/?enc=7xNgMN/lANLW1T+WtxaRTw==.2V6rGOujFfMFB6ixj80d0+4f6+y2t1lIiFhqnB9rkpzHHkyaSa3fm2ejEu9JcuU4">最详尽的 JS 原型与原型链终极详解，没有「可能是」。（一）</a></li><li><a href="https://link.segmentfault.com/?enc=8C1exLlrbNeOebNSQr52jQ==.4ktwPOVf5B26ft97qIzOmpwyAe7o+9uboudzeCo3Me04IrhIuCM4MxrBJomYIES8">最详尽的 JS 原型与原型链终极详解，没有「可能是」。（二）</a></li><li><a href="https://link.segmentfault.com/?enc=C0eMDV2CpDiFcyhXcahHrw==.70jvokN3BwKiAArKaFTGoWZXocecoXEOF4PEbpXoHrWswJCcZzXv7PCRARpT4EP6">最详尽的 JS 原型与原型链终极详解，没有「可能是」。（三）</a></li></ul><h3 id="JS执行底层"><a href="#JS执行底层" class="headerlink" title="JS执行底层"></a>JS执行底层</h3><ul><li><a href="https://link.segmentfault.com/?enc=/9kbQRddhUQUkgr7i/gytw==.Q8tO/7CjCAjzCM+Bdc5IMd/HWDnz5pUBf4HOECdpsxZgLZjVZ0VGSNFz8A3Fyumj">前端基础进阶（一）：内存空间详细图解</a></li><li><a href="https://link.segmentfault.com/?enc=Zh4QQ8pjyC9QrsKP65bw8A==.dhlXrxiBeSRKlFflyOpCZgOqhqY/BcW3LbY6sDbho/KW+64b9+r5WvD27HAk4Ne+">前端基础进阶（二）：执行上下文详细图解</a></li><li><a href="https://link.segmentfault.com/?enc=OzVxcMlTVWMWJ7GnQlimyA==.RmCVprzxuCReYE4abCBb6rPO+Yxuztz9Y1+sqqk9QzKhc9HUYgDVpiQdMP/LCK3j">前端基础进阶（十二）：深入核心，详解事件循环机制</a></li><li><a href="https://link.segmentfault.com/?enc=wRjCXddzfM6EieSmvuE9WQ==.47WN6VL5Jou3aqM0VAuGb8+oeTj7gCyScryElvKe/1MWSIbdvgksOSPVhX8DdULj73JXL8mMHDIc8KFpvNHi+A==">js中的事件委托或是事件代理详解</a></li></ul><h3 id="ES6-x2F-ES7"><a href="#ES6-x2F-ES7" class="headerlink" title="ES6/ES7.."></a>ES6/ES7..</h3><ul><li><a href="https://link.segmentfault.com/?enc=ZmYPY0dhHj9jY0LStOROhQ==.boIFQ9/2ABV3/rDLBBE+OldjcEp87eTayjUQb6ROaJI/0UrsBl2XM0on2V48wsaM">ES6 系列之 let 和 const</a></li><li><a href="https://link.segmentfault.com/?enc=TNd27y32l54QZAI32juQWA==.vbk1bXW6G2Cs82HMN6qWoFF+ZjJyTMlsC3OTqeEKjgQq4MiEmA9sl5/5E2c6Cjk+">前端基础进阶（十四）：es6常用基础合集</a></li><li><a href="https://link.segmentfault.com/?enc=S5QsxnmwJlc3WrUoftcF1A==.VxwdD6IelXXwRljTU2fowd7DRYLnQ+WkElXl/MKUt3WpOz8I1oXCHsY+L4q5SJ2b">ES6 系列之箭头函数</a></li><li><a href="https://link.segmentfault.com/?enc=HQ3R+eC9w6G8+GgyDcPwTw==.c8CXfquj1jHI8woSX6rlCs35/yJDxnaZWvWKR6yT41hiCI8OGW/2Sb1dghFsmEgE">JavaScript初学者必看“箭头函数”</a></li><li><a href="https://link.segmentfault.com/?enc=K1cHmzO57GvN4LrvoZKpFg==.hcXtjNb8vp3ckPzBD9y8mpmHTFuYXYXwSdFMf1PTfUAt7sYik2V9Uuw4HhlwLLHR">Promise之你看得懂的Promise</a></li><li><a href="https://link.segmentfault.com/?enc=ViBnUHnNnbRvjpgzVtrPCw==.H/eDA6EhFg2tDHED2GWUzgYg+nBkGYi1ERPykjAJ7duUh8prTL/Gi3Tjs12AGJtq">ES6 系列之我们来聊聊 Promise</a></li><li><a href="https://link.segmentfault.com/?enc=sdVrIek4efN3ycy3aqxoDA==.CWkWiSjWJFzmSzMhyusVx7MVDSR2y+LHltxbDH/gvKy61kmFgA3dmlSbPGLF0zmm">Promise原理讲解 &amp;&amp; 实现一个Promise对象 (遵循Promise/A+规范)</a></li><li><a href="https://link.segmentfault.com/?enc=4fGmniZCFY6+v5u5zwDtkw==.FAoioFlynzb4WdTrYKLki8fXoRSgIs03RT95h/nladSkE8UDTIYoPQWHCXox0aV4">web前端-js继承的理解</a></li><li><a href="https://link.segmentfault.com/?enc=U0R9B0McwJ7olmprT20Mqg==.VozBKB46KROizdYtPKz+tR1/NGRF2h/mD0bbCZWBt3IpcBQKuojf07ZcSqEAYSX9">js 深拷贝 vs 浅拷贝</a></li><li><a href="https://link.segmentfault.com/?enc=T1F7H04D2jSew+0aQmsufg==.9A/6TdlHuXBduN2eCvT0Cr6IVzVLvD8fqT4LRYgHC5DPfUCtNY0vPGf2XfdvlOjQ">深拷贝的终极探索（90%的人都不知道）</a></li><li><a href="https://link.segmentfault.com/?enc=4/c9cHuwn98IiQ1tK0Onmw==.rc+gCv9O868kwbW6BPDjgkjrrNdcrpiukOd+lTqqPPjEtxPZNRvfA5fvyLu2Klfc">理解 async/await</a></li><li><a href="https://link.segmentfault.com/?enc=LzQ20U2RZJH+PjdwkLKdUg==.Sd4I5OWw15qT3biBRA+KILOfvnGLOPS453+ftsWVk3zHC8sv4vAhwvPAVV5xLw+C">ES6 系列之我们来聊聊 Async</a></li></ul><p>除此之外强烈推荐冴羽老师的<a href="https://link.segmentfault.com/?enc=OjQTgOLzsxOHomFEMglKNQ==.CXNeYeJ+kAgZDPwpzPQVHY+osY2sDiGF8uPmaDzjqDlktNMGv3WfDw6ufL7hUv8LUbj+RN6mX4JT/S144jMzrA==">ES6系列</a>文章，深入骨髓的理解ES6中的核心。</p><h3 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h3><ul><li><a href="https://link.segmentfault.com/?enc=JeIs2Vt9k0igajb0xDN23Q==.4v32W/rTaOYC2E2Rlm5nnbxSCbBih21Huw0cG4bbv/BAGJ/ybCIQlyesy63w+rI3BwSgkhF9vN+haFu87ZhGoQ==">深入理解 TypeScript</a></li><li><a href="https://link.segmentfault.com/?enc=9ZpLhwWgHlImb5vFmaFEFQ==.Ou92bXJtxHCKieZH7zzZOl9Cw06T1kLIEq3M4wiWoNu7/DswWsuLcshMS4R6UT8O">TypeScript体系调研报告</a></li><li><a href="https://link.segmentfault.com/?enc=SBSnCdXX4KBo9OVvQA2jWg==.B/bnetUBdsObdZF7nNLgsLrOneshhp1XqPv/qM+K3no3UJHirHftFzZaPk8/Lv7B">TypeScript 实践</a></li></ul><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><ul><li><a href="https://link.segmentfault.com/?enc=lU2wwNuDsnqyV4dEz/Afsg==.CcZ6Ld+N3cuQ+xuj+siSEj9IJpz0K3QEVLUqgOopgCw7lQi770oGF93tOW3MoU2u">Node入门</a></li><li><a href="https://link.segmentfault.com/?enc=O8P/owcftH35i4WaoPM7dA==.bUKe+2JnA8oU9Bh85Da0J+nQR5MGu0+HHYLIPEuIUr2XrcVl4yWPboVrJNKzWaBF">谈谈Node中的常见概念</a></li><li><a href="https://link.segmentfault.com/?enc=WgOuJXlkDDPJeEk9TCqQXQ==.PTwvLscVgDbtPWXL/xTYN++QBlqiHbdR12QUj1APf6zjJkKhmfqU+mqr3RLRkh7CtdH3uDCrNrhKOx6L/t+BzH5Q6U8bJ4xAv0ZMysonBN4hcvhib/+ThCGqVDJtDczE">Node &amp; Express 入门指南</a></li><li><a href="https://link.segmentfault.com/?enc=uJOb46cl4g9qnOLPf1MaSQ==.Pbzu19UmD/iL+GJ6XqWPxOtv06u7uIwiz2oNWFudtwzbRMqIV+gsEcPvMiEOEsbl">Express使用手记：核心入门</a></li><li><a href="https://link.segmentfault.com/?enc=gqmFHTPaVTNk+1Y1m2Nqbg==.NDkBu/YnxBYRgJWFmxosR3KA+vGmejRBepexTq6N1BgKh6XMr/0M6YXs5Gn9RbmG">node进阶——之事无巨细手写koa源码</a></li><li><a href="https://link.segmentfault.com/?enc=+XDnJ2b3IgVcBUXKJXC46Q==.nbe/U3i3vwv1gTXCBaspHrQyUriklBIAuNqkDBfOj16a62Hyy8GNWXZsAeoViAZI">带你走进 koa2 的世界（koa2 源码浅谈）</a></li><li><a href="https://link.segmentfault.com/?enc=8wmd9JpPpZ4k/4QC1S6rQg==.eH+yXsGS9p7krkONyZgIc1qvzf6ermQM4IaSHHYcgu0C+OBezpHXnFIglRwS8Dsv">fly.js—Node下增强的API</a></li></ul><h2 id="HTML-x2F-CSS篇"><a href="#HTML-x2F-CSS篇" class="headerlink" title="HTML/CSS篇"></a>HTML/CSS篇</h2><ul><li><a href="https://link.segmentfault.com/?enc=RsjdeJCkE0jqoPaOXQWWnQ==.+H4wOZfW+P8T6AxaDYYF3HmuGN2354bRYKEq0r0E9p/iFjKrxeq04/Uca+WMeDPe">CSS 常见布局方式</a></li><li><a href="https://segmentfault.com/a/1190000010989110">【整理】CSS布局方案</a></li><li><a href="https://segmentfault.com/a/1190000006242814">CSS查漏补缺</a></li><li>[<a href="https://link.segmentfault.com/?enc=itW6KumPXIrrYXE7orilxg==.UkVLfXXbJ8ve219Ei61s6ejh4qpy9PWgILAswWYhGa9kWILIgTcKB6KooGxbsnzc">布局概念] 关于CSS-BFC深入理解</a></li><li>[<a href="https://link.segmentfault.com/?enc=Edkmi/KXc5JyM7uTI/Imzg==.Z7KGu+iJRNOAWPklEEUzR6E/XJ9T6Clqvg5gkw6QEqAkZp7RDW/o9sr8kKWFEEA9">译]这些 CSS 命名规范将省下你大把调试时间</a></li><li><a href="https://link.segmentfault.com/?enc=TeuYjkMAjz45Ty70eyQDdA==./lafPbRLHy/WH4sXwCYiN7arDRqGPYZm8OoqTSJN31bAlGBd7esJkFrm25A8mGwu">CSS知识总结</a></li><li><a href="https://link.segmentfault.com/?enc=KiVkvhv/8NAzHbU+MF003Q==.oLay3Ou/dkLrLKIkQ18ZatPP5BNTDNq/ZVgcEENLYQD6A+xK8U33LB9ntOfomIgh">前端开发规范：命名规范、html规范、css规范、js规范</a></li></ul><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><ul><li>HTTP状态码（HTTP Status Code）</li><li><a href="https://link.segmentfault.com/?enc=htcI53TABQIyZvEsJYW71Q==.unimpAAdzaGhXKHQW7KWA91G1A4tosHPDnl+8XaBTdCL1hgTUJjpoJAVuWVwd7lN">面试 – 网络 HTTP</a></li><li><a href="https://link.segmentfault.com/?enc=82nBN7dYdUuZoHvIfsRIRA==.qCWbi6huMESIzfhbDdnlyhID0r9p5Wfj4l2lQsIJ1rSPiUB2WbW548wf4SNOD8fM">HTTP最强资料大全</a></li><li><a href="https://link.segmentfault.com/?enc=uGU52JWfHIoo+TrPxi+Efw==.TKC0SnLpUcCdlCtFJHsnggl+1Zk2s1XaosZL+coBNm7meMm6eGGXeubDOSvVRTqP">我知道的HTTP请求</a></li></ul><h2 id="性能-amp-优化篇"><a href="#性能-amp-优化篇" class="headerlink" title="性能&amp;优化篇"></a>性能&amp;优化篇</h2><ul><li><a href="https://link.segmentfault.com/?enc=+A1YrLcP/YA6XXeSoZP2eg==.4OQAFRcCboFPLDW2Y1qENESqHSptnx6PFajtSD0oUHg2kbPDDxsmHdc6pOQqGrsD">浏览器的回流与重绘 (Reflow &amp; Repaint)</a></li><li><a href="https://segmentfault.com/a/1190000008377508">浏览器缓存</a></li><li><a href="https://link.segmentfault.com/?enc=SGj46u+c0Nvdzlw0bfXlgQ==.92vGvYKChee2ufr2ittF/xaSyD5d+VJZiJ6e0OWMj0lKnf3l/SghJzoppgQUcaH2y2vfbv4o4XzSKyul2AW+zDUwdC+q5XpM8uNOtCjx9RXV9Pwc7d4s3rMOfSgy1JxH">浏览器前端优化</a></li><li><a href="https://link.segmentfault.com/?enc=UswvHkm+rjWkj70UGDk5tg==.3oXY7COkgQPyY9b+NiFm02estiPw6acrFTfSHFLfXBfQ+UoEasD4M7vPmD6+J8vI">浏览器渲染引擎</a></li><li><a href="https://link.segmentfault.com/?enc=/U2tR5A2zyyjFrvh+FFeIQ==.aHtO1E33QjoX2okqpn4IMfJ+V1xX4NrJ9JLLq+Uv2zTJMd3iXbfFIwwDhb+/hFNr">JavaScript 浏览器事件解析</a></li><li><a href="https://link.segmentfault.com/?enc=wxhu7/QNT5fup5a3rUMaAg==.lj7u62+f3tRzKdpWlo74N/OzTAL4V48ibNbifhFDZgPJ5G4A2EUSRrSYRm9p4GA9V3twVNVlV0bJUoUc4XWtcA==">前端性能——监控起步</a></li><li><a href="https://link.segmentfault.com/?enc=IK7WRQhnGVZ3Vo9TsrHkrA==.0WjOuSYEHxU25vikgERt1hfIRICGOrDCidtm9jWx6lQ/6yLvBxKL+avYV6EsOmGa">javascript性能优化</a></li><li><a href="https://link.segmentfault.com/?enc=jzVWV4RAoJw+fynQ78zyeg==.9gtn0OrWElbY4oMrz09vA8i1tKto69P1KHgi99n20/Vuu5HtifbOoCSut+j5Vqay">浏览器性能优化-渲染性能</a></li><li><a href="https://link.segmentfault.com/?enc=bSh9OhBdumUB7+6C5ukIGg==.YN5D9a/NuTuWntjQOJo4f9bj91VwGpQHXDKN2T+N5dMXyvhCUO2yxi3GQD0sVUyR">浏览器渲染过程与性能优化</a></li><li><a href="https://link.segmentfault.com/?enc=VGaqZlX7/ztMowoISKLs1w==.yZIUe0GHw0n3fpWu3LODCHNsGkwyNTWToBy0jmzB0vuvXoupsU5MpYSYOqsYOJKF">现代浏览器性能优化-CSS篇</a></li><li><a href="https://link.segmentfault.com/?enc=dhSq/Mco5GBYnEueaTUWEA==.56jX7coieSnlIMcgDV9jG5VGXbNz0N1T2q8+DnBK1QUnwa7xZ8Y3QnDNvAGNt+H7">浏览器工作原理及web 性能优化</a></li></ul><h2 id="Webpack篇"><a href="#Webpack篇" class="headerlink" title="Webpack篇"></a>Webpack篇</h2><ul><li><a href="https://link.segmentfault.com/?enc=U/KQin4S3dsPmyJrUxuT2Q==.KK1ATJTO3kDaTb0cwdAgeuz4DDBMKLVWiD2LmJBDFXgL+Ou1xRGDWgqtpoWRkpLn">webpack详解</a></li><li><a href="https://link.segmentfault.com/?enc=5JUOI14rrispHPoEnBBFcw==.3N4/VV25rsGxP0iu/Y7+dZB0Noxs/tAbamNRVTJKU25qNlm9q/kGXzfDeq+H5LUn">Webpack4优化之路</a></li><li><a href="https://link.segmentfault.com/?enc=7cL37UNPzXBTfpHlOPrqCw==.agAwKius0ICJ6FKgJ6t1qePmSYH9yDxXqTG8QPjnHK4nkynPNFyLFXrU0sRWYItB">webpack4之高级篇</a></li><li><a href="https://link.segmentfault.com/?enc=eUO3zJoTv9a91Dh40ohtkA==.ffQAUpQJVkzjYogAFs/n4dyJ5Q7dCm1YFcrFXdxDjEGNfykUVACckOMBdrvkXrBF">webpack4-用之初体验，一起敲它十一遍</a></li><li><a href="https://link.segmentfault.com/?enc=yME63TDpWqpE5gOgI359XA==.LFHdRhFCv1Fevx75VCF60VeaFLRxX4oTaKaFcK9DWN4SYIWhx8DlnOXcqXGHP4JB">📚免费的渐进式教程：Webpack4的16篇讲解和16份代码</a></li><li><a href="https://link.segmentfault.com/?enc=2R2jJRc6x/tY8P8oHoaWOw==.0e2JHHqyb1tgQDMx92IbUhs+raEktJHvfxaAjdRaR2UHzfYVeQvpxoQogzt6yZTN">手写一个webpack4.0配置</a></li></ul><h2 id="React篇"><a href="#React篇" class="headerlink" title="React篇"></a>React篇</h2><ul><li><a href="https://link.segmentfault.com/?enc=DU1tXWXqCm0JxFSQgTNVuw==.LwO52u3DHgvzt5WnfkmvH7nZBAgKurR5vt95RE/FsZK4ysY+Nox0rYy1yXa91L46">五星推荐的系列文章清单</a></li><li><a href="https://link.segmentfault.com/?enc=Knuo0cH8zLxkpbB6x2IDyQ==.AAOr3oiNqdf2Bg9pvlWBk7NboLKFgbl7ovuHSHE0M4THru+DP/yWdnleXjw8LyRJ">胡子大哈React.js 小书</a></li><li><a href="https://link.segmentfault.com/?enc=sCbDTfwJ26Wks65cwbn4Rw==.D022bXmNSm37H6wp1WiX/K47uhMif767Yc9jIQN3lfVdk3F9Web55spVZauvG68x">TypeScript 2.8下的终极React组件模式</a></li></ul><h2 id="面试篇"><a href="#面试篇" class="headerlink" title="面试篇"></a>面试篇</h2><ul><li><a href="https://link.segmentfault.com/?enc=AlPdhgZSuolxdpQgP6JS0A==.HQFLHX0mYNuM5fVmvSCYhWHGZH1YdDUQlPScjO74gJUosabWCgEUT6wcx0j3fd8O">HTML&amp;&amp;css面试题</a></li><li><a href="https://link.segmentfault.com/?enc=BF+90IenPikOw3+FRu8mbQ==.oqOVGEQBBrUckTadI2kTrWG/AffgA/rGF2OZm3nVtwZC1LRn6BfGcseQlXRN1W9k">Excuse me？这个前端面试在搞事！</a></li><li><a href="https://link.segmentfault.com/?enc=jsB91Q90SvOBTb4ttxbHow==.sEB9ijFuAhBdXeOXKDCVZ2A1dNAPuARNibypqjogFykYHv05+V/idbw4BpyA3/3k">80% 应聘者都不及格的 JS 面试题</a></li><li><a href="https://link.segmentfault.com/?enc=fpRfbKTT7PAMGOx5hhIS8Q==.TKolh7QBLb4hhqlQyhXPJSPdOzC9X+ofOplVjHDqLBifn1swDCvJGDkRXP0RxIP/">2019年前端面试都聊啥？一起来看看</a></li><li><a href="https://link.segmentfault.com/?enc=9MWqrLFV+YGZv+O1/wqCmg==.KFhsAZDS1+jsB/F7ggau9o4NquPQ9D9l4tjbg8N58398WEIEy0QHnCivFA+Wflf7">一篇文章搞定前端面试</a></li><li><a href="https://link.segmentfault.com/?enc=HnIAzscCSkeb903nPRdCGQ==.EE1XHDg5tbI1jF1jn74YnktCNX1McV+lnWnndlE/BNrdFkRbSl+3cLweI3O4CuLs">如何轻松拿到淘宝前端 offer | 掘金技术征文</a></li><li><a href="https://link.segmentfault.com/?enc=nq2072wg+qRQwjivuNurSQ==.ZLbUVGE+ara9hpye7btv++CMNyaaKCmIzoywjKHu0ilsHkUhVrBo93NudKcJB0rH">腾讯前端面试篇（一）</a></li><li><a href="https://link.segmentfault.com/?enc=xQaNIYA3hX+CFpJed1VacA==.0GQ1TBbD2NJLQl31ElRBimMf1o7lbXeb3Fj3Dct+A/FxQayniy8PXKXGh/wmQcQ3">腾讯前端面试篇（二）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 链接、前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring注解大全</title>
      <link href="/archives/8b620503.html"/>
      <url>/archives/8b620503.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>@Controller<br>@RestController：<br>@Service<br>@Autowired<br>@RequestMapping<br>@RequestParam<br>@ModelAttribute<br>@Cacheable<br>@CacheEvict<br>@Resource<br>@PostConstruct<br>@PreDestroy<br>@Repository<br>@Component<br>@Scope<br>@SessionAttributes<br>@Required<br>@Qualifier</p><span id="more"></span></blockquote><h3 id="1-Controller"><a href="#1-Controller" class="headerlink" title="1. @Controller"></a>1. @Controller</h3><p>标识一个该类是Spring MVC controller处理器，用来创建处理http请求的对象.</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">1</span><span class="token annotation punctuation">@Controller</span><span class="token number">2</span>public <span class="token keyword">class</span> <span class="token class-name">TestController</span> <span class="token punctuation">{</span><span class="token number">3</span>        <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/test"</span><span class="token punctuation">)</span><span class="token number">4</span>        <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> map<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token number">5</span><span class="token number">6</span>            <span class="token keyword">return</span> <span class="token string">"hello"</span><span class="token punctuation">;</span><span class="token number">7</span>        <span class="token punctuation">}</span><span class="token number">8</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-RestController"><a href="#2-RestController" class="headerlink" title="2. @RestController"></a>2. @RestController</h3><p>Spring4之后加入的注解，原来在@Controller中返回json需要@ResponseBody来配合，如果直接用@RestController替代@Controller就不需要再配置@ResponseBody，默认返回json格式。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">1</span><span class="token annotation punctuation">@RestController</span><span class="token number">2</span>public <span class="token keyword">class</span> <span class="token class-name">TestController</span> <span class="token punctuation">{</span><span class="token number">3</span>        <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/test"</span><span class="token punctuation">)</span><span class="token number">4</span>        <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> map<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token number">5</span><span class="token number">6</span>            <span class="token keyword">return</span> <span class="token string">"hello"</span><span class="token punctuation">;</span><span class="token number">7</span>        <span class="token punctuation">}</span><span class="token number">8</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-Service"><a href="#3-Service" class="headerlink" title="3. @Service"></a>3. @Service</h3><p>用于标注业务层组件，说白了就是加入你有一个用注解的方式把这个类注入到spring配置中</p><h3 id="4-Autowired"><a href="#4-Autowired" class="headerlink" title="4. @Autowired"></a>4. @Autowired</h3><p>用来装配bean，都可以写在字段上，或者方法上。<br>默认情况下必须要求依赖对象必须存在，如果要允许null值，可以设置它的required属性为false，例如：@Autowired(required=false)</p><h3 id="5-RequestMapping"><a href="#5-RequestMapping" class="headerlink" title="5. @RequestMapping"></a>5. @RequestMapping</h3><blockquote><p>类定义处: 提供初步的请求映射信息，相对于 WEB 应用的根目录。<br>方法处: 提供进一步的细分映射信息，相对于类定义处的 URL。</p></blockquote><p>用过RequestMapping的同学都知道，他有非常多的作用，因此详细的用法<br>我会在下一篇文章专门讲述，请关注公众号哦，以免错过。</p><h3 id="6-RequestParam"><a href="#6-RequestParam" class="headerlink" title="6. @RequestParam"></a>6. @RequestParam</h3><p>用于将请求参数区数据映射到功能处理方法的参数上<br>例如</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">1</span>public <span class="token class-name">Resp</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span> <span class="token class-name">Integer</span> id<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token number">2</span>        <span class="token keyword">return</span> <span class="token class-name">Resp</span><span class="token punctuation">.</span><span class="token function">success</span><span class="token punctuation">(</span>customerInfoService<span class="token punctuation">.</span><span class="token function">fetch</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">3</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这个id就是要接收从接口传递过来的参数id的值的，如果接口传递过来的参数名和你接收的不一致，也可以如下</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">1</span>public <span class="token class-name">Resp</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"course_id"</span><span class="token punctuation">)</span> <span class="token class-name">Integer</span> id<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token number">2</span>        <span class="token keyword">return</span> <span class="token class-name">Resp</span><span class="token punctuation">.</span><span class="token function">success</span><span class="token punctuation">(</span>customerInfoService<span class="token punctuation">.</span><span class="token function">fetch</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">3</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中course_id就是接口传递的参数，id就是映射course_id的参数名</p><h3 id="7-ModelAttribute"><a href="#7-ModelAttribute" class="headerlink" title="7. @ModelAttribute"></a>7. @ModelAttribute</h3><p>使用地方有三种：</p><blockquote><h4 id="1-标记在方法上。"><a href="#1-标记在方法上。" class="headerlink" title="1. 标记在方法上。"></a>1. 标记在方法上。</h4><p>标记在方法上，会在每一个@RequestMapping标注的方法前执行，如果有返回值，则自动&gt;将该返回值加入到ModelMap中。</p><blockquote><p>A.在有返回的方法上:<br>当ModelAttribute设置了value，方法返回的值会以这个value为key，以参数接受到的值作为value，存入到Model中，如下面的方法执行之后，最终相当于 model.addAttribute(“user_name”, name);假如 @ModelAttribute没有自定义value，则相当于<br>model.addAttribute(“name”, name);</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">1</span><span class="token annotation punctuation">@ModelAttribute</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"user_name"</span><span class="token punctuation">)</span><span class="token number">2</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">before2</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span>required <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">Model</span> model<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token number">3</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"进入了2："</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">4</span>        <span class="token keyword">return</span> name<span class="token punctuation">;</span><span class="token number">5</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>B.在没返回的方法上：<br>需要手动model.add方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">1</span>    <span class="token annotation punctuation">@ModelAttribute</span><span class="token number">2</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">before</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span>required <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token class-name">Integer</span> age<span class="token punctuation">,</span> <span class="token class-name">Model</span> model<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token number">3</span>        model<span class="token punctuation">.</span><span class="token function">addAttribute</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">4</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"进入了1："</span> <span class="token operator">+</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">5</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们在当前类下建一个请求方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"> <span class="token number">1</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"/mod"</span><span class="token punctuation">)</span> <span class="token number">2</span>    <span class="token keyword">public</span> <span class="token class-name">Resp</span> <span class="token function">mod</span><span class="token punctuation">(</span> <span class="token number">3</span>            <span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span>required <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token number">4</span>            <span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span>required <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token class-name">Integer</span> age<span class="token punctuation">,</span>  <span class="token number">5</span>            <span class="token class-name">Model</span> model<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token number">6</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"进入mod"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">7</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"参数接受的数值{name="</span><span class="token operator">+</span>name<span class="token operator">+</span><span class="token string">";age="</span><span class="token operator">+</span>age<span class="token operator">+</span><span class="token string">"}"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">8</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"model传过来的值:"</span><span class="token operator">+</span>model<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">9</span>        <span class="token keyword">return</span> <span class="token class-name">Resp</span><span class="token punctuation">.</span><span class="token function">success</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">10</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在浏览器中输入访问地址并且加上参数：<br><a href="https://link.segmentfault.com/?enc=kLLw8vJYjWLzZO27+gYQtQ==.OOxVpPBwujWW/qxU2bBXIRGnnhqW18xSHWYMMC10Ko0=">http://localhost</a>:8081/api/test/mod?name=我是小菜&amp;age=12</p><p>最终输出如下：</p><pre class="line-numbers language-none"><code class="language-none">1进入了1：402进入了2：我是小菜3进入mod4参数接受的数值{name=我是小菜;age=12}5model传过来的值:{age=40, user_name=我是小菜}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-标记在方法的参数上。"><a href="#2-标记在方法的参数上。" class="headerlink" title="2. 标记在方法的参数上。"></a>2. 标记在方法的参数上。</h4><p>标记在方法的参数上，会将客户端传递过来的参数按名称注入到指定对象中，并且会将这个对象自动加入ModelMap中，便于View层使用.<br>我们在上面的类中加入一个方法如下</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"> <span class="token number">1</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"/mod2"</span><span class="token punctuation">)</span> <span class="token number">2</span>    <span class="token keyword">public</span> <span class="token class-name">Resp</span> <span class="token function">mod2</span><span class="token punctuation">(</span><span class="token annotation punctuation">@ModelAttribute</span><span class="token punctuation">(</span><span class="token string">"user_name"</span><span class="token punctuation">)</span> <span class="token class-name">String</span> user_name<span class="token punctuation">,</span>  <span class="token number">3</span>            <span class="token annotation punctuation">@ModelAttribute</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span> <span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token number">4</span>            <span class="token annotation punctuation">@ModelAttribute</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">)</span> <span class="token class-name">Integer</span> age<span class="token punctuation">,</span><span class="token class-name">Model</span> model<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token number">5</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"进入mod2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">6</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"user_name:"</span><span class="token operator">+</span>user_name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">7</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"name："</span><span class="token operator">+</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">8</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"age:"</span><span class="token operator">+</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">9</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"model:"</span><span class="token operator">+</span>model<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">10</span>        <span class="token keyword">return</span> <span class="token class-name">Resp</span><span class="token punctuation">.</span><span class="token function">success</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">11</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在浏览器中输入访问地址并且加上参数：<br><a href="https://link.segmentfault.com/?enc=hY+T1n7GdqDl0sXGM2rwaw==.j/DzBgXJ58l1qsSbdam7gKCKQMDkj1URX/2uXjKJMys=">http://localhost</a>:8081/api/test/mod2?name=我是小菜&amp;age=12<br>最终输出：</p><pre class="line-numbers language-none"><code class="language-none">1进入了1：402进入了2：我是小菜3进入mod24user_name:我是小菜5name：我是小菜6age:407model:{user_name=我是小菜, <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>org.springframework.validation.BindingResult.user_name=org.springframework.validation.BeanPropertyBindingResult: 0 errors, name=我是小菜, org.springframework.validation.BindingResult.name=org.springframework.validation.BeanPropertyBindingResult: 0 errors, age=40, org.springframework.validation.BindingResult.age=org.springframework.validation.BeanPropertyBindingResult: 0 errors}<br>从结果就能看出，用在方法参数中的@ModelAttribute注解，实际上是一种接受参数并且自动放入Model对象中，便于使用。</p></blockquote></blockquote><h3 id="8-Cacheable"><a href="#8-Cacheable" class="headerlink" title="8. @Cacheable"></a>8. @Cacheable</h3><p>用来标记缓存查询。可用用于方法或者类中，</p><blockquote><p>当标记在一个方法上时表示该方法是支持缓存的，<br>当标记在一个类上时则表示该类所有的方法都是支持缓存的。</p></blockquote><h4 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a>参数列表</h4><table><thead><tr><th align="center">参数</th><th>解释</th><th>例子</th></tr></thead><tbody><tr><td align="center">value</td><td>名称</td><td>@Cacheable(value={”c1”,”c2”}</td></tr><tr><td align="center">key</td><td>key</td><td>@Cacheable(value=”c1”,key=”#id”)</td></tr><tr><td align="center">condition</td><td>条件</td><td>@Cacheable(value=”c1”,condition=”#id=1”)比如@Cacheable(value=”UserCache”) 标识的是当调用了标记了这个注解的方法时，逻辑默认加上从缓存中获取结果的逻辑，如果缓存中没有数据，则执行用户编写查询逻辑，查询成功之后，同时将结果放入缓存中。但凡说到缓存，都是key-value的形式的，因此key就是方法中的参数（id），value就是查询的结果，而命名空间UserCache是在spring*.xml中定义.</td></tr></tbody></table><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">1</span><span class="token annotation punctuation">@Cacheable</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"UserCache"</span><span class="token punctuation">)</span><span class="token comment">// 使用了一个缓存名叫 accountCache   </span><span class="token number">2</span>public <span class="token class-name">Account</span> <span class="token function">getUserAge</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token number">3</span>     <span class="token comment">//这里不用写缓存的逻辑，直接按正常业务逻辑走即可，</span><span class="token number">4</span>     <span class="token comment">//缓存通过切面自动切入  </span><span class="token number">5</span>    <span class="token keyword">int</span> age<span class="token operator">=</span><span class="token function">getUser</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token number">6</span>     <span class="token keyword">return</span> age<span class="token punctuation">;</span>   <span class="token number">7</span><span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="9-CacheEvict"><a href="#9-CacheEvict" class="headerlink" title="9. @CacheEvict"></a>9. @CacheEvict</h3><blockquote><p>用来标记要清空缓存的方法，当这个方法被调用后，即会清空缓存。 @CacheEvict(value=”UserCache”)</p></blockquote><h4 id="参数列表-1"><a href="#参数列表-1" class="headerlink" title="参数列表"></a>参数列表</h4><table><thead><tr><th align="center">参数</th><th>解释</th><th>例子</th></tr></thead><tbody><tr><td align="center">value</td><td>名称</td><td>@CachEvict(value={”c1”,”c2”}</td></tr><tr><td align="center">key</td><td>key</td><td>@CachEvict(value=”c1”,key=”#id”)</td></tr><tr><td align="center">condition</td><td>缓存的条件，可以为空</td><td></td></tr><tr><td align="center">allEntries</td><td>是否清空所有缓存内容</td><td>@CachEvict(value=”c1”，allEntries=true)</td></tr><tr><td align="center">beforeInvocation</td><td>是否在方法执行前就清空</td><td>@CachEvict(value=”c1”，beforeInvocation=true)</td></tr></tbody></table><h3 id="10-Resource"><a href="#10-Resource" class="headerlink" title="10. @Resource"></a>10. @Resource</h3><p>@Resource的作用相当于@Autowired<br>只不过@Autowired按byType自动注入，<br>而@Resource默认按 byName自动注入罢了。</p><p>@Resource有两个属性是比较重要的，分是name和type，Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入策略。</p><blockquote><p>@Resource装配顺序:</p><p>如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常</p><p>如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常</p><p>如果指定了type，则从上下文中找到类型匹配的唯一bean进行装配，找不到或者找到多个，都会抛出异常</p><p>如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配；</p></blockquote><h3 id="11-PostConstruct"><a href="#11-PostConstruct" class="headerlink" title="11. @PostConstruct"></a>11. @PostConstruct</h3><p>用来标记是在项目启动的时候执行这个方法。用来修饰一个非静态的void()方法<br>也就是spring容器启动时就执行，多用于一些全局配置、数据字典之类的加载</p><p>被@PostConstruct修饰的方法会在服务器加载Servlet的时候运行，并且只会被服务器执行一次。PostConstruct在构造函数之后执行,init()方法之前执行。PreDestroy（）方法在destroy()方法执行执行之后执</p><h3 id="12-PreDestroy"><a href="#12-PreDestroy" class="headerlink" title="12. @PreDestroy"></a>12. @PreDestroy</h3><p>被@PreDestroy修饰的方法会在服务器卸载Servlet的时候运行，并且只会被服务器调用一次，类似于Servlet的destroy()方法。被@PreDestroy修饰的方法会在destroy()方法之后运行，在Servlet被彻底卸载之前</p><h3 id="13-Repository"><a href="#13-Repository" class="headerlink" title="13. @Repository"></a>13. @Repository</h3><p>用于标注数据访问组件，即DAO组件</p><h3 id="14-Component"><a href="#14-Component" class="headerlink" title="14. @Component"></a>14. @Component</h3><p>泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注</p><h3 id="15-Scope"><a href="#15-Scope" class="headerlink" title="15. @Scope"></a>15. @Scope</h3><p>用来配置 spring bean 的作用域，它标识 bean 的作用域。<br>默认值是单例</p><blockquote><p>singleton:单例模式,全局有且仅有一个实例</p><p>prototype:原型模式,每次获取Bean的时候会有一个新的实例</p><p>request:request表示该针对每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP request内有效</p><p>session:session作用域表示该针对每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP session内有效</p><p>global session:只在portal应用中有用，给每一个 global http session 新建一个Bean实例。</p></blockquote><h3 id="16-SessionAttributes"><a href="#16-SessionAttributes" class="headerlink" title="16. @SessionAttributes"></a>16. @SessionAttributes</h3><p>默认情况下Spring MVC将模型中的数据存储到request域中。当一个请求结束后，数据就失效了。如果要跨页面使用。那么需要使用到session。而@SessionAttributes注解就可以使得模型中的数据存储一份到session域中</p><p>参数：</p><blockquote><p>names：这是一个字符串数组。里面应写需要存储到session中数据的名称。<br>types：根据指定参数的类型，将模型中对应类型的参数存储到session中<br>value：和names是一样的。</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"> <span class="token number">1</span><span class="token annotation punctuation">@Controller</span> <span class="token number">2</span><span class="token annotation punctuation">@SessionAttributes</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">"names"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>types<span class="token operator">=</span><span class="token punctuation">{</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token number">3</span>public <span class="token keyword">class</span> <span class="token class-name">ScopeService</span> <span class="token punctuation">{</span> <span class="token number">4</span>        <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/testSession"</span><span class="token punctuation">)</span> <span class="token number">5</span>        <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> map<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token number">6</span>            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"names"</span><span class="token punctuation">,</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token string">"b"</span><span class="token punctuation">,</span><span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">7</span>            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">8</span>            <span class="token keyword">return</span> <span class="token string">"hello"</span><span class="token punctuation">;</span> <span class="token number">9</span>        <span class="token punctuation">}</span><span class="token number">10</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="17-Required"><a href="#17-Required" class="headerlink" title="17. @Required"></a>17. @Required</h3><p>适用于bean属性setter方法，并表示受影响的bean属性必须在XML配置文件在配置时进行填充。否则，容器会抛出一个BeanInitializationException异常。</p><h3 id="18-Qualifier"><a href="#18-Qualifier" class="headerlink" title="18. @Qualifier"></a>18. @Qualifier</h3><p>当你创建多个具有相同类型的 bean 时，并且想要用一个属性只为它们其中的一个进行装配，在这种情况下，你可以使用 @Qualifier 注释和 @Autowired 注释通过指定哪一个真正的 bean 将会被装配来消除混乱。</p><p>-–</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat知识</title>
      <link href="/archives/6a02d6b9.html"/>
      <url>/archives/6a02d6b9.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="什么是Tomcat"><a href="#什么是Tomcat" class="headerlink" title="什么是Tomcat"></a>什么是Tomcat</h2><p>Tomcat简单的说就是一个运行JAVA的网络服务器，底层是Socket的一个程序，它也是JSP和Serlvet的一个容器。</p><hr><h2 id="为什么我们需要用到Tomcat"><a href="#为什么我们需要用到Tomcat" class="headerlink" title="为什么我们需要用到Tomcat"></a>为什么我们需要用到Tomcat</h2><p>如果你学过html，css，你会知道你写的页面只能自己访问，<strong>别人不能远程访问你写的页面</strong>，Tomcat就是<strong>提供能够让别人访问自己写的页面的一个程序</strong></p><p><img src="https://segmentfault.com/img/remote/1460000013228164?w=694&amp;h=483" alt="img"></p><span id="more"></span><hr><h2 id="配置Tomcat"><a href="#配置Tomcat" class="headerlink" title="配置Tomcat"></a>配置Tomcat</h2><p>运行Tomcat需要JDK的支持【Tomcat会通过JAVA_HOME找到所需要的JDK】。</p><ul><li><strong>新建JAVA_HOME环境变量</strong>【路径是JDK的主目录】</li></ul><p><img src="https://segmentfault.com/img/remote/1460000013228165?w=460&amp;h=558" alt="img"></p><ul><li><strong>进入Tomcat目录下的bin中启动startup.bat</strong>，以下是成功启动Tomcat的页面。</li></ul><p><img src="https://segmentfault.com/img/remote/1460000013228166?w=677&amp;h=443" alt="img"></p><ul><li>在浏览器地址栏输入<a href="https://link.segmentfault.com/?enc=bUjcdijEFEfthdzlrUudAQ==.U2YeR39IOs+MVao0jzamq1FKBwJfSy4RN6o3n1uNqus=">http://localhost</a>:8080,如果<strong>能够出现Tomcat页面，说明配置成功了</strong>！</li></ul><p><strong>注意：</strong>如果在使用Tomcat时出现了<code>Error deploying web application directory web222</code>,很大原因就是jdk和tomcat的版本不匹配。目前，<strong>jdk8不能匹配tomcat7.0</strong>，所以<strong>要降低jdk版本</strong>【换成JDK7】</p><hr><p>当然也有可能不是一帆风顺能够直接启动Tomcat，<strong>不能正常启动Tomcat会有以下情况</strong></p><ol><li>JAVA_HOME配置错误</li><li>端口被占用了<ul><li>第一种方法：在cmd输入netstat -anb查看谁占用了该端口【Tomcat默认的是8080】,在进程中关闭它</li><li>第二种方法：主动改变tomcat的端口, <strong>到tomcat主目录下的conf/server.xml文件中修改</strong>,把8080端口改成是8088或者是其他的‘</li><li><img src="https://segmentfault.com/img/remote/1460000013228145?w=855&amp;h=318" alt="img"></li></ul></li></ol><hr><h2 id="相关术语介绍"><a href="#相关术语介绍" class="headerlink" title="相关术语介绍"></a>相关术语介绍</h2><p><img src="https://segmentfault.com/img/remote/1460000013228167?w=522&amp;h=317" alt="img"></p><hr><h2 id="tomcat结构目录"><a href="#tomcat结构目录" class="headerlink" title="tomcat结构目录"></a>tomcat结构目录</h2><p><img src="https://segmentfault.com/img/remote/1460000013228168?w=728&amp;h=388" alt="img"></p><h3 id="目录的简单介绍"><a href="#目录的简单介绍" class="headerlink" title="目录的简单介绍"></a>目录的简单介绍</h3><ol><li>bin：启动和关闭tomcat的bat文件</li><li>conf：配置文件<ul><li><code>server.xml</code>该文件用于配置server相关的信息，比如tomcat启动的端口号，配置主机(Host)</li><li><code>web.xml</code>文件配置与web应用（web应用相当于一个web站点）</li><li><code>tomcat-user.xml</code>配置用户名密码和相关权限.</li></ul></li><li>lib：该目录放置运行tomcat运行需要的jar包</li><li>logs：存放日志，当我们需要查看日志的时候，可以查询信息</li><li>webapps：放置我们的web应用</li><li>work工作目录：该目录用于存放<strong>jsp被访问后生成对应的server文件和.class文件</strong></li></ol><hr><h3 id="webapps目录的详细说明"><a href="#webapps目录的详细说明" class="headerlink" title="webapps目录的详细说明"></a>webapps目录的详细说明</h3><p><strong>在webapps中建立了web1目录</strong>，下面放置我们的html文件，jsp文件，图片等等，<strong>则web1就被当做web应用管理起来</strong>【tomcat6.0以后的版本才支持】</p><p>例子：<strong>在webapps下创建一个web站点，在web站点下创建一个html文件，访问html文件</strong></p><p><img src="https://segmentfault.com/img/remote/1460000013228169?w=819&amp;h=571" alt="img"></p><hr><p><strong>web站点的目录是有规范的</strong><br><img src="https://segmentfault.com/img/remote/1460000013228170?w=926&amp;h=628" alt="img"></p><p>为什么要这样设置web站点目录呢？</p><ul><li>需求：我有多个html文件，想把其中的一个html文件作为我web站点的首页。</li><li>如果<strong>没有WEB-INF目录下的web.xml文件支持，是无法解决我的需求的</strong></li><li><strong>这个规范是约定熟成的。</strong></li></ul><hr><p>下面将web站点下的helloword2.xml文件作为站点的首页</p><ul><li>新建一个WEB-INF目录</li></ul><p><img src="https://segmentfault.com/img/remote/1460000013228171?w=770&amp;h=154" alt="img"></p><ul><li>在WEB-INF目录下创建一个web.xml</li></ul><p><img src="https://segmentfault.com/img/remote/1460000013228172?w=770&amp;h=154" alt="img"></p><ul><li>web.xml我们不可能会写，所以可以<strong>在webapps目录下其他的站点中抄一份过来</strong>【复制ROOT/WEB-INF/web.xml的文件到自己的站点中】</li><li>在web.xml中添加以下代码</li></ul><pre class="line-numbers language-applescript" data-language="applescript"><code class="language-applescript"><span class="token operator">&lt;</span>welcome<span class="token operator">-</span><span class="token class-name">file</span><span class="token operator">-</span><span class="token class-name">list</span><span class="token operator">&gt;</span>      <span class="token operator">&lt;</span>welcome<span class="token operator">-</span><span class="token class-name">file</span><span class="token operator">&gt;</span>helloword2.html<span class="token operator">&lt;</span><span class="token operator">/</span>welcome<span class="token operator">-</span><span class="token class-name">file</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>welcome<span class="token operator">-</span><span class="token class-name">file</span><span class="token operator">-</span><span class="token class-name">list</span><span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://segmentfault.com/img/remote/1460000013228173?w=1050&amp;h=860" alt="img"></p><ul><li>访问web站点【<strong>helloword2.html已经是web站点的首页了，所以不需要指定资源访问了</strong>】</li></ul><p><img src="https://segmentfault.com/img/remote/1460000013228174?w=726&amp;h=195" alt="img"></p><hr><h2 id="配置虚拟目录"><a href="#配置虚拟目录" class="headerlink" title="配置虚拟目录"></a>配置虚拟目录</h2><h3 id="为什么需要配置虚拟目录？"><a href="#为什么需要配置虚拟目录？" class="headerlink" title="为什么需要配置虚拟目录？"></a>为什么需要配置虚拟目录？</h3><ul><li>如果把所有web站点的目录都放在webapps下，可能导致<strong>磁盘空间不够用</strong>，也<strong>不利于对web站点目录的管理</strong>【如果存在非常多的web站点目录】</li><li>把<strong>web站点的目录分散到其他磁盘管理就需要配置虚拟目录【默认情况下，只有webapps下的目录才能被Tomcat自动管理成一个web站点】</strong></li><li>把web应用所在目录交给web服务器管理，这个过程称之为虚拟目录的映射</li></ul><hr><h3 id="配置虚拟目录方法一："><a href="#配置虚拟目录方法一：" class="headerlink" title="配置虚拟目录方法一："></a>配置虚拟目录方法一：</h3><ul><li>在其他盘符下创建一个web站点目录，并创建WEB-INF目录和一个html文件。</li></ul><p><img src="https://segmentfault.com/img/remote/1460000013228146?w=1106&amp;h=243" alt="img"></p><ul><li>找到Tomcat目录下/conf/server.xml文件</li></ul><p><img src="https://segmentfault.com/img/remote/1460000013228147?w=1184&amp;h=323" alt="img"></p><ul><li>在server.xml中的<host>节点下添加如下代码。<strong>path表示的是访问时输入的web项目名，docBase表示的是站点目录的绝对路径</strong></host></li></ul><pre class="line-numbers language-routeros" data-language="routeros"><code class="language-routeros">&lt;Context path="/web1" docBase="D:\web1"/&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://segmentfault.com/img/remote/1460000013228148?w=1332&amp;h=673" alt="img"></p><ul><li>访问配置好的web站点</li></ul><p><img src="https://segmentfault.com/img/remote/1460000013228149?w=726&amp;h=195" alt="img"></p><hr><h3 id="配置虚拟目录方法二："><a href="#配置虚拟目录方法二：" class="headerlink" title="配置虚拟目录方法二："></a>配置虚拟目录方法二：</h3><ul><li>进入到confCatalinalocalhost文件下，创建一个xml文件，<strong>该文件的名字就是站点的名字。</strong></li></ul><p><img src="https://segmentfault.com/img/remote/1460000013228150?w=1056&amp;h=243" alt="这里写图片描述"></p><ul><li>xml文件的代码如下，<strong>docBase是你web站点的绝对路径</strong></li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Context</span>     <span class="token attr-name">docBase</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>D:\web1<span class="token punctuation">"</span></span>     <span class="token attr-name">reloadable</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Context</span><span class="token punctuation">&gt;</span></span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>访问web站点下的html资源</li></ul><p><img src="https://segmentfault.com/img/remote/1460000013228151?w=1538&amp;h=267" alt="这里写图片描述"></p><hr><h2 id="配置临时域名"><a href="#配置临时域名" class="headerlink" title="配置临时域名"></a>配置临时域名</h2><p>访问Tomcat服务器有好几种方式</p><ul><li>使用localhost域名访问【localhost代表本机】</li><li>使用ip地址127.0.0.1访问【该ip地址也是本机】</li><li>使用机器名称访问【只限用于本机上或者局域网】</li><li>使用本机IP地址访问【<strong>在cmd中输入ipconfig可以查询到本机IP地址</strong>】</li><li>还可以为机器配置临时域名</li></ul><h3 id="配置临时域名步骤"><a href="#配置临时域名步骤" class="headerlink" title="配置临时域名步骤"></a>配置临时域名步骤</h3><ul><li>打开到C:WindowsSystem32driversetc下，找到hosts文件</li></ul><p><img src="https://segmentfault.com/img/remote/1460000013228175?w=1184&amp;h=243" alt="img"></p><ul><li>在hosts文件下配置临时域名</li></ul><p><img src="https://segmentfault.com/img/remote/1460000013228176?w=1453&amp;h=407" alt="img"></p><hr><h2 id="设置虚拟主机"><a href="#设置虚拟主机" class="headerlink" title="设置虚拟主机"></a>设置虚拟主机</h2><h3 id="什么是虚拟主机？"><a href="#什么是虚拟主机？" class="headerlink" title="什么是虚拟主机？"></a>什么是虚拟主机？</h3><p><strong>多个不同域名的网站共存于一个Tomcat中</strong></p><h3 id="为什么需要用到虚拟主机？"><a href="#为什么需要用到虚拟主机？" class="headerlink" title="为什么需要用到虚拟主机？"></a>为什么需要用到虚拟主机？</h3><p>例子：我现在开发了4个网站，有4个域名。如果我不配置虚拟主机，一个Tomcat服务器运行一个网站，我就需要4台电脑才能把4个网站运行起来。</p><h3 id="配置虚拟主机的步骤"><a href="#配置虚拟主机的步骤" class="headerlink" title="配置虚拟主机的步骤"></a>配置虚拟主机的步骤</h3><ul><li>在tomcat的server.xml文件中添加主机名</li></ul><pre class="line-numbers language-abnf" data-language="abnf"><code class="language-abnf">&lt;Host <span class="token rule">name</span><span class="token operator">=</span><span class="token string">"zhongfucheng"</span> <span class="token definition keyword">appBase</span><span class="token operator">=</span><span class="token string">"D:\web1"</span>&gt;              &lt;Context <span class="token rule">path</span><span class="token operator">=</span><span class="token string">"/web1"</span> <span class="token definition keyword">docBase</span><span class="token operator">=</span><span class="token string">"D:\web1"</span><span class="token operator">/</span>&gt;<span class="token rule"><span class="token punctuation">&lt;</span>/Host<span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://segmentfault.com/img/remote/1460000013228177?w=1137&amp;h=407" alt="img"></p><ul><li>访问虚拟主机下的web站点</li></ul><p><img src="https://segmentfault.com/img/remote/1460000013228178?w=784&amp;h=197" alt="img"></p><hr><h2 id="Tomcat体系结构"><a href="#Tomcat体系结构" class="headerlink" title="Tomcat体系结构"></a>Tomcat体系结构</h2><p><img src="https://segmentfault.com/img/remote/1460000013228179?w=983&amp;h=593" alt="img"></p><hr><h2 id="浏览器访问WEB资源的流程图"><a href="#浏览器访问WEB资源的流程图" class="headerlink" title="浏览器访问WEB资源的流程图"></a>浏览器访问WEB资源的流程图</h2><p><img src="https://segmentfault.com/img/remote/1460000013228180?w=953&amp;h=561" alt="img"></p><hr><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>在浏览器输入http//:zhongfucheng直接显示到页面</p><p>分析：</p><ol><li>需要配置虚拟主机</li><li>把8080端口改成80</li><li>设置web站点首页</li><li>映射虚拟目录为/</li></ol><p><img src="https://segmentfault.com/img/remote/1460000013228181?w=1114&amp;h=217" alt="img"></p><blockquote><p>如果文章有错的地方欢迎指正，大家互相交流。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Javaweb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git常用命令</title>
      <link href="/archives/caff8000.html"/>
      <url>/archives/caff8000.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h2><ol><li><p>git branch 创建分支</p></li><li><p>git checkout -b 创建并切换到新建的分支上</p></li><li><p>git checkout 切换分支</p></li><li><p>git branch 查看分支列表</p></li><li><p>git branch -v 查看所有分支的最后一次操作</p></li><li><p>git branch -vv 查看当前分支</p></li><li><p>git brabch -b 分支名 origin/分支名 创建远程分支到本地</p></li><li><p>git branch –merged 查看别的分支和当前分支合并过的分支</p></li><li><p>git branch –no-merged 查看未与当前分支合并的分支</p><span id="more"></span></li><li><p>git branch -d 分支名 删除本地分支</p></li><li><p>git branch -D 分支名 强行删除分支</p></li><li><p>git branch origin :分支名 删除远处仓库分支</p></li><li><p>git merge 分支名 合并分支到当前分支上</p></li></ol><h2 id="暂存操作"><a href="#暂存操作" class="headerlink" title="暂存操作"></a>暂存操作</h2><ol><li>git stash 暂存当前修改</li><li>git stash apply 恢复最近的一次暂存</li><li>git stash pop 恢复暂存并删除暂存记录</li><li>git stash list 查看暂存列表</li><li>git stash drop 暂存名(例：stash@{0}) 移除某次暂存</li><li>git stash clear 清除暂存</li></ol><h2 id="回退操作"><a href="#回退操作" class="headerlink" title="回退操作"></a>回退操作</h2><ol><li>git reset –hard HEAD^ 回退到上一个版本</li><li>git reset –hard ahdhs1(commit_id) 回退到某个版本</li><li>git checkout – file撤销修改的文件(如果文件加入到了暂存区，则回退到暂存区的，如果文件加入到了版本库，则还原至加入版本库之后的状态)</li><li>git reset HEAD file 撤回暂存区的文件修改到工作区</li></ol><h2 id="标签操作"><a href="#标签操作" class="headerlink" title="标签操作"></a>标签操作</h2><ol><li>git tag 标签名 添加标签(默认对当前版本)</li><li>git tag 标签名 commit_id 对某一提交记录打标签</li><li>git tag -a 标签名 -m ‘描述’ 创建新标签并增加备注</li><li>git tag 列出所有标签列表</li><li>git show 标签名 查看标签信息</li><li>git tag -d 标签名 删除本地标签</li><li>git push origin 标签名 推送标签到远程仓库</li><li>git push origin –tags 推送所有标签到远程仓库</li><li>git push origin :refs/tags/标签名 从远程仓库中删除标签</li></ol><h2 id="其它操作"><a href="#其它操作" class="headerlink" title="其它操作"></a>其它操作</h2><h3 id="常规操作"><a href="#常规操作" class="headerlink" title="常规操作"></a>常规操作</h3><ol><li>git push origin test 推送本地分支到远程仓库</li><li>git rm -r –cached 文件/文件夹名字 取消文件被版本控制</li><li>git reflog 获取执行过的命令</li><li>git log –graph 查看分支合并图</li><li>git merge –no-ff -m ‘合并描述’ 分支名 不使用Fast forward方式合并，采用这种方式合并可以看到合并记录</li><li>git check-ignore -v 文件名 查看忽略规则</li><li>git add -f 文件名 强制将文件提交</li></ol><h3 id="git创建项目仓库"><a href="#git创建项目仓库" class="headerlink" title="git创建项目仓库"></a>git创建项目仓库</h3><p>1、git init 初始化<br>2、git remote add origin url 关联远程仓库<br>3、git pull<br>4、git fetch 获取远程仓库中所有的分支到本地</p><h3 id="忽略已加入到版本库中的文件"><a href="#忽略已加入到版本库中的文件" class="headerlink" title="忽略已加入到版本库中的文件"></a>忽略已加入到版本库中的文件</h3><p>1、git update-index –assume-unchanged file 忽略单个文件<br>2、git rm -r –cached 文件/文件夹名字 (. 忽略全部文件)</p><h3 id="取消忽略文件"><a href="#取消忽略文件" class="headerlink" title="取消忽略文件"></a>取消忽略文件</h3><p>git update-index –no-assume-unchanged file</p><h3 id="拉取、上传免密码"><a href="#拉取、上传免密码" class="headerlink" title="拉取、上传免密码"></a>拉取、上传免密码</h3><p>git config –global credential.helper store</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring事物传播行为</title>
      <link href="/archives/785f467a.html"/>
      <url>/archives/785f467a.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Spring在TransactionDefinition接口中规定了7种类型的事务传播行为。事务传播行为是Spring框架独有的事务增强特性，他不属于的事务实际提供方数据库行为。这是Spring为我们提供的强大的工具箱，使用事务传播行可以为我们的开发工作提供许多便利。但是人们对他的误解也颇多，你一定也听过“service方法事务最好不要嵌套”的传言。要想正确的使用工具首先需要了解工具。本文对七种事务传播行为做详细介绍，内容主要代码示例的方式呈现。</p><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="1-什么是事务传播行为？"><a href="#1-什么是事务传播行为？" class="headerlink" title="1. 什么是事务传播行为？"></a>1. 什么是事务传播行为？</h3><p>事务传播行为用来描述由某一个事务传播行为修饰的方法被嵌套进另一个方法的时事务如何传播。</p><span id="more"></span><p>用伪代码说明：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">methodA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token function">methodB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//doSomething</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Transaction</span><span class="token punctuation">(</span><span class="token class-name">Propagation</span><span class="token operator">=</span>XXX<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">methodB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token comment">//doSomething</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码中<code>methodA()</code>方法嵌套调用了<code>methodB()</code>方法，<code>methodB()</code>的事务传播行为由<code>@Transaction(Propagation=XXX)</code>设置决定。这里需要注意的是<code>methodA()</code>并没有开启事务，某一个事务传播行为修饰的方法并不是必须要在开启事务的外围方法中调用。</p><h3 id="2-Spring中七种事务传播行为"><a href="#2-Spring中七种事务传播行为" class="headerlink" title="2. Spring中七种事务传播行为"></a>2. Spring中七种事务传播行为</h3><table><thead><tr><th>事务传播行为类型</th><th>说明</th></tr></thead><tbody><tr><td>PROPAGATION_REQUIRED</td><td>如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。</td></tr><tr><td>PROPAGATION_SUPPORTS</td><td>支持当前事务，如果当前没有事务，就以非事务方式执行。</td></tr><tr><td>PROPAGATION_MANDATORY</td><td>使用当前的事务，如果当前没有事务，就抛出异常。</td></tr><tr><td>PROPAGATION_REQUIRES_NEW</td><td>新建事务，如果当前存在事务，把当前事务挂起。</td></tr><tr><td>PROPAGATION_NOT_SUPPORTED</td><td>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</td></tr><tr><td>PROPAGATION_NEVER</td><td>以非事务方式执行，如果当前存在事务，则抛出异常。</td></tr><tr><td>PROPAGATION_NESTED</td><td>如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</td></tr></tbody></table><p>定义非常简单，也很好理解，下面我们就进入代码测试部分，验证我们的理解是否正确。</p><h2 id="代码验证"><a href="#代码验证" class="headerlink" title="代码验证"></a>代码验证</h2><p>文中代码以传统三层结构中两层呈现，即Service和Dao层，由Spring负责依赖注入和注解式事务管理，DAO层由Mybatis实现，你也可以使用任何喜欢的方式，例如，Hibernate,JPA,JDBCTemplate等。数据库使用的是MySQL数据库，你也可以使用任何支持事务的数据库，并不会影响验证结果。</p><p>首先我们在数据库中创建两张表：</p><p><strong>user1</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>user1<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>  <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">INTEGER</span> <span class="token keyword">UNSIGNED</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span> <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">45</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">''</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">ENGINE</span> <span class="token operator">=</span> <span class="token keyword">InnoDB</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>user2</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>user2<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>  <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">INTEGER</span> <span class="token keyword">UNSIGNED</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span> <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">45</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">''</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">ENGINE</span> <span class="token operator">=</span> <span class="token keyword">InnoDB</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后编写相应的Bean和DAO层代码：</p><p><strong>User1</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User1</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>   <span class="token comment">//get和set方法省略...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>User2</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User2</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>   <span class="token comment">//get和set方法省略...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>User1Mapper</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">User1Mapper</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token class-name">User1</span> record<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">User1</span> <span class="token function">selectByPrimaryKey</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//其他方法省略...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>User2Mapper</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">User2Mapper</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token class-name">User2</span> record<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">User2</span> <span class="token function">selectByPrimaryKey</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//其他方法省略...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后也是具体验证的代码由service层实现，下面我们分情况列举。</p><h3 id="1-PROPAGATION-REQUIRED"><a href="#1-PROPAGATION-REQUIRED" class="headerlink" title="1.PROPAGATION_REQUIRED"></a>1.PROPAGATION_REQUIRED</h3><p>我们为User1Service和User2Service相应方法加上<code>Propagation.REQUIRED</code>属性。</p><p><strong>User1Service方法：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User1ServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">User1Service</span> <span class="token punctuation">{</span>    <span class="token comment">//省略其他...</span>    <span class="token annotation punctuation">@Override</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> <span class="token class-name">Propagation</span><span class="token punctuation">.</span>REQUIRED<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addRequired</span><span class="token punctuation">(</span><span class="token class-name">User1</span> user<span class="token punctuation">)</span><span class="token punctuation">{</span>        user1Mapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>User2Service方法：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User2ServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">User2Service</span> <span class="token punctuation">{</span>    <span class="token comment">//省略其他...</span>    <span class="token annotation punctuation">@Override</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> <span class="token class-name">Propagation</span><span class="token punctuation">.</span>REQUIRED<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addRequired</span><span class="token punctuation">(</span><span class="token class-name">User2</span> user<span class="token punctuation">)</span><span class="token punctuation">{</span>        user2Mapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> <span class="token class-name">Propagation</span><span class="token punctuation">.</span>REQUIRED<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addRequiredException</span><span class="token punctuation">(</span><span class="token class-name">User2</span> user<span class="token punctuation">)</span><span class="token punctuation">{</span>        user2Mapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-1-场景一"><a href="#1-1-场景一" class="headerlink" title="1.1 场景一"></a>1.1 场景一</h4><p>此场景外围方法没有开启事务。</p><p><strong>验证方法1：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">notransaction_exception_required_required</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">User1</span> user1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user1<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user1Service<span class="token punctuation">.</span><span class="token function">addRequired</span><span class="token punctuation">(</span>user1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">User2</span> user2<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user2<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"李四"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user2Service<span class="token punctuation">.</span><span class="token function">addRequired</span><span class="token punctuation">(</span>user2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>验证方法2：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">notransaction_required_required_exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">User1</span> user1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user1<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user1Service<span class="token punctuation">.</span><span class="token function">addRequired</span><span class="token punctuation">(</span>user1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">User2</span> user2<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user2<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"李四"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user2Service<span class="token punctuation">.</span><span class="token function">addRequiredException</span><span class="token punctuation">(</span>user2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>分别执行验证方法，结果：</p><table><thead><tr><th>验证方法序号</th><th>数据库结果</th><th>结果分析</th></tr></thead><tbody><tr><td>1</td><td>“张三”、“李四”均插入。</td><td>外围方法未开启事务，插入“张三”、“李四”方法在自己的事务中独立运行，外围方法异常不影响内部插入“张三”、“李四”方法独立的事务。</td></tr><tr><td>2</td><td>“张三”插入，“李四”未插入。</td><td>外围方法没有事务，插入“张三”、“李四”方法都在自己的事务中独立运行,所以插入“李四”方法抛出异常只会回滚插入“李四”方法，插入“张三”方法不受影响。</td></tr></tbody></table><p><strong>结论：通过这两个方法我们证明了在外围方法未开启事务的情况下<code>Propagation.REQUIRED</code>修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</strong></p><h4 id="1-2-场景二"><a href="#1-2-场景二" class="headerlink" title="1.2 场景二"></a>1.2 场景二</h4><p>外围方法开启事务，这个是使用率比较高的场景。</p><p><strong>验证方法1：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span> <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> <span class="token class-name">Propagation</span><span class="token punctuation">.</span>REQUIRED<span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">transaction_exception_required_required</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token class-name">User1</span> user1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     user1<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     user1Service<span class="token punctuation">.</span><span class="token function">addRequired</span><span class="token punctuation">(</span>user1<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token class-name">User2</span> user2<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     user2<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"李四"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     user2Service<span class="token punctuation">.</span><span class="token function">addRequired</span><span class="token punctuation">(</span>user2<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>验证方法2：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> <span class="token class-name">Propagation</span><span class="token punctuation">.</span>REQUIRED<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">transaction_required_required_exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">User1</span> user1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user1<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user1Service<span class="token punctuation">.</span><span class="token function">addRequired</span><span class="token punctuation">(</span>user1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">User2</span> user2<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user2<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"李四"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user2Service<span class="token punctuation">.</span><span class="token function">addRequiredException</span><span class="token punctuation">(</span>user2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>验证方法3：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Transactional</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">transaction_required_required_exception_try</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">User1</span> user1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user1<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user1Service<span class="token punctuation">.</span><span class="token function">addRequired</span><span class="token punctuation">(</span>user1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">User2</span> user2<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user2<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"李四"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        user2Service<span class="token punctuation">.</span><span class="token function">addRequiredException</span><span class="token punctuation">(</span>user2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"方法回滚"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>分别执行验证方法，结果：</p><table><thead><tr><th>验证方法序号</th><th>数据库结果</th><th>结果分析</th></tr></thead><tbody><tr><td>1</td><td>“张三”、“李四”均未插入。</td><td>外围方法开启事务，内部方法加入外围方法事务，外围方法回滚，内部方法也要回滚。</td></tr><tr><td>2</td><td>“张三”、“李四”均未插入。</td><td>外围方法开启事务，内部方法加入外围方法事务，内部方法抛出异常回滚，外围方法感知异常致使整体事务回滚。</td></tr><tr><td>3</td><td>“张三”、“李四”均未插入。</td><td>外围方法开启事务，内部方法加入外围方法事务，内部方法抛出异常回滚，即使方法被catch不被外围方法感知，整个事务依然回滚。</td></tr></tbody></table><p><strong>结论：以上试验结果我们证明在外围方法开启事务的情况下<code>Propagation.REQUIRED</code>修饰的内部方法会加入到外围方法的事务中，所有<code>Propagation.REQUIRED</code>修饰的内部方法和外围方法均属于同一事务，只要一个方法回滚，整个事务均回滚。</strong></p><h3 id="2-PROPAGATION-REQUIRES-NEW"><a href="#2-PROPAGATION-REQUIRES-NEW" class="headerlink" title="2.PROPAGATION_REQUIRES_NEW"></a>2.PROPAGATION_REQUIRES_NEW</h3><p>我们为User1Service和User2Service相应方法加上<code>Propagation.REQUIRES_NEW</code>属性。<br><strong>User1Service方法：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User1ServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">User1Service</span> <span class="token punctuation">{</span>    <span class="token comment">//省略其他...</span>    <span class="token annotation punctuation">@Override</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> <span class="token class-name">Propagation</span><span class="token punctuation">.</span>REQUIRES_NEW<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addRequiresNew</span><span class="token punctuation">(</span><span class="token class-name">User1</span> user<span class="token punctuation">)</span><span class="token punctuation">{</span>        user1Mapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> <span class="token class-name">Propagation</span><span class="token punctuation">.</span>REQUIRED<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addRequired</span><span class="token punctuation">(</span><span class="token class-name">User1</span> user<span class="token punctuation">)</span><span class="token punctuation">{</span>        user1Mapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>User2Service方法：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User2ServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">User2Service</span> <span class="token punctuation">{</span>    <span class="token comment">//省略其他...</span>    <span class="token annotation punctuation">@Override</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> <span class="token class-name">Propagation</span><span class="token punctuation">.</span>REQUIRES_NEW<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addRequiresNew</span><span class="token punctuation">(</span><span class="token class-name">User2</span> user<span class="token punctuation">)</span><span class="token punctuation">{</span>        user2Mapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> <span class="token class-name">Propagation</span><span class="token punctuation">.</span>REQUIRES_NEW<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addRequiresNewException</span><span class="token punctuation">(</span><span class="token class-name">User2</span> user<span class="token punctuation">)</span><span class="token punctuation">{</span>        user2Mapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-1-场景一"><a href="#2-1-场景一" class="headerlink" title="2.1 场景一"></a>2.1 场景一</h4><p>外围方法没有开启事务。</p><p><strong>验证方法1：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">notransaction_exception_requiresNew_requiresNew</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">User1</span> user1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user1<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user1Service<span class="token punctuation">.</span><span class="token function">addRequiresNew</span><span class="token punctuation">(</span>user1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">User2</span> user2<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user2<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"李四"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user2Service<span class="token punctuation">.</span><span class="token function">addRequiresNew</span><span class="token punctuation">(</span>user2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>验证方法2：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">notransaction_requiresNew_requiresNew_exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">User1</span> user1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user1<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user1Service<span class="token punctuation">.</span><span class="token function">addRequiresNew</span><span class="token punctuation">(</span>user1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">User2</span> user2<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user2<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"李四"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user2Service<span class="token punctuation">.</span><span class="token function">addRequiresNewException</span><span class="token punctuation">(</span>user2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>分别执行验证方法，结果：</p><table><thead><tr><th>验证方法序号</th><th>数据库结果</th><th>结果分析</th></tr></thead><tbody><tr><td>1</td><td>“张三”插入，“李四”插入。</td><td>外围方法没有事务，插入“张三”、“李四”方法都在自己的事务中独立运行,外围方法抛出异常回滚不会影响内部方法。</td></tr><tr><td>2</td><td>“张三”插入，“李四”未插入</td><td>外围方法没有开启事务，插入“张三”方法和插入“李四”方法分别开启自己的事务，插入“李四”方法抛出异常回滚，其他事务不受影响。</td></tr></tbody></table><p><strong>结论：通过这两个方法我们证明了在外围方法未开启事务的情况下<code>Propagation.REQUIRES_NEW</code>修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</strong></p><h4 id="2-2-场景二"><a href="#2-2-场景二" class="headerlink" title="2.2 场景二"></a>2.2 场景二</h4><p>外围方法开启事务。</p><p><strong>验证方法1：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> <span class="token class-name">Propagation</span><span class="token punctuation">.</span>REQUIRED<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">transaction_exception_required_requiresNew_requiresNew</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">User1</span> user1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user1<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user1Service<span class="token punctuation">.</span><span class="token function">addRequired</span><span class="token punctuation">(</span>user1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">User2</span> user2<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user2<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"李四"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user2Service<span class="token punctuation">.</span><span class="token function">addRequiresNew</span><span class="token punctuation">(</span>user2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">User2</span> user3<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user3<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"王五"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user2Service<span class="token punctuation">.</span><span class="token function">addRequiresNew</span><span class="token punctuation">(</span>user3<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>验证方法2：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> <span class="token class-name">Propagation</span><span class="token punctuation">.</span>REQUIRED<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">transaction_required_requiresNew_requiresNew_exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">User1</span> user1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user1<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user1Service<span class="token punctuation">.</span><span class="token function">addRequired</span><span class="token punctuation">(</span>user1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">User2</span> user2<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user2<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"李四"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user2Service<span class="token punctuation">.</span><span class="token function">addRequiresNew</span><span class="token punctuation">(</span>user2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">User2</span> user3<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user3<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"王五"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user2Service<span class="token punctuation">.</span><span class="token function">addRequiresNewException</span><span class="token punctuation">(</span>user3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>验证方法3：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> <span class="token class-name">Propagation</span><span class="token punctuation">.</span>REQUIRED<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">transaction_required_requiresNew_requiresNew_exception_try</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">User1</span> user1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user1<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user1Service<span class="token punctuation">.</span><span class="token function">addRequired</span><span class="token punctuation">(</span>user1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">User2</span> user2<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user2<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"李四"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user2Service<span class="token punctuation">.</span><span class="token function">addRequiresNew</span><span class="token punctuation">(</span>user2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">User2</span> user3<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user3<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"王五"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        user2Service<span class="token punctuation">.</span><span class="token function">addRequiresNewException</span><span class="token punctuation">(</span>user3<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"回滚"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>分别执行验证方法，结果：</p><table><thead><tr><th>验证方法序号</th><th>数据库结果</th><th>结果分析</th></tr></thead><tbody><tr><td>1</td><td>“张三”未插入，“李四”插入，“王五”插入。</td><td>外围方法开启事务，插入“张三”方法和外围方法一个事务，插入“李四”方法、插入“王五”方法分别在独立的新建事务中，外围方法抛出异常只回滚和外围方法同一事务的方法，故插入“张三”的方法回滚。</td></tr><tr><td>2</td><td>“张三”未插入，“李四”插入，“王五”未插入。</td><td>外围方法开启事务，插入“张三”方法和外围方法一个事务，插入“李四”方法、插入“王五”方法分别在独立的新建事务中。插入“王五”方法抛出异常，首先插入 “王五”方法的事务被回滚，异常继续抛出被外围方法感知，外围方法事务亦被回滚，故插入“张三”方法也被回滚。</td></tr><tr><td>3</td><td>“张三”插入，“李四”插入，“王五”未插入。</td><td>外围方法开启事务，插入“张三”方法和外围方法一个事务，插入“李四”方法、插入“王五”方法分别在独立的新建事务中。插入“王五”方法抛出异常，首先插入“王五”方法的事务被回滚，异常被catch不会被外围方法感知，外围方法事务不回滚，故插入“张三”方法插入成功。</td></tr></tbody></table><p><strong>结论：在外围方法开启事务的情况下<code>Propagation.REQUIRES_NEW</code>修饰的内部方法依然会单独开启独立事务，且与外部方法事务也独立，内部方法之间、内部方法和外部方法事务均相互独立，互不干扰。</strong></p><h3 id="3-PROPAGATION-NESTED"><a href="#3-PROPAGATION-NESTED" class="headerlink" title="3.PROPAGATION_NESTED"></a>3.PROPAGATION_NESTED</h3><p>我们为User1Service和User2Service相应方法加上<code>Propagation.NESTED</code>属性。<br><strong>User1Service方法：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User1ServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">User1Service</span> <span class="token punctuation">{</span>    <span class="token comment">//省略其他...</span>    <span class="token annotation punctuation">@Override</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> <span class="token class-name">Propagation</span><span class="token punctuation">.</span>NESTED<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addNested</span><span class="token punctuation">(</span><span class="token class-name">User1</span> user<span class="token punctuation">)</span><span class="token punctuation">{</span>        user1Mapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>User2Service方法：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User2ServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">User2Service</span> <span class="token punctuation">{</span>    <span class="token comment">//省略其他...</span>    <span class="token annotation punctuation">@Override</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> <span class="token class-name">Propagation</span><span class="token punctuation">.</span>NESTED<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addNested</span><span class="token punctuation">(</span><span class="token class-name">User2</span> user<span class="token punctuation">)</span><span class="token punctuation">{</span>        user2Mapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> <span class="token class-name">Propagation</span><span class="token punctuation">.</span>NESTED<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addNestedException</span><span class="token punctuation">(</span><span class="token class-name">User2</span> user<span class="token punctuation">)</span><span class="token punctuation">{</span>        user2Mapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-1-场景一"><a href="#3-1-场景一" class="headerlink" title="3.1 场景一"></a>3.1 场景一</h4><p>此场景外围方法没有开启事务。</p><p><strong>验证方法1：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">notransaction_exception_nested_nested</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">User1</span> user1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user1<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user1Service<span class="token punctuation">.</span><span class="token function">addNested</span><span class="token punctuation">(</span>user1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">User2</span> user2<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user2<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"李四"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user2Service<span class="token punctuation">.</span><span class="token function">addNested</span><span class="token punctuation">(</span>user2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>验证方法2：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">notransaction_nested_nested_exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">User1</span> user1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user1<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user1Service<span class="token punctuation">.</span><span class="token function">addNested</span><span class="token punctuation">(</span>user1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">User2</span> user2<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user2<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"李四"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user2Service<span class="token punctuation">.</span><span class="token function">addNestedException</span><span class="token punctuation">(</span>user2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>分别执行验证方法，结果：</p><table><thead><tr><th>验证方法序号</th><th>数据库结果</th><th>结果分析</th></tr></thead><tbody><tr><td>1</td><td>“张三”、“李四”均插入。</td><td>外围方法未开启事务，插入“张三”、“李四”方法在自己的事务中独立运行，外围方法异常不影响内部插入“张三”、“李四”方法独立的事务。</td></tr><tr><td>2</td><td>“张三”插入，“李四”未插入。</td><td>外围方法没有事务，插入“张三”、“李四”方法都在自己的事务中独立运行,所以插入“李四”方法抛出异常只会回滚插入“李四”方法，插入“张三”方法不受影响。</td></tr></tbody></table><p><strong>结论：通过这两个方法我们证明了在外围方法未开启事务的情况下<code>Propagation.NESTED</code>和<code>Propagation.REQUIRED</code>作用相同，修饰的内部方法都会新开启自己的事务，且开启的事务相互独立，互不干扰。</strong></p><h4 id="3-2-场景二"><a href="#3-2-场景二" class="headerlink" title="3.2 场景二"></a>3.2 场景二</h4><p>外围方法开启事务。</p><p><strong>验证方法1：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Transactional</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">transaction_exception_nested_nested</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">User1</span> user1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user1<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user1Service<span class="token punctuation">.</span><span class="token function">addNested</span><span class="token punctuation">(</span>user1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">User2</span> user2<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user2<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"李四"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user2Service<span class="token punctuation">.</span><span class="token function">addNested</span><span class="token punctuation">(</span>user2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>验证方法2：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Transactional</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">transaction_nested_nested_exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">User1</span> user1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user1<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user1Service<span class="token punctuation">.</span><span class="token function">addNested</span><span class="token punctuation">(</span>user1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">User2</span> user2<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user2<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"李四"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user2Service<span class="token punctuation">.</span><span class="token function">addNestedException</span><span class="token punctuation">(</span>user2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>验证方法3：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Transactional</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">transaction_nested_nested_exception_try</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">User1</span> user1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user1<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user1Service<span class="token punctuation">.</span><span class="token function">addNested</span><span class="token punctuation">(</span>user1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">User2</span> user2<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user2<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"李四"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        user2Service<span class="token punctuation">.</span><span class="token function">addNestedException</span><span class="token punctuation">(</span>user2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"方法回滚"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>分别执行验证方法，结果：</p><table><thead><tr><th>验证方法序号</th><th>数据库结果</th><th>结果分析</th></tr></thead><tbody><tr><td>1</td><td>“张三”、“李四”均未插入。</td><td>外围方法开启事务，内部事务为外围事务的子事务，外围方法回滚，内部方法也要回滚。</td></tr><tr><td>2</td><td>“张三”、“李四”均未插入。</td><td>外围方法开启事务，内部事务为外围事务的子事务，内部方法抛出异常回滚，且外围方法感知异常致使整体事务回滚。</td></tr><tr><td>3</td><td>“张三”插入、“李四”未插入。</td><td>外围方法开启事务，内部事务为外围事务的子事务，插入“李四”内部方法抛出异常，可以单独对子事务回滚。</td></tr></tbody></table><p><strong>结论：以上试验结果我们证明在外围方法开启事务的情况下<code>Propagation.NESTED</code>修饰的内部方法属于外部事务的子事务，外围主事务回滚，子事务一定回滚，而内部子事务可以单独回滚而不影响外围主事务和其他子事务</strong></p><h3 id="4-REQUIRED-REQUIRES-NEW-NESTED异同"><a href="#4-REQUIRED-REQUIRES-NEW-NESTED异同" class="headerlink" title="4. REQUIRED,REQUIRES_NEW,NESTED异同"></a>4. REQUIRED,REQUIRES_NEW,NESTED异同</h3><p>由“1.2 场景二”和“3.2 场景二”对比，我们可知：<br><strong>NESTED和REQUIRED修饰的内部方法都属于外围方法事务，如果外围方法抛出异常，这两种方法的事务都会被回滚。但是REQUIRED是加入外围方法事务，所以和外围事务同属于一个事务，一旦REQUIRED事务抛出异常被回滚，外围方法事务也将被回滚。而NESTED是外围方法的子事务，有单独的保存点，所以NESTED方法抛出异常被回滚，不会影响到外围方法的事务。</strong></p><p>由“2.2 场景二”和“3.2 场景二”对比，我们可知：<br><strong>NESTED和REQUIRES_NEW都可以做到内部方法事务回滚而不影响外围方法事务。但是因为NESTED是嵌套事务，所以外围方法回滚之后，作为外围方法事务的子事务也会被回滚。而REQUIRES_NEW是通过开启新的事务实现的，内部事务和外围事务是两个事务，外围事务回滚不会影响内部事务。</strong></p><h3 id="5-其他事务传播行为"><a href="#5-其他事务传播行为" class="headerlink" title="5. 其他事务传播行为"></a>5. 其他事务传播行为</h3><p>鉴于文章篇幅问题，其他事务传播行为的测试就不在此一一描述了，感兴趣的读者可以去源码中自己寻找相应测试代码和结果解释。传送门：<a href="https://link.segmentfault.com/?enc=XPnxgO60NuYvzxumdFsY6w==.+0KPYqSpK+2lVLyLsEpK86DIS0Lsp4D9t1XLeaRMjehV0oZQvOV4VED1gLgeN01i">https://github.com/TmTse/tran...</a></p><h2 id="模拟用例"><a href="#模拟用例" class="headerlink" title="模拟用例"></a>模拟用例</h2><p>介绍了这么多事务传播行为，我们在实际工作中如何应用呢？下面我来举一个示例：</p><p>假设我们有一个注册的方法，方法中调用添加积分的方法，如果我们希望添加积分不会影响注册流程（即添加积分执行失败回滚不能使注册方法也回滚），我们会这样写：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">UserService</span> <span class="token punctuation">{</span>          <span class="token annotation punctuation">@Transactional</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">register</span><span class="token punctuation">(</span><span class="token class-name">User</span> user<span class="token punctuation">)</span><span class="token punctuation">{</span>                         <span class="token keyword">try</span> <span class="token punctuation">{</span>             membershipPointService<span class="token punctuation">.</span><span class="token function">addPoint</span><span class="token punctuation">(</span><span class="token class-name">Point</span> point<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//省略...</span>         <span class="token punctuation">}</span>         <span class="token comment">//省略...</span>     <span class="token punctuation">}</span>     <span class="token comment">//省略...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们还规定注册失败要影响<code>addPoint()</code>方法（注册方法回滚添加积分方法也需要回滚），那么<code>addPoint()</code>方法就需要这样实现：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MembershipPointServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">MembershipPointService</span><span class="token punctuation">{</span>          <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> <span class="token class-name">Propagation</span><span class="token punctuation">.</span>NESTED<span class="token punctuation">)</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addPoint</span><span class="token punctuation">(</span><span class="token class-name">Point</span> point<span class="token punctuation">)</span><span class="token punctuation">{</span>                         <span class="token keyword">try</span> <span class="token punctuation">{</span>             recordService<span class="token punctuation">.</span><span class="token function">addRecord</span><span class="token punctuation">(</span><span class="token class-name">Record</span> record<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//省略...</span>         <span class="token punctuation">}</span>         <span class="token comment">//省略...</span>     <span class="token punctuation">}</span>     <span class="token comment">//省略...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们注意到了在<code>addPoint()</code>中还调用了<code>addRecord()</code>方法，这个方法用来记录日志。他的实现如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RecordServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">RecordService</span><span class="token punctuation">{</span>          <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> <span class="token class-name">Propagation</span><span class="token punctuation">.</span>NOT_SUPPORTED<span class="token punctuation">)</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addRecord</span><span class="token punctuation">(</span><span class="token class-name">Record</span> record<span class="token punctuation">)</span><span class="token punctuation">{</span>                                 <span class="token comment">//省略...</span>     <span class="token punctuation">}</span>     <span class="token comment">//省略...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们注意到<code>addRecord()</code>方法中<code>propagation = Propagation.NOT_SUPPORTED</code>，因为对于日志无所谓精确，可以多一条也可以少一条，所以<code>addRecord()</code>方法本身和外围<code>addPoint()</code>方法抛出异常都不会使<code>addRecord()</code>方法回滚，并且<code>addRecord()</code>方法抛出异常也不会影响外围<code>addPoint()</code>方法的执行。</p><p>通过这个例子相信大家对事务传播行为的使用有了更加直观的认识，通过各种属性的组合确实能让我们的业务实现更加灵活多样。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>通过上面的介绍，相信大家对Spring事务传播行为有了更加深入的理解，希望大家日常开发工作有所帮助。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>域名</title>
      <link href="/archives/c5f0d6d.html"/>
      <url>/archives/c5f0d6d.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>xin是什么域名？经常关注域名的朋友可能有注意到又新出了一个.xin域名。很多朋友对于xin是什么域名还不了解，随着域名后缀越来越多，很多朋友确实混淆不清，小编之所以了解.xin域名，是因为这个与马云有关。话不多说，本文将详细介绍下.xin域名是什么意思。</p><p><img src="https://img.jbzj.com/file_images/article/201511/2015111015360832.jpg" alt="xin是什么域名 .xin域名是什么意思？"></p><span id="more"></span><p><strong>xin是什么域名？</strong></p><p>.xin域名注册局：阿里巴巴集团</p><p>注册商：万网</p><p>域名类型：国际域名</p><p>.xin是一个网络诚信专属域名，音同“信”，意为诚信、信任、信赖！</p><p>作为全球首个诚信通用顶级域名，联合诚信评价机构（包括诚信通、芝麻信用等），希望在互联网的访问入口带有诚信标识，成为让用户信赖的域名，让诚信可见！无信不立，有xin有未来！</p><p>.xin域名简短易记，符合国人认知和拼写习惯，注册资源丰富。例如：zhima.xin（芝麻信用）、kai.xin（开心网）、wang.xin（网信）、fairy.xin、buji.xin等等。目前已经可以开始注册，普通.xin域名售价88元每年。</p><p><img src="https://img.jbzj.com/file_images/article/201511/2015111015360833.jpg" alt="xin是什么域名 .xin域名是什么意思？"></p><p><strong>.xin域名是什么意思？</strong></p><p>.xin域名是阿里巴巴创始人马云推出的主打诚信域名，欲以.xin域名打造全新的中国互联网诚信体系，马云曾说：“诚信是生产力！信用危机时代，如何让信用升值？马云希望借助.xin域名构建诚信网络体系！</p><p><strong>.xin域名特点：</strong></p><p>唯一性：开创了以域名为网络诚信标识的网络诚信体系，资源唯一，便于识别和展现； </p><p>应用化：将诚信打造为一个应用，一方面可通过开放API将网络诚信体系查询应用于互联网的，另一方面可以建立及时更新的诚信记录机制；</p><p>适用性：面向企业和个人同时适用，无论个人还是企业，都有诚信体系记录和评价体系，通过此注册局都可以展示，用户可以用户建设网站或者用于投资；</p><p><strong>科普：</strong></p><p>目前国内可以注册的域名众多，包括.com、.cn、.net、.com.cn等等，这些都是大家比较熟悉的域名，其中.com域名最值钱，四位纯数字域名如今报价都在10w以上，而且价格一直再涨，行情非常好，具备良好的投资价值，只是目前好的.com域名基本绝了，要想拥有，只能高价买。</p><p>而目前比较热门的几个新顶级域名有.cc、.xyz .win .top、.xin.wang .one .ooo 等等，.xin就是新顶级域名中的一些，相信马云，可以考虑选择.xin域名，后期是否会成为主流，目前还不好说！</p><p>想要建立网站，选择一个合适的<a href="https://www.jpisp.com/domain/top-domain-registration.php?s=Eleven&amp;d=20220426">域名</a>是很重要的事。现在网络上开放了许多域名可以供大家选择注册。要选择合适自己的，就应该先了解这些域名的特点。那么今天老刀就为大家介绍一下top域名～都有哪些优势？</p><h2 id="什么是-top域名"><a href="#什么是-top域名" class="headerlink" title="什么是.top域名?"></a>什么是.top域名?</h2><p>.top(dot top)，Internet网络域名，是国际通用顶级域名GTLD(Generictop-level domain top)。并不属于任何单独国家。于2012年通过ICANN审核通过。于2014年8月3日完成入根，正式成为全球顶级<a href="https://www.iisp.com/domain/">通用域名</a>。于2014年11月18日全球开放注册。</p><p>2015年4月，**<a href="https://www.jpisp.com/domain/top-domain-registration.php?s=Eleven&amp;d=20220426">.top域名</a>**获工信部资质审批，可以在国内进行ICP备案，正常使用。<br>2011.06.20 ICANN宣布2012年开放申请<br>2011.06.20 在线提交.top申请<br>2012.06.09 进入ICANN申请公示名单<br>2013.06.28 申请通过ICANN初始评估程序<br>2014.03.20 与ICANN正式签约.top<br>2014.08.03 入DNS全球根服务器<br>2014.10.15 .top进入日升期注册<br>2014.11.18 .top进入全球开放注册2014年7月14日，发布《.top<a href="https://www.iisp.com/domain/">域名</a>作为通用顶级域名新字符串报告》报告显示.top域名所有申请流程已经完成。</p><p>2014年8月4日ICANN在其官网宣布，“.top”新通用顶级域名入根国际申请已完成所有评审环节，正式写入互联网根域。</p><p>截止2014年9月15日“.top”域名技术调试和顶级节点升级工作已完成，2014年11月18日开放注册，供全球网民注册使用，全球网民在世界任何地区在浏览器地址栏中直接输入“.TOP”即可访问相应网站，中国网站用户可以直接将中文名称注册成“中文.top”供网民访问。</p><p>2014.9.15-10.14公示期注册通知阶段，2014.11.18 全球开放注册。</p><h2 id="top域名有什么特点？"><a href="#top域名有什么特点？" class="headerlink" title=".top域名有什么特点？"></a>.top域名有什么特点？</h2><p>.top域名的英文意译可解释为“顶级、高端、高级、首席、顶端”等正能量词，中文音译为“突破”，其旨在建立一个“高端定位，突破自我”的域名体系。</p><p>作为在国际市场认可度极高的.top域名，本身具有高端的品牌调性，更能体现自身的价值和定位，吸引力极高，传播性极度广泛，各大品牌均能借势.top域名宣传。而且其拥有大量易记、易识别的优质域名资源，是众多一流企业、人才的选择。</p><p><img src="https://pic4.zhimg.com/80/v2-c406cd878724f2a9b9796b769977f67b_720w.jpg" alt="img"></p><h2 id="top域名有什么价值优势？"><a href="#top域名有什么价值优势？" class="headerlink" title=".top域名有什么价值优势？"></a>.top域名有什么价值优势？</h2><p>1、拥有宽松的申请政策，宽松的准入制度对于把握瞬息变化的互联网市场而言至关重要;</p><p>2、与国际接轨，全球高知名度标识。.top拥有“顶级”英语语系释义，其基本释义已经蕴含其品牌定位;</p><p>3、原始完整的资源拼盘，大量简短、易记、有意义的域名资源潜藏着无限可能，均能满足用户的各种需求。</p><p><strong>适用企业及人群：</strong></p><p>1、高端品牌的网站和有卓越追求的网站等;</p><p>2、需要创新改革的企业、政府、事业单位及其他组织的网络和个人应用的网站等;</p><p>3、对现有域名前缀不满意，有更换域名需求的网站;</p><p>4、品牌保护的需求;</p><p>5、域名投资的需求。</p><h2 id="top域名可以在哪里注册呢？"><a href="#top域名可以在哪里注册呢？" class="headerlink" title=".top域名可以在哪里注册呢？"></a>.top域名可以在哪里注册呢？</h2><p>先说一下申请规则：</p><p>(1)申请注册的域名</p><p>(2)域名主域名服务器和辅域名服务器的主机名以及IP地址</p><p>(3)申请者为自然人的，应提交姓名、通信地址、联系电话、电子邮箱等；申请者为组织的，应提交其单位名称、组织机构代码、通信地址、电子邮箱、电话号码等</p><p>(4)申请者的管理联系人、域名技术联系人、缴费联系人、承办人的姓名、通信地址、电子邮件、电话号码</p><p>(5)域名注册年限。</p><p>日常我们经常熟悉和使用的后缀是com后缀、net后缀以及cn后缀，其实除了一些主流后缀，还有很多域名后缀种类。那么还存在哪些域名后缀种类呢?哪个域名后缀比较好呢?</p><p>1、存在哪些域名后缀种类，罗列如下:</p><p>com 全球注册量第一，注册首选</p><p>.cn 中国企业和个人的互联网标识</p><p>.live 爱现场，爱生活</p><p>.studio 特指工作室</p><p>.xin 网络诚信专属域名</p><p>.ren 以人为本的域名，彰显团队力量</p><p>.club 俱乐部、会所专属域名</p><p>.site 代表站点/网站</p><p>.online 特指网络在线服务</p><p>.tech 技术专属域名</p><p>.website 代表网站/站点</p><p>.space 造梦空间专属域名</p><p>.win 适合竞技类游戏站点</p><p>.date 交友约会平台</p><p>.press 新闻、出版等自媒体专属域名</p><p>.xyz 最有个性和创意的域名</p><p>.news 资讯类站点最佳选择</p><p>.video 视频服务首选</p><p>.party 社交聚会平台</p><p>.wang 寓意网络，互联网域名首选</p><p>.top 寓意巅峰、突破</p><p>.cc 简单好记，极具商业潜力</p><p>.biz 代表商业，最具竞争力的域名</p><p>.click 寓意热点、点击</p><p>.trade 商业贸易专属</p><p>.science 学术研究领域专属</p><p>.wiki 维基百科</p><p>.design 设计领域专属域名</p><p>.link 即刻链接世界</p><p>.pics 用影像记录生活</p><p>.photo 透过镜头看世界</p><p>.help 网络助手</p><p>.gift 生活充满惊喜</p><p>.pub 客栈、酒吧专属域名</p><p>.rocks 互联网摇滚文化</p><p>.net 为企业树立全球化商业品牌</p><p>.org 非盈利组织或机构的首选</p><p>.band 乐队职业专属域名</p><p>.market 市场商业专属</p><p>.software 特指“软件”</p><p>.social 打造社交平台</p><p>.lawyer 律师职业专属域名</p><p>.engineer 工程师专属于域名</p><p>.me 代表”自己”，打造个性站点</p><p>.gov.cn 中国政府机关/部门的专属域名</p><p>.name 个人品牌推广最佳选择</p><p>.info 信息时代的标识域名</p><p>.tv 媒体域名，视频服务首选</p><p>.mobi 建立WAP网站的首选域名</p><p>.asia 含义为“亚洲”，标识强烈</p><p>.co 代表公司和商业</p><p>.我爱你 最有爱意的中文域名</p><p>.中国 最具中国色彩的域名</p><p>.公司 具有显著的标识作用</p><p>.网络 适合应用于网络服务</p><p>.集团 集团级企业专属定制</p><p>以上是小聚给大家罗列的域名后缀种类，还有一些别的国外域名后缀，没有列出。</p><p>2、哪个域名后缀好?</p><p>对于域名后缀来说，.com是全球公认的最佳域名，各大知名网站，基本都是.com后缀域名;除了com域名外，.net.cn，.cn，.com.cn，.org等域名也是比较常见的，虽然不如.com好，但也算主流，相对来说也具备较好的价值。或是一些新兴流行起来的域名，如.cc，.top，.top，.wang。</p>]]></content>
      
      
      <categories>
          
          <category> 域名 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫Scrapy基础</title>
      <link href="/archives/7c5d4ed3.html"/>
      <url>/archives/7c5d4ed3.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一. 概述"></a>一. 概述</h1><p>最近学习了一下这个非常强大的爬虫框架，这里将自己的学习过程记录下来</p><p>本文主要从下面几个方面进行介绍：</p><ul><li><p>我的学习过程</p></li><li><p>需求分析</p></li><li><p>搭建项目</p></li><li><p>编写代码实现需求</p></li><li><p>部署爬虫项目到 <code>SpiderKeeper</code></p><span id="more"></span></li></ul><h1 id="二-我的学习过程"><a href="#二-我的学习过程" class="headerlink" title="二. 我的学习过程"></a>二. 我的学习过程</h1><p>学习一个新的技术，首先就是去阅读它的官方文档，因为官方文档写的是比较全面的而且权威。</p><blockquote><p><a href="https://docs.scrapy.org/en/latest/">scrapy 官方文档地址</a>： <a href="https://docs.scrapy.org/en/latest/">https://docs.scrapy.org/en/latest/</a></p></blockquote><p>上面是 <code>scrapy</code> 的官方文档地址，文档是英文的，如果英文比较好建议直接看英文文档，其实自己的英语也不是很好，但是一直强迫自己看英文文档，遇到不认识的单词，就是用 <code>chrome</code> 的 一个叫做 <code>沙拉查词</code> 的插件翻译，翻译完就记下这些单词，慢慢的读这些英文技术文档就没有太大问题了。</p><p>如果学习的时间比较充足，可以看完整个文档再进行实践开发，如果需要快速上手，可以看文档中的快速开始。因为自己在开发需求之前有空闲的时间，所以把它的文档看了七七八八。</p><h2 id="Scrapy-简介"><a href="#Scrapy-简介" class="headerlink" title="Scrapy 简介"></a>Scrapy 简介</h2><p>下面根据自己阅读官方文档的过程做一个总结：</p><p><code>Scrapy</code> 是一个快速强大的高级 web 抓取框架，用于抓取网站和从网页中提取结构化数据，它可以用于从数据挖掘到监控和自动化测试等广泛的用途。</p><p><code>Scrapy</code> 提供了许多强大的功能来使抓取变得简单高效，例如：</p><ul><li>内置支持使用扩展的 <code>CSS</code> 选择器和 <code>XPath</code> 表达式从 <code>HTML/XML</code> 源中<a href="https://docs.scrapy.org/en/latest/topics/selectors.html#topics-selectors">选择和提取</a>数据，以及使用正则表达式提取的辅助方法。</li><li>一个<a href="https://docs.scrapy.org/en/latest/topics/shell.html#topics-shell">交互式 shell 控制台</a>（IPython 感知），用于尝试使用 <code>CSS</code> 和 <code>XPath</code> 表达式来抓取数据，在编写或调试时非常有用。</li><li>内置支持以多种格式（<code>JSON、CSV、XML</code>）<a href="https://docs.scrapy.org/en/latest/topics/feed-exports.html#topics-feed-exports">生成提要导出</a>并将它们存储在多个后端（FTP、S3、本地文件系统）</li><li>强大的编码支持和自动检测，用于处理外部、非标准和损坏的编码声明。</li><li><a href="https://docs.scrapy.org/en/latest/index.html#extending-scrapy">强大的可扩展性支持</a>，允许您使用<a href="https://docs.scrapy.org/en/latest/topics/signals.html#topics-signals">signals</a>和定义良好的 API（中间件、<a href="https://docs.scrapy.org/en/latest/topics/extensions.html#topics-extensions">扩展</a>和 <a href="https://docs.scrapy.org/en/latest/topics/item-pipeline.html#topics-item-pipeline">pipeline </a>）插入自己的功能。</li><li>一个<a href="https://docs.scrapy.org/en/latest/topics/telnetconsole.html#topics-telnetconsole">Telnet 控制台，</a>用于连接到在 <code>Scrapy</code> 进程中运行的 Python 控制台，以检查和调试您的爬虫</li><li>可重复使用的spider从<a href="https://www.sitemaps.org/index.html">站点地图</a>和 <code>XML/CSV</code> 提要中抓取站点、用于<a href="https://docs.scrapy.org/en/latest/topics/media-pipeline.html#topics-media-pipeline">自动下载</a>与抓取的项目相关联的<a href="https://docs.scrapy.org/en/latest/topics/media-pipeline.html#topics-media-pipeline">图像</a>（或任何其他媒体）的媒体 pipeline 、缓存 DNS 解析器等等！</li><li>用于处理的各种内置扩展和中间件：<ul><li>cookie 和会话处理</li><li>HTTP 功能，如压缩、身份验证、缓存</li><li>用户代理欺骗</li><li>robots.txt</li><li>爬行深度限制</li></ul></li></ul><p>从前面的介绍可以看出 <code>scrapy</code> 的功能非常强大，如果要掌握全部功能，需要花费大量的时间，并且也没有那个必要，只是需要的时候再去查阅官方文档即可。对于一般的网站都没有特别的反爬虫措施，除非一些数据比较敏感的网站，可能需要输入图形验证码之类的，个人觉得对于一般的网站，在抓取网页的过程中合理设置请求头，控制爬取的速度都能够将网页抓取下来。获取到网页内容之后，我们开发的内容就是根据需求解析出需要的结构化数据，所以重点是掌握 <code>scrapy</code> 的选择器。</p><!--more--><h2 id="Scrapy-选择器"><a href="#Scrapy-选择器" class="headerlink" title="Scrapy 选择器"></a>Scrapy 选择器</h2><p><code>scrapy</code> 使用的选择器包括如下：</p><ul><li><code>css</code> 选择器</li><li><code>xpath</code> 选择器</li><li>正则表达式提取</li></ul><p><code>XPath</code> 表达式非常强大，是 <code>Scrapy</code> 选择器的基础，事实上，<code>CSS</code> 选择器在后台被转换为 <code>XPath</code>。虽然可能不如 <code>CSS</code> 选择器流行，但 <code>XPath</code> 表达式提供了更强大的功能，因为除了导航结构之外，它还可以查看内容。使用 <code>XPath</code> 您可以选择以下内容：<em>选择包含文本“下一页”的链接</em>，这使得 <code>XPath</code> 非常适合抓取任务。</p><p><strong><code>XPath</code> 常用规则</strong></p><table><thead><tr><th align="left">表达式</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">nodename</td><td align="left">选取此节点的所有子节点</td></tr><tr><td align="left">/</td><td align="left">从当前节点选区直接子节点</td></tr><tr><td align="left">//</td><td align="left">从当前节点选取子孙节点</td></tr><tr><td align="left">.</td><td align="left">选取当前节点</td></tr><tr><td align="left">..</td><td align="left">选取当前节点的父节点</td></tr><tr><td align="left">@</td><td align="left">选取属性</td></tr><tr><td align="left">text()</td><td align="left">获取节点中的文本</td></tr></tbody></table><h1 id="三-需求分析"><a href="#三-需求分析" class="headerlink" title="三. 需求分析"></a>三. 需求分析</h1><p>通过前面的介绍我们大概了解了 <code>Scrapy</code> 的特性，接下来，自己模拟一个实际的需求，该需求是在网上找的，只是用来学习 <code>Scrapy</code> 的一个 <code>demo</code>，需求如下：</p><p>目标网站：站长之家 <a href="https://top.chinaz.com/">https://top.chinaz.com/</a></p><p>需求：在站长之家的网站排行板块中，提供了行业排名、地区排名等多种分类网站排行数据。现在请你任选一种感兴趣的排名方式，摘取其中的数据。</p><p><img src="https://gitee.com/peterwd/pic-oss/raw/master/image/202201071459767.png" alt="image-20220107145943621"></p><p>字段要求，一共5个字段，分别是:</p><ul><li>网站名称：web_name</li><li>网站域名：domain</li><li>排名：rank</li><li>得分：score</li><li>网站简介：abstract</li></ul><p>技术要求：使用 <code>scrapy</code> 编写爬虫，最终将提取到的数据存到 <code>mongodb</code> 中；</p><h1 id="四-搭建项目"><a href="#四-搭建项目" class="headerlink" title="四. 搭建项目"></a>四. 搭建项目</h1><p>前面已经介绍了需求，现在我们开始从零搭建一个 <code>scrapy</code> 的项目，因为 <code>scrapy</code> 是使用 <code>python</code> 开发的，所以需要提前安装 <code>python</code> 的环境，推荐使用 <code>Anaconda</code>，关于 <code>Anaconda</code> 的安装可以查阅其官方文档，这里默认已经安装好了。</p><h2 id="1-安装-scrapy"><a href="#1-安装-scrapy" class="headerlink" title="1. 安装 scrapy"></a>1. 安装 scrapy</h2><p>在 <code>CMD</code> 控制台使用如下命令安装 <code>scrapy</code> :</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip <span class="token function">install</span> scrapy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装完成后输入 <code>scrapy</code> 可以看到如下输出：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">D:<span class="token punctuation">\</span>my-projects<span class="token operator">&gt;</span>scrapyScrapy <span class="token number">2.5</span>.1 - no active projectUsage:  scrapy <span class="token operator">&lt;</span>command<span class="token operator">&gt;</span> <span class="token punctuation">[</span>options<span class="token punctuation">]</span> <span class="token punctuation">[</span>args<span class="token punctuation">]</span>Available commands:  bench         Run quick benchmark <span class="token builtin class-name">test</span>  check         Check spider contracts  commands  crawl         Run a spider  edit          Edit spider  fetch         Fetch a URL using the Scrapy downloader  genspider     Generate new spider using pre-defined templates  list          List available spiders  parse         Parse URL <span class="token punctuation">(</span>using its spider<span class="token punctuation">)</span> and print the results  runspider     Run a self-contained spider <span class="token punctuation">(</span>without creating a project<span class="token punctuation">)</span>  settings      Get settings values  shell         Interactive scraping console  startproject  Create new project  version       Print Scrapy version  view          Open URL <span class="token keyword">in</span> browser, as seen by ScrapyUse <span class="token string">"scrapy &lt;command&gt; -h"</span> to see <span class="token function">more</span> info about a <span class="token builtin class-name">command</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-创建项目"><a href="#2-创建项目" class="headerlink" title="2. 创建项目"></a>2. 创建项目</h2><p>语法：<code>scrapy startproject &lt;project_name&gt; [project_dir]</code></p><p>在 <code>project_dir</code> 目录下创建一个名为 <code>&lt;project_name&gt;</code> 的新 Scrapy 项目，如果 <code>project_dir</code> 未指定，表示当前目录。</p><blockquote><p>项目名只能使用数字、字母、下划线组成</p></blockquote><p>使用如下命令创建一个叫做 <code>scrapy_demo</code> 的项目：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">scrapy startproject scrapy_demo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出内容如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">D:<span class="token punctuation">\</span>my-projects<span class="token operator">&gt;</span>scrapy startproject scrapy_demoNew Scrapy project <span class="token string">'scrapy_demo'</span>, using template directory <span class="token string">'e:\anaconda3\lib\site-packages\scrapy\templates\project'</span>, created in:    D:<span class="token punctuation">\</span>my-projects<span class="token punctuation">\</span>scrapy_demoYou can start your first spider with:    <span class="token builtin class-name">cd</span> scrapy_demo    scrapy genspider example example.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>自动生成的项目目录结构如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">scrapy_demo├── scrapy_demo│   ├── items.py       <span class="token comment"># 数据模型文件</span>│   ├── middlewares.py <span class="token comment"># 中间件文件，配置所有中间件</span>│   ├── pipelines.py   <span class="token comment">#  pipeline 文件，用于存放自定义pipeline的处理逻辑，比如配置保存数据库的逻辑</span>│   ├── settings.py    <span class="token comment"># 项目的配置文件，自定义的外部配置都可以放在这里</span>│   └── spiders        <span class="token comment"># Spider类文件夹，我们编写的解析代码均存放在这里</span>└── scrapy.cfg         <span class="token comment"># 项目的部署配置文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-生成-spider-文件"><a href="#3-生成-spider-文件" class="headerlink" title="3. 生成 spider 文件"></a>3. 生成 spider 文件</h2><p>语法：<code>scrapy genspider [-t template] &lt;name&gt; &lt;domain&gt;</code></p><p>如果在 scrapy 项目中调用，将在当前项目的 spiders 文件夹中创建一个新的 spider 文件，该<code>&lt;name&gt;</code>参数设置为 spider 的<code>name</code>，而<code>&lt;domain&gt;</code>用于生成<code>allowed_domains </code>和 <code>start_urls </code>的属性值。</p><p>执行下面的命令，生成 spider 文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">scrapy genspider tech_web top.chinaz.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出内容如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">D:<span class="token punctuation">\</span>my-projects<span class="token punctuation">\</span>scrapy_demo<span class="token operator">&gt;</span>scrapy genspider tech_web top.chinaz.comCreated spider <span class="token string">'tech_web'</span> using template <span class="token string">'basic'</span> <span class="token keyword">in</span> module:  scrapy_demo.spiders.tech_web<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>生成的 spider 文件内容如下图所示：</p><p><img src="https://gitee.com/peterwd/pic-oss/raw/master/image/202201071550723.png" alt="image-20220107155030530"></p><h1 id="五-代码实现"><a href="#五-代码实现" class="headerlink" title="五. 代码实现"></a>五. 代码实现</h1><p>按照前面的步骤，我们已经完成项目的搭建，接下来开始正式实现需求。</p><h2 id="1-在-items-py-文件中定义采集的字段"><a href="#1-在-items-py-文件中定义采集的字段" class="headerlink" title="1. 在 items.py 文件中定义采集的字段"></a>1. 在 items.py 文件中定义采集的字段</h2><p>前面已经知道要采集的字段，所以我们需要在 <code>items.py</code> 文件中定义采集的字段以及一些其他需要的字段，如下所示：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># Define here the models for your scraped items</span><span class="token comment">#</span><span class="token comment"># See documentation in:</span><span class="token comment"># https://docs.scrapy.org/en/latest/topics/items.html</span><span class="token keyword">import</span> scrapy<span class="token keyword">class</span> <span class="token class-name">ScrapyDemoItem</span><span class="token punctuation">(</span>scrapy<span class="token punctuation">.</span>Item<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># define the fields for your item here like:</span>    <span class="token comment"># name = scrapy.Field()</span>    _id <span class="token operator">=</span> scrapy<span class="token punctuation">.</span>Field<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 保存到 mongodb 中的 _id</span>    web_name <span class="token operator">=</span> scrapy<span class="token punctuation">.</span>Field<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 网站名称</span>    domain <span class="token operator">=</span> scrapy<span class="token punctuation">.</span>Field<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 网站域名</span>    rank <span class="token operator">=</span> scrapy<span class="token punctuation">.</span>Field<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 排名</span>    score <span class="token operator">=</span> scrapy<span class="token punctuation">.</span>Field<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 得分</span>    abstract <span class="token operator">=</span> scrapy<span class="token punctuation">.</span>Field<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 摘要</span>    create_time <span class="token operator">=</span> scrapy<span class="token punctuation">.</span>Field<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 创建时间</span>    update_time <span class="token operator">=</span> scrapy<span class="token punctuation">.</span>Field<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 更新时间</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-在-spider-文件中编写采集逻辑"><a href="#2-在-spider-文件中编写采集逻辑" class="headerlink" title="2. 在 spider 文件中编写采集逻辑"></a>2. 在 spider 文件中编写采集逻辑</h2><p>我们这里打算采集网络科技网站排行榜，它的地址为：<code>https://top.chinaz.com/hangye/index_wangluo.html</code>，在正式编写代码之前，我们可以使用 scrapy 提供的 shell 工具进行测试，通过交互式的方式解析需要的字段，使用方式如下：</p><p>语法： <code>scrapy shell [url]</code></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">scrapy shell https://top.chinaz.com/hangye/index_wangluo.html --nolog<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果使用上面的命令输出如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">D:<span class="token punctuation">\</span>my-projects<span class="token punctuation">\</span>scrapy_demo<span class="token operator">&gt;</span>scrapy shell https://top.chinaz.com/hangye/index_wangluo.html --nolog<span class="token punctuation">[</span>s<span class="token punctuation">]</span> Available Scrapy objects:<span class="token punctuation">[</span>s<span class="token punctuation">]</span>   scrapy     scrapy module <span class="token punctuation">(</span>contains scrapy.Request, scrapy.Selector, etc<span class="token punctuation">)</span><span class="token punctuation">[</span>s<span class="token punctuation">]</span>   crawler    <span class="token operator">&lt;</span>scrapy.crawler.Crawler object at 0x0000011BEAE8474<span class="token operator"><span class="token file-descriptor important">8</span>&gt;</span><span class="token punctuation">[</span>s<span class="token punctuation">]</span>   item       <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">[</span>s<span class="token punctuation">]</span>   request    <span class="token operator">&lt;</span>GET https://top.chinaz.com/hangye/index_wangluo.html<span class="token operator">&gt;</span><span class="token punctuation">[</span>s<span class="token punctuation">]</span>   response   <span class="token operator">&lt;</span><span class="token number">200</span> https://top.chinaz.com/hangye/index_wangluo.html<span class="token operator">&gt;</span><span class="token punctuation">[</span>s<span class="token punctuation">]</span>   settings   <span class="token operator">&lt;</span>scrapy.settings.Settings object at 0x0000011BEB0F1B8<span class="token operator"><span class="token file-descriptor important">8</span>&gt;</span><span class="token punctuation">[</span>s<span class="token punctuation">]</span>   spider     <span class="token operator">&lt;</span>TechWebSpider <span class="token string">'tech_web'</span> at 0x11beb53848<span class="token operator"><span class="token file-descriptor important">8</span>&gt;</span><span class="token punctuation">[</span>s<span class="token punctuation">]</span> Useful shortcuts:<span class="token punctuation">[</span>s<span class="token punctuation">]</span>   fetch<span class="token punctuation">(</span>url<span class="token punctuation">[</span>, <span class="token assign-left variable">redirect</span><span class="token operator">=</span>True<span class="token punctuation">]</span><span class="token punctuation">)</span> Fetch URL and update <span class="token builtin class-name">local</span> objects <span class="token punctuation">(</span>by default, redirects are followed<span class="token punctuation">)</span><span class="token punctuation">[</span>s<span class="token punctuation">]</span>   fetch<span class="token punctuation">(</span>req<span class="token punctuation">)</span>                  Fetch a scrapy.Request and update <span class="token builtin class-name">local</span> objects<span class="token punctuation">[</span>s<span class="token punctuation">]</span>   shelp<span class="token punctuation">(</span><span class="token punctuation">)</span>           Shell <span class="token builtin class-name">help</span> <span class="token punctuation">(</span>print this <span class="token builtin class-name">help</span><span class="token punctuation">)</span><span class="token punctuation">[</span>s<span class="token punctuation">]</span>   view<span class="token punctuation">(</span>response<span class="token punctuation">)</span>    View response <span class="token keyword">in</span> a browserIn <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>:  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时你可以使用 <code>response.text</code> 来检查我们是否获取了整个页面的源码，scrapy的所有资源解析操作都被集成在了<code>response</code>这个对象中，使用 <code>Tab</code> 建可以提示补全相关的内容。</p><p>接下来我们可以在浏览器中分析需要抓取的页面的信息</p><p><img src="https://gitee.com/peterwd/pic-oss/raw/master/image/202201071632306.png" alt="image-20220107163221087"></p><p>解析网页的 spider 代码如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> datetime<span class="token keyword">from</span> hashlib <span class="token keyword">import</span> md5<span class="token keyword">import</span> scrapy<span class="token keyword">from</span> scrapy_demo<span class="token punctuation">.</span>items <span class="token keyword">import</span> ScrapyDemoItem<span class="token keyword">class</span> <span class="token class-name">TechWebSpider</span><span class="token punctuation">(</span>scrapy<span class="token punctuation">.</span>Spider<span class="token punctuation">)</span><span class="token punctuation">:</span>    name <span class="token operator">=</span> <span class="token string">'tech_web'</span>    allowed_domains <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'top.chinaz.com'</span><span class="token punctuation">]</span>    url <span class="token operator">=</span> <span class="token string">'https://top.chinaz.com/hangye/index_wangluo_{}.html'</span>    pagesize <span class="token operator">=</span> <span class="token number">1</span>    start_urls <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'https://top.chinaz.com/hangye/index_wangluo.html'</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">parse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">:</span>        li_list <span class="token operator">=</span> response<span class="token punctuation">.</span>xpath<span class="token punctuation">(</span><span class="token string">'//ul[@class="listCentent"]/li'</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> li <span class="token keyword">in</span> li_list<span class="token punctuation">:</span>            web_name <span class="token operator">=</span> li<span class="token punctuation">.</span>xpath<span class="token punctuation">(</span><span class="token string">'.//h3/a/text()'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span>            domain <span class="token operator">=</span> li<span class="token punctuation">.</span>xpath<span class="token punctuation">(</span><span class="token string">'.//h3/span/text()'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span>            abstract <span class="token operator">=</span> li<span class="token punctuation">.</span>xpath<span class="token punctuation">(</span><span class="token string">'.//div[@class="CentTxt"]/p/text()'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>get<span class="token punctuation">(</span>default<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span>            rank <span class="token operator">=</span> li<span class="token punctuation">.</span>xpath<span class="token punctuation">(</span><span class="token string">'.//div[@class="RtCRateCent"]/strong/text()'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>get<span class="token punctuation">(</span>default<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span>            score <span class="token operator">=</span> li<span class="token punctuation">.</span>xpath<span class="token punctuation">(</span><span class="token string">'.//div[@class="RtCRateCent"]/span/text()'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>get<span class="token punctuation">(</span>default<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span>            <span class="token comment"># 封装数据</span>            item <span class="token operator">=</span> ScrapyDemoItem<span class="token punctuation">(</span><span class="token punctuation">)</span>            date <span class="token operator">=</span> datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">.</span>now<span class="token punctuation">(</span><span class="token punctuation">)</span>            item<span class="token punctuation">[</span><span class="token string">'_id'</span><span class="token punctuation">]</span> <span class="token operator">=</span> md5<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>web_name<span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>hexdigest<span class="token punctuation">(</span><span class="token punctuation">)</span>            item<span class="token punctuation">[</span><span class="token string">'web_name'</span><span class="token punctuation">]</span> <span class="token operator">=</span> web_name            item<span class="token punctuation">[</span><span class="token string">'domain'</span><span class="token punctuation">]</span> <span class="token operator">=</span> domain            item<span class="token punctuation">[</span><span class="token string">'abstract'</span><span class="token punctuation">]</span> <span class="token operator">=</span> abstract            item<span class="token punctuation">[</span><span class="token string">'rank'</span><span class="token punctuation">]</span> <span class="token operator">=</span> rank            item<span class="token punctuation">[</span><span class="token string">'score'</span><span class="token punctuation">]</span> <span class="token operator">=</span> score            item<span class="token punctuation">[</span><span class="token string">'create_time'</span><span class="token punctuation">]</span> <span class="token operator">=</span> date            item<span class="token punctuation">[</span><span class="token string">'update_time'</span><span class="token punctuation">]</span> <span class="token operator">=</span> date            <span class="token keyword">yield</span> item        <span class="token comment"># 构造下一页的请求</span>        self<span class="token punctuation">.</span>pagesize <span class="token operator">=</span> self<span class="token punctuation">.</span>pagesize <span class="token operator">+</span> <span class="token number">1</span>        url <span class="token operator">=</span> self<span class="token punctuation">.</span>url<span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>pagesize<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>li_list<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">yield</span> scrapy<span class="token punctuation">.</span>Request<span class="token punctuation">(</span>url<span class="token operator">=</span>url<span class="token punctuation">,</span> callback<span class="token operator">=</span>self<span class="token punctuation">.</span>parse<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>Spider parse</code>方法：所有的<code>parse</code>方法都必须返回 Item 对象(目前可以理解为数据项)或者 Request 对象(下一条请求)。这里所有的<code>parse</code>的意思是不是特指<code>Spider</code>类中生成的<code>parse</code>方法，而是所有具备解析功能的函数都应该返回 Item 或者 Request。</p></blockquote><p>启动 spider ：</p><p>语法：<code>scrapy crawl &lt;spider&gt;</code></p><p>其中的 <code>&lt;spider&gt;</code> 是我们 spider 文件中 <code>name</code> 属性的值，我们在 scrapy 项目中可以通过 <code>scrapy list</code> 命令查看，如下所示：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">D:<span class="token punctuation">\</span>my-projects<span class="token punctuation">\</span>scrapy_demo<span class="token operator">&gt;</span>scrapy listtech_web<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>所以我们可以使用下面的命令启动我们创建的这个 spider :</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">scrapy crawl tech_web<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>那么现在有一个问题是我需要将数据保存应该如何做呢？</p><pre class="line-numbers language-none"><code class="language-none">Scrapy` 提供了许多`Feed exports`的方法，可以将输出数据保存为`json, json lines, csv, xml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在启动命令后面加 <code>-o xx.json</code> 就可以将文件保存为<code>json</code>格式。</p><p>例如使用如下命令将抓取的数据保存到一个 <code>json</code> 文件中：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">scrapy crawl tech_web -o result.json<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>打开保存的 json 文件，发现出现了乱码，出于历史原因，JSON 输出使用安全数字编码（<code>\uXXXX</code>序列），如果想要 UTF-8 用于 JSON，请使用 <code>FEED_EXPORT_ENCODING = 'utf-8'</code>。官方文档对该字段的说明如下：</p><p><img src="https://gitee.com/peterwd/pic-oss/raw/master/image/202201071740442.png" alt="image-20220107174023299"></p><h2 id="3-保存数据到-mongodb"><a href="#3-保存数据到-mongodb" class="headerlink" title="3. 保存数据到 mongodb"></a>3. 保存数据到 mongodb</h2><p>前面我们介绍了如何将采集的结构化数据保存到 json 文件中，下面将介绍如何将采集的数据保存到 mongodb 中，保存到其他数据库也是类似的。</p><p>首先由于我们需要保存数据到 mongodb 中，所以这里先用 docker 部署一个 mongodb 数据库，如果已经有了 mongodb 数据库，就不需要这个操作。</p><blockquote><p>docker 部署 mongodb 地址：<a href="https://hub.docker.com/r/bitnami/mongodb">https://hub.docker.com/r/bitnami/mongodb</a></p></blockquote><p>使用下面的命令启动一个 <code>mongodb</code> 数据库：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">docker run --name mongodb  -e MONGODB_ROOT_PASSWORD=password123 -p 27017:27017  bitnami/mongodb:latest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其次需要介绍一下 <code>scrapy</code> 的 <code>pipeline</code> ，在每一个item 被抓取之后，都会被发送到 <code>pipeline</code> 中，每个 <code>pipeline</code> 都是一个实现简单方法的 <code>python</code> 类，</p><p>它们接收一个 <code>item</code> 并对其执行操作，同时决定该 <code>item</code> 是应该继续进入下一个 <code>pipeline</code> 还是被丢弃不再处理。</p><p><strong>pipeline 的典型用途如下：</strong></p><ul><li>清洗 HTML 数据</li><li>验证抓取的数据（检查项目是否包含某些字段）</li><li>检查重复项（并删除它们）</li><li>将抓取的项目存储在数据库中</li></ul><p><strong>编写自己的 pipeline</strong></p><p>每个 pipeline 组件都是一个必须实现 <code>process_item</code> 方法的 Python 类：</p><ul><li><p><strong>process_item ( *self* , *item* , *spider* )<a href="https://docs.scrapy.org/en/latest/topics/item-pipeline.html#process_item">¶</a></strong></p><p>处理每个 item 都会调用此方法。item是一个<a href="https://docs.scrapy.org/en/latest/topics/items.html#item-types">item 对象</a>，请参阅 <a href="https://docs.scrapy.org/en/latest/topics/items.html#supporting-item-types">支持所有项目类型</a>。<a href="https://docs.scrapy.org/en/latest/topics/item-pipeline.html#process_item"><code>process_item()</code></a>必须要么：返回一个<a href="https://docs.scrapy.org/en/latest/topics/items.html#item-types">项目对象</a>，返回一个<a href="https://twistedmatrix.com/documents/current/api/twisted.internet.defer.Deferred.html"><code>Deferred</code></a>或引发 <a href="https://docs.scrapy.org/en/latest/topics/exceptions.html#scrapy.exceptions.DropItem"><code>DropItem</code></a>异常。丢弃的项目不再由进一步的 pipeline 组件处理。</p><p>参数</p><ul><li><strong>item</strong> ( <a href="https://docs.scrapy.org/en/latest/topics/items.html#item-types">item object</a> ) – 抓取的项目</li><li><strong>spider</strong> ( <a href="https://docs.scrapy.org/en/latest/topics/spiders.html#scrapy.spiders.Spider"><code>Spider</code></a>object) – 抓取物品的spider</li></ul><p>返回值</p><ul><li>返回一个 <a href="https://docs.scrapy.org/en/latest/topics/items.html#item-types">Item 对象</a>，让后续的 pipeline 处理</li><li>返回一个<a href="https://twistedmatrix.com/documents/current/api/twisted.internet.defer.Deferred.html"><code>Deferred</code></a>或引发 <a href="https://docs.scrapy.org/en/latest/topics/exceptions.html#scrapy.exceptions.DropItem"><code>DropItem</code></a>异常，丢弃 item 不再由后续的 pipeline 组件处理。</li></ul></li></ul><p>此外，它们还可以实现以下方法：</p><ul><li><p><strong>open_spider（self，spider）</strong><a href="https://docs.scrapy.org/en/latest/topics/item-pipeline.html#open_spider">¶</a></p><p>这个方法在 spider 打开时被调用。参数<strong>spider</strong>– 打开的 spider</p></li><li><p><strong>close_spider（self，spider）</strong><a href="https://docs.scrapy.org/en/latest/topics/item-pipeline.html#close_spider">¶</a></p><p>当 spider 关闭时调用此方法。参数 <strong>spider</strong> – 关闭的spider</p></li><li><p><strong>from_crawler ( *cls* , *crawler* )</strong><a href="https://docs.scrapy.org/en/latest/topics/item-pipeline.html#from_crawler">¶</a></p><p>如果存在，必须返回 pipeline 的新实例，通常在这个方法中传入一些外部配置，构造一个新的 pipeline 实例。Crawler 对象提供对所有 Scrapy 核心组件的访问，如 settings 和 signals ；这是 pipeline 访问它们并将其功能挂钩到 Scrapy 的一种方式。参数<strong>crawler</strong> ( <a href="https://docs.scrapy.org/en/latest/topics/api.html#scrapy.crawler.Crawler"><code>Crawler</code></a>object) – 使用这个 pipeline 的爬虫。</p></li></ul><p>知道了 pipeline 的作用和定义方法后，我们定义一个保存数据到 <code>mongodb</code> 的 <code>pipeline</code> ，如下所示：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># Define your item pipelines here</span><span class="token comment">#</span><span class="token comment"># Don't forget to add your pipeline to the ITEM_PIPELINES setting</span><span class="token comment"># See: https://docs.scrapy.org/en/latest/topics/item-pipeline.html</span><span class="token comment"># useful for handling different item types with a single interface</span><span class="token keyword">from</span> itemadapter <span class="token keyword">import</span> ItemAdapter<span class="token keyword">import</span> pymongo<span class="token keyword">class</span> <span class="token class-name">ScrapyDemoPipeline</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">process_item</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> item<span class="token punctuation">,</span> spider<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> item<span class="token keyword">class</span> <span class="token class-name">SaveToMongoPipeline</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> mongo_uri<span class="token punctuation">,</span> mongo_db<span class="token punctuation">,</span> collection<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>mongo_uri <span class="token operator">=</span> mongo_uri        self<span class="token punctuation">.</span>mongo_db <span class="token operator">=</span> mongo_db        self<span class="token punctuation">.</span>collection <span class="token operator">=</span> collection    <span class="token decorator annotation punctuation">@classmethod</span>    <span class="token keyword">def</span> <span class="token function">from_crawler</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> crawler<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 从 settings.py 文件中读取对应的配置</span>        env <span class="token operator">=</span> crawler<span class="token punctuation">.</span>settings<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'ENV'</span><span class="token punctuation">,</span> <span class="token string">'local'</span><span class="token punctuation">)</span>        config <span class="token operator">=</span> crawler<span class="token punctuation">.</span>settings<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'CONFIG'</span><span class="token punctuation">)</span>        config <span class="token operator">=</span> config<span class="token punctuation">[</span>env<span class="token punctuation">]</span>        mongo_uri <span class="token operator">=</span> config<span class="token punctuation">.</span>MONGO_URI        mongo_db <span class="token operator">=</span> config<span class="token punctuation">.</span>MONGODB_DB        collection <span class="token operator">=</span> config<span class="token punctuation">.</span>COLLECTION_NAME        <span class="token comment"># 返回当前 pipeline 的实例，传入从 settings 中读取的配置</span>        <span class="token keyword">return</span> cls<span class="token punctuation">(</span>            mongo_uri<span class="token operator">=</span>mongo_uri<span class="token punctuation">,</span>            mongo_db<span class="token operator">=</span>mongo_db<span class="token punctuation">,</span>            collection<span class="token operator">=</span>collection<span class="token punctuation">,</span>        <span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">open_spider</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> spider<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        打开 spider 的时候调用一次，可以在这里创建数据的连接        """</span>        self<span class="token punctuation">.</span>client <span class="token operator">=</span> pymongo<span class="token punctuation">.</span>MongoClient<span class="token punctuation">(</span>self<span class="token punctuation">.</span>mongo_uri<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>db <span class="token operator">=</span> self<span class="token punctuation">.</span>client<span class="token punctuation">[</span>self<span class="token punctuation">.</span>mongo_db<span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">process_item</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> item<span class="token punctuation">,</span> spider<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        每一个 item 都会调用这个方法，可以在这里清洗数据，并保存到数据库        """</span>        adapter <span class="token operator">=</span> ItemAdapter<span class="token punctuation">(</span>item<span class="token punctuation">)</span>        coll <span class="token operator">=</span> self<span class="token punctuation">.</span>db<span class="token punctuation">[</span>self<span class="token punctuation">.</span>collection<span class="token punctuation">]</span>        <span class="token comment"># 使用 ItemAdapter 的 asdict() 方法可以处理嵌套的 item 格式，获取 json 字符串</span>        doc <span class="token operator">=</span> adapter<span class="token punctuation">.</span>asdict<span class="token punctuation">(</span><span class="token punctuation">)</span>        count <span class="token operator">=</span> coll<span class="token punctuation">.</span>find<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'_id'</span><span class="token punctuation">:</span> doc<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'_id'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span>count<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            coll<span class="token punctuation">.</span>insert_one<span class="token punctuation">(</span>doc<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">del</span> doc<span class="token punctuation">[</span><span class="token string">'create_time'</span><span class="token punctuation">]</span>            coll<span class="token punctuation">.</span>update_one<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"_id"</span><span class="token punctuation">:</span> doc<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'_id'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">'$set'</span><span class="token punctuation">:</span> doc<span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> item    <span class="token keyword">def</span> <span class="token function">close_spider</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> spider<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        spider 关闭的时候调用一次，可以在这里关闭数据库连接，释放资源        """</span>        self<span class="token punctuation">.</span>client<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果要让自己的 pipeline 生效， 需要配置在 <code>settings.py</code> 文件中，如下所示：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># Configure item pipelines</span><span class="token comment"># See https://docs.scrapy.org/en/latest/topics/item-pipeline.html</span>ITEM_PIPELINES <span class="token operator">=</span> <span class="token punctuation">{</span>   <span class="token string">'scrapy_demo.pipelines.ScrapyDemoPipeline'</span><span class="token punctuation">:</span> <span class="token number">300</span><span class="token punctuation">,</span>   <span class="token string">'scrapy_demo.pipelines.SaveToMongoPipeline'</span><span class="token punctuation">:</span> <span class="token number">400</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>ITEM_PIPELINES</code> 是一个字典，它的 <code>key</code> 是 <code>pipeline</code> 的类路径，它的值是一个数字， 这个数字决定了 pipeline 的执行顺序，它的执行顺序为从低到高，数字越大越后执行，自定义的数字范围为 <code>0 - 1000</code>。</p><p>上述的pipeline 中的 <code>from_crawler</code> 方法使用了 settings 中配置的 <code>mongodb</code> 的地址，<code>settings.py</code> 文件的配置如下所示：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># Scrapy settings for scrapy_demo project</span><span class="token comment">#</span><span class="token comment"># For simplicity, this file contains only settings considered important or</span><span class="token comment"># commonly used. You can find more settings consulting the documentation:</span><span class="token comment">#</span><span class="token comment">#     https://docs.scrapy.org/en/latest/topics/settings.html</span><span class="token comment">#     https://docs.scrapy.org/en/latest/topics/downloader-middleware.html</span><span class="token comment">#     https://docs.scrapy.org/en/latest/topics/spider-middleware.html</span>BOT_NAME <span class="token operator">=</span> <span class="token string">'scrapy_demo'</span>SPIDER_MODULES <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'scrapy_demo.spiders'</span><span class="token punctuation">]</span>NEWSPIDER_MODULE <span class="token operator">=</span> <span class="token string">'scrapy_demo.spiders'</span>FEED_EXPORT_ENCODING <span class="token operator">=</span> <span class="token string">'utf-8'</span><span class="token comment"># Crawl responsibly by identifying yourself (and your website) on the user-agent</span>USER_AGENT <span class="token operator">=</span> <span class="token string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.45 Safari/537.36'</span><span class="token comment"># Obey robots.txt rules</span>ROBOTSTXT_OBEY <span class="token operator">=</span> <span class="token boolean">False</span><span class="token comment"># Override the default request headers:</span>DEFAULT_REQUEST_HEADERS <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token string">'Accept'</span><span class="token punctuation">:</span> <span class="token string">'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9'</span><span class="token punctuation">,</span>    <span class="token string">'Accept-Encoding'</span><span class="token punctuation">:</span> <span class="token string">'gzip, deflate, br'</span><span class="token punctuation">,</span>    <span class="token string">'Accept-Language'</span><span class="token punctuation">:</span> <span class="token string">'zh-CN,zh;q=0.9,en;q=0.8'</span><span class="token punctuation">,</span>    <span class="token string">'Connection'</span><span class="token punctuation">:</span> <span class="token string">'keep-alive'</span><span class="token punctuation">,</span>    <span class="token string">'User-Agent'</span><span class="token punctuation">:</span> USER_AGENT<span class="token punctuation">}</span><span class="token comment"># Configure item pipelines</span><span class="token comment"># See https://docs.scrapy.org/en/latest/topics/item-pipeline.html</span>ITEM_PIPELINES <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token string">'scrapy_demo.pipelines.ScrapyDemoPipeline'</span><span class="token punctuation">:</span> <span class="token number">300</span><span class="token punctuation">,</span>    <span class="token string">'scrapy_demo.pipelines.SaveToMongoPipeline'</span><span class="token punctuation">:</span> <span class="token number">400</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">LocalConfig</span><span class="token punctuation">:</span>    <span class="token comment"># 本地环境mongeDB地址</span>    MONGODB_HOST <span class="token operator">=</span> <span class="token string">'localhost:27017'</span>    MONGODB_USERNAME <span class="token operator">=</span> <span class="token string">'root'</span>    MONGODB_PASSWORD <span class="token operator">=</span> <span class="token string">'password123'</span>    MONGODB_DB <span class="token operator">=</span> <span class="token string">'admin'</span>    COLLECTION_NAME <span class="token operator">=</span> <span class="token string">'tech_web'</span>    MONGO_URI <span class="token operator">=</span> <span class="token string">"mongodb://{username}:{password}@{server}/{database}"</span><span class="token punctuation">.</span> \        <span class="token builtin">format</span><span class="token punctuation">(</span>username<span class="token operator">=</span>MONGODB_USERNAME<span class="token punctuation">,</span> password<span class="token operator">=</span>MONGODB_PASSWORD<span class="token punctuation">,</span> server<span class="token operator">=</span>MONGODB_HOST<span class="token punctuation">,</span> database<span class="token operator">=</span>MONGODB_DB<span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">DevelopmentConfig</span><span class="token punctuation">:</span>    <span class="token comment"># 开发环境mongeDB地址</span>    MONGODB_HOST <span class="token operator">=</span> <span class="token string">'localhost:27017'</span>    MONGODB_USERNAME <span class="token operator">=</span> <span class="token string">'root'</span>    MONGODB_PASSWORD <span class="token operator">=</span> <span class="token string">'password123'</span>    MONGODB_DB <span class="token operator">=</span> <span class="token string">'admin'</span>    COLLECTION_NAME <span class="token operator">=</span> <span class="token string">'tech_web'</span>    MONGO_URI <span class="token operator">=</span> <span class="token string">"mongodb://{username}:{password}@{server}/{database}"</span><span class="token punctuation">.</span> \        <span class="token builtin">format</span><span class="token punctuation">(</span>username<span class="token operator">=</span>MONGODB_USERNAME<span class="token punctuation">,</span> password<span class="token operator">=</span>MONGODB_PASSWORD<span class="token punctuation">,</span> server<span class="token operator">=</span>MONGODB_HOST<span class="token punctuation">,</span> database<span class="token operator">=</span>MONGODB_DB<span class="token punctuation">)</span>CONFIG <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token string">'local'</span><span class="token punctuation">:</span> LocalConfig<span class="token punctuation">,</span>    <span class="token string">'dev'</span><span class="token punctuation">:</span> DevelopmentConfig<span class="token punctuation">,</span><span class="token punctuation">}</span>ENV <span class="token operator">=</span> <span class="token string">'local'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编写完成后运行下面的命令就可以启动 spider：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">scrapy crawl tech_web<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看到数据保存到 mongodb 中了：</p><p><img src="https://gitee.com/peterwd/pic-oss/raw/master/image/202201072015589.png" alt="image-20220107201532414"></p><h1 id="六-部署爬虫项目到-SpiderKeeper"><a href="#六-部署爬虫项目到-SpiderKeeper" class="headerlink" title="六. 部署爬虫项目到 SpiderKeeper"></a>六. 部署爬虫项目到 <code>SpiderKeeper</code></h1><p>前面介绍了使用命令 <code>scrapy crawl &lt;name&gt;</code> 来运行 spider ，如果我们想要定时运行这些爬虫任务应该怎么做呢？</p><ul><li>如果运行在Linux系统中，可以使用 <code>crontab</code> 来执行定时任务</li><li>可以使用 python 的定时库 <code>apscheduler</code> ，通过手动编程的方式执行定时任务</li><li>使用 <code>scrapy</code> 的可视化管理工具 <code>SpiderKeeper</code></li></ul><p>接下来将介绍部署 <code>scrapy</code> 项目到 <code>SpiderKeeper</code>，部署 <code>scrapy</code> 项目到 <code>SpiderKeeper</code> 需要安装两个 python 库：</p><ul><li>spiderkeeper</li><li>scrapyd</li></ul><h2 id="1-SpiderKeeper-简介"><a href="#1-SpiderKeeper-简介" class="headerlink" title="1. SpiderKeeper 简介"></a>1. SpiderKeeper 简介</h2><blockquote><p>SpiderKeeper 的源码地址：<a href="https://github.com/DormyMo/SpiderKeeper">https://github.com/DormyMo/SpiderKeeper</a></p></blockquote><p><code>SpiderKeeper</code> 是 <code>spider</code> 服务的可扩展管理 ui，包括如下功能：</p><ul><li>从仪表板管理 <code>spider</code> ，并且调度它们自动运行</li><li>只需单击一次，即可部署 <code>scrapy</code> 项目</li><li>显示 <code>spider</code> 运行统计信息</li><li>提供 <code>api</code></li></ul><p><code>spiderkeeper</code> 目前只支持 <code>scrapyd</code> 方式运行的 <code>scrapy</code> 项目的管理，所以在安装 <code>spiderkeeper</code> 之前需要先安装 <code>scrapyd</code>。</p><h2 id="2-Scrapyd-简介"><a href="#2-Scrapyd-简介" class="headerlink" title="2. Scrapyd 简介"></a>2. Scrapyd 简介</h2><blockquote><p>Scrapyd 的源码地址：<a href="https://github.com/scrapy/scrapyd">https://github.com/scrapy/scrapyd</a></p></blockquote><p><code>Scrapyd</code> 是运行 <code>scrapy</code> 项目的一个守护服务，它允许你部署 <code>scrapy</code> 项目，并且可以使用 <code>http json api</code> 的方式控制 <code>scrapy</code> 的 <code>spider</code> 。</p><h2 id="3-安装-spiderkeeper"><a href="#3-安装-spiderkeeper" class="headerlink" title="3. 安装 spiderkeeper"></a>3. 安装 spiderkeeper</h2><p>使用下面的命令安装 <code>scrapyd</code>：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">pip install scrapyd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用下面的命令启动 <code>scrapyd</code>， <code>scrapyd</code> 默认运行在 <code>6800</code> 端口，如下所示：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">&gt;scrapyd2022-01-09T10:24:19+0800 [-] Loading e:\anaconda3\lib\site-packages\scrapyd\txapp.py...2022-01-09T10:24:20+0800 [-] Scrapyd web console available at http://127.0.0.1:6800/2022-01-09T10:24:20+0800 [-] Loaded.2022-01-09T10:24:20+0800 [twisted.application.app.AppLogger#info] twistd 21.7.0 (e:\anaconda3\python.exe 3.7.6) starting up.2022-01-09T10:24:20+0800 [twisted.application.app.AppLogger#info] reactor class: twisted.internet.selectreactor.SelectReactor.2022-01-09T10:24:20+0800 [-] Site starting on 68002022-01-09T10:24:20+0800 [twisted.web.server.Site#info] Starting factory &lt;twisted.web.server.Site object at 0x000001DA664F3C88&gt;2022-01-09T10:24:20+0800 [Launcher] Scrapyd 1.2.1 started: max_proc=16, runner='scrapyd.runner'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用下面的命令安装 <code>spiderkeeper</code> ：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">pip install spiderkeeper<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用下面的命令启动 <code>spiderkeeper</code>，默认运行在 <code>5000</code> 端口，如下所示：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">&gt;spiderkeeper--------------------------------------------------------------------------------INFO in run [e:\anaconda3\lib\site-packages\SpiderKeeper\run.py:22]:SpiderKeeper startd on 0.0.0.0:5000 username:admin/password:admin with scrapyd servers:http://localhost:6800--------------------------------------------------------------------------------2022-01-09 10:27:24,828 - SpiderKeeper.app - INFO - SpiderKeeper startd on 0.0.0.0:5000 username:admin/password:admin with scrapyd servers:http://localhost:6800<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>spiderkeeper</code> 的其他配置说明如下：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">spiderkeeper [options]Options:  -h, --help            show this help message and exit  --host=HOST           host, default:0.0.0.0  --port=PORT           port, default:5000  --username=USERNAME   basic auth username ,default: admin  --password=PASSWORD   basic auth password ,default: admin  --type=SERVER_TYPE    access spider server type, default: scrapyd  --server=SERVERS      servers, default: 'http://localhost:6800'  --database-url=DATABASE_URL                        SpiderKeeper metadata database default: sqlite:////home/souche/SpiderKeeper.db  --no-auth             disable basic auth  -v, --verbose         log level  example:spiderkeeper --server=http://localhost:6800<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>启动完成 spiderkeeper 后，在浏览器访问：<code>http://localhost:5000</code>，可以看到如下所示页面：</p><p>默认用户名和密码都为：<code>admin</code></p><p><img src="https://gitee.com/peterwd/pic-oss/raw/master/image/202201091031461.png" alt="image-20220109103152935"></p><p>登录成功后可以看到如下所示页面：</p><p><img src="https://gitee.com/peterwd/pic-oss/raw/master/image/202201091033643.png" alt="image-20220109103307504"></p><p>点击创建一个项目：</p><p><img src="https://gitee.com/peterwd/pic-oss/raw/master/image/202201091034490.png" alt="image-20220109103406400"></p><p>可以看到如下部署页面：</p><p><img src="https://gitee.com/peterwd/pic-oss/raw/master/image/202201091034875.png" alt="image-20220109103452704"></p><p>在 <code>scrapy</code> 项目中使用命令 <code>scrapyd-deploy --build-egg output.egg</code> 生成部署文件，并上传，即可完成 <code>scrapy</code> 项目的部署。</p><p>使用下面的命令生成部署文件：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">&gt;scrapyd-deploy --build-egg output.eggWriting egg to output.egg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>将前面的 <code>scrapy</code> 项目生成的 <code>output.egg</code> 上传到 <code>spiderkeeper</code> 中：</p><p><img src="https://gitee.com/peterwd/pic-oss/raw/master/image/202201091039413.png" alt="image-20220109103902307"></p><p>点击 <code>Dashboard</code> –&gt; 点击 <code>Run</code> –&gt; 选择需要运行的 <code>spider</code>，<code>spiderkeeper</code> 会自动识别 spider 中 <code>name</code> 的名称：</p><p><img src="https://gitee.com/peterwd/pic-oss/raw/master/image/202201091043201.png" alt="image-20220109104314079"></p><p>如果要创建定时任务，如下图所示：</p><p><img src="https://gitee.com/peterwd/pic-oss/raw/master/image/202201091045320.png" alt="image-20220109104510161"></p><h1 id="七-总结"><a href="#七-总结" class="headerlink" title="七. 总结"></a>七. 总结</h1><p>这篇文章简单记录自己学习 <code>scrapy</code> 的过程，包括从创建项目到部署项目的完整流程，很多细节并没有详细介绍，更多内容可以查看文章中列出的官方文档。</p>]]></content>
      
      
      <categories>
          
          <category> Scarpy、爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫Scrapy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 如何实现线程间通信</title>
      <link href="/archives/5c704262.html"/>
      <url>/archives/5c704262.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>虽然通常每个子线程只需要完成自己的任务，但是有时我们希望多个线程一起工作来完成一个任务，这就涉及到线程间通信。</p><p>关于线程间通信本文涉及到的方法和类包括：<code>thread.join()</code>、<code>object.wait()</code>、<code>object.notify()</code>、<code>CountdownLatch</code>、<code>CyclicBarrier</code>、<code>FutureTask</code>、<code>Callable</code>。</p><p>接下来将用几个例子来介绍如何在Java中实现线程间通信：</p><ol><li><p><strong>如何让两个线程依次执行，即一个线程等待另一个线程执行完成后再执行？</strong></p></li><li><p><strong>如何让两个线程以指定的方式有序相交执行？</strong></p></li><li><p><strong>有四个线程：A、B、C、D，如何实现 D 在 A、B、C 都同步执行完毕后执行？</strong></p></li><li><p><strong>三个运动员分开准备，然后在每个人准备好后同时开始跑步。</strong></p></li><li><p><strong>子线程完成任务后，将结果返回给主线程。</strong></p><span id="more"></span></li></ol><h1 id="1-如何让两个线程依次执行？"><a href="#1-如何让两个线程依次执行？" class="headerlink" title="1. 如何让两个线程依次执行？"></a>1. 如何让两个线程依次执行？</h1><p>假设有两个线程：A 和 B，这两个线程都可以按照顺序打印数字，代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test01</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>        <span class="token function">demo1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">demo1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Thread</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            <span class="token function">printNumber</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Thread</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            <span class="token function">printNumber</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        a<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        b<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printNumber</span><span class="token punctuation">(</span><span class="token class-name">String</span> threadName<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">++</span> <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>threadName <span class="token operator">+</span> <span class="token string">" print: "</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>得到的结果如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">A</span> print<span class="token operator">:</span> <span class="token number">1</span><span class="token class-name">B</span> print<span class="token operator">:</span> <span class="token number">1</span><span class="token class-name">B</span> print<span class="token operator">:</span> <span class="token number">2</span><span class="token class-name">A</span> print<span class="token operator">:</span> <span class="token number">2</span><span class="token class-name">A</span> print<span class="token operator">:</span> <span class="token number">3</span><span class="token class-name">B</span> print<span class="token operator">:</span> <span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到 A 和 B 同时打印数字，如果我们希望 B 在 A 执行完成之后开始执行，那么可以使用 <code>thread.join()</code> 方法实现，代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">demo2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">Thread</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>        <span class="token function">printNumber</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Thread</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"B 等待 A 执行"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            a<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">printNumber</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    a<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    b<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>得到的结果如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">B</span> 等待 <span class="token class-name">A</span> 执行<span class="token class-name">A</span> print<span class="token operator">:</span> <span class="token number">1</span><span class="token class-name">A</span> print<span class="token operator">:</span> <span class="token number">2</span><span class="token class-name">A</span> print<span class="token operator">:</span> <span class="token number">3</span><span class="token class-name">B</span> print<span class="token operator">:</span> <span class="token number">1</span><span class="token class-name">B</span> print<span class="token operator">:</span> <span class="token number">2</span><span class="token class-name">B</span> print<span class="token operator">:</span> <span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以看到该 <code>a.join()</code> 方法会让 B 等待 A 完成打印。</p><p><code>thread.join()</code> 方法的作用就是阻塞当前线程，等待调用 <code>join()</code> 方法的线程执行完毕后再执行后面的代码。</p><p>查看 <code>join()</code> 方法的源码，内部是调用了 <code>join(0)</code> ，如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>    <span class="token function">join</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>查看 <code>join(0)</code> 的源码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 注意这里使用了 sychronized 加锁，锁对象是线程的实例对象</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">join</span><span class="token punctuation">(</span><span class="token keyword">long</span> millis<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>    <span class="token keyword">long</span> base <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> now <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>millis <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"timeout value is negative"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment">// 调用 join(0) 执行下面的代码</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>millis <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 这里使用 while 循环的目的是为了避免虚假唤醒</span>        <span class="token comment">// 如果当前线程存活则调用 wait(0), 0 表示永久等待，直到调用 notifyAll() 或者 notify() 方法</span>        <span class="token comment">// 当线程结束的时候会调用 notifyAll() 方法</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">long</span> delay <span class="token operator">=</span> millis <span class="token operator">-</span> now<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>delay <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token function">wait</span><span class="token punctuation">(</span>delay<span class="token punctuation">)</span><span class="token punctuation">;</span>            now <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> base<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从源码中可以看出 <code>join(long millis)</code> 方法是通过 <code>wait(long timeout)</code> （<code>Object</code> 提供的方法）方法实现的，调用 <code>wait</code> 方法之前，当前线程必须获得对象的锁，所以此 <code>join</code> 方法使用了 <code>synchronized</code> 加锁，锁对象是线程的实例对象。其中 <code>wait(0)</code>方法会让当前线程阻塞等待，直到另一个线程调用<strong>此对象</strong>的 <code>notify()</code> 或者 <code>notifyAll()</code> 方法才会继续执行。当调用 <code>join</code> 方法的线程结束的时候会调用 <code>notifyAll()</code> 方法，所以 <code>join()</code> 方法可以实现一个线程等待另一个调用 <code>join()</code> 的线程结束后再执行。</p><blockquote><p><strong>虚假唤醒</strong>：一个线程在没有被通知、中断、超时的情况下被唤醒；</p><p>虚假唤醒可能导致条件不成立的情况下执行代码，破坏被锁保护的约束关系；</p><p>为什么使用 while 循环来避免<strong>虚假唤醒</strong>：</p><p>在 if 块中使用 wait 方法，是非常危险的，因为一旦线程被唤醒，并得到锁，就不会再判断 if 条件而执行 if 语句块外的代码，所以建议凡是先要做条件判断，再 wait 的地方，都使用 while 循环来做，循环会在等待之前和之后对条件进行测试。</p></blockquote><h1 id="2-如何让两个线程按照指定的方式有序相交？"><a href="#2-如何让两个线程按照指定的方式有序相交？" class="headerlink" title="2. 如何让两个线程按照指定的方式有序相交？"></a>2. 如何让两个线程按照指定的方式有序相交？</h1><p>如果现在我们希望 B线程在 A 线程打印 1 后立即打印 1，2，3，然后 A 线程继续打印 2，3，那么我们需要更细粒度的锁来控制执行顺序。</p><p>在这里，我们可以利用 <code>object.wait()</code> 和 <code>object.notify()</code> 方法，代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">demo3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">Object</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Thread</span> <span class="token class-name">A</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"A 1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                lock<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"A 2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"A 3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Thread</span> <span class="token class-name">B</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"B 1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"B 2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"B 3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            lock<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">A</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">B</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>得到的结果如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">A</span> <span class="token number">1</span><span class="token class-name">B</span> <span class="token number">1</span><span class="token class-name">B</span> <span class="token number">2</span><span class="token class-name">B</span> <span class="token number">3</span><span class="token class-name">A</span> <span class="token number">2</span><span class="token class-name">A</span> <span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码的执行流程如下：</p><ol><li>首先我们创建一个由 A 和 B 共享的对象锁： <code>lock = new Object()</code>;</li><li>当A拿到锁时，先打印1，然后调用<code>lock.wait()</code>方法进入等待状态，然后交出锁的控制权；</li><li>B 不会被执行，直到 A 调用该<code>lock.wait()</code>方法释放控制权并且 B 获得锁；</li><li>B拿到锁后打印1，2，3，然后调用<code>lock.notify()</code>方法唤醒正在等待的A；</li><li>A 唤醒后继续打印剩余的 2，3。</li></ol><p>为了便于理解，我将上面的代码添加了日志，代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">demo3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">Object</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Thread</span> <span class="token class-name">A</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"INFO：A 等待获取锁"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"INFO：A 获取到锁"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"A 1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"INFO：A 进入 waiting 状态，放弃锁的控制权"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                lock<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"INFO：A 被 B 唤醒继续执行"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"A 2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"A 3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Thread</span> <span class="token class-name">B</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"INFO：B 等待获取锁"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"INFO：B 获取到锁"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"B 1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"B 2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"B 3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"INFO：B 执行结束，调用 notify 方法唤醒 A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            lock<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">A</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">B</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>得到的结果如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">INFO：<span class="token class-name">A</span> 等待获取锁INFO：<span class="token class-name">A</span> 获取到锁<span class="token class-name">A</span> <span class="token number">1</span>INFO：<span class="token class-name">A</span> 进入 waiting 状态，放弃锁的控制权INFO：<span class="token class-name">B</span> 等待获取锁INFO：<span class="token class-name">B</span> 获取到锁<span class="token class-name">B</span> <span class="token number">1</span><span class="token class-name">B</span> <span class="token number">2</span><span class="token class-name">B</span> <span class="token number">3</span>INFO：<span class="token class-name">B</span> 执行结束，调用 notify 方法唤醒 <span class="token class-name">A</span>INFO：<span class="token class-name">A</span> 被 <span class="token class-name">B</span> 唤醒继续执行<span class="token class-name">A</span> <span class="token number">2</span><span class="token class-name">A</span> <span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="3-线程-D-在A、B、C都同步执行完毕后执行"><a href="#3-线程-D-在A、B、C都同步执行完毕后执行" class="headerlink" title="3. 线程 D 在A、B、C都同步执行完毕后执行"></a>3. 线程 D 在A、B、C都同步执行完毕后执行</h1><p><code>thread.join()</code> 前面介绍的方法允许一个线程在等待另一个线程完成运行后继续执行。但是如果我们将A、B、C依次加入到D线程中，就会让A、B、C依次执行，而我们希望它们三个同步运行。</p><p>我们要实现的目标是：A、B、C三个线程可以同时开始运行，各自独立运行完成后通知D；D 不会开始运行，直到 A、B 和 C 都运行完毕。所以我们 <code>CountdownLatch</code> 用来实现这种类型的通信。它的基本用法是：</p><ol><li>创建一个计数器，并设置一个初始值， <code>CountdownLatch countDownLatch = new CountDownLatch(3)</code>;</li><li>调用<code>countDownLatch.await()</code>进入等待状态，直到计数值变为0；</li><li>在其他线程调用<code>countDownLatch.countDown()</code>，该方法会将计数值减一；</li><li>当计数器的值变为 <code>0</code> 时，<code>countDownLatch.await()</code>等待线程中的方法会继续执行下面的代码。</li></ol><p>实现代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">runDAfterABC</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token class-name">CountDownLatch</span> countDownLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"INFO: D 等待 A B C 运行完成"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"INFO: A B C 运行完成，D 开始运行"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"D is working"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> threadName <span class="token operator">=</span> <span class="token char">'A'</span><span class="token punctuation">;</span> threadName <span class="token operator">&lt;=</span> <span class="token char">'C'</span> <span class="token punctuation">;</span> threadName<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> <span class="token class-name">String</span> name <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>threadName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name <span class="token operator">+</span> <span class="token string">" is working"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name <span class="token operator">+</span> <span class="token string">" finished"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>得到的结果如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">INFO<span class="token operator">:</span> <span class="token class-name">D</span> 等待 <span class="token class-name">A</span> <span class="token class-name">B</span> <span class="token class-name">C</span> 运行完成<span class="token class-name">A</span> is working<span class="token class-name">B</span> is working<span class="token class-name">C</span> is working<span class="token class-name">C</span> finished<span class="token class-name">B</span> finished<span class="token class-name">A</span> finishedINFO<span class="token operator">:</span> <span class="token class-name">A</span> <span class="token class-name">B</span> <span class="token class-name">C</span> 运行完成，<span class="token class-name">D</span> 开始运行<span class="token class-name">D</span> is working<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实<code>CountDownLatch</code>它本身就是一个倒数计数器，我们把初始的count值设置为3。D运行的时候，首先调用该<code>countDownLatch.await()</code>方法检查计数器的值是否为0，如果不是0则保持等待状态. A、B、C 运行完毕后，分别使用<code>countDownLatch.countDown()</code>方法将倒数计数器减1。计数器将减为 0，然后通知<code>await()</code>方法结束等待，D开始继续执行。</p><p>因此，<code>CountDownLatch</code>适用于一个线程需要等待多个线程的情况。</p><h1 id="4-三个运动员分开准备同时开跑"><a href="#4-三个运动员分开准备同时开跑" class="headerlink" title="4. 三个运动员分开准备同时开跑"></a>4. 三个运动员分开准备同时开跑</h1><p>这一次，A、B、C这三个线程都需要分别准备，等三个线程都准备好后开始同时运行，我们应该如何做到这一点？</p><p><code>CountDownLatch</code>可以用来计数，但完成计数的时候，只有一个线程的一个<code>await()</code>方法会得到响应，所以多线程不能在同一时间被触发。为了达到线程相互等待的效果，我们可以使用该<code>CyclicBarrier</code>，其基本用法为：</p><ol><li>首先创建一个公共对象<code>CyclicBarrier</code>，并设置同时等待的线程数，<code>CyclicBarrier cyclicBarrier = new CyclicBarrier(3);</code></li><li>这些线程同时开始准备，准备好后，需要等待别人准备好，所以调用<code>cyclicBarrier.await()</code>方法等待别人；</li><li>当指定的需要同时等待的线程都调用了该<code>cyclicBarrier.await()</code>方法时，意味着这些线程准备好了，那么这些线程就会开始同时继续执行。</li></ol><p>想象一下有三个跑步者需要同时开始跑步，所以他们需要等待其他人都准备好，实现代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">runABCWhenAllReady</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token class-name">CyclicBarrier</span> cyclicBarrier <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CyclicBarrier</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Random</span> random <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> threadName <span class="token operator">=</span> <span class="token char">'A'</span><span class="token punctuation">;</span> threadName <span class="token operator">&lt;=</span> <span class="token char">'C'</span> <span class="token punctuation">;</span> threadName<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> <span class="token class-name">String</span> name <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>threadName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> prepareTime <span class="token operator">=</span> random<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name <span class="token operator">+</span> <span class="token string">" 准备时间："</span> <span class="token operator">+</span> prepareTime<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>prepareTime<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name <span class="token operator">+</span> <span class="token string">" 准备好了，等待其他人"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                cyclicBarrier<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> <span class="token operator">|</span> <span class="token class-name">BrokenBarrierException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name <span class="token operator">+</span> <span class="token string">" 开始跑步"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>得到结果如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">A</span> 准备时间：<span class="token number">1085</span><span class="token class-name">B</span> 准备时间：<span class="token number">7729</span><span class="token class-name">C</span> 准备时间：<span class="token number">8444</span><span class="token class-name">A</span> 准备好了，等待其他人<span class="token class-name">B</span> 准备好了，等待其他人<span class="token class-name">C</span> 准备好了，等待其他人<span class="token class-name">C</span> 开始跑步<span class="token class-name">A</span> 开始跑步<span class="token class-name">B</span> 开始跑步<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>CyclicBarrier</code> 的作用就是等待多个线程同时执行。</p><h1 id="5-子线程将结果返回给主线程"><a href="#5-子线程将结果返回给主线程" class="headerlink" title="5. 子线程将结果返回给主线程"></a>5. 子线程将结果返回给主线程</h1><p>在实际开发中，往往我们需要创建子线程来做一些耗时的任务，然后将执行结果传回主线程。那么如何在 Java 中实现呢？</p><p>一般在创建线程的时候，我们会把 <code>Runnable</code> 对象传递给 <code>Thread</code> 执行，<code>Runable</code> 的源码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到 Runable 是一个函数式接口，该接口中的 run 方法没有返回值，那么如果要返回结果，可以使用另一个类似的接口 <code>Callable</code>。</p><blockquote><p>函数式接口：只有一个方法的接口</p></blockquote><p><code>Callable</code> 接口的源码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token comment">/**     * Computes a result, or throws an exception if unable to do so.     *     * @return computed result     * @throws Exception if unable to compute a result     */</span>    <span class="token class-name">V</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，最大的区别<code>Callable</code>在于它返回的是泛型。</p><p>那么接下来的问题是，如何将子线程的结果传回去呢？Java 有一个类，<code>FutureTask</code>，它可以与 一起工作<code>Callable</code>，但请注意，<code>get</code>用于获取结果的方法会阻塞主线程。<code>FutureTask</code> 本质上还是一个 <code>Runnable</code>，所以可以直接传到 <code>Thread</code> 中。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/41cdd9426d1418fe870ae32c45bbd428.png" alt="image-20210905183800030.png"></p><p>比如我们想让子线程计算1到100的总和，并将结果返回给主线程，代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">getResultInWorker</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> callable <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"子任务开始执行"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">+=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"子任务执行完成并返回结果"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> futureTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>callable<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>futureTask<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"开始执行 futureTask.get()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Integer</span> result <span class="token operator">=</span> futureTask<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行的结果："</span> <span class="token operator">+</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ExecutionException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>得到的结果如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">开始执行 futureTask<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>子任务开始执行子任务执行完成并返回结果执行的结果：<span class="token number">5050</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出在主线程调用<code>futureTask.get()</code>方法时阻塞了主线程；然后<code>Callable</code>开始在内部执行并返回操作的结果；然后<code>futureTask.get()</code>得到结果，主线程恢复运行。</p><p>在这里我们可以了解到，<code>FutureTask</code>和<code>Callable</code>可以直接在主线程中获取子线程的结果，但是它们会阻塞主线程。当然，如果你不希望阻塞主线程，可以考虑使用<code>ExecutorService</code>把<code>FutureTask</code>到线程池来管理执行。</p><p>参考文章：</p><p><a href="https://www.tutorialdocs.com/article/java-inter-thread-communication.html">https://www.tutorialdocs.com/article/java-inter-thread-communication.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java线程间通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阅读阿里Java开发手册记录</title>
      <link href="/archives/6ab7fbd2.html"/>
      <url>/archives/6ab7fbd2.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在阅读完阿里Java开发手册(嵩山版)后，发现自己在开发过程中有一些没有按照规范开发的情况，这里将容易忘记的规范记录下来，并且添加自己的理解，一方面方便自己巩固记忆，另一方面希望对其他同学能够提供一下帮助。这里将收集的<strong>阿里Java开发手册</strong>文档放在了 <a href="https://github.com/edisonwd/alibaba-Java-development-document">github 仓库</a>，更多详细内容可以下载文档查看。</p><h2 id="编程规约"><a href="#编程规约" class="headerlink" title="编程规约"></a>编程规约</h2><ol><li><p><strong>【强制】</strong> 抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类 命名以它要测试的类的名称开始，以 Test 结尾。</p><span id="more"></span></li><li><p><strong>【强制】</strong> <code>POJO</code> 类中的任何布尔类型的变量，都不要加 is 前缀，否则部分框架解析会引起序列 化错误。</p><blockquote><p><strong>说明：</strong>在本文 <code>MySQL</code> 规约中的建表约定第一条，表达<strong>是与否</strong>的变量采用 <code>is_xxx</code> 的命名方式，所以需要在 <code>&lt;resultMap&gt;</code> 设置从 <code>is_xxx</code> 到 <code>xxx</code> 的映射关系。</p><p><strong>反例：</strong>定义为基本数据类型 Boolean <code>isDeleted</code> 的属性，它的方法也是 <code>isDeleted()</code>，框架在反向解析的时 候，“误以为”对应的属性名称是 deleted，导致属性获取不到，进而抛出异常。</p></blockquote></li><li><p><strong>【推荐】</strong>如果模块、接口、类、方法使用了设计模式，在命名时需体现出具体模式。</p><blockquote><p>说明：将设计模式体现在名字中，有利于阅读者快速理解架构设计理念。例如使用了代理模式可以命名为：<code>public class LoginProxy;</code></p></blockquote></li><li><p>【推荐】枚举类名带上 <code>Enum</code> 后缀，枚举成员名称需要全大写，单词间用下划线隔开。</p><blockquote><p>说明：枚举其实就是特殊的常量类，且构造方法被默认强制是私有。</p><!--more--></blockquote></li><li><p><strong>【强制】</strong> 不允许任何魔法值（即未经预先定义的常量）直接出现在代码中。</p></li><li><p><strong>【强制】</strong> 采用 4 个空格缩进，禁止使用 Tab 字符。</p><blockquote><p>说明：如果使用 Tab 缩进，必须设置 1 个 Tab 为 4 个空格。IDEA 设置 Tab 为 4 个空格时，请勿勾选 Use tab character；而在 Eclipse 中，必须勾选 insert spaces for tabs。</p></blockquote></li><li><p><strong>【强制】</strong> 避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成 本，直接用<code>类名.静态属性或静态方法</code>来访问即可。</p></li><li><p><strong>【强制】</strong> Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用 equals。</p><blockquote><p>说明：推荐使用 <code>JDK7</code> 引入的工具类 <code>java.util.Objects.equals(Object a, Object b)</code>，此方法的内部实现为：<code>return (a == b) || (a != null &amp;&amp; a.equals(b));</code></p></blockquote></li><li><p>关于基本数据类型与包装数据类型的使用标准如下：</p><p>1)<strong>【强制】</strong> 所有的 POJO 类属性必须使用包装数据类型。</p><p>2)<strong>【强制】</strong> RPC 方法的返回值和参数必须使用包装数据类型。</p><p>3)【推荐】所有的局部变量使用基本数据类型。</p><blockquote><p>说明：POJO 类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何 NPE 问题，或 者入库检查，都由使用者来保证。数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 NPE 风险。</p></blockquote></li><li><p><strong>【强制】</strong> 定义 DO/DTO/VO 等 POJO 类时，不要设定任何属性默认值。</p></li><li><p>.<strong>【强制】</strong> 构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 <code>init</code> 方法中。</p></li><li><p><strong>【强制】</strong> POJO 类必须写 toString 方法。使用 IDE 中的工具：<code>source&gt; generate toString</code> 时，如果继承了另一个 POJO 类，注意在前面加一下 <code>super.toString()</code>。</p><blockquote><p>说明：在方法执行抛出异常时，可以直接调用 POJO 的 toString()方法打印其属性值，便于排查问题。</p></blockquote></li><li><p>【推荐】慎用 Object 的 clone 方法来拷贝对象。</p><blockquote><p>说明：对象 clone 方法默认是浅拷贝，若想实现深拷贝，需覆写 clone 方法实现域对象的深度遍历式拷贝。</p></blockquote></li><li><p><strong>【强制】</strong> 获取当前毫秒数：<code>System.currentTimeMillis();</code> 而不是 <code>new Date().getTime()</code>。</p><blockquote><p>说明：如果想获取更加精确的纳秒级时间值，使用 <code>System.nanoTime()</code> 的方式。在 JDK8 中，针对统计时间等场景，推荐使用 Instant 类。</p></blockquote></li><li><p>【推荐】前后端的时间格式统一为<code>"yyyy-MM-dd HH:mm:ss"</code>，统一为 GMT。</p></li><li><p><strong>【强制】</strong> 在前后端交互的 <code>JSON</code> 格式数据中，所有的 key 必须为小写字母开始的 <code>lowerCamelCase</code> 风格，符合英文表达习惯，且表意完整。</p><blockquote><p>正例：errorCode / errorMessage / assetStatus / menuList / orderList / configFlag</p></blockquote></li></ol><h2 id="集合处理"><a href="#集合处理" class="headerlink" title="集合处理"></a>集合处理</h2><ol><li><p><strong>【强制】</strong> 只要覆写 <code>equals</code>，就必须覆写 <code>hashCode</code>。</p><blockquote><p>说明：String 因为覆写了 <code>hashCode</code> 和 <code>equals</code> 方法，所以可以愉快地将 <code>String</code> 对象作为 Map 的 key 来使用。</p></blockquote></li><li><p><strong>【强制】</strong> 判断所有集合内部的元素是否为空，使用 <code>isEmpty()</code> 方法，而不是 <code>size()==0</code> 的方式。</p><blockquote><p>说明：在某些集合中，前者的时间复杂度为 O(1)，而且可读性更好。</p></blockquote></li><li><p><strong>【强制】</strong> 使用集合转数组的方法，必须使用集合的 <code>toArray(T[] array)</code>方法，传入的是类型完全一致、长度为 0 的空数组。</p><blockquote><p>说明：直接使用 <code>toArray()</code> 无参方法存在问题，此方法返回值只能是 <code>Object[]</code> 类，若强转其它类型数组将出现 <code>ClassCastException</code> 错误。正例：<code>String[] array = list.toArray(new String[0]);</code></p></blockquote></li><li><p><strong>【强制】</strong> 使用工具类 <code>Arrays.asList()</code> 把数组转换成集合时，不能使用其修改集合相关的方法， 它的 <code>add/remove/clear</code> 方法会抛出 <code>UnsupportedOperationException</code> 异常。</p><blockquote><p>说明：<code>asList()</code> 的返回对象是一个 <code>Arrays</code> 内部类，并没有实现集合的修改方法。<code>Arrays.asList</code> 体现的是适配器模式，只是转换接口，后台的数据仍是数组。</p></blockquote></li><li><p><strong>【强制】</strong> 不要在 <code>foreach</code> 循环里进行元素的 <code>remove/add</code> 操作。<code>remove</code> 元素请使用 <code>Iterator</code> 方式，如果并发操作，需要对 <code>Iterator</code> 对象加锁。</p></li><li><p>.【推荐】高度注意 Map 类集合 K/V 能不能存储 null 值的情况，如下表格：</p><table><thead><tr><th>集合类</th><th>key（键）</th><th>value（值）</th><th>super（父类）</th><th>说明</th></tr></thead><tbody><tr><td>Hashtable</td><td>不允许为 null</td><td>不允许为 null</td><td>Dictionary</td><td>线程安全</td></tr><tr><td>ConcurrentHashMap</td><td>不允许为 null</td><td>不允许为 null</td><td>AbstractMap</td><td>线程安全，锁分段（jdk8:CAS）</td></tr><tr><td>TreeMap</td><td>不允许为 null</td><td>允许为 null</td><td>AbstractMap</td><td>线程不安全</td></tr><tr><td>HashMap</td><td>允许为 null</td><td>允许为 null</td><td>AbstractMap</td><td>线程不安全</td></tr></tbody></table><blockquote><p>反例：由于 HashMap 的干扰，很多人认为 ConcurrentHashMap 是可以置入 null 值，而事实上，存储 null 值时会抛出 NPE 异常。</p></blockquote></li></ol><h2 id="并发处理"><a href="#并发处理" class="headerlink" title="并发处理"></a>并发处理</h2><ol><li><p><strong>【强制】</strong> 创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。</p></li><li><p><strong>【强制】</strong> 线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。</p><blockquote><p>说明：线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题。 如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。</p></blockquote></li><li><p><strong>【强制】</strong> 线程池不允许使用 <code>Executors</code> 去创建，而是通过 <code>ThreadPoolExecutor</code> 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p><blockquote><p>说明：Executors 返回的线程池对象的弊端如下：</p><p>1） <code>FixedThreadPool</code> 和 <code>SingleThreadPool</code>： 允许的请求队列长度为 <code>Integer.MAX_VALUE</code>，可能会堆积大量的请求，从而导致 <code>OOM</code>。</p><p>2） <code>CachedThreadPool</code>： 允许的创建线程数量为 <code>Integer.MAX_VALUE</code>，可能会创建大量的线程，从而导致 <code>OOM</code>。</p></blockquote></li><li><p><strong>【强制】</strong> <code>SimpleDateFormat</code> 是线程不安全的类，一般不要定义为 <code>static</code> 变量，如果定义为 <code>static</code>， 必须加锁，或者使用 <code>DateUtils</code> 工具类。</p><blockquote><p>说明：如果是 <code>JDK8</code> 的应用，可以使用 <code>Instant</code> 代替 <code>Date</code>，<code>LocalDateTime</code> 代替 <code>Calendar</code>， <code>DateTimeFormatter</code> 代替 <code>SimpleDateFormat</code>，官方给出的解释：<code>simple beautiful strong immutable thread-safe</code>。</p></blockquote></li><li><p><strong>【强制】</strong> 并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加 锁，要么在数据库层使用乐观锁，使用 version 作为更新依据。</p><blockquote><p>说明：如果每次访问冲突概率小于 20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于 3 次。</p></blockquote></li><li><p>【推荐】资金相关的金融敏感信息，使用悲观锁策略。</p><blockquote><p>说明：乐观锁在获得锁的同时已经完成了更新操作，校验逻辑容易出现漏洞，另外，乐观锁对冲突的解决策 略有较复杂的要求，处理不当容易造成系统压力或数据异常，所以资金相关的金融敏感信息不建议使用乐观 锁更新。</p><p>正例：悲观锁遵循一锁、二判、三更新、四释放的原则。\</p></blockquote></li><li><p><strong>【强制】</strong> 在高并发场景中，避免使用”等于”判断作为中断或退出的条件。</p><blockquote><p>说明：如果并发控制没有处理好，容易产生等值判断被“击穿”的情况，使用大于或小于的区间判断条件 来代替。</p><p>反例：判断剩余奖品数量等于 0 时，终止发放奖品，但因为并发处理错误导致奖品数量瞬间变成了负数， 这样的话，活动无法终止。</p></blockquote></li></ol><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><ol><li><p>**<strong>【强制】</strong> **生产环境禁止直接使用 <code>System.out</code> 或 <code>System.err</code> 输出日志或使用 <code>e.printStackTrace()</code>打印异常堆栈。</p><blockquote><p><strong>说明：</strong>标准日志输出与标准错误输出文件每次 <code>Jboss</code> 重启时才滚动，如果大量输出送往这两个文件，容易 造成文件大小超过操作系统大小限制。</p></blockquote></li><li><p><strong>【强制】</strong> 错误码使用者避免随意定义新的错误码。</p><blockquote><p>说明：尽可能在原有错误码附表中找到语义相同或者相近的错误码在代码中使用即可。</p></blockquote></li><li><p><strong>【强制】</strong> 错误码不能直接输出给用户作为提示信息使用。</p><blockquote><p>说明：堆栈、错误信息、错误码、提示信息 是一个有效关联并互相转义的和谐整体，但是请勿互相越俎代庖。</p></blockquote></li><li><p><strong>【强制】</strong> 捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请 将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的 内容。</p></li><li><p><strong>【强制】</strong> 事务场景中，抛出异常被 catch 后，如果需要回滚，一定要注意手动回滚事务。</p></li><li><p><strong>【强制】</strong> finally 块必须对资源对象、流对象进行关闭，有异常也要做 try-catch。</p><blockquote><p>说明：如果 <code>JDK7</code> 及以上，可以使用 <code>try-with-resources</code> 方式。</p></blockquote></li><li><p><strong>【强制】</strong> 异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过 关键字 throws 往上抛出。</p></li><li><p><strong>【强制】</strong> 日志打印时禁止直接用 JSON 工具将对象转换成 String。</p><blockquote><p>说明：如果对象里某些 get 方法被覆写，存在抛出异常的情况，则可能会因为打印日志而影响正常业务流 程的执行。</p><p>正例：打印日志时仅打印出业务相关属性值或者调用其对象的 <code>toString()</code>方法</p></blockquote></li><li><p>【推荐】谨慎地记录日志。生产环境禁止输出 debug 日志；有选择地输出 info 日志；如果使用 warn 来记录刚上线时的业务行为信息，一定要注意日志输出量的问题，避免把服务器磁盘撑 爆，并记得及时删除这些观察日志。</p><blockquote><p>说明：大量地输出无效日志，不利于系统性能提升，也不利于快速定位错误点。记录日志时请思考：这些 日志真的有人看吗？看到这条日志你能做什么？能不能给问题排查带来好处？</p></blockquote></li></ol><h2 id="MySQL-数据库"><a href="#MySQL-数据库" class="headerlink" title="MySQL 数据库"></a><code>MySQL</code> 数据库</h2><h3 id="建表规约"><a href="#建表规约" class="headerlink" title="建表规约"></a>建表规约</h3><ol><li><p><strong>【强制】</strong> 表达是与否概念的字段，必须使用 <code>is_xxx</code> 的方式命名，数据类型是 <code>unsigned tinyint</code> （1 表示是，0 表示否）。</p><blockquote><p>说明：任何字段如果为非负数，必须是 unsigned。</p><p>注意：POJO 类中的任何布尔类型的变量，都不要加 is 前缀，所以，需要在设置从 is_xxx 到 Xxx 的映射关系。数据库表示是与否的值，使用 tinyint 类型，坚持 is_xxx 的命名方式是为了明确其取值含 义与取值范围。</p><p>正例：表达逻辑删除的字段名 is_deleted，1 表示删除，0 表示未删除。</p></blockquote></li><li><p><strong>【强制】</strong> 表名、字段名必须<strong>使用小写字母或数字</strong>，禁止出现数字开头，禁止两个下划线中间只 出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。</p></li><li><p><strong>【强制】</strong> 表名不使用复数名词。</p></li><li><p><strong>【强制】</strong> 禁用保留字，如 <code>desc、range、match、delayed</code> 等，请参考 MySQL 官方保留字。</p></li><li><p><strong>【强制】</strong> 主键索引名为 pk_字段名；唯一索引名为 uk_字段名；普通索引名则为 idx_字段名。</p><blockquote><p>说明：pk_ 即 primary key；uk_ 即 unique key；idx_ 即 index 的简称。</p></blockquote></li><li><p><strong>【强制】</strong> 小数类型为 <code>decimal</code>，禁止使用 <code>float</code> 和 <code>double</code>。</p><blockquote><p>说明：在存储的时候，float 和 double 都存在精度损失的问题，很可能在比较值的时候，得到不正确的 结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数并分开存储。</p></blockquote></li><li><p><strong>【强制】</strong> 如果存储的字符串长度几乎相等，使用 char 定长字符串类型。</p></li><li><p><strong>【强制】</strong> <code>varchar</code> 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度 大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索引效率。</p></li><li><p><strong>【强制】</strong> 表必备三字段：<code>id, create_time, update_time</code>。</p><blockquote><p>说明：其中 id 必为主键，类型为 bigint unsigned、单表时自增、步长为 1。create_time, update_time 的类型均为 datetime 类型，前者现在时表示主动式创建，后者过去分词表示被动式更新。</p></blockquote></li></ol><h3 id="索引规约"><a href="#索引规约" class="headerlink" title="索引规约"></a>索引规约</h3><ol><li><p><strong>【强制】</strong> 业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。</p><blockquote><p>说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外， 即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。</p></blockquote></li><li><p><strong>【强制】</strong> 超过三个表禁止 join。需要 join 的字段，数据类型保持绝对一致；多表关联查询时， 保证被关联的字段需要有索引。</p><blockquote><p>说明：即使双表 join 也要注意表索引、SQL 性能。</p></blockquote></li><li><p><strong>【强制】</strong> 在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据 实际文本区分度决定索引长度。</p><blockquote><p>说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达 90% 以上，可以使用 count(distinct left(列名, 索引长度))/count(*)的区分度来确定。</p></blockquote></li><li><p><strong>【强制】</strong> 页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。</p><blockquote><p>说明：索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。</p></blockquote></li><li><p>【推荐】利用覆盖索引来进行查询操作，避免回表。</p><blockquote><p>正例：能够建立索引的种类分为主键索引、唯一索引、普通索引三种，而覆盖索引只是一种查询的一种效 果，用 explain 的结果，extra 列会出现：using index。</p></blockquote></li><li><p>【推荐】利用延迟关联或者子查询优化超多分页场景。</p><blockquote><p>说明：MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL 改写。</p><p>正例：先快速定位需要获取的 id 段，然后再关联： <code>SELECT t1.* FROM 表 1 as t1, (select id from 表 1 where 条件 LIMIT 100000,20 ) as t2 where t1.id=t2.id</code></p></blockquote></li><li><p>【推荐】建组合索引的时候，区分度最高的在最左边。</p><blockquote><p>正例：如果 where a=? and b=?，a 列的几乎接近于唯一值，那么只需要单建 idx_a 索引即可。</p><p>说明：存在非等号和等号混合判断条件时，在建索引时，请把等号条件的列前置。如：where c&gt;? and d=? 那么即使 c 的区分度更高，也必须把 d 放在索引的最前列，即建立组合索引 idx_d_c。</p></blockquote></li></ol><h3 id="SQL-语句"><a href="#SQL-语句" class="headerlink" title="SQL 语句"></a>SQL 语句</h3><ol><li><p><strong>【强制】</strong> 不要使用 <code>count(列名)</code>或 <code>count(常量)</code>来替代 <code>count(*)</code>，<code>count(*)</code>是 <code>SQL92</code> 定义的标 准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。</p><blockquote><p>说明：<code>count(*)</code>会统计值为 NULL 的行，而 <code>count(列名)</code>不会统计此列为 NULL 值的行。</p></blockquote></li><li><p><strong>【强制】</strong> <code>count(distinct col)</code> 计算该列除 NULL 之外的不重复行数，注意 <code>count(distinct col1, col2)</code> 如果其中一列全为 NULL，那么即使另一列有不同的值，也返回为 0。</p></li><li><p><strong>【强制】</strong> 当某一列的值全是 NULL 时，count(col)的返回结果为 0，但 sum(col)的返回结果为 NULL，因此使用 sum()时需注意 NPE 问题。</p><blockquote><p>正例：可以使用如下方式来避免 sum 的 NPE 问题：<code>SELECT IFNULL(SUM(column), 0) FROM table;</code></p></blockquote></li><li><p>. <strong>【强制】</strong> 使用 ISNULL()来判断是否为 NULL 值。</p><blockquote><p>反例：在 SQL 语句中，如果在 null 前换行，影响可读性。<code>select * from table where column1 is null and column3 is not null; 而ISNULL(column)</code>是一个整体，简洁易懂。从性能数据上分析，<code>ISNULL(column)</code> 执行效率更快一些。</p></blockquote></li><li><p><strong>【强制】</strong> 不得使用外键与级联，一切外键概念必须在应用层解决。</p><blockquote><p>说明：（概念解释）学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学 生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于单机 低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库 的插入速度。</p></blockquote></li><li><p><strong>【强制】</strong> 禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。</p></li><li><p><strong>【强制】</strong> 数据订正（特别是删除或修改记录操作）时，要先 select，避免出现误删除，确认无 误才能执行更新语句。</p></li></ol><h3 id="ORM-映射"><a href="#ORM-映射" class="headerlink" title="ORM 映射"></a>ORM 映射</h3><ol><li><p><strong>【强制】</strong> 在表查询中，一律不要使用 <code>*</code> 作为查询的字段列表，需要哪些字段必须明确写明。</p><blockquote><p>说明：</p><p>1）增加查询分析器解析成本。</p><p>2）增减字段容易与 <code>resultMap</code> 配置不一致。</p><p>3）无用字段增加网络 消耗，尤其是 text 类型的字段。</p></blockquote></li><li><p><strong>【强制】</strong> 不要用 resultClass 当返回参数，即使所有类属性名与数据库字段一一对应，也需要 定义；反过来，每一个表也必然有一个与之对应。</p><blockquote><p>说明：配置映射关系，使字段与 DO 类解耦，方便维护。</p></blockquote></li><li><p><strong>【强制】</strong> sql.xml 配置参数使用：<code>#{}，#param#</code> 不要使用 <code>${}</code> 此种方式容易出现 SQL 注入。</p></li><li><p><strong>【强制】</strong> 不允许直接拿 HashMap 与 Hashtable 作为查询结果集的输出。</p></li><li><p><strong>【强制】</strong> 更新数据表记录时，必须同时更新记录对应的 update_time 字段值为当前时间。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 阿里开发手册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发手册 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 异常分析</title>
      <link href="/archives/b563544.html"/>
      <url>/archives/b563544.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>本文是对以下内容的分析：</strong></p><ul><li><strong>Java异常设计</strong></li><li><strong>Java 异常分类</strong></li><li><strong>Java异常可以告诉什么问题</strong></li><li><strong>Java异常处理最佳实践</strong></li></ul><p>Java Exception 是为了处理应用程序的异常行为而创建的类。在本文中，将解释如何使用 Java Exception 类以及如何在考虑现有 Java Exception 设计的情况下创建异常结构。Java 异常概念是 Java 中的重要里程碑之一，每个开发人员都<em><strong>必须</strong></em>知道它。</p><span id="more"></span><h2 id="Java-异常体系结构"><a href="#Java-异常体系结构" class="headerlink" title="Java 异常体系结构"></a>Java 异常体系结构</h2><p>基本结构如下图：</p><p><img src="https://img2020.cnblogs.com/blog/1373850/202109/1373850-20210916171610134-74256038.png" alt="img"></p><p><code>Throwable</code> 是所有异常的父类，它有两个子类：<code>Error</code> 和 <code>Exception</code>。</p><p><strong>Error ：程序一旦出现 Error 错误，程序可能会停止运行。</strong></p><p><strong>Exception：与 Error 不同，程序中出现 Exception 异常有机会从问题中恢复，并尝试保持程序运行。</strong></p><!--more--><h2 id="Java-检查异常和非检查异常"><a href="#Java-检查异常和非检查异常" class="headerlink" title="Java 检查异常和非检查异常"></a>Java 检查异常和非检查异常</h2><p><strong>检查异常：</strong>所有不是 <code>Runtime Exception</code> 的异常，统称为 <code>Checked Exception</code>，又被称为检查性异常。这类异常的产生不是程序本身的问题，通常由外界因素造成的。为了预防这些异常产生时，造成程序的中断或得到不正确的结果，Java 要求编写可能产生这类异常的程序代码时，一定要去做异常的处理。</p><p><strong>非检查异常：</strong> Java 语言将派生于 <code>RuntimeException</code> 类或 <code>Error</code> 类的所有异常称为非检查性异常。</p><p><img src="https://img2020.cnblogs.com/blog/1373850/202109/1373850-20210916171647519-902584283.png" alt="img"></p><h2 id="Java-中的异常处理"><a href="#Java-中的异常处理" class="headerlink" title="Java 中的异常处理"></a>Java 中的异常处理</h2><p>有两种方法可以处理抛出的异常：</p><ol><li><strong>在当前方法中通过 <code>try-catch</code> 的方式处理该异常。</strong></li><li><strong>在方法签名的后面通过 <code>throws</code> 重新抛出该异常。</strong></li></ol><p><img src="https://img2020.cnblogs.com/blog/1373850/202109/1373850-20210916171732070-500009018.png" alt="img"></p><h2 id="Java-中的异常分类"><a href="#Java-中的异常分类" class="headerlink" title="Java 中的异常分类"></a>Java 中的异常分类</h2><p>我们可以将所有的异常分为三类：</p><ul><li><strong>检查性异常(checked exceptions)</strong> 是必须在在方法的 throws 子句中声明的异常。它们扩展了异常，旨在成为一种“在你面前”的异常类型。JAVA希望你能够处理它们，因为它们以某种方式依赖于程序之外的外部因素。检查的异常表示在正常系统操作期间可能发生的预期问题。 当你尝试通过网络或文件系统使用外部系统时，通常会发生这些异常。 大多数情况下，对检查性异常的正确响应应该是稍后重试，或者提示用户修改其输入。</li><li><strong>非检查性异常(unchecked Exceptions)</strong> 是不需要在throws子句中声明的异常。 由于程序错误，JVM并不会强制你处理它们，因为它们大多数是在运行时生成的。 它们扩展了 RuntimeException。 最常见的例子是 NullPointerException， 未经检查的异常可能不应该重试，正确的操作通常应该是什么都不做，并让它从你的方法和执行堆栈中出来。</li><li><strong>错误(errors)</strong> 是严重的运行时环境问题，肯定无法恢复。 例如 <code>OutOfMemoryError</code>，<code>LinkageError</code> 和 <code>StackOverflowError</code>，通常会让程序崩溃。</li></ul><p>了解异常类的类型后，我们可能需要回答以下问题：</p><ul><li><strong>异常情况有多糟糕以及异常的原因是什么？</strong></li><li><strong>如何解决这个异常？</strong></li><li><strong>我们需要重启JVM吗？</strong></li><li><strong>我们需要重写代码吗？</strong></li></ul><p>知道异常类，我们可以预测可能出错的地方。考虑潜在的原因，我们可以假设问题的原因是什么以及如何解决它。在接下来的段落中，我们将回顾常见的异常并调查潜在的原因是什么。在我们的调查中，我们假设应用程序足够稳定并且已经完成开发和测试。</p><h3 id="常见-Error-异常"><a href="#常见-Error-异常" class="headerlink" title="常见 Error 异常"></a>常见 Error 异常</h3><p><img src="https://img2020.cnblogs.com/blog/1373850/202109/1373850-20210916171750289-1950745888.png" alt="img"></p><table><thead><tr><th>异常类型</th><th>潜在原因</th><th>原因的可能性有多大</th><th>怎么修复</th><th>需要重写代码吗？</th><th>需要重启JVM吗？</th></tr></thead><tbody><tr><td>OutOfMemoryError</td><td>应用程序吃掉了所有内存</td><td>高的</td><td>增加堆内存大小</td><td>不</td><td>是的</td></tr><tr><td>内存泄漏</td><td>低的</td><td>查找内存泄漏并修复</td><td>是的</td><td>是的</td><td></td></tr><tr><td>StackOverflowError</td><td>堆栈内存不足</td><td>高的</td><td>增加堆栈内存大小</td><td>不</td><td>是的</td></tr><tr><td>无限递归</td><td>低的</td><td>设置递归调用的限制</td><td>是的</td><td>是的</td><td></td></tr><tr><td>NoClassDefFoundError</td><td>缺少依赖</td><td>高的</td><td>添加依赖或修复依赖配置</td><td>不</td><td>是的</td></tr><tr><td>初始化期间加载类失败</td><td>低的</td><td>更改初始化过程</td><td>是的</td><td>是的</td><td></td></tr></tbody></table><p>在大多数情况下，需要做的就是更改 JVM 配置或添加缺少的依赖项，仍然存在需要更改代码的情况，但它们不太可能在每种情况下更改。</p><h3 id="常见-Runtime-异常"><a href="#常见-Runtime-异常" class="headerlink" title="常见 Runtime 异常"></a>常见 Runtime 异常</h3><p><img src="https://img2020.cnblogs.com/blog/1373850/202109/1373850-20210916171907687-1229459232.png" alt="img"></p><table><thead><tr><th>异常类型</th><th>潜在原因</th><th>原因的可能性有多大</th><th>怎么修复</th><th>需要重写代码吗？</th><th>需要重启吗？</th></tr></thead><tbody><tr><td>NullPointerException</td><td>预期的不可为空的对象为空</td><td>高的</td><td>调用前添加验证层</td><td>是的</td><td>是的</td></tr><tr><td>某些资源不可用并返回空数据</td><td>中等的</td><td>调用前添加验证层</td><td>是的</td><td>是的</td><td></td></tr><tr><td>ConcurrentModificationException</td><td>迭代期间集合已更改</td><td>高的</td><td>分别进行集合迭代和修改</td><td>是的</td><td>是的</td></tr><tr><td></td><td>集合在迭代期间已从另一个线程更改</td><td>高的</td><td>为集合添加同步</td><td>是的</td><td>是的</td></tr><tr><td>IlliegalArgumentException</td><td>传递的参数无效</td><td>高的</td><td>在传递参数之前添加验证</td><td>是的</td><td>是的</td></tr><tr><td>NumberFormatException</td><td>传递的参数格式错误或符号错误</td><td>高的</td><td>在传递数据之前添加格式或删除不可见符号</td><td>是的</td><td>是的</td></tr><tr><td>ArrayIndexOutOfBoundsException</td><td>指令试图通过不存在的索引访问单元格</td><td>高的</td><td>将访问逻辑更改为正确的逻辑</td><td>是的</td><td>是的</td></tr><tr><td>NoSuchElementException</td><td>当指针已经改变位置时访问元素</td><td>高的</td><td>将访问逻辑更改为正确的逻辑</td><td>是的</td><td>是的</td></tr><tr><td>集合在迭代过程中被修改</td><td>高的</td><td>为集合添加同步</td><td>是的</td><td>是的</td><td></td></tr></tbody></table><p>Checked 和 Error 异常错误不会导致任何代码更改，但是在大多数情况下，运行时异常突出了代码中的真正问题，如果不重写代码就无法修复这些问题。</p><h3 id="常见-Checked-异常"><a href="#常见-Checked-异常" class="headerlink" title="常见 Checked 异常"></a>常见 Checked 异常</h3><p><img src="https://img2020.cnblogs.com/blog/1373850/202109/1373850-20210916171930515-322340961.png" alt="img"></p><table><thead><tr><th>异常类型</th><th>潜在原因</th><th>原因的可能性有多大</th><th>怎么修复</th><th>需要重写代码吗？</th><th>需要重启吗？</th></tr></thead><tbody><tr><td>FileNotFoundException</td><td>该文件不存在</td><td>高的</td><td>创建文件</td><td>不</td><td>不</td></tr><tr><td>应用程序调用错误的路径</td><td>低的</td><td>修复错误的路径生成</td><td>是的</td><td>是的</td><td></td></tr><tr><td>IOException</td><td>访问资源无效</td><td>高的</td><td>让资源再次可用</td><td>不</td><td>不</td></tr><tr><td>ClassNotFoundException</td><td>该类未添加依赖项</td><td>高的</td><td>添加缺少的依赖项</td><td>不</td><td>是的</td></tr><tr><td>实现调用了错误的类</td><td>中等的</td><td>更改类调用</td><td>是的</td><td>是的</td><td></td></tr><tr><td>SqlException</td><td>架构与查询不匹配</td><td>高的</td><td>将缺失的脚本应用到数据库</td><td>不</td><td>不</td></tr><tr><td>查询错误</td><td>低的</td><td>更改查询</td><td>是的</td><td>是的</td><td></td></tr><tr><td>拒绝连接</td><td>高的</td><td>打开数据库，更改端口</td><td>不</td><td>不</td><td></td></tr><tr><td>InterruptedException</td><td>依赖线程通知中断（锁释放，另一个线程完成操作）</td><td>高的</td><td>没有必要修复它；这是一种通知相关线程中事件的方法</td><td>不</td><td>不</td></tr><tr><td>另一个线程中断并使用中断通知相关</td><td>中等的</td><td>修复另一个线程中出现的问题（可以是任何东西）</td><td>是的</td><td>是的</td><td></td></tr><tr><td>SocketException</td><td>端口被占用</td><td>高的</td><td>打开/释放端口</td><td>不</td><td>不</td></tr><tr><td>服务器断开连接</td><td>高的</td><td>检查网络连接</td><td>不</td><td>不</td><td></td></tr></tbody></table><p>如果我们查看最可能的原因，我们会发现其中的<em>大多数</em> 不仅不需要任何代码更改，甚至不需要重新启动应用程序。</p><h1 id="Java-异常处理最佳实践"><a href="#Java-异常处理最佳实践" class="headerlink" title="Java 异常处理最佳实践"></a>Java 异常处理最佳实践</h1><h2 id="1-不要忽略捕获的异常"><a href="#1-不要忽略捕获的异常" class="headerlink" title="1. 不要忽略捕获的异常"></a>1. 不要忽略捕获的异常</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Copycatch</span> <span class="token punctuation">(</span><span class="token class-name">NoSuchMethodException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>虽然捕获了异常但是却没有做任何处理，除非你确信这个异常可以忽略，不然不应该这样做，这样会导致外面无法知晓该方法发生了错误，无法定位错误原因。</p><h2 id="2-在你的方法里抛出具体的检查性异常"><a href="#2-在你的方法里抛出具体的检查性异常" class="headerlink" title="2. 在你的方法里抛出具体的检查性异常"></a>2. 在你的方法里抛出具体的检查性异常</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Copypublic</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span> <span class="token comment">//错误方式</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>一定要避免出现上面的代码示例，它破坏了检查性异常的目的。 声明你的方法可能抛出的具体检查性异常，如果有太多这样的检查性异常，你应该把它们包装在你自己的异常中，并在异常消息中添加信息。 如果可能的话，你也可以考虑代码重构。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Copypublic</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">SpecificException1</span><span class="token punctuation">,</span> <span class="token class-name">SpecificException2</span> <span class="token punctuation">{</span> <span class="token comment">//正确方式</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="3-捕获具体的子类而不是捕获-Exception-类"><a href="#3-捕获具体的子类而不是捕获-Exception-类" class="headerlink" title="3. 捕获具体的子类而不是捕获 Exception 类"></a>3. 捕获具体的子类而不是捕获 Exception 类</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Copytry</span> <span class="token punctuation">{</span>   <span class="token function">someMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//错误方式</span>   LOGGER<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"method has failed"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>捕获 <code>Exception</code> 的问题是，如果稍后调用的方法为其方法声明添加了新的检查性异常，则开发人员的意图是应该处理具体的新异常，但是你的代码只是捕获 <code>Exception</code> （或 <code>Throwable</code>），那么永远不会知道这个新的异常，并且你的程序可能会在运行时的任何时候中断。</p><h2 id="3-永远不要捕获-Throwable-类"><a href="#3-永远不要捕获-Throwable-类" class="headerlink" title="3. 永远不要捕获 Throwable 类"></a>3. 永远不要捕获 Throwable 类</h2><p>这是一个更严重的问题，因为 <code>Error</code> 也是 <code>Throwable</code> 的子类，<code>Error</code> 是 JVM 本身无法处理的不可逆转的错误，对于某些 JVM 的实现，JVM 可能实际上甚至不会在 Error 上调用 catch 子句。</p><h2 id="4-始终正确包装自定义异常中的异常，以便堆栈跟踪不会丢失"><a href="#4-始终正确包装自定义异常中的异常，以便堆栈跟踪不会丢失" class="headerlink" title="4. 始终正确包装自定义异常中的异常，以便堆栈跟踪不会丢失"></a>4. 始终正确包装自定义异常中的异常，以便堆栈跟踪不会丢失</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Copycatch</span> <span class="token punctuation">(</span><span class="token class-name">NoSuchMethodException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">MyServiceException</span><span class="token punctuation">(</span><span class="token string">"Some information: "</span> <span class="token operator">+</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//错误方式</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这破坏了原始异常的堆栈跟踪，并且始终是错误的，正确的做法是：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Copycatch</span> <span class="token punctuation">(</span><span class="token class-name">NoSuchMethodException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">MyServiceException</span><span class="token punctuation">(</span><span class="token string">"Some information: "</span> <span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//正确方式</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="5-要么记录异常要么抛出异常，但不要一起执行"><a href="#5-要么记录异常要么抛出异常，但不要一起执行" class="headerlink" title="5. 要么记录异常要么抛出异常，但不要一起执行"></a>5. 要么记录异常要么抛出异常，但不要一起执行</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Copycatch</span> <span class="token punctuation">(</span><span class="token class-name">NoSuchMethodException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">//错误方式 </span>   LOGGER<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"Some information"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">throw</span> e<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正如上面的代码中，记录和抛出异常会在日志文件中产生多条日志消息，代码中存在单个问题，并且对尝试分析日志的同事很不友好。</p><h2 id="6-finally-块中永远不要抛出任何异常"><a href="#6-finally-块中永远不要抛出任何异常" class="headerlink" title="6. finally 块中永远不要抛出任何异常"></a>6. finally 块中永远不要抛出任何异常</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Copytry</span> <span class="token punctuation">{</span>  <span class="token function">someMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//Throws exceptionOne</span><span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>  <span class="token function">cleanUp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//如果finally还抛出异常，那么exceptionOne将永远丢失</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只要 <code>cleanUp()</code> 永远不会抛出任何异常，上面的代码没有问题，但是如果 <code>someMethod()</code> 抛出一个异常，并且在 <code>finally</code> 块中，<code>cleanUp()</code> 也抛出另一个异常，那么程序只会把第二个异常抛出来，原来的第一个异常（正确的原因）将永远丢失。如果在 <code>finally</code> 块中调用的代码可能会引发异常，请确保要么处理它，要么将其记录下来，永远不要让它从 finally 块中抛出来。</p><h2 id="7-始终只捕获实际可处理的异常"><a href="#7-始终只捕获实际可处理的异常" class="headerlink" title="7. 始终只捕获实际可处理的异常"></a>7. 始终只捕获实际可处理的异常</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Copycatch</span> <span class="token punctuation">(</span><span class="token class-name">NoSuchMethodException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">throw</span> e<span class="token punctuation">;</span> <span class="token comment">//避免这种情况，因为它没有任何帮助</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这是最重要的概念，不要为了捕获异常而捕获，只有在想要处理异常时才捕获异常，或者希望在该异常中提供其他上下文信息。如果你不能在 catch 块中处理它，那么最好的建议就是不要只为了重新抛出它而捕获它。</p><h2 id="8-不要使用-printStackTrace-语句或类似的方法"><a href="#8-不要使用-printStackTrace-语句或类似的方法" class="headerlink" title="8. 不要使用 printStackTrace() 语句或类似的方法"></a>8. 不要使用 printStackTrace() 语句或类似的方法</h2><p>完成代码后，切勿忽略 <code>printStackTrace()</code>，最终别人可能会得到这些堆栈，并且对于如何处理它完全没有任何帮助，因为它不会附加任何上下文信息。</p><h2 id="9-对于不打算处理的异常，直接使用-finally"><a href="#9-对于不打算处理的异常，直接使用-finally" class="headerlink" title="9. 对于不打算处理的异常，直接使用 finally"></a>9. 对于不打算处理的异常，直接使用 finally</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Copytry</span> <span class="token punctuation">{</span>  <span class="token function">someMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//Method 2</span><span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>  <span class="token function">cleanUp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//do cleanup here</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是一个很好的做法，如果在你的方法中你正在访问 Method 2，而 Method 2 抛出一些你不想在 Method 1 中处理的异常，但是仍然希望在发生异常时进行一些清理，然后在 finally 块中进行清理，不要使用 catch 块。</p><h2 id="10-记住早-throw-晚-catch-原则"><a href="#10-记住早-throw-晚-catch-原则" class="headerlink" title="10. 记住早 throw 晚 catch 原则"></a>10. 记住早 throw 晚 catch 原则</h2><p>这可能是关于异常处理最著名的原则，简单说，应该尽快抛出(throw)异常，并尽可能晚地捕获(catch)它。应该等到有足够的信息来妥善处理它。</p><p>这个原则隐含地说，你将更有可能把它放在低级方法中，在那里你将检查单个值是否为空或不适合。而且你会让异常堆栈跟踪上升好几个级别，直到达到足够的抽象级别才能处理问题。</p><h2 id="11-在异常处理后清理资源"><a href="#11-在异常处理后清理资源" class="headerlink" title="11. 在异常处理后清理资源"></a>11. 在异常处理后清理资源</h2><p>如果你正在使用数据库连接或网络连接等资源，请确保关闭它们。如果你正在调用的 API 仅使用非检查性异常，则仍应使用 try-finally 块来清理资源。 在 try 模块里面访问资源，在 finally 里面最后关闭资源。即使在访问资源时发生任何异常，资源也会优雅地关闭。</p><h2 id="12-只抛出和方法相关的异常"><a href="#12-只抛出和方法相关的异常" class="headerlink" title="12. 只抛出和方法相关的异常"></a>12. 只抛出和方法相关的异常</h2><p>相关性对于应用程序排查问题非常重要。一种尝试读取文件的方法，如果抛出 <code>NullPointerException</code>，那么它不会给用户任何相关的信息。相反，如果这种异常被包裹在自定义异常中，则会更好，<code>NoSuchFileFoundException</code> 则对该方法的用户更有用。</p><h2 id="13-切勿在程序中使用异常来进行流程控制"><a href="#13-切勿在程序中使用异常来进行流程控制" class="headerlink" title="13. 切勿在程序中使用异常来进行流程控制"></a>13. 切勿在程序中使用异常来进行流程控制</h2><p>不要在项目中出现使用异常来处理应用程序逻辑，永远不要这样做，它会使代码很难阅读和理解。</p><h2 id="14-尽早验证用户输入以在请求处理的早期捕获异常"><a href="#14-尽早验证用户输入以在请求处理的早期捕获异常" class="headerlink" title="14. 尽早验证用户输入以在请求处理的早期捕获异常"></a>14. 尽早验证用户输入以在请求处理的早期捕获异常</h2><p>始终要在非常早的阶段验证用户输入，甚至在达到 <code>controller</code> 之前，它将帮助你把核心应用程序逻辑中的异常处理代码量降到最低。如果用户输入出现错误，还可以保证与应用程序一致。</p><p>例如：如果在用户注册应用程序中，遵循以下逻辑：</p><ol><li>验证用户</li><li>插入用户</li><li>验证地址</li><li>插入地址</li><li>如果出问题回滚一切</li></ol><p>这是不正确的做法，它会使数据库在各种情况下处于不一致的状态，应该首先验证所有内容，然后将用户数据置于 <code>dao</code> 层并进行数据库更新。正确的做法是：</p><ol><li>验证用户</li><li>验证地址</li><li>插入用户</li><li>插入地址</li><li>如果问题回滚一切</li></ol><h2 id="15-一个异常只能包含在一个日志中"><a href="#15-一个异常只能包含在一个日志中" class="headerlink" title="15. 一个异常只能包含在一个日志中"></a>15. 一个异常只能包含在一个日志中</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">CopyLOGGER</span><span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Using cache sector A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>LOGGER<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Using retry sector B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>不要像上面这样做，对多个 <code>LOGGER.debug()</code> 调用使用多行日志消息可能在你的测试用例中看起来不错，但是当它在具有 100 个并行运行的线程的应用程序服务器的日志文件中显示时，所有信息都输出到相同的日志文件，即使它们在实际代码中为前后行，但是在日志文件中这两个日志消息可能会间隔 100 多行。应该这样做：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">CopyLOGGER</span><span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Using cache sector A, using retry sector B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="16-将所有相关信息尽可能地传递给异常"><a href="#16-将所有相关信息尽可能地传递给异常" class="headerlink" title="16. 将所有相关信息尽可能地传递给异常"></a>16. 将所有相关信息尽可能地传递给异常</h2><p>有用的异常消息和堆栈跟踪非常重要，如果你的日志不能定位异常位置，那要日志有什么用呢？</p><h2 id="17-终止掉被中断的线程"><a href="#17-终止掉被中断的线程" class="headerlink" title="17. 终止掉被中断的线程"></a>17. 终止掉被中断的线程</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Copywhile</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">//别这样做</span>  <span class="token function">doSomethingCool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>InterruptedException</code> 异常提示应该停止程序正在做的事情，比如事务超时或线程池被关闭等。</p><p>应该尽最大努力完成正在做的事情，并完成当前执行的线程，而不是忽略 <code>InterruptedException</code>。修改后的程序如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Copywhile</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">break</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function">doSomethingCool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="18-对于重复的-try-catch，使用模板方法"><a href="#18-对于重复的-try-catch，使用模板方法" class="headerlink" title="18. 对于重复的 try-catch，使用模板方法"></a>18. 对于重复的 try-catch，使用模板方法</h2><p>在代码中有许多类似的 catch 块是无用的，只会增加代码的重复性，针对这样的问题可以使用模板方法。</p><p>例如，在尝试关闭数据库连接时的异常处理。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Copyclass</span> <span class="token class-name">DBUtil</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">closeConnection</span><span class="token punctuation">(</span><span class="token class-name">Connection</span> conn<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">try</span><span class="token punctuation">{</span>            conn<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">Exception</span> ex<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment">//Log Exception - Cannot close connection</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这类的方法将在应用程序很多地方使用，不要把这块代码放的到处都是，而是定义上面的方法，然后像下面这样使用它：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Copypublic</span> <span class="token keyword">void</span> <span class="token function">dataAccessCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">Connection</span> conn <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">try</span><span class="token punctuation">{</span>        conn <span class="token operator">=</span> <span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span><span class="token punctuation">{</span>        <span class="token class-name">DBUtil</span><span class="token punctuation">.</span><span class="token function">closeConnection</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="19-使用-JavaDoc-中记录应用程序中的所有异常"><a href="#19-使用-JavaDoc-中记录应用程序中的所有异常" class="headerlink" title="19. 使用 JavaDoc 中记录应用程序中的所有异常"></a>19. 使用 JavaDoc 中记录应用程序中的所有异常</h2><p>把用 JavaDoc 记录运行时可能抛出的所有异常作为一种习惯，其中也尽量包括用户应该遵循的操作，以防这些异常发生。</p><h2 id="20-使用-try-with-resource-自动地关闭资源"><a href="#20-使用-try-with-resource-自动地关闭资源" class="headerlink" title="20. 使用 try-with-resource 自动地关闭资源"></a>20. 使用 try-with-resource 自动地关闭资源</h2><p>1、当一个外部资源的句柄对象实现了 <code>AutoCloseable</code> 接口，JDK7中便可以利用 try-with-resource 语法更优雅的关闭资源，消除板式代码。</p><p>2、使用 try-with-resource 时，如果对外部资源的处理和对外部资源的关闭均遭遇了异常，“关闭异常”将被抑制，“处理异常”将被抛出，但“关闭异常”并没有丢失，而是存放在“处理异常”的被抑制的异常列表中。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">FileInputStream</span> inputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>inputStream<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>将外部资源的句柄对象的创建放在try关键字后面的括号中</strong>，当这个try-catch代码块执行完毕后，Java会确保外部资源的close方法被调用。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇文章首先介绍了什么是异常，以及异常的三种分类，然后通过 20 个最佳实践来讨论如何处理异常，希望能在以后异常处理的时候有所改进及感悟。</p><p>参考文档：</p><p><a href="https://dzone.com/articles/java-exceptions-1">https://dzone.com/articles/java-exceptions-1</a></p><p><a href="http://www.yinwang.org/blog-cn/2015/11/21/programming-philosophy">http://www.yinwang.org/blog-cn/2015/11/21/programming-philosophy</a></p><p><a href="https://www.cnblogs.com/wupeixuan/p/11746117.html">https://www.cnblogs.com/wupeixuan/p/11746117.html</a></p><p><a href="https://howtodoinjava.com/best-practices/java-exception-handling-best-practices/">https://howtodoinjava.com/best-practices/java-exception-handling-best-practices/</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis基础</title>
      <link href="/archives/fe29e710.html"/>
      <url>/archives/fe29e710.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、学习Redis基础"><a href="#一、学习Redis基础" class="headerlink" title="一、学习Redis基础"></a>一、学习Redis基础</h2><ol><li><p>在前面学习了MySQL数据库，它是一种传统的关系型数据库，我们可以使用MySQL来更好地管理和组织我们的数据，虽然在小型Web下，只需要一个MySQL+Mybatis自带的缓存系统就可以胜任大部分的数据存储工作，但是MySQL的缺点也很明显，他的数据始终是存储在硬盘上，对于我们的用户信息这种不需要经常发生修改的内容，使用MySQL确实可以，但是如果是快速更新或是频繁使用的数据，比如微博resource、双十一秒杀，这些数据不仅要求服务器需要提供更高的响应速度，而且还需要面对短时间内上百万甚至上千万次访问，而MySQL的磁盘IO读写性能完全不能满足上面的需求，能够满足上述需求的只有内存，因为速度远高于磁盘IO。</p><span id="more"></span></li><li><p>NoSQL概论<br>NoSQL全称是Not Only SQL(不仅仅是SQL) 它是一种非关系型数据库，相比传统SQL关系型数据库，它：</p></li></ol><ul><li>特点：<ol><li>不保证关系数据的ACID特性</li><li>并不遵循SQL标准</li><li>消除数据之间关联性</li></ol></li><li>优势：</li></ul><ol><li><p>远超传统关系型数据库的性能</p></li><li><p>非常易于扩展</p></li><li><p>数据模型更加灵活</p></li><li><p>高可用</p><blockquote><p>这样，NoSQL的优势就出来了，这就是我们正在寻找的高并发海量数据的解决方案。</p><!--more--></blockquote></li><li><p>NoSQL数据库分为以下几种：</p></li></ol><ul><li>键值存储数据库：所有的数据都是以键值方式存储的，类似于HashMap，使用起来非常简单方便，性能也非常高</li><li>列存储数据库：这部分数据库通常用来应对分布式存储的海量数据。键仍然存在，但是他们的特点是指向了多个列</li><li>文档型数据库：它是以一种特定的文档格式存储数据，比如JSON格式，在处理网页等复杂数据时，文档型数据库比传统型键值数据库查询效率更高</li><li>图形数据库：利用类似于图的数据结构存储数据，结合图相关算法实现高速访问</li></ul><blockquote><p>Redis是一个开源的键值存储数据库，所有的数据全部存在内存中，它的性能远远高于磁盘IO，并且它也可以支持数据持久化，它还支持横向扩展、主从复制等。</p></blockquote><ol><li>Redis中键值对命令</li></ol><p>set ye 44<br>get ye</p><p>定义数据有效时间<br><code>reprie a 10</code></p><ol><li>HashMap键值对<br><code>hset yecode 111</code><br><code>hset b name lbw age 10</code><br><code>hget b</code><br><code>hexists &lt;key&gt; &lt;字段&gt; #判断某个字段是否存在</code><br><code>hdel &lt;key&gt; &lt;字段&gt; #删除某个字段</code><br><code>hdel &lt;key&gt; #删除hash中某个键</code></li></ol><p>我们现在想要知道Hash中一共存了多少个键值对：<code>hlen &lt;key&gt;</code></p><p>我们也可以一次性获取所有字段的值: <code>hvals &lt;key&gt;</code></p><ol><li><p>List</p><p>我们可以直接向一个已存在或是不存在的List中添加数据，如果不存在，会自动创建：</p><p>#向列表头部添加元素</p><p>lpush</p><p>#向列表尾部添加元素<br>rpush</p><p>#在指定元素前面/后面插入元素<br>linsert </p><p>before/after &lt;指定元素&gt;</p><pre class="line-numbers language-none"><code class="language-none">BASHlpush c 111 222 333insert c before 222 000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>同样的获取元素也非常简单<br>#根据下表获取元素<br>lindex </p><p>&lt;下标&gt;<br>#获取并移除头部元素<br>lpop<br>#获取并移除尾部与阿奴苏<br>rpop<br>#获取指定范围内的<br>lrange start stop</p></li></ol><h2 id="二、持久化"><a href="#二、持久化" class="headerlink" title="二、持久化"></a>二、持久化</h2><ul><li>Redis数据库中的数据是存放在内存中的，虽然很高效，但是这样存在一个非常严重的问题，如果突然停电，或者突然关闭了终端，那数据不就全部丢失了吗？</li><li>这个时候就需要持久化，我们需要将我们的数据备份到硬盘上，防止断电或机器故障导致数据丢失</li></ul><ol><li>持久化实现方法有两种方案：</li></ol><ul><li>一种是直接保存当前已经存储的数据，相当于复制内存中的数据到硬盘上，需要回复数据时直接读取即可</li><li>一种是保存我们存放数据的所有过程，需要恢复数据时，只需要将整个过程完整地重演一篇就能保证与之前数据库中的内容一致。</li></ul><h3 id="1-RDB"><a href="#1-RDB" class="headerlink" title="1. RDB"></a>1. RDB</h3><p>RDB就是上述的第一种方案，保存到本地，使用以下命令</p><pre class="line-numbers language-none"><code class="language-none">BASHsave--注意上面这个命令会直接保存，会占用一定时间，可以单独开一个子进程后台执行保存bgsave  --可以单独开一个子进程后台执行保存<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行后，会在服务端目录下生成一个<code>dump.rdb</code>文件，而这个文件中就保存了内存中存放的数据，当服务器重启后，会自动加载里面的内容到对应数据库中。<br>保存后我们就可以关闭服务器<br><code>shutdown</code></p><h3 id="2-AOF"><a href="#2-AOF" class="headerlink" title="2. AOF"></a>2. AOF</h3><p>虽然RDB能够很好地解决持久化问题，但是它的缺点也很明显：每次都需要去完整地保存整个数据库中的数据，同时后台保存过程中也会产生额外的内存开销，最严重的是它不是实时保存的，如果在自动保存出发之前服务器崩溃，那么依然会导致少量数据的丢失<br>AOF就是另一种方式，它会以日志的形式将我们每次执行的命令都进行保存，服务器重启时会将所有命令依次执行，通过重演的方式将数据恢复，这样就能很好解决实时性存储问题。</p><p>但是，我们多久写一次日志呢？我们可以自己配置保存策略<br>always：每次执行写操作都会保存一次<br>everysec：每秒保存一次（默认配置）<br>no： 看系统心情</p><p>开启AOF自动记录日志功能需要在日志文件中找到oppendonly，将no改成yes</p><p>重启服务器后，可以看到服务器目录下多了一个oppendonly.aof文件，存储的就是我们执行的命令</p><p>AOF的命令也很明显，每次服务器启动都需要进行过程重演，相比RDB更加耗费时间，并且随着我们的操作变多，不断累积，到最后我们的aof文件会变得无比巨大。我们需要改进方案优化这些问题</p><p>Redis有一个AOF重写机制进行优化，比如我们执行了这样的语句：</p><pre class="line-numbers language-none"><code class="language-none">BASHlpush test 666lpush test 777lpush test 888<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>实际上用一条语句也可以实现<br><code>lpush test 666 777 888</code><br>正是如此，只要我们能够保证最终的重演结果和原有语句的结果一致，无论语句如何修改都可以，所以我们可以通过这种方式将多余语句进行压缩</p><ol><li>我们可以输入命令来手动执行重写操作<br><code>bgrewiteof</code></li><li>或是在配置文件中配置自动重写<br>百分比配置文件中配置自动重写：<br><code>auto-aof-rewrite-percentage 100</code><br>当达到这个大小时，触发自动重写：<br><code>a</code>oto-aof-rewrite-min-size 64mb`<br>至此，两种持久化方案介绍结束，最后进行总结</li></ol><h3 id="两种方案优缺点"><a href="#两种方案优缺点" class="headerlink" title="两种方案优缺点"></a>两种方案优缺点</h3><ul><li><p><code>RDB</code>：<br>优点：加载速度快、数据体积小<br>缺点：存储速度慢大量消耗资源、会发生数据丢失</p></li><li><p><code>AOF</code>：<br>有点：存储速度快，消耗资源少、支持实时存储<br>缺点：加载速度慢、数据体积大</p></li></ul><h2 id="三、Redis中事物和锁机制"><a href="#三、Redis中事物和锁机制" class="headerlink" title="三、Redis中事物和锁机制"></a>三、Redis中事物和锁机制</h2><h3 id="1-事物机制："><a href="#1-事物机制：" class="headerlink" title="1. 事物机制："></a>1. 事物机制：</h3><ul><li>和MySQL一样，在Redis中也有事物机制，当我们需要保证多余命令一次性完执行而中途不受其他命令干扰时，就可以使用事物机制。</li></ul><ol><li>我们可以使用明里阿尼过来直接开启事物：<br><code>multi</code></li><li>当我们输入完所有要执行的命令，可以使用命令来立即执行事物：<br><code>exec</code></li><li>我们也可以中途取消事物：<br><code>discard</code></li></ol><ul><li>实际上整个事物是创建了一个命令队列，它不像MySQL那种在事物中也能单独得到结果，而是我们提前将所有的命令装在队列中，但是并不会执行，而是等我们提交事务的时候再统一执行。</li></ul><h3 id="2-锁："><a href="#2-锁：" class="headerlink" title="2. 锁："></a>2. 锁：</h3><ul><li>又提到锁了，实际上这个概念对我来说已经不算陌生了。实际上在Redis中也会出现多个命令竞争同一个数据的情况，比如现在有两条命令同时执行，他们都要去修改a的值，那么这个时候就只能动用锁机制来保证同一时间只能有一个命令操作。</li><li>虽然Redis中也有锁机制，但是它是一种乐观锁，不同于MySQL，我们在MySQL中认识的锁是悲观锁。</li></ul><ol><li>悲观锁：时刻认为别人会来抢占资源，禁止一切外来访问，直到释放锁，具有强烈的排他性质</li><li>乐观锁：并不认为会有人来抢占资源，所以会直接对数据进行操作，在操作时再去验证是否有其它人抢占资源</li></ol><ul><li>Redis中可以使用watch来监视一个目标，如果执行事务之前被监视目标发生了修改，则取消本次事物：<br><code>watch</code></li></ul><h2 id="四、使用Java与Redis交互"><a href="#四、使用Java与Redis交互" class="headerlink" title="四、使用Java与Redis交互"></a>四、使用Java与Redis交互</h2><p>既然了解如何通过命令窗口操作Redis数据库，那么我们如何使用java来操作呢？<br>这里我们需要使用Jedis框架，他能够实现Java与Redis数据库交互，导入依赖：</p><pre class="line-numbers language-none"><code class="language-none">YML&lt;groupId&gt;&lt;redis.clients&gt;&lt;/groupId&gt;&lt;artifactId&gt;jedis&lt;/artifactId&gt;&lt;version&gt;4.0.0&lt;/version&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git版本控制笔记</title>
      <link href="/archives/45e57f1.html"/>
      <url>/archives/45e57f1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、Git工作流"><a href="#一、Git工作流" class="headerlink" title="一、Git工作流"></a>一、Git工作流</h2><p><a href="https://s2.loli.net/2022/01/22/VWYkdFjNil5A6L1.jpg"><img src="https://s2.loli.net/2022/01/22/VWYkdFjNil5A6L1.jpg" alt="1.jpg"></a></p><h3 id="四大板块"><a href="#四大板块" class="headerlink" title="四大板块"></a>四大板块</h3><h4 id="1-工作目录"><a href="#1-工作目录" class="headerlink" title="(1)工作目录"></a>(1)工作目录</h4><p>存放我们正在写的代码</p><h4 id="2-暂存区"><a href="#2-暂存区" class="headerlink" title="(2)暂存区"></a>(2)暂存区</h4><p>暂时保存待提交的内容</p><h4 id="3-本地仓库"><a href="#3-本地仓库" class="headerlink" title="(3)本地仓库"></a>(3)本地仓库</h4><p>位于我们电脑上的一个版本控制仓库</p><h4 id="4-远程仓库"><a href="#4-远程仓库" class="headerlink" title="(4)远程仓库"></a>(4)远程仓库</h4><p>位于服务器上的版本控制仓库</p><span id="more"></span><h2 id="二、创建本地仓库"><a href="#二、创建本地仓库" class="headerlink" title="二、创建本地仓库"></a>二、创建本地仓库</h2><h3 id="2-1初始化为本地仓库"><a href="#2-1初始化为本地仓库" class="headerlink" title="2.1初始化为本地仓库"></a>2.1初始化为本地仓库</h3><pre class="line-numbers language-none"><code class="language-none">BASHgit init   #可以创建多个本地仓库<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-2查看当前仓库状态"><a href="#2-2查看当前仓库状态" class="headerlink" title="2.2查看当前仓库状态"></a>2.2查看当前仓库状态</h3><pre class="line-numbers language-none"><code class="language-none">BASHgit status     #查看当前，如果有未追踪的文件则需要追踪<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-3添加为追踪文件"><a href="#2-3添加为追踪文件" class="headerlink" title="2.3添加为追踪文件"></a>2.3添加为追踪文件</h3><pre class="line-numbers language-none"><code class="language-none">BASHgit add text.txt      #添加完成就放到了暂存区等待提交<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-4这提交到本地仓库"><a href="#2-4这提交到本地仓库" class="headerlink" title="2.4这提交到本地仓库"></a>2.4这提交到本地仓库</h3><pre class="line-numbers language-none"><code class="language-none">BASHgit commit -m '描述'    #这个版本就提交到git的本地仓库了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-5修改文件内容提交"><a href="#2-5修改文件内容提交" class="headerlink" title="2.5修改文件内容提交"></a>2.5修改文件内容提交</h3><pre class="line-numbers language-none"><code class="language-none">BASHgit commit -a -m '备注'   #如果修改了已经提交过的文件内容，再次提交就使用这个命令<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-6查看提交日志"><a href="#2-6查看提交日志" class="headerlink" title="2.6查看提交日志"></a>2.6查看提交日志</h3><pre class="line-numbers language-none"><code class="language-none">BASHgit log    #可以查看提交日志，谁在什么时候提交的，也能查看提交ID<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-7查看一条日志"><a href="#2-7查看一条日志" class="headerlink" title="2.7查看一条日志"></a>2.7查看一条日志</h3><pre class="line-numbers language-none"><code class="language-none">BASHgit log --all --oneline --graph   #图形化查看一条日志的所有操作<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-8改变初始化提交"><a href="#2-8改变初始化提交" class="headerlink" title="2.8改变初始化提交"></a>2.8改变初始化提交</h3><pre class="line-numbers language-none"><code class="language-none">BASHgit reset --hard conmmitID   #改变初始化提交为哪一次提交的版本<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-9查看所有分支的所有操作记录"><a href="#2-9查看所有分支的所有操作记录" class="headerlink" title="2.9查看所有分支的所有操作记录"></a>2.9查看所有分支的所有操作记录</h3><pre class="line-numbers language-none"><code class="language-none">BASHgit reflog       #查看所有分支的所有操作记录 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="三、新建分支"><a href="#三、新建分支" class="headerlink" title="三、新建分支"></a>三、新建分支</h2><h3 id="3-1查看当前所在分支"><a href="#3-1查看当前所在分支" class="headerlink" title="3.1查看当前所在分支"></a>3.1查看当前所在分支</h3><pre class="line-numbers language-none"><code class="language-none">BASHgit branch<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="3-2创建新的分支"><a href="#3-2创建新的分支" class="headerlink" title="3.2创建新的分支"></a>3.2创建新的分支</h3><pre class="line-numbers language-none"><code class="language-none">BASHgit branch 分支名 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="3-3删除分支"><a href="#3-3删除分支" class="headerlink" title="3.3删除分支"></a>3.3删除分支</h3><pre class="line-numbers language-none"><code class="language-none">BASHgit branch -d 分支名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="3-4切换分支"><a href="#3-4切换分支" class="headerlink" title="3.4切换分支"></a>3.4切换分支</h3><pre class="line-numbers language-none"><code class="language-none">BASHgit checkout 分支名   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="四、合并分支"><a href="#四、合并分支" class="headerlink" title="四、合并分支"></a>四、合并分支</h2><p>我们也可以将两个分支更新的内容最终合并到同一个分支上<br>我们先切换回主分支</p><pre class="line-numbers language-none"><code class="language-none">BASHgit checkout master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后合并</p><pre class="line-numbers language-none"><code class="language-none">BASHgit merge 分支名   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果合并有冲突，查看哪里发生了冲突</p><pre class="line-numbers language-none"><code class="language-none">BASHgit diff  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="五、变基分支"><a href="#五、变基分支" class="headerlink" title="五、变基分支"></a>五、变基分支</h2><p>除了直接合并分支，我们还可以进行变基操作，它跟合并不同，合并是分支回到主干的过程，而变基是直接修改分支开始的位置，比如我们希望将text变基到master上，那么test会将分支起点移动到master最后一次提交位置</p><pre class="line-numbers language-none"><code class="language-none">BASHgit rebase master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>变基后，test分支相当于同步了此前master分支的全部提交</p><h2 id="六、优选"><a href="#六、优选" class="headerlink" title="六、优选"></a>六、优选</h2><p>我们还可以选择其它分支上的提交作用于当前分支，这种操作称为cherrypick</p><pre class="line-numbers language-none"><code class="language-none">PLAINTEXTgit checkout test   #先切换到test分支git cherry-pick &lt;commit ID&gt;   #单独合并一个提交<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里我们在master分支上创建一个新的文件，提交此次更新，接着通过cherry-pick的方式将此次更新作用于test分支上。</p><h2 id="七、使用IDEA版本控制"><a href="#七、使用IDEA版本控制" class="headerlink" title="七、使用IDEA版本控制"></a>七、使用IDEA版本控制</h2><p>虽然前面学习了git命令行的使用方法，但是没有一个图形化界面，始终会感觉很抽象，所有再继续学习使用IDEA的版本控制</p><p>打开IDEA后，找到版本控制模块，我们直接点击创建本地仓库，它会自动将当前项目的根目录作为我们的本地仓库，当我们编写的所有代码和项目目录下其它文件都可以进行版本控制</p><p>我发现所有项目中正在编写的类文件全部变红了，也就是处于未追踪状态，接着我进行第一次初始化提交，提交之后我可以在下方看到所有本地仓库提交记录</p><p>接着我来整合一下Web环境，创建新的类之后，IDEA会提示我们是否将文件添加Git，也就是是否放入暂存区并开启追踪，我们可以直接对比两次代码的相同和不同之处。</p><h2 id="八、远程仓库"><a href="#八、远程仓库" class="headerlink" title="八、远程仓库"></a>八、远程仓库</h2><h3 id="8-1-远程仓库概述"><a href="#8-1-远程仓库概述" class="headerlink" title="8.1 远程仓库概述"></a>8.1 远程仓库概述</h3><p>远程仓库实绩上就是位于服务器上的仓库，它能在远端保存我们的版本历史，并且实现多人同时合作编写项目，每个人都能够同步他人的版本，能够看到他人的版本提交，相当于将我们的代码放在服务器上进行托管。</p><h3 id="8-2-Github和Bitbacket"><a href="#8-2-Github和Bitbacket" class="headerlink" title="8.2 Github和Bitbacket"></a>8.2 Github和Bitbacket</h3><p>托管 Git 仓库最受欢迎的网站是 GitHub 和Bitbucket。：GitHub 为开源项目提供无限量的免费仓库,但私有仓库收费;而 Bitbucket 提供了无限量的私有仓库,仅当协作者超过一定数量时才收费。选择哪个网站,取决于具体的需求。在学习ruby on rails的教程中作者将代码托管在了Bitbucket上面，所以我也申请了一个账号试试。觉得用户体验还是很棒的。跟github很像，界面也十分友好。这是一个免费托管私人仓库的好地方。</p><h3 id="8-3-公有和私有远程仓库"><a href="#8-3-公有和私有远程仓库" class="headerlink" title="8.3 公有和私有远程仓库"></a>8.3 公有和私有远程仓库</h3><p>远程仓库有公有和私有的，公有的远程仓库有GitHub，码云，Coding等，他们都是对外开放的，我们注册账号之后就可以使用远程仓库进行版本控制，其中最大的就是GitHub，但是它服务器在国外，国内链接可能会有一点卡。私有一般是GitLab这种自主搭建的远程私服，在公司中比较常用，我们公司的项目就是托管在GitLab上，使用局域网搭建的一个远程仓库，它只对公司内部开放，不对外开放。</p><h3 id="8-9-将自己的项目conmmit到本地仓库以后push到远程仓库"><a href="#8-9-将自己的项目conmmit到本地仓库以后push到远程仓库" class="headerlink" title="8.9 将自己的项目conmmit到本地仓库以后push到远程仓库"></a>8.9 将自己的项目conmmit到本地仓库以后push到远程仓库</h3><h3 id="1、完成本地提交"><a href="#1、完成本地提交" class="headerlink" title="1、完成本地提交"></a>1、完成本地提交</h3><pre class="line-numbers language-none"><code class="language-none">BASHgit commit -a -m '提交描述'git log --oneline --all --graph<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2、让本地仓库知道远程仓库的存在-本地仓库绑定远程仓库"><a href="#2、让本地仓库知道远程仓库的存在-本地仓库绑定远程仓库" class="headerlink" title="2、让本地仓库知道远程仓库的存在(本地仓库绑定远程仓库)"></a>2、让本地仓库知道远程仓库的存在(本地仓库绑定远程仓库)</h3><pre class="line-numbers language-none"><code class="language-none">BASHgit remote add origin https地址  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="3、push到远程仓库"><a href="#3、push到远程仓库" class="headerlink" title="3、push到远程仓库"></a>3、push到远程仓库</h3><p>语法格式：</p><pre class="line-numbers language-none"><code class="language-none">BASHgit push 远程仓库分支 本地分支名称<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>具体命令</p><pre class="line-numbers language-none"><code class="language-none">BASHgit push origin maser<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="4、本地绑定远程"><a href="#4、本地绑定远程" class="headerlink" title="4、本地绑定远程"></a>4、本地绑定远程</h3><p>我们可以将远端和本地的分支进行绑定，绑定后就不需要指定分支名称了</p><pre class="line-numbers language-none"><code class="language-none">BASHgit Push--set-upstream yecode master:mastergit push yecode<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在一个本地仓库对应一个远程仓库的下，远程仓库基本上就是纯粹的代码托管了，类似于云盘那种感觉，存你的代码。</p><h2 id="九、克隆项目"><a href="#九、克隆项目" class="headerlink" title="九、克隆项目"></a>九、克隆项目</h2><pre class="line-numbers language-none"><code class="language-none">BASHgit clone https地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="十、抓取、拉取和冲突解决"><a href="#十、抓取、拉取和冲突解决" class="headerlink" title="十、抓取、拉取和冲突解决"></a>十、抓取、拉取和冲突解决</h2><p>比如程序员A完成了他的模块，那么他就可以提交代码并推送到远程仓库，这时程序员B也要开始写代码了，由于远程仓库有其他程序员提交的记录，因此程序员B的本地仓库就和远程仓库不一致，就需要先进行pull操作，获取远程仓库最新的提交：</p><pre class="line-numbers language-none"><code class="language-none">BASHgit fetch   #抓取：只获取但是不会合并远端分支，后面需要我们手动合并并提交git pull     #拉取：获取+合并<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果存在不协调的地方，比如本地有两个仓库，一个仓库去修改hello.txt并直接提交，另一个仓库也修改hexllo.txt并直接提交，会报错</p><p>一旦一一个本地仓库推送了代码，那么另一个本地仓库的推送会被拒绝，原因是当前文件已经被其他的推送给修改了，我们这边相当于是另一个版本，和之前两个分支合并一样，产生了冲突，因此我们只能去解决冲突问题。</p><p>如果远程仓库中的提交和本地仓库的提交没有去编写同一个文件，那么就可以直接拉取：</p><pre class="line-numbers language-none"><code class="language-none">BASHgit pull 远程仓库<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSM框架工作原理及流程</title>
      <link href="/archives/813428a5.html"/>
      <url>/archives/813428a5.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、什么是SSM框架："><a href="#一、什么是SSM框架：" class="headerlink" title="一、什么是SSM框架："></a>一、什么是SSM框架：</h2><p>SSM框架是Spring、SpringMVC和Mybatis框架的整合，是标准的MVC模式，将整个系统划分为View层，Controller层，Service层，DAO层四层，使用Spring MVC负责请求的转发和视图管理，Spring实现业务对象管理，Mybatis作为数据对象的持久化引擎。</p><h2 id="二、各框架介绍"><a href="#二、各框架介绍" class="headerlink" title="二、各框架介绍"></a>二、各框架介绍</h2><ol><li>Spring</li></ol><p>Spring就像是整个项目中装配bean的大工厂，在配置文件中可以指定使用特定的参数去调用实体类的构造方法来实例化对象。也可以称之为项目中的粘合剂。<br>Spring的核心思想是IoC（控制反转），即不再需要程序员去显式地<code>new</code>一个对象，而是让Spring框架帮你来完成这一切。</p><span id="more"></span><ol><li>SpringMVC</li></ol><p>SpringMVC作用于web层，相当于controller，与struts中的action一样，都是用来处理用户请求的。同时，相比于struts2来说，更加细粒度，它是基于方法层面的，而struts是基于类层面的。Spring MVC 分离了控制器、模型对象、分派器以及处理程序对象的角色，这种分离让它们更容易进行定制。</p><p>SpringMVC在项目中拦截用户请求，它的核心Servlet即DispatcherServlet承担中介或是前台这样的职责，将用户请求通过HandlerMapping去匹配Controller，Controller就是具体对应请求所执行的操作。SpringMVC相当于SSH框架中struts。</p><!--more--><p>SpringMVC具体工作流程如下</p><p><a href="https://s2.loli.net/2021/12/28/MQKh3PsZGeUNty4.jpg"><img src="https://s2.loli.net/2021/12/28/MQKh3PsZGeUNty4.jpg" alt="24.jpg"></a></p><ol><li>mybatis</li></ol><p>MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。</p><p>mybatis是对jdbc的封装，它让数据库底层操作变的透明。</p><p>mybatis的操作都是围绕一个sqlSessionFactory实例展开的。mybatis通过配置文件关联到各实体类的Mapper文件，Mapper文件中配置了每个类对数据库所需进行的sql语句映射。在每次与数据库交互时，通过sqlSessionFactory拿到一个sqlSession，再执行sql命令。</p><p>Mybatis层次图：</p><p><a href="https://s2.loli.net/2021/12/29/NVsUmGkYPcpXg4y.png"><img src="https://s2.loli.net/2021/12/29/NVsUmGkYPcpXg4y.png" alt="27.png"></a></p><h2 id="三、SSM框架中各层介绍"><a href="#三、SSM框架中各层介绍" class="headerlink" title="三、SSM框架中各层介绍"></a>三、SSM框架中各层介绍</h2><h3 id="pojo层，Dao层，Mapper层，service层，controller层"><a href="#pojo层，Dao层，Mapper层，service层，controller层" class="headerlink" title="pojo层，Dao层，Mapper层，service层，controller层"></a>pojo层，Dao层，Mapper层，service层，controller层</h3><h3 id="DAO层："><a href="#DAO层：" class="headerlink" title="DAO层："></a>DAO层：</h3><p>DAO层叫数据访问层，全称为data access object，某个DAO一定是和数据库的某一张表一一对应的，其中封装了CRUD（增加Create、检索Retrieve、更新Update和删除Delete）基本操作，DAO只做原子操作。无论多么复杂的查询，dao只是封装增删改查。至于增删查改如何去实现一个功能，dao是不管的。Mapper就是Mybatis操作数据库的那一层，就是DAO层</p><h3 id="Service层："><a href="#Service层：" class="headerlink" title="Service层："></a>Service层：</h3><p>Service层叫服务层，被称为服务，粗略的理解就是对一个或多个DAO进行的再次封装，封装成一个服务，所以这里也就不会是一个原子操作了，需要事物控制。管理具体的功能的。service包含了serviceImpl（service接口的实现类） 是提供给controller 使用的，针对于某些业务将 dao 的对于某些表的crud进行组合，也就是说间接的和数据库打交道。</p><h3 id="Controller层："><a href="#Controller层：" class="headerlink" title="Controller层："></a>Controller层：</h3><p>Controler负责请求转发，接受页面过来的参数，传给Service处理，接到返回值，再传给页面。管理业务（Service）调度和管理跳转的。controller 通过调用service来完成业务逻辑。</p><h3 id="pojo层"><a href="#pojo层" class="headerlink" title="pojo层"></a>pojo层</h3><p>实体类这一层，与数据库中的属性值基本保持一致。有的开发写成pojo，有的写成model，也有domain，也有dto（这里做参数验证，比如password不能为空等）。</p><h3 id="mapper层"><a href="#mapper层" class="headerlink" title="mapper层"></a>mapper层</h3><p>Mapper就是Mybatis操作数据库的那一层，就是DAO层，对数据库进行数据持久化操作，他的方法语句是直接针对数据库操作的。</p><p>各个层之间的流程如下：</p><p><a href="https://s2.loli.net/2021/12/28/AWg2Q4Ze7lrGItC.jpg"><img src="https://s2.loli.net/2021/12/28/AWg2Q4Ze7lrGItC.jpg" alt="26.jpg"></a></p><p><a href="https://s2.loli.net/2021/12/28/hkmle1TdL4g3yrx.jpg"><img src="https://s2.loli.net/2021/12/28/hkmle1TdL4g3yrx.jpg" alt="25.jpg"></a></p><h2 id="四、框架核心原理"><a href="#四、框架核心原理" class="headerlink" title="四、框架核心原理"></a>四、框架核心原理</h2><ol><li>AOP 面向切面编程（AOP）提供另外一种角度来思考程序结构，通过这种方式弥补了面向对象编程（OOP）的不足。除了类（classes）以外，AOP提供了切面。切面对关注点进行模块化，例如横切多个类型和对象的事务管理。Spring的一个关键的组件就是AOP框架，可以自由选择是否使用AOP。提供声明式企业服务，特别是为了替代EJB声明式服务。最重要的服务是声明性事务管理，这个服务建立在Spring的抽象事物管理之上。允许用户实现自定义切面，用AOP来完善OOP的使用可以把Spring AOP看作是对Spring的一种增强。AOP的实现乃至spring框架基本上核心代码都是基于Java语言的反射机制（所谓的反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。）。<br>AOP主要作用就是不通过修改源代码的方式、将非核心功能代码织入来实现对方法的增强。那么Spring AOP的底层如何实现对方法的增强？实现的关键在于使用了代理模式。代理模式的作用就是为其它对象提供一种代理，以控制对这个对象的访问，用于解决在直接访问对象时带来的各种问题，比如要访问的对象在远程的机器上。在面向对象系统中，由于其他某些原因（对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问）等<br>代理主要分为两种方式：静态代理和动态代理</li><li>IOC IoC不是一种技术，只是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。有了IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以相较于传统的java servlet需要自己request.getParamiter等需要一系列取值，转换中文，转换值类型的繁琐，更重要的是使得程序的整个体系结构变得非常灵活。<br>自定义一个IOC容器的思路：<br>Map做一个容器，然后用解析xml文件的工具解析出需要扫描的包。利用Java反射机制拿到锁具有的方法，属性，注入到Map容器中</li><li>DI 依赖注入，是组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态地将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。</li></ol><h3 id="AOP-IoC以及DI我单独写了两篇博客，比较详细的介绍了其思想，大家可以在”笔记”标签中找到。"><a href="#AOP-IoC以及DI我单独写了两篇博客，比较详细的介绍了其思想，大家可以在”笔记”标签中找到。" class="headerlink" title="AOP,IoC以及DI我单独写了两篇博客，比较详细的介绍了其思想，大家可以在”笔记”标签中找到。"></a>AOP,IoC以及DI我单独写了两篇博客，比较详细的介绍了其思想，大家可以在”笔记”标签中找到。</h3><h2 id="五、SSM框架工作流程"><a href="#五、SSM框架工作流程" class="headerlink" title="五、SSM框架工作流程"></a>五、SSM框架工作流程</h2><ol><li>用户访问客户端发出请求，请求会被Spring MVC中的前端控制器拦截，前端控制器配置在web.xml中。</li><li>DispatcherServlet拦截到请求后，调用处理器映射器在dispatcher-servlet.xml文件中</li><li>处理器映射器根据URL找到具体的处理器，生成具体的处理器对象及处理器拦截器（如果有生成）返回给前端控制器。</li><li>前端控制器会选择合适的处理器适配器</li><li>HandlerAdapter会调用并执行Handler（Controller层）也被称之为后端控制器</li><li>处理器对持久化对象进行增删改查</li><li>POJO将操作映射到ORM框架</li><li>ORM框架将操作映射到数据库</li><li>关系数据库把操作的数据返回给ORM框架</li><li>ORM框架把数据返回给持久化对象</li><li>持久化对象把数据返回给Handler</li><li>Handler返回一个ModelAndView对象，包含模型和视图名</li><li>处理器适配器将这个模型返回给前端控制器</li><li>前端控制器会根据ModelAndView选择一个合适的ViewResolver</li><li>视图解析器解析后返回一个合适的视图View给前端控制器</li><li>前端控制器对view进行渲染</li><li>返回给客户端浏览器显示</li></ol><h3 id="SSM框架全网最详细流程图如下："><a href="#SSM框架全网最详细流程图如下：" class="headerlink" title="SSM框架全网最详细流程图如下："></a>SSM框架全网最详细流程图如下：</h3><p><a href="https://s2.loli.net/2021/12/28/pJsGW5PoaBcOrFZ.jpg"><img src="https://s2.loli.net/2021/12/28/pJsGW5PoaBcOrFZ.jpg" alt="22.jpg"></a></p><h2 id="六、SSM框架整合"><a href="#六、SSM框架整合" class="headerlink" title="六、SSM框架整合"></a>六、SSM框架整合</h2><p>要让几个框架相互配合，配置文件怎么写，项目的目录结构怎么设计对我这样一个新手来说实在很头疼。<br>目前我也只刚刚写过一个用户登录的demo，在此记录一下。</p><h3 id="一-、项目目录结构"><a href="#一-、项目目录结构" class="headerlink" title="(一)、项目目录结构"></a>(一)、项目目录结构</h3><p>－LoginDemo<br>   －src<br>     －项目主包<br>        －controller<br>        －mapper<br>        －entity<br>        －service<br>   －web<br>     －WEB-INF<br>        －log4j.properties<br>        －spring-mybatis.xml<br>        －springMVC-config.xml<br>        －web.xml<br>     －index.jsp<br>   －pom.xml</p><h3 id="二、需要引入的包-pom-xml"><a href="#二、需要引入的包-pom-xml" class="headerlink" title="二、需要引入的包 (pom.xml)"></a>二、需要引入的包 (pom.xml)</h3><pre class="line-numbers language-none"><code class="language-none">XML&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;name&gt;LoginDemo&lt;/name&gt;    &lt;groupId&gt;com.cyan&lt;/groupId&gt;    &lt;artifactId&gt;ssm&lt;/artifactId&gt;    &lt;packaging&gt;war&lt;/packaging&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;url&gt;http://maven.apache.org&lt;/url&gt;    &lt;build&gt;        &lt;finalName&gt;ssm&lt;/finalName&gt;        &lt;plugins&gt;            &lt;!--mybatis 逆向工程插件--&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;                &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;                &lt;version&gt;1.3.2&lt;/version&gt;                &lt;configuration&gt;                    &lt;verbose&gt;true&lt;/verbose&gt;                    &lt;overwrite&gt;true&lt;/overwrite&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                &lt;configuration&gt;                    &lt;source&gt;1.6&lt;/source&gt;                    &lt;target&gt;1.6&lt;/target&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;    &lt;properties&gt;        &lt;spring.version&gt;4.1.1.RELEASE&lt;/spring.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;!-- springframe start --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-core&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-web&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- springframe end --&gt;        &lt;!--aspectj start--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;            &lt;version&gt;1.8.6&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;            &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt;            &lt;version&gt;1.8.6&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--aspectj end--&gt;        &lt;!--c3p0--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.mchange&lt;/groupId&gt;            &lt;artifactId&gt;c3p0&lt;/artifactId&gt;            &lt;version&gt;0.9.5.1&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--servlet/jsp api start--&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;            &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;            &lt;version&gt;2.5&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;            &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;            &lt;version&gt;2.1&lt;/version&gt;            &lt;scope&gt;provided&lt;/scope&gt;        &lt;/dependency&gt;        &lt;!--servlet/jsp api end--&gt;        &lt;!--junit4--&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.11&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;!--mybatis--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;            &lt;version&gt;3.3.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--mybatis spring整合--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;            &lt;version&gt;1.2.3&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--mysql driver--&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;5.1.6&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--jstl--&gt;        &lt;dependency&gt;            &lt;groupId&gt;jstl&lt;/groupId&gt;            &lt;artifactId&gt;jstl&lt;/artifactId&gt;            &lt;version&gt;1.2&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="三-、配置文件"><a href="#三-、配置文件" class="headerlink" title="(三)、配置文件"></a>(三)、配置文件</h3><ol><li>web.xml</li></ol><pre class="line-numbers language-none"><code class="language-none">XML&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"         version="3.1"&gt;    &lt;!-- Spring ApplicationContext 载入 --&gt;    &lt;listener&gt;        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;    &lt;/listener&gt;    &lt;!-- SpringMVC核心Servlet --&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;springMVC-config&lt;/servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;            &lt;param-value&gt;classpath:/WEB-INF/springMVC-config.xml&lt;/param-value&gt;        &lt;/init-param&gt;    &lt;/servlet&gt;    &lt;!-- 拦截所有请求 --&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;springMVC-config&lt;/servlet-name&gt;        &lt;url-pattern&gt;/&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;    &lt;!-- spring配置文件加载 --&gt;    &lt;context-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;classpath:WEB-INF/spring-mybatis.xml&lt;/param-value&gt;    &lt;/context-param&gt;&lt;/web-app&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>spring-mybatis.xml</li></ol><pre class="line-numbers language-none"><code class="language-none">XML&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"       xmlns:p="http://www.springframework.org/schema/p"       xmlns:context="http://www.springframework.org/schema/context"       xmlns:tx="http://www.springframework.org/schema/tx" xmlns:aop="http://www.springframework.org/schema/aop"       xsi:schemaLocation="http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans-3.2.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context-3.2.xsd        http://www.springframework.org/schema/tx        http://www.springframework.org/schema/tx/spring-tx-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt;    &lt;!-- 自动搜索bean --&gt;    &lt;context:annotation-config/&gt;    &lt;context:component-scan base-package="com.cyan" /&gt;    &lt;bean id="datasource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt;        &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"/&gt;        &lt;property name="url" value="jdbc:mysql://localhost:3306/Demo"/&gt;        &lt;property name="username" value="root"/&gt;        &lt;property name="password" value="2233"/&gt;    &lt;/bean&gt;    &lt;!-- mybatis核心bean --&gt;    &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt;        &lt;property name="dataSource" ref="datasource"/&gt;        &lt;!-- 这句配置mapper配置文件的位置 如果采用注解的方式这句可以省去 --&gt;        &lt;!--&lt;property name="mapperLocations" value="classpath:/WEB-INF/Mappers/*.xml" /&gt;--&gt;    &lt;/bean&gt;    &lt;!-- 自动搜索mapper接口 --&gt;    &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt;        &lt;property name="basePackage" value="com.cyan.Mapper" /&gt;    &lt;/bean&gt;    &lt;!-- 事务处理 --&gt;    &lt;bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;        &lt;property name="dataSource" ref="datasource"/&gt;    &lt;/bean&gt;    &lt;tx:advice id="txAdvice" transaction-manager="txManager"&gt;        &lt;tx:attributes&gt;            &lt;tx:method name="insert*" propagation="REQUIRED"/&gt;            &lt;tx:method name="delete*" propagation="REQUIRED"/&gt;            &lt;tx:method name="update*" propagation="REQUIRED"/&gt;            &lt;tx:method name="select*" propagation="SUPPORTS"/&gt;        &lt;/tx:attributes&gt;    &lt;/tx:advice&gt;    &lt;aop:config&gt;        &lt;aop:pointcut id="serviceCut" expression="execution(public * Service.*.*(..))" /&gt;        &lt;aop:advisor pointcut-ref="serviceCut" advice-ref="txAdvice" /&gt;    &lt;/aop:config&gt;&lt;/beans&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>springMVC-config.xml</li></ol><pre class="line-numbers language-none"><code class="language-none">XML&lt;beans xmlns="http://www.springframework.org/schema/beans"       xmlns:context="http://www.springframework.org/schema/context"       xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"       xsi:schemaLocation="        http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans-3.0.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context-3.0.xsd        http://www.springframework.org/schema/mvc        http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd"&gt;    &lt;!--spring可以自动去扫描base-pack下面或者子包下面的java文件，    如果扫描到有@Component @Controller@Service等这些注解的类，则把这些类注册为bean--&gt;    &lt;context:component-scan base-package="com.cyan.Controller"&gt;        &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt;        &lt;context:include-filter type="annotation" expression="org.springframework.web.bind.annotation.ControllerAdvice"/&gt;    &lt;/context:component-scan&gt;    &lt;mvc:annotation-driven /&gt;    &lt;mvc:default-servlet-handler/&gt;    &lt;!-- 配置jsp文件的前后缀 “／”代表的是项目设定的Resource目录 --&gt;    &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;        &lt;property name="prefix" value="/"/&gt;        &lt;property name="suffix" value=".jsp" /&gt;    &lt;/bean&gt;&lt;/beans&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="四-、详细类设计"><a href="#四-、详细类设计" class="headerlink" title="(四)、详细类设计"></a>(四)、详细类设计</h3><ol><li>－mapper<br>UserMapper</li></ol><pre class="line-numbers language-none"><code class="language-none">JAVApackage com.cyan.Mapper;import com.cyan.Model.User;import org.apache.ibatis.annotations.Param;import org.apache.ibatis.annotations.Select;import javax.annotation.Resource;import java.util.List;/** * Created by cyan on 16/3/29. */public interface UserMapper {    @Select("select * from LoginDemo")    public List&lt;User&gt; selectUser();    @Select("select * from LoginDemo where username=#{username}")    public List&lt;User&gt; selectUserByUsername(@Param("username")String username);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>－entity<br>User</li></ol><pre class="line-numbers language-none"><code class="language-none">JAVApackage com.cyan.Entity;/** * Created by cyan on 16/3/29. */public class User {    private int id;    private String username,password,slogan;    public int getId() {        return id;    }    public void setId(int id) {        this.id = id;    }    public String getUsername() {        return username;    }    public void setUsername(String username) {        this.username = username;    }    public String getPassword() {        return password;    }    public void setPassword(String password) {        this.password = password;    }    public String getSlogan() {        return slogan;    }    public void setSlogan(String slogan) {        this.slogan = slogan;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>－service</li></ol><ul><li>IUserService</li></ul><pre class="line-numbers language-none"><code class="language-none">JAVApackage com.cyan.Service;import com.cyan.Entity.User;/** * Created by cyan on 16/3/31. */public interface IUserService {    public User getUserByName(String name);    public boolean verify(String username,String pwd);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>UserService<br>Spring中的几个标签@Component（声明一个类是Spring容器管理的类，可以细分为后面提到的三个标签）、@Controller（控制层）、@Service（服务层）、@Repository（持久层）。标签的作用是让Spring根据名字关联到这个类。</li></ul><p>@Autowired标签默认以byType的形式注入，使用这个标签是不需要getter和setter方法的。（这次代码中因为用户名密码校验部分要用到get方法所以写上了）<br>可以配合@Qualifier标签根据bean的id来装配。</p><pre class="line-numbers language-none"><code class="language-none">JAVApackage com.cyan.Service;import com.cyan.Mapper.UserMapper;import com.cyan.Entity.User;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;/** * Created by cyan on 16/3/31. */@Service("userService")public class UserService implements IUserService{    @Autowired    private UserMapper userMapper;    public void setUserMapper(UserMapper userMapper) {        this.userMapper = userMapper;    }    @Override    public User getUserByName(String name) {        return userMapper.selectUserByUsername(name).get(0);    }    @Override    public boolean verify(String username, String pwd) {        if(userMapper.selectUserByUsername(username).get(0).getPassword().equals(pwd))            return true;        else return false;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>－controller<br>Login</li></ol><pre class="line-numbers language-none"><code class="language-none">JAVApackage com.cyan.Controller;import com.cyan.Service.IUserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * Created by cyan on 16/3/29. */@Controllerpublic class Login {    @Autowired    private IUserService userService;    @RequestMapping("/index")    public String index(){        return "index";    }    @RequestMapping(value ="/login",method = RequestMethod.POST)    public String login(HttpServletRequest req, HttpServletResponse resp){        String username=req.getParameter("username");        String pwd=req.getParameter("password");        if(userService.verify(username,pwd)){            req.getSession().setAttribute("user",userService.getUserByName(username));            return "success";        }        else return "index";    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>jsp页面</li></ol><ul><li>index.jsp</li></ul><pre class="line-numbers language-none"><code class="language-none">JAVA&lt;%--  Created by IntelliJ IDEA.  User: cyan  Date: 16/3/29  Time: 15:55  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;  &lt;head&gt;    &lt;title&gt;Login&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;form action="/login" method="post"&gt;      用户名:&lt;input type="text" name="username" id="username"/&gt;      &lt;br&gt;      密码:&lt;input type="password" name="password" id="password"/&gt;      &lt;br&gt;      &lt;input type="submit" value="登录"/&gt;    &lt;/form&gt;  &lt;/body&gt;&lt;/html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>success.jsp</li></ul><pre class="line-numbers language-none"><code class="language-none">JAVA&lt;%@ page import="com.cyan.Entity.User" %&gt;&lt;%--  Created by IntelliJ IDEA.  User: cyan  Date: 16/3/31  Time: 23:45  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;LoginSuccess&lt;/title&gt;&lt;/head&gt;&lt;body&gt;登录成功!&lt;%    User user=(User)session.getAttribute("user");%&gt;用户名:&lt;%=user.getUsername()%&gt;&lt;br&gt;个性签名:&lt;%=user.getSlogan()%&gt;&lt;br&gt;&lt;/body&gt;&lt;/html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="运行结果，大家自行测试。"><a href="#运行结果，大家自行测试。" class="headerlink" title="运行结果，大家自行测试。"></a>运行结果，大家自行测试。</h3><h3 id="感谢阅读！"><a href="#感谢阅读！" class="headerlink" title="感谢阅读！"></a>感谢阅读！</h3>]]></content>
      
      
      <categories>
          
          <category> SSM框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring中AOP的理解</title>
      <link href="/archives/b6262337.html"/>
      <url>/archives/b6262337.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、Spring是什么？"><a href="#一、Spring是什么？" class="headerlink" title="一、Spring是什么？"></a>一、Spring是什么？</h1><p>Spring是一个轻量级的2EE框架。它是一个容器框架，用来装<code>javabean</code>(java对象)，中间层框架(万能胶)可以起到一个连接作用，比如把Struts和hibernate粘合在一起运作，可以让我们的企业开发更快，更简洁。<br>spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器框架。</p><ul><li><p>1、从大小与开销两方面而言，spring都是轻量级的</p></li><li><p>2、通过控制反转(IoC)的技术达到松耦合的目的</p></li><li><p>3、提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务进行内聚性的开发</p></li><li><p>4、包含并管理应用对象(Bean)的配置和生命周期，这个意义上是一个容器</p></li><li><p>5、将简单的组件配置，组合成为复杂的应用，这个意义上是一个框架</p><span id="more"></span></li></ul><h1 id="二、AOP的理解"><a href="#二、AOP的理解" class="headerlink" title="二、AOP的理解"></a>二、AOP的理解</h1><p>系统是由许多不同的组件所组成的，每一个组件各负责一块特定功能。除了实现自身核心功能之外，这些组件还经常承担着额外的职责。例如日志、事物管理和安全这样的核心服务经常融入到自身具有核心业务逻辑的组件中去，这些系统服务经常被称为横切关注点，因为它们会跨越系统多个组件。</p><p>当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系，例如日志功能。</p><p>日志代码往往水平的散布在所有对象层，而与它所散布到的对象的核心功能搞无关系，在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。</p><p>AOP：将程序中的交叉业务了逻辑(比如安全、日志、事物等)，封装成一个切面，然后注入到目标对象(具体业务逻辑)中去。AOP可以对某个对象或某些对象的功能进行增强，比如对象中的方法进行增强，可以在执行某个方法之前额外的做一些事情，在某个方法执行之后额外做一些事情。</p><h1 id="三、AOP-讲义"><a href="#三、AOP-讲义" class="headerlink" title="三、AOP(讲义)"></a>三、AOP(讲义)</h1><h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><p>（1）在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP( Oriented Object Programming)的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p><p>（2）说到AOP，我们就不得不来提一下软件的纵向和横向问题。从纵向结构来看就是我们软件系统的各个模块，它主要负责处理我们的核心业务（例如商品订购、购物车查看）；而从横向结构来看，我们几乎每个系统又包含一些公共模块（例如 权限、日志模块等）。这些公共模块分布于我们各个核心业务之中（例如订购和查看商品明细的过程都需要检查用户权限、记录系统日志等）。这样一来不仅在开发过程中要处处关注公共模块的处理而且开发后维护起来也是十分麻烦。而有了AOP之后将应用程序中的商业逻辑同对其提供支持的通用服务进行分离，使得开发人 员可以更多的关注核心业务开发。</p><p><a href="https://s2.loli.net/2021/12/26/82rfukJS35LcOPs.png"><img src="https://s2.loli.net/2021/12/26/82rfukJS35LcOPs.png" alt="软件纵向与横向结构"></a></p><h2 id="2、AOP开发中的相关术语"><a href="#2、AOP开发中的相关术语" class="headerlink" title="2、AOP开发中的相关术语"></a>2、AOP开发中的相关术语</h2><h3 id="1-链接点-Joinpoint"><a href="#1-链接点-Joinpoint" class="headerlink" title="* (1) 链接点(Joinpoint)"></a>* (1) 链接点(Joinpoint)</h3><p>程序执行的某个特定位置：如类开始初始化前、类初始化后、类某个方法调用前、调用后、方法抛出异常后。一个类或一段程序代码拥有一些具有边界性质的特定点，这些点中的特定点就称为“连接点”。Spring仅支持方法的连接点，即仅能在方法调用前、方法调用后、方法抛出异常时以及方法调用前后这些程序执行点织入增强。（可以被切入的点）</p><h3 id="2-切点-Pointcut"><a href="#2-切点-Pointcut" class="headerlink" title="* (2) 切点(Pointcut)"></a>* (2) 切点(Pointcut)</h3><p>每个程序类都拥有多个连接点，如一个拥有两个方法的类，这两个方法都是连接点，即连接点是程序类中客观存在的事物。AOP通过“切点”定位特定的连接点。连接点相当于数据库中的记录，而切点相当于查询条件。切点和连接点不是一对一的关系，一个切点可以匹配多个连接点。在Spring中，切点通过org.springframework.aop.Pointcut接口进行描述，它使用类和方法作为连接点的查询条件，Spring AOP的规则解析引擎负责切点所设定的查询条件，找到对应的连接点。其实确切地说，不能称之为查询连接点，因为连接点是方法执行前、执行后等包括方位信息的具体程序执行点，而切点只定位到某个方法上，所以如果希望定位到具体连接点上，还需要提供方位信息。（已经被切入的点）</p><h3 id="3-通知-x2F-增强-Advice"><a href="#3-通知-x2F-增强-Advice" class="headerlink" title="* (3) 通知/增强(Advice)"></a>* (3) 通知/增强(Advice)</h3><p>增强是织入到目标类连接点上的一段程序代码，在Spring中，增强除用于描述一段程序代码外，还拥有另一个和连接点相关的信息，这便是执行点的方位。结合执行点方位信息和切点信息，我们就可以找到特定的连接点。（在切入点添加通过，增强它的功能）</p><h3 id="4-目标对象-Target"><a href="#4-目标对象-Target" class="headerlink" title="* (4) 目标对象(Target)"></a>* (4) 目标对象(Target)</h3><p>增强逻辑的织入目标类。如果没有AOP，目标业务类需要自己实现所有逻辑，而在AOP的帮助下，目标业务类只实现那些非横切逻辑的程序逻辑，而性能监视和事务管理等这些横切逻辑则可以使用AOP动态织入到特定的连接点上。（代理的目标对象）</p><h3 id="5-引介-Introduction"><a href="#5-引介-Introduction" class="headerlink" title="* (5) 引介(Introduction)"></a>* (5) 引介(Introduction)</h3><p>引介是一种特殊的增强，它为类添加一些属性和方法。这样，即使一个业务类原本没有实现某个接口，通过AOP的引介功能，我们可以动态地为该业务类添加接口的实现逻辑，让业务类成为这个接口的实现类。 （理解一种特殊的通知）</p><h3 id="6-织入-Weaving"><a href="#6-织入-Weaving" class="headerlink" title="* (6) 织入(Weaving)"></a>* (6) 织入(Weaving)</h3><p>织入是将增强添加对目标类具体连接点上的过程。AOP像一台织布机，将目标类、增强或引介通过AOP这台织布机天衣无缝地编织到一起。根据不同的实现技术，AOP有三种织入的方式：<br>a、编译期织入，这要求使用特殊的Java编译器。<br>b、类装载期织入，这要求使用特殊的类装载器。<br>c、动态代理织入，在运行期为目标类添加增强生成子类的方式。<br>Spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入。（通知放到切入点）</p><h3 id="7-代理-Proxy"><a href="#7-代理-Proxy" class="headerlink" title="* (7) 代理(Proxy)"></a>* (7) 代理(Proxy)</h3><p>一个类被AOP织入增强后，就产出了一个结果类，它是融合了原类和增强逻辑的代理类。根据不同的代理方式，代理类既可能是和原类具有相同接口的类，也可能就是原类的子类，所以我们可以采用调用原类相同的方式调用代理类。</p><h3 id="8-切面-Aspect"><a href="#8-切面-Aspect" class="headerlink" title="* (8) 切面(Aspect)"></a>* (8) 切面(Aspect)</h3><p>切面由切点和增强（引介）组成，它既包括了横切逻辑的定义，也包括了连接点的定义，Spring AOP就是负责实施切面的框架，它将切面所定义的横切逻辑织入到切面所指定的连接点中。（是切入点和通知的结合）</p><h2 id="AOP相关概念定义："><a href="#AOP相关概念定义：" class="headerlink" title="AOP相关概念定义："></a>AOP相关概念定义：</h2><ul><li><strong>Aspect（切面）</strong>： Aspect 声明类似于 Java 中的类声明，在 Aspect 中会包含着一些 Pointcut 以及相应的 Advice。</li><li><strong>Joint point（连接点）</strong>：表示在程序中明确定义的点，典型的包括方法调用，对类成员的访问以及异常处理程序块的执行等等，它自身还可以嵌套其它 joint point。</li><li><strong>Pointcut（切点）</strong>：表示一组 joint point，这些 joint point 或是通过逻辑关系组合起来，或是通过通配、正则表达式等方式集中起来，它定义了相应的 Advice 将要发生的地方。</li><li><strong>Advice（增强）</strong>：Advice 定义了在 Pointcut 里面定义的程序点具体要做的操作，它通过 before、after 和 around 来区别是在每个 joint point 之前、之后还是代替执行的代码。</li><li><strong>Target（目标对象）</strong>：织入 Advice 的目标对象.。</li><li><strong>Weaving（织入）</strong>：将 Aspect 和其他对象连接起来, 并创建 Adviced object 的过程</li></ul><h2 id="四、AOP其他知识点"><a href="#四、AOP其他知识点" class="headerlink" title="四、AOP其他知识点"></a>四、AOP其他知识点</h2><h3 id="1、通配符使用"><a href="#1、通配符使用" class="headerlink" title="1、通配符使用"></a>1、通配符使用</h3><p>在配置文件的切入点定义中，可以使用通配符*，该通配符可以表示返回值、类的全类名、方法名<br>如：</p><pre class="line-numbers language-none"><code class="language-none">JAVA&lt;aop:pointcut expression="execution(* *.*())" id="pointcut"/&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2、后置通知"><a href="#2、后置通知" class="headerlink" title="2、后置通知"></a>2、后置通知</h3><pre class="line-numbers language-none"><code class="language-none">JAVA&lt;aop:config&gt;   &lt;!-- 定义切入点（切入单个方法） --&gt;        &lt;aop:pointcut expression="execution(* *.update())" id="pointcut"/&gt;   &lt;!-- 定义切面，引用通知类 --&gt;   &lt;aop:aspect ref="transactionAdvice"&gt;      &lt;!-- method="before" 通知类型   pointcut="pointcut"  选择切入点 --&gt;     &lt;aop:after method="after" pointcut-ref="pointcut"/&gt;   &lt;/aop:aspect&gt;&lt;/aop:config&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3、环绕通知"><a href="#3、环绕通知" class="headerlink" title="3、环绕通知"></a>3、环绕通知</h3><pre class="line-numbers language-none"><code class="language-none">JAVA&lt;aop:config&gt;   &lt;!-- 定义切入点（切入所有方法） --&gt;        &lt;aop:pointcut expression="execution(* *.*())" id="pointcut"/&gt;   &lt;!-- 定义切面，引用通知类 --&gt;   &lt;aop:aspect ref="transactionAdvice"&gt;      &lt;!-- method="before" 通知类型   pointcut="pointcut"  选择切入点 --&gt;     &lt;aop:around method="around" pointcut-ref="pointcut"/&gt;   &lt;/aop:aspect&gt;&lt;/aop:config&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4、异常通知"><a href="#4、异常通知" class="headerlink" title="4、异常通知"></a>4、异常通知</h3><pre class="line-numbers language-none"><code class="language-none">JAVApublic void save(String n) {int i=9/0;System.out.println("***保存数据***");}&lt;aop:after-returning method="afterReturning" pointcut-ref="pointcut"/&gt;&lt;aop:after-throwing method="afterException" pointcut-ref="pointcut"/&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5、通知汇总"><a href="#5、通知汇总" class="headerlink" title="5、通知汇总"></a>5、通知汇总</h3><pre class="line-numbers language-none"><code class="language-none">JAVA&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xmlns:p="http://www.springframework.org/schema/p"xmlns:context="http://www.springframework.org/schema/context"xmlns:aop="http://www.springframework.org/schema/aop"xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsdhttp://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd"&gt;&lt;!--  Spring AOP实现方式有两种，一种使用JDK动态代理，另一种通过CGLIB来为目标对象创建代理。如果被代理的目标实现了至少一个接口，则会使用JDK动态代理，所有该目标类型实现的接口都将被代理。 --&gt;&lt;aop:aspectj-autoproxy proxy-target-class="true"/&gt;&lt;!-- 目标对象 --&gt;&lt;bean id="userService" class="com.ahbvc.spring.aop.service.UserServiceImpl"&gt;&lt;/bean&gt;&lt;!-- 通知类/增强类 --&gt;&lt;bean id="transactionAdvice" class="com.ahbvc.spring.aop.advice.TransactionAdvice"&gt;&lt;/bean&gt;&lt;!-- 将通知织入到目标对象，即开始面向切面编程 --&gt;&lt;aop:config&gt;   &lt;!-- 定义切入点 --&gt;        &lt;aop:pointcut expression="execution(* *.save(..))" id="pointcut"/&gt;   &lt;!-- 定义切面，引用通知类 --&gt;   &lt;aop:aspect ref="transactionAdvice"&gt;      &lt;!-- method="before" 通知类型   pointcut="pointcut"  选择切入点 --&gt;      &lt;aop:before method="before" pointcut-ref="pointcut"/&gt;      &lt;aop:after method="after" pointcut-ref="pointcut"/&gt;      &lt;aop:after-returning method="afterReturning" pointcut-ref="pointcut"/&gt;     &lt;aop:around method="around" pointcut-ref="pointcut"/&gt;     &lt;aop:after-throwing method="afterException" pointcut-ref="pointcut"/&gt;   &lt;/aop:aspect&gt;&lt;/aop:config&gt;&lt;/beans&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6、方法带参数"><a href="#6、方法带参数" class="headerlink" title="6、方法带参数"></a>6、方法带参数</h3><pre class="line-numbers language-none"><code class="language-none">JAVA&lt;aop:pointcut expression="execution(* *.*(..))" id="pointcut"/&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="7、spring官方文档定义"><a href="#7、spring官方文档定义" class="headerlink" title="7、spring官方文档定义"></a>7、spring官方文档定义</h3><p><a href="https://s2.loli.net/2021/12/26/9iXyrGh3xID6S1n.png"><img src="https://s2.loli.net/2021/12/26/9iXyrGh3xID6S1n.png" alt="19.png"></a></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring中IoC和DI的理解</title>
      <link href="/archives/e49c87f4.html"/>
      <url>/archives/e49c87f4.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>tips:<br>学习过Spring框架的人一定都会听过Spring的IoC(控制反转) 、DI(依赖注入)这两个概念，对于初学Spring的人来说，总觉得IoC 、DI这两个概念是模糊不清的，是很难理解的，今天和大家分享网上的一些技术大牛们对Spring框架的IOC的理解以及谈谈我对Spring Ioc的理解。</p></blockquote><h1 id="一、分享Iteye的开涛对IoC的精彩讲解"><a href="#一、分享Iteye的开涛对IoC的精彩讲解" class="headerlink" title="一、分享Iteye的开涛对IoC的精彩讲解"></a>一、分享Iteye的开涛对IoC的精彩讲解</h1><h2 id="1-1、IoC是什么"><a href="#1-1、IoC是什么" class="headerlink" title="1.1、IoC是什么"></a>1.1、IoC是什么</h2><p>　　IoC—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。如何理解好Ioc呢？理解好Ioc的关键是要明确“谁控制谁，控制什么，为何是反转（有反转就应该有正转了），哪些方面反转了”，那我们来深入分析一下：</p><span id="more"></span><p>　　●谁控制谁，控制什么：传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对 象的创建；谁控制谁？当然是IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。</p><p>　　●为何是反转，哪些方面反转了：有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。</p><h2 id="1-2、IoC能做什么"><a href="#1-2、IoC能做什么" class="headerlink" title="1.2、IoC能做什么"></a>1.2、IoC能做什么</h2><p>　　IoC 不是一种技术，只是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是 松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。</p><p>　　其实IoC对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IoC/DI思想中，应用程序就变成被动的了，被动的等待IoC容器来创建并注入它所需要的资源了。</p><p>　　IoC很好的体现了面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你”；即由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。</p><h2 id="1-3、IoC和DI"><a href="#1-3、IoC和DI" class="headerlink" title="1.3、IoC和DI"></a>1.3、IoC和DI</h2><p>　　DI—Dependency Injection，即“依赖注入”：组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。</p><p>　　理解DI的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”，那我们来深入分析一下：</p><p>　　●谁依赖于谁：当然是应用程序依赖于IoC容器；</p><p>　　●为什么需要依赖：应用程序需要IoC容器来提供对象需要的外部资源；</p><p>　　●谁注入谁：很明显是IoC容器注入应用程序某个对象，应用程序依赖的对象；</p><p>　　●注入了什么：就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。</p><p>　　IoC和DI由什么关系呢？其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IoC 而言，“依赖注入”明确描述了“被注入对象依赖IoC容器配置依赖对象”。</p><p>　　看过很多对Spring的Ioc理解的文章，好多人对Ioc和DI的解释都晦涩难懂，反正就是一种说不清，道不明的感觉，读完之后依然是一头雾水，感觉就是开涛这位技术牛人写得特别通俗易懂，他清楚地解释了IoC(控制反转) 和DI(依赖注入)中的每一个字，读完之后给人一种豁然开朗的感觉。我相信对于初学Spring框架的人对Ioc的理解应该是有很大帮助的。</p><h1 id="二、分享Bromon的blog上对IoC与DI浅显易懂的讲解"><a href="#二、分享Bromon的blog上对IoC与DI浅显易懂的讲解" class="headerlink" title="二、分享Bromon的blog上对IoC与DI浅显易懂的讲解"></a>二、分享Bromon的blog上对IoC与DI浅显易懂的讲解</h1><h2 id="2-1、IoC-控制反转"><a href="#2-1、IoC-控制反转" class="headerlink" title="2.1、IoC(控制反转)"></a>2.1、IoC(控制反转)</h2><p>　　首先想说说IoC（Inversion of Control，控制反转）。这是spring的核心，贯穿始终。所谓IoC，对于spring框架来说，就是由spring来负责控制对象的生命周期和对象间的关系。这是什么意思呢，举个简单的例子，我们是如何找女朋友的？常见的情况是，我们到处去看哪里有长得漂亮身材又好的mm，然后打听她们的兴趣爱好、qq号、电话号、ip号、iq号………，想办法认识她们，投其所好送其所要，然后嘿嘿……这个过程是复杂深奥的，我们必须自己设计和面对每个环节。传统的程序开发也是如此，在一个对象中，如果要使用另外的对象，就必须得到它（自己new一个，或者从JNDI中查询一个），使用完之后还要将对象销毁（比如Connection等），对象始终会和其他的接口或类藕合起来。</p><p>　　那么IoC是如何做的呢？有点像通过婚介找女朋友，在我和女朋友之间引入了一个第三者：婚姻介绍所。婚介管理了很多男男女女的资料，我可以向婚介提出一个列表，告诉它我想找个什么样的女朋友，比如长得像李嘉欣，身材像林熙雷，唱歌像周杰伦，速度像卡洛斯，技术像齐达内之类的，然后婚介就会按照我们的要求，提供一个mm，我们只需要去和她谈恋爱、结婚就行了。简单明了，如果婚介给我们的人选不符合要求，我们就会抛出异常。整个过程不再由我自己控制，而是有婚介这样一个类似容器的机构来控制。Spring所倡导的开发方式就是如此，所有的类都会在spring容器中登记，告诉spring你是个什么东西，你需要什么东西，然后spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由 spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。</p><h2 id="2-2、DI-依赖注入"><a href="#2-2、DI-依赖注入" class="headerlink" title="2.2、DI(依赖注入)"></a>2.2、DI(依赖注入)</h2><p>　　IoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。比如对象A需要操作数据库，以前我们总是要在A中自己编写代码来获得一个Connection对象，有了 spring我们就只需要告诉spring，A中需要一个Connection，至于这个Connection怎么构造，何时构造，A不需要知道。在系统运行时，spring会在适当的时候制造一个Connection，然后像打针一样，注射到A当中，这样就完成了对各个对象之间关系的控制。A需要依赖 Connection才能正常运行，而这个Connection是由spring注入到A中的，依赖注入的名字就这么来的。那么DI是如何实现的呢？ Java 1.3之后一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。</p><p>　　理解了IoC和DI的概念后，一切都将变得简单明了，剩下的工作只是在spring的框架中堆积木而已。</p><h1 id="三、我对IoC-控制反转-和DI-依赖注入-的理解"><a href="#三、我对IoC-控制反转-和DI-依赖注入-的理解" class="headerlink" title="三、我对IoC(控制反转)和DI(依赖注入)的理解"></a>三、我对IoC(控制反转)和DI(依赖注入)的理解</h1><p>　　在平时的java应用开发中，我们要实现某一个功能或者说是完成某个业务逻辑时至少需要两个或以上的对象来协作完成，在没有使用Spring的时候，每个对象在需要使用他的合作对象时，自己均要使用像new object() 这样的语法来将合作对象创建出来，这个合作对象是由自己主动创建出来的，创建合作对象的主动权在自己手上，自己需要哪个合作对象，就主动去创建，创建合作对象的主动权和创建时机是由自己把控的，而这样就会使得对象间的耦合度高了，A对象需要使用合作对象B来共同完成一件事，A要使用B，那么A就对B产生了依赖，也就是A和B之间存在一种耦合关系，并且是紧密耦合在一起，而使用了Spring之后就不一样了，创建合作对象B的工作是由Spring来做的，Spring创建好B对象，然后存储到一个容器里面，当A对象需要使用B对象时，Spring就从存放对象的那个容器里面取出A要使用的那个B对象，然后交给A对象使用，至于Spring是如何创建那个对象，以及什么时候创建好对象的，A对象不需要关心这些细节问题(你是什么时候生的，怎么生出来的我可不关心，能帮我干活就行)，A得到Spring给我们的对象之后，两个人一起协作完成要完成的工作即可。</p><p>　　所以控制反转IoC(Inversion of Control)是说创建对象的控制权进行转移，以前创建对象的主动权和创建时机是由自己把控的，而现在这种权力转移到第三方，比如转移交给了IoC容器，它就是一个专门用来创建对象的工厂，你要什么对象，它就给你什么对象，有了 IoC容器，依赖关系就变了，原先的依赖关系就没了，它们都依赖IoC容器了，通过IoC容器来建立它们之间的关系。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>键盘选择</title>
      <link href="/archives/4ac2cecb.html"/>
      <url>/archives/4ac2cecb.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最简单最快速最精辟的挑选键盘指南</p><p>1 手感<br>  1.1 键帽支撑（平衡杆 优于 卫星轴 优于 啥都没有）直接问店家有没有平衡杆/卫星轴<br>  1.2 线性VS段落<br>    1.2.1 喜欢反馈的感觉（按下的时候有东西弹你类似圆珠笔），选段落轴<br>    1.2.2 喜欢直上直下，选线性<br>  1.3 键程<br>    1.3.1 特别喜欢敲击触感体验，选机械<br>    1.3.2 少一点敲击感，多一点轻松，选静电容、薄膜<br>    1.3.3 喜欢点一下就可以的选巧克力键盘，触摸屏键盘等<br>  1.4 压力克数<br>    1.4.1 喜欢更爽，回弹快就选克数大的（45）<br>    1.4.2 喜欢轻松就选小的（35）<br>2 敲击速度（打字速度）<br>  2.1 选择标准<br>    2.1.1 喜欢快速敲击（更爽但是更累）则选压力克数大的<br>    2.1.2 喜欢长时间轻松敲击的可以选压力克数小的<br>    2.1.3 速度和耐用性上 静电容、光轴&gt;机械&gt;薄膜<br>  2.2 回弹速度<br>    2.2.1 打字更爽更快，但是更累选回弹快的<br>    2.2.2 打字稍慢但是更轻松选回弹慢的<br>  2.3 灵敏度<br>    2.3.1 静电容是程序判断触发，所以可调，个人认为灵活性最好，耐用性最好。首推<br>    2.3.2 静电容和光轴触发都很快，灵敏度高，需要灵敏度的游戏可选<br>    2.3.3 机械轴触发稍慢一丢丢，可以从缩短触发键程角度改良<br>    2.3.4 薄膜最慢</p><span id="more"></span><p>3 是否适合长时间敲击（长时间工作/游戏）<br>  3.1 如果想轻松一点，就找让你做功少的键盘。敲击力度(压力克数)，按键距离（触发键程）至少一个要少。<br>  3.2 如果想爽一点（体会鞭挞的快感😂），就找敲击力度（压力克数），按键距离（触发键程）至少一个要多的<br>4 键位<br>  4.1 根据自己对键位要求<br>  4.2 喜欢小一点便携的键盘就66，84左右；喜欢大的就108<br>5 敲击声音<br>  5.1 根据自己的环境需求<br>    5.1.1 需要静的就选静电容/薄膜或者至少是线性轴<br>  5.2 自己就是喜欢啪啪的声音<br>    5.2.1 选段落感轴或者有发声弹簧的键盘<br>  5.3 键盘无杂音肯定是更好的（问好有没有弹簧音）</p><p><img src="https://mubu.com/document_image/a112fed7-9dc9-4ee2-9825-210eab1877e9-3316715.jpg" alt="img"></p><p><img src="https://mubu.com/document_image/45b6f583-f5b2-4908-9a18-656627e66359-3316715.jpg" alt="img"></p><p>今天讲一下怎么DIY键盘 ，从零做键盘呢~</p><p><a href="http://dongshuyan.com/diykey.html#printcenter1">DIY键盘 从零做键盘</a></p><p>文字版简洁框架：</p><p><a href="http://dongshuyan.com/keyfeature.html">购买流程框架文字版</a></p><p>图片版：<br><img src="https://mubu.com/document_image/1a3b592b-0c27-4ca0-9a79-fa45d7c46cf2-3316715.jpg" alt="img"><br>思维导图<br><img src="https://mubu.com/document_image/e4da9cd4-01c5-4150-a4bb-c640bf796b74-3316715.jpg" alt="img"></p><p>具体弹性曲线图，触发原理图，键程参数，各种轴型介绍请参考如下文章：</p><p><a href="https://zhuanlan.zhihu.com/p/68429267">一篇文章看懂所有键盘原理（机械键盘 静电容键盘 薄膜键盘 光轴键盘 静电容机械键盘）+如何选购键盘</a></p>]]></content>
      
      
      <categories>
          
          <category> 键盘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 选键盘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零搭建hexo博客</title>
      <link href="/archives/2f76a78a.html"/>
      <url>/archives/2f76a78a.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>搭建博客</strong><br>1.在GitHub创建个人仓库「名字必须是user.github.io」（此处省略，文章底部有教程链接）<br>2.本地安装Git（此处省略，文章底部有教程链接）<br>3.本地安装Node.js（此处省略，文章底部有教程链接）<br>4.本地安装Hexo<br>5.网站推送至github<br>6.github绑定域名<br>7.更换主题<br>8.Hexo高级个性化设置</p><p><strong>编写博客</strong><br>1.Hexo文章的开头<br>2.Hexo文章的内容<br>2.1MarkDown语法<br>2.2寻找图床</p><span id="more"></span><h1 id="1-搭建博客"><a href="#1-搭建博客" class="headerlink" title="1.搭建博客"></a>1.搭建博客</h1><h2 id="1-1-本地安装Hexo"><a href="#1-1-本地安装Hexo" class="headerlink" title="1.1.本地安装Hexo"></a>1.1.本地安装Hexo</h2><p>下载安装Git与Node.js略过</p><p>1.安装hexo</p><pre class="line-numbers language-none"><code class="language-none">npm install hexo -g #-g表示全局安装, npm默认为当前项目安装<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2.Hexo基本命令:</p><pre class="line-numbers language-none"><code class="language-none">npm update hexo -g  #升级 hexo init &lt;folder&gt;  #执行init命令初始化hexo到你指定的目录hexo n "我的博客" == hexo new "我的博客" #新建文章hexo generate       #自动根据当前目录下文件,生成静态网页 hexo ghexo server         #运行本地服务 hexo shexo clean          #清理hexo deploy         #部署 hexo dhexo server         #Hexo会监视文件变动并自动更新，无须重启服务器hexo server -s      #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最常用的是：</p><pre class="line-numbers language-none"><code class="language-none">hexo cleanhexo ghexo dhexo s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这个时候hexo s之后就可以在浏览器</p><pre class="line-numbers language-none"><code class="language-none">http://localhost:4000/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里看到hexo博客的基本样子了</p><h2 id="1-2-将网站推送至github"><a href="#1-2-将网站推送至github" class="headerlink" title="1.2.将网站推送至github"></a>1.2.将网站推送至github</h2><p>1.首先在本地告诉退给谁<br>打开本地博客本目录下的配置文件_config.yml<br>修改最后一行的配置：</p><pre class="line-numbers language-none"><code class="language-none">deploy:  type: git  repository: https://github.com/dongshuyan/dongshuyan.github.io.git  branch: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>2.上传github</p><pre class="line-numbers language-none"><code class="language-none">hexo cleanhexo ghexo d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>若执行hexo g出错则执行</p><pre class="line-numbers language-none"><code class="language-none">npm install hexo --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>若执行hexo d出错则执行</p><pre class="line-numbers language-none"><code class="language-none">npm install hexo-deployer-git --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>错误修正后再次执行hexo g和hexo d上传到服务器。<br>若未关联GitHub，执行hexo d时会提示输入GitHub账号用户名和密码，即:</p><pre class="line-numbers language-none"><code class="language-none">username for 'https://github.com':password for 'https://github.com':<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>输入你的github账号密码即可。<br>hexo d执行成功后便可通过<a href="https://dongshuyan.github.io访问博客,看到的内容和http//localhost:4000%E7%9B%B8%E5%90%8C%E3%80%82">https://dongshuyan.github.io访问博客，看到的内容和http://localhost:4000相同。</a></p><p>3.记住github密码<br>在github添加ssh key后不需要每次更新博客再输入用户名和密码。首先检查本地是否包含ssh keys。如果存在则直接将ssh key添加到GitHub之中，否则新生成ssh key。</p><p>执行下述命令生成新的ssh key</p><pre class="line-numbers language-none"><code class="language-none">ssh-keygen -t rsa -C "your_email@exampl"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里需要将</p><pre class="line-numbers language-none"><code class="language-none">your_email@example.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>改成自己注册的GitHub邮箱地址。默认会在~/.ssh/id_rsa.pub中生成id_rsa和id_rsa.pub文件。</p><p>Mac下利用open ~/.ssh打开文件夹，打开id_rsa.pub文件，里面的信息即为ssh key，将此信息复制到GitHub的Add ssh key路径GitHub-&gt;Setting-&gt;SSH keys-&gt;add SSH key中即可。Title里填写任意标题，将复制的内容粘贴到key中，点击Add key完成添加即可记住密码。</p><p>此时本地博客内容便已关联到GitHub之中，本地博客改变之后，通过hexo g和hexo d便可更新到GitHub之中。</p><h2 id="1-3-github绑定域名"><a href="#1-3-github绑定域名" class="headerlink" title="1.3.github绑定域名"></a>1.3.github绑定域名</h2><p>如果你有自己的域名了，比如我买了“dongshuyan.com”<br>那么可以把博客与域名关联起来，这样你打开dongshuyan.com显示的就是dongshuyan.github.io的内容。你打开dongshuyan.github.io会自动跳转dongshuyan.com</p><p>这里演示的是在阿里云万网的域名绑定，在国内主流的域名代理厂商也就阿里云和腾讯云。登录到阿里云，进入管理控制台的域名列表，找到你的个性化域名，进入解析：<br><img src="https://mubu.com/document_image/a949feea-b9d8-4b58-aa3e-b1bca87ebabc-3316715.jpg" alt="img"></p><p>然后再你本地博客文件夹下的source文件夹里添加一个文件，文件名为”CNAME”，内容为你的域名。<br>例如：</p><pre class="line-numbers language-none"><code class="language-none">dongshuyan.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里要求一个字符不差。</p><h2 id="1-4-更改主题（以Yilia为例）"><a href="#1-4-更改主题（以Yilia为例）" class="headerlink" title="1.4.更改主题（以Yilia为例）"></a>1.4.更改主题（以Yilia为例）</h2><ol><li><p>安装yilia</p><pre class="line-numbers language-none"><code class="language-none">git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>配置<br>修改hexo根目录下的 _config.yml ： theme: yilia</p></li><li><p>更新</p><pre class="line-numbers language-none"><code class="language-none">cd themes/yiliagit pull<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><h2 id="1-5-Hexo-高级配置"><a href="#1-5-Hexo-高级配置" class="headerlink" title="1.5.Hexo 高级配置"></a>1.5.Hexo 高级配置</h2><p>详见<br><a href="http://dongshuyan.com/2019/05/24/hexo%E5%8D%9A%E5%AE%A2%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/">Hexo Yilia 高级配置大全</a></p><h1 id="2-编写博客"><a href="#2-编写博客" class="headerlink" title="2.编写博客"></a>2.编写博客</h1><h2 id="2-1-Hexo文章的开头"><a href="#2-1-Hexo文章的开头" class="headerlink" title="2.1.Hexo文章的开头"></a>2.1.Hexo文章的开头</h2><p>举例：</p><pre class="line-numbers language-none"><code class="language-none">title: 从零搭建博客 教程 Hexo GitHub    #文章标题subtitle:                            #子标题#categories: 文章                     #文章分類目錄 可以省略    toc: true                            #目录 需要安装插件或者主题自带reward: true                         #打赏 需要安装插件或者主题自带declare: true                        #版权 需要安装插件或者主题自带date:                                #文章日期 2019/7/1header-img:                          #顶部背景图片tags:                                #标签- 自学- Blog- Original<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-2-Hexo文章的内容"><a href="#2-2-Hexo文章的内容" class="headerlink" title="2.2.Hexo文章的内容"></a>2.2.Hexo文章的内容</h2><h3 id="2-2-1markdown常用语法"><a href="#2-2-1markdown常用语法" class="headerlink" title="2.2.1markdown常用语法"></a>2.2.1markdown常用语法</h3><h4 id="2-2-1-1-标题"><a href="#2-2-1-1-标题" class="headerlink" title="2.2.1.1 标题"></a>2.2.1.1 标题</h4><p>建立一个1级标题：</p><pre class="line-numbers language-none"><code class="language-none"># 建立一个1级标题：<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>建立一个2级标题：</p><pre class="line-numbers language-none"><code class="language-none">## 建立一个2级标题<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>建立一个3级标题：</p><pre class="line-numbers language-none"><code class="language-none">### 建立一个3级标题<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最多五级标题</p><h4 id="2-2-1-2建立一个超链接"><a href="#2-2-1-2建立一个超链接" class="headerlink" title="2.2.1.2建立一个超链接"></a>2.2.1.2建立一个超链接</h4><p>效果:More info: <a href="https://hexo.io/docs/writing.html">Writing</a><br>代码如下：</p><pre class="line-numbers language-none"><code class="language-none">More info: [Writing](https://hexo.io/docs/writing.html)新窗口打开链接：&lt;a target = "_blank" href="#"&gt;AAA&lt;/a&gt;#：表示要跳转的连接点击 AAA 超链接，将在新窗口打开#连接<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-1-3建立目录"><a href="#2-2-1-3建立目录" class="headerlink" title="2.2.1.3建立目录"></a>2.2.1.3建立目录</h4><p>大部分Hexo主题不支持markdown建立目录，不过这里还是教一下。<br>代码如下：</p><pre class="line-numbers language-none"><code class="language-none">[TOC]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2-2-1-4建立标签"><a href="#2-2-1-4建立标签" class="headerlink" title="2.2.1.4建立标签"></a>2.2.1.4建立标签</h4><p>代码如下：</p><pre class="line-numbers language-none"><code class="language-none">tags: 自学记录 (写在头上）若多个标签，则：tags:- first- essay- picture效果看题头<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-1-5代码块"><a href="#2-2-1-5代码块" class="headerlink" title="2.2.1.5代码块"></a>2.2.1.5代码块</h4><p>代码如下：</p><pre class="line-numbers language-none"><code class="language-none">先写三个“`”带一个空格，后面写语言类型例如C++再写三个“`”<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>注意！</strong></p><pre class="line-numbers language-none"><code class="language-none">写markdown的时候，用txt打开，一定要用UTF-8保存。否则中文乱码。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2-2-1-6图片"><a href="#2-2-1-6图片" class="headerlink" title="2.2.1.6图片"></a>2.2.1.6图片</h4><p><img src="https://mubu.com/document_image/0a0cb2aa-3db9-425c-b09c-3fae711fb832-3316715.jpg" alt="1"><br>代码如下：</p><pre class="line-numbers language-none"><code class="language-none">![1](https://mubu.com/document_image/0a0cb2aa-3db9-425c-b09c-3fae711fb832-3316715.jpg)或者&lt;img src="https://mubu.com/document_image/c816afe950cad003-3316715.jpg" width = 100% div align=center/&gt;下面这个可以调整大小。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-1-7音乐"><a href="#2-2-1-7音乐" class="headerlink" title="2.2.1.7音乐"></a>2.2.1.7音乐</h4><p>（具体功能百度htmlaudio标签）</p><pre class="line-numbers language-none"><code class="language-none">&lt;audio id="audio" autoplay="autoplay"&gt;    &lt;source src="http://qzone.haoduoge.com/music1/2015-04-23/1429774382.mp3" type="audio/mp3"&gt;&lt;/source&gt;&lt;/audio&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="2-2-1-8怎么改字体加颜色"><a href="#2-2-1-8怎么改字体加颜色" class="headerlink" title="2.2.1.8怎么改字体加颜色"></a>2.2.1.8怎么改字体加颜色</h4><p>摘要：<br><strong>加粗</strong></p><p><em>斜体</em></p><p>下划线</p><p>删除线</p><p><del>删除线2</del><br>DEMO1: 上标<br>DEMO2: 下标</p><p>居中</p><p>标记</p><pre class="line-numbers language-none"><code class="language-none">&lt;font color="red" face="宋体" size= 3&gt;摘要：&lt;/font&gt;&lt;b&gt; 加粗 &lt;/b&gt;&lt;I&gt;斜体&lt;/I&gt; &lt;U&gt;下划线&lt;/U&gt; &lt;S&gt;删除线&lt;/S&gt; &lt;STRIKE&gt;删除线2&lt;/STRIKE&gt; DEMO1: &lt;SUP&gt;上标&lt;/SUP&gt; DEMO2: &lt;SUB&gt;下标&lt;/SUB&gt;&lt;!-- 注释 --&gt;&lt;center&gt;居中&lt;/center&gt;&lt;mark&gt;标记&lt;/mark&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-1-9怎么加空格和回车"><a href="#2-2-1-9怎么加空格和回车" class="headerlink" title="2.2.1.9怎么加空格和回车"></a>2.2.1.9怎么加空格和回车</h4><pre class="line-numbers language-none"><code class="language-none">空格&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;回车&lt;br/&gt; &lt;br/&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="2-2-1-10折叠"><a href="#2-2-1-10折叠" class="headerlink" title="2.2.1.10折叠"></a>2.2.1.10折叠</h4><details style="box-sizing: border-box; display: block; color: rgb(230, 221, 206); font-family: &quot;lucida grande&quot;, &quot;lucida sans unicode&quot;, lucida, helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif; font-size: 12px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(26, 27, 26); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><br style="box-sizing: border-box;"><summary style="box-sizing: border-box; display: block;"><font color="darkred" data-darkreader-inline-color style="box-sizing: border-box; color: var(--darkreader-inline-color)  !important; --darkreader-inline-color:#e67d75;">标题</font></summary><br style="box-sizing: border-box;"><br style="box-sizing: border-box;"></details><pre class="line-numbers language-none"><code class="language-none">&lt;details&gt;  &lt;summary&gt;&lt;font color=darkred&gt;标题&lt;/font&gt;&lt;/summary&gt;  被折叠内容&lt;/details&gt;&lt;details&gt;&lt;summary&gt;&lt;font color=darkred&gt;标题&lt;/font&gt;&lt;/summary&gt;  被折叠内容&lt;/details&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-1-11页面内跳转"><a href="#2-2-1-11页面内跳转" class="headerlink" title="2.2.1.11页面内跳转"></a>2.2.1.11页面内跳转</h4><p>页面内跳转由两部分组成：<br>跳转标识（mark）：在你想跳转到的地方放一个标识，后面就会跳到这里来。</p><pre class="line-numbers language-none"><code class="language-none">&lt;div id="Mark"&gt;&lt;/div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>跳转命令：点击就会跳转到对应的标识</p><pre class="line-numbers language-none"><code class="language-none">[返回目录](#Mark)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2-2-1-12-文章省略"><a href="#2-2-1-12-文章省略" class="headerlink" title="2.2.1.12 文章省略"></a>2.2.1.12 文章省略</h4><p>这里是为了不再博客主页面把每一个文章全部显示出来<br>在文章中间插入：</p><pre class="line-numbers language-none"><code class="language-none">&lt;!--more--&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其就会显示到标识前面的部分。</p><h2 id="2-3-图床"><a href="#2-3-图床" class="headerlink" title="2.3 图床"></a>2.3 图床</h2><p>图床就是网上可以在线储存图片的服务器。因为markdown里面无法存储图片，所以我们要把图片放在图床里，再以链接的形式引用。</p><p><strong>什么是好的图床</strong>：（重要程度一次递减）<br>1.平台稳定（别动不动就崩 别用几天平台没了 ）<br>2.图片存储时间长（保证你的博客需求）<br>3.支持所需的图片要求（大小 格式要求）<br>4.加载速度<br>5.总容量<br>6.廉价最好免费</p><p>根据上面的几个指标利用知乎，百度去搜索吧~</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://zhuanlan.zhihu.com/p/26625249">GitHub+Hexo 搭建个人网站详细教程</a><br><a href="https://zhuanlan.zhihu.com/p/35668237">超详细Hexo+Github博客搭建小白教程</a><br><a href="https://zhuanlan.zhihu.com/p/34654952">Mac+Hexo+GitHub搭建博客教程</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo、github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo GitHub Mac Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo Yilia高级配置</title>
      <link href="/archives/a5f1f796.html"/>
      <url>/archives/a5f1f796.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>这篇文章列举了搭建博客至今遇到所有问题的解决方法以及一些新功能的添加方法。</strong><br>这篇文章集合了几乎所有的Hexo Yilia进阶用法教程，包括且不限于：<br>1.微信分享异常 2.“所有文章”无显示 3.显示总文章数 4.置顶文章 5.文章加密 6.文章点击数统计 7.版权声明 8.字数、阅读时长 9.点击红心 10.文章结束 11.404 12.Sitemap 13.自动推送 14.百度统计 15.链接提交 16.google收录 17.Valine增删改查，邮件提示，云引擎 18.板娘<br>19.Yilia标签搜索Bug 20.添加文章顶部转载说明 21.google广告投放 22 Gitment/Gitalk评论系统 23.tag中含有大写字母的bug 24.hexo-d失败 25 跳转到指定位置</p><h1 id="1、微信分享异常"><a href="#1、微信分享异常" class="headerlink" title="1、微信分享异常"></a>1、微信分享异常</h1><p>这里是themes\yilia\layout\ _partial\post\share.ejs出了问题。<br>而且是两个问题：</p><h2 id="1-1-首先是百度网盘取消了生成二维码的功能。"><a href="#1-1-首先是百度网盘取消了生成二维码的功能。" class="headerlink" title="1.1 首先是百度网盘取消了生成二维码的功能。"></a>1.1 首先是百度网盘取消了生成二维码的功能。</h2><p>解决方法是修改themes\yilia\layout_partial\post\share.ejs<br>文件中的</p><pre class="line-numbers language-none"><code class="language-none">//pan.baidu.com/share/qrcode?url=<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改为</p><pre class="line-numbers language-none"><code class="language-none">//api.qrserver.com/v1/create-qr-code/?size=150x150&amp;data=<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><span id="more"></span><h2 id="1-2-我这里分享的网址有问题。方法一"><a href="#1-2-我这里分享的网址有问题。方法一" class="headerlink" title="1.2 我这里分享的网址有问题。方法一"></a>1.2 我这里分享的网址有问题。方法一</h2><p>直接在根目录的配置文件中添加你网站的url信息。</p><h2 id="1-3-我这里分享的网址有问题。方法二"><a href="#1-3-我这里分享的网址有问题。方法二" class="headerlink" title="1.3 我这里分享的网址有问题。方法二"></a>1.3 我这里分享的网址有问题。方法二</h2><p>解决方法是在文件中的</p><pre class="line-numbers language-none"><code class="language-none">var sUrl = url.replace(/index\.html$/, '');  sUrl = /^(http:|https:)\/\//.test(sUrl) ? sUrl : 'http:' + sUrl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>下面加一行（这里的20是根据自己网址长度计算得到的）</p><pre class="line-numbers language-none"><code class="language-none">test=sUrl.substring(20);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后上面就变成了：</p><pre class="line-numbers language-none"><code class="language-none">&lt;%  var sUrl = url.replace(/index\.html$/, '');  sUrl = /^(http:|https:)\/\//.test(sUrl) ? sUrl : 'http:' + sUrl;  test=sUrl.substring(20);%&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后将上一步中的</p><pre class="line-numbers language-none"><code class="language-none">'//api.qrserver.com/v1/create-qr-code/?size=150x150&amp;data=' + sUrl<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>改为</p><pre class="line-numbers language-none"><code class="language-none">'//api.qrserver.com/v1/create-qr-code/?size=150x150&amp;data=你的主页网址' + test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>举例，我的网址是（dongshuyan.github.io）那么就改为：</p><pre class="line-numbers language-none"><code class="language-none">&lt;div class="page-modal wx-share js-wx-box"&gt;    &lt;a class="close js-modal-close" href="javascript:;"&gt;&lt;i class="icon icon-close"&gt;&lt;/i&gt;&lt;/a&gt;    &lt;p&gt;扫一扫，分享到微信&lt;/p&gt;    &lt;div class="wx-qrcode"&gt;      &lt;img src="&lt;%- 'qrcode' in locals ? qrcode(sUrl) : '//api.qrserver.com/v1/create-qr-code/?size=150x150&amp;data=http://dongshuyan.github.io/' + test  %&gt;" alt="微信分享二维码"&gt;    &lt;/div&gt;&lt;/div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="2-点击“所有文章”无显示"><a href="#2-点击“所有文章”无显示" class="headerlink" title="2.点击“所有文章”无显示"></a>2.点击“所有文章”无显示</h1><p>themes\yilia\ _config.yml文件里面</p><pre class="line-numbers language-none"><code class="language-none">mathjax: true<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>改成</p><pre class="line-numbers language-none"><code class="language-none">mathjax: false<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="3-在左侧显示总文章数"><a href="#3-在左侧显示总文章数" class="headerlink" title="3.在左侧显示总文章数"></a>3.在左侧显示总文章数</h1><p>将themes\yilia\layout_partial\left-col.ejs文件的</p><pre class="line-numbers language-none"><code class="language-none">&lt;nav class="header-menu"&gt;    &lt;ul&gt;    &lt;% for (var i in theme.menu){ %&gt;        &lt;li&gt;&lt;a href="&lt;%- url_for(theme.menu[i]) %&gt;"&gt;&lt;%= i %&gt;&lt;/a&gt;&lt;/li&gt;    &lt;%}%&gt;    &lt;/ul&gt;&lt;/nav&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>后面加上</p><pre class="line-numbers language-none"><code class="language-none">&lt;nav&gt;    总文章数 &lt;%=site.posts.length%&gt;&lt;/nav&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="4-怎么置顶文章"><a href="#4-怎么置顶文章" class="headerlink" title="4.怎么置顶文章"></a>4.怎么置顶文章</h1><h2 id="4-1安装插件"><a href="#4-1安装插件" class="headerlink" title="4.1安装插件"></a>4.1安装插件</h2><pre class="line-numbers language-none"><code class="language-none">npm uninstall hexo-generator-index --savenpm install hexo-generator-index-pin-top --save<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="4-2配置置顶标准"><a href="#4-2配置置顶标准" class="headerlink" title="4.2配置置顶标准"></a>4.2配置置顶标准</h2><p>打开：/themes/*/layout（/_macro）/post.ejs<br>直接在最前面加入以下代码即可</p><pre class="line-numbers language-none"><code class="language-none">&lt;% if (page.top) { %&gt;  &lt;i class="fa fa-thumb-tack"&gt;&lt;/i&gt;  &lt;font color=7D26CD&gt;置顶&lt;/font&gt;  &lt;span class="post-meta-divider"&gt;|&lt;/span&gt;&lt;% } %&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-3配置文章"><a href="#4-3配置文章" class="headerlink" title="4.3配置文章"></a>4.3配置文章</h2><p>然后在需要置顶的文章的Front-matter中加上top选项即可<br>top后面的数字越大，优先级越高</p><pre class="line-numbers language-none"><code class="language-none">---title: 2019date: 2019-02-14 16:10:03top: 5---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-4优先级配置"><a href="#4-4优先级配置" class="headerlink" title="4.4优先级配置"></a>4.4优先级配置</h2><p>修改根目录配置文件/_config.yml,top值-1标示根据top值倒序（正序设置为1即可），同样date也是根据创建日期倒序。</p><pre class="line-numbers language-none"><code class="language-none">index_generator:  path: ''  per_page: 10  order_by:    top: -1    date: -1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="5-Hexo-实现私密文章加密"><a href="#5-Hexo-实现私密文章加密" class="headerlink" title="5.Hexo 实现私密文章加密"></a>5.Hexo 实现私密文章加密</h1><pre class="line-numbers language-none"><code class="language-none">cd /Hexonpm install hexo-blog-encryptvim /Hexo/_config.yml  添加如下内容# Security## 文章加密 hexo-blog-encryptencrypt:    enable: true然后在想加密的文章头部添加上对应字段，如---title: hello worlddate: 2016-03-30 21:18:02   tags:       password: 12345   （密码）abstract: Welcome to my blog, enter password to read. message: Welcome to my blog, enter password to read.     ---password: 是该博客加密使用的密码abstract: 是该博客的摘要，会显示在博客的列表页message: 这个是博客查看时，密码输入框上面的描述性文字<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="6-增加不蒜子统计"><a href="#6-增加不蒜子统计" class="headerlink" title="6.增加不蒜子统计"></a>6.增加不蒜子统计</h1><p>利用这个统计，可以知道你博客的访问量</p><h2 id="6-1安装不蒜子脚本"><a href="#6-1安装不蒜子脚本" class="headerlink" title="6.1安装不蒜子脚本"></a>6.1安装不蒜子脚本</h2><p>在 themes\yilia\layout\ _partial\after-footer.ejs最后添加</p><pre class="line-numbers language-none"><code class="language-none">&lt;script  async  src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="6-2单篇文章点击量"><a href="#6-2单篇文章点击量" class="headerlink" title="6.2单篇文章点击量"></a>6.2单篇文章点击量</h2><p>在themes/yilia/layout/_partial/article.ejs中 在</p><pre class="line-numbers language-none"><code class="language-none">&lt;%- partial('post/title', {class_name: 'article-title'}) %&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>后面插入如下代码</p><pre class="line-numbers language-none"><code class="language-none">&lt;!--显示阅读次数--&gt;&lt;% if (!index &amp;&amp; post.comments){ %&gt;  &lt;br/&gt;  &lt;a class="cloud-tie-join-count" href="javascript:void(0);" style="color:gray;font-size:14px;"&gt;  &lt;span class="icon-sort"&gt;&lt;/span&gt;  &lt;span id="busuanzi_container_page_pv" style="color:#ef7522;font-size:14px;"&gt;            阅读数: &lt;span id="busuanzi_value_page_pv"&gt;&lt;/span&gt;次 &amp;nbsp;&amp;nbsp;  &lt;/span&gt;  &lt;/a&gt;&lt;% } %&gt;&lt;!--显示阅读次数完毕--&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="7-增加版权声明"><a href="#7-增加版权声明" class="headerlink" title="7.增加版权声明"></a>7.增加版权声明</h1><h2 id="7-1配置yilia"><a href="#7-1配置yilia" class="headerlink" title="7.1配置yilia"></a>7.1配置yilia</h2><p>在</p><pre class="line-numbers language-none"><code class="language-none">themes/yilia/layout/_partial/article.ejs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>中标注的位置添加代码</p><pre class="line-numbers language-none"><code class="language-none">&lt;div class="article-entry" itemprop="articleBody"&gt;  &lt;% if (post.excerpt &amp;&amp; index){ %&gt;    &lt;%- post.excerpt %&gt;    &lt;% if (theme.excerpt_link) { %&gt;      &lt;a class="article-more-a" href="&lt;%- url_for(post.path) %&gt;#more"&gt;&lt;%= theme.excerpt_link %&gt; &gt;&gt;&lt;/a&gt;    &lt;% } %&gt;  &lt;% } else { %&gt;    &lt;%- post.content %&gt;  &lt;% } %&gt;  &lt;-- 在此处添加代码--&gt;  &lt;% if ((theme.reward_type === 2 || (theme.reward_type === 1 &amp;&amp; post.reward)) &amp;&amp; !index){ %&gt;  &lt;div class="page-reward"&gt;    &lt;a href="javascript:;" class="page-reward-btn tooltip-top"&gt;    &lt;div class="tooltip tooltip-east"&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>添加的代码如下</p><pre class="line-numbers language-none"><code class="language-none">http://dongshuyan.com/2019/05/24/hexo%E5%8D%9A%E5%AE%A2%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/#20%E6%96%87%E7%AB%A0%E9%A1%B6%E9%83%A8%E8%BD%AC%E8%BD%BD%E8%AF%B4%E6%98%8E%EF%BC%88%E5%8E%9F%E5%88%9B%EF%BC%89<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建新文件</p><pre class="line-numbers language-none"><code class="language-none">themes/yilia/source-src/css/declare.scss<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>并添加如下CSS代码。</p><pre class="line-numbers language-none"><code class="language-none">.declare {    background-color: #eaeaea;    margin-top: 2em;    border-left: 3px solid #ff1700;    padding: .5em 1em;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为</p><pre class="line-numbers language-none"><code class="language-none">themes/yilia/source-src/css/main.scss<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>添加如下代码：</p><pre class="line-numbers language-none"><code class="language-none">@import "./declare";<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="7-2配置显示"><a href="#7-2配置显示" class="headerlink" title="7.2配置显示"></a>7.2配置显示</h2><p>修改为</p><pre class="line-numbers language-none"><code class="language-none">themes/yilia/_config.yml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在里面加入：</p><pre class="line-numbers language-none"><code class="language-none">#版权基础设定：0-关闭声明； 1-文章对应的md文件里有declare: true属性，才有版权声明； 2-所有文章均有版权声明#当前应用的版权协议地址。#版权协议的名称#版权协议的Logodeclare_type: 1licensee_url: https://creativecommons.org/licenses/by-nc-sa/4.0/licensee_name: '知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议'licensee_img: https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后在需要进行版权声明的文章的md文件头部，设置属性</p><pre class="line-numbers language-none"><code class="language-none">declare: true<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>即可。</p><h1 id="8-字数、阅读时长添加-失败"><a href="#8-字数、阅读时长添加-失败" class="headerlink" title="8.字数、阅读时长添加(失败)"></a>8.字数、阅读时长添加(失败)</h1><h2 id="8-1-安装hexo-wordcount-安装完就报错了-pass"><a href="#8-1-安装hexo-wordcount-安装完就报错了-pass" class="headerlink" title="8.1 安装hexo-wordcount 安装完就报错了 pass"></a>8.1 安装hexo-wordcount 安装完就报错了 pass</h2><p>在博客目录下打开terminal，输入命令</p><pre class="line-numbers language-none"><code class="language-none">npm i --save hexo-wordcount<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="9-鼠标点击小红心的设置"><a href="#9-鼠标点击小红心的设置" class="headerlink" title="9.鼠标点击小红心的设置"></a>9.鼠标点击小红心的设置</h1><p>在</p><pre class="line-numbers language-none"><code class="language-none">hexo/themes/yilia/source<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>文件目录下添加</p><pre class="line-numbers language-none"><code class="language-none">love.js<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>文件。</p><pre class="line-numbers language-none"><code class="language-none">!function(e,t,a){function r(){for(var e=0;e&lt;s.length;e++)s[e].alpha&lt;=0?(t.body.removeChild(s[e].el),s.splice(e,1)):(s[e].y--,s[e].scale+=.004,s[e].alpha-=.013,s[e].el.style.cssText="left:"+s[e].x+"px;top:"+s[e].y+"px;opacity:"+s[e].alpha+";transform:scale("+s[e].scale+","+s[e].scale+") rotate(45deg);background:"+s[e].color+";z-index:99999");requestAnimationFrame(r)}function n(){var t="function"==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e){t&amp;&amp;t(),o(e)}}function o(e){var a=t.createElement("div");a.className="heart",s.push({el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:c()}),t.body.appendChild(a)}function i(e){var a=t.createElement("style");a.type="text/css";try{a.appendChild(t.createTextNode(e))}catch(t){a.styleSheet.cssText=e}t.getElementsByTagName("head")[0].appendChild(a)}function c(){return"rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")"}var s=[];e.requestAnimationFrame=e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e){setTimeout(e,1e3/60)},i(".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}"),n(),r()}(window,document);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在</p><pre class="line-numbers language-none"><code class="language-none">hexo/themes/yilia/layout/_partial/footer.ejs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>文件的最后， 添加以下代码：</p><pre class="line-numbers language-none"><code class="language-none">&lt;!--页面点击小红心--&gt;&lt;script type="text/javascript" src="/love.js"&gt;&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="10-文本结束并且与more无冲突"><a href="#10-文本结束并且与more无冲突" class="headerlink" title="10.文本结束并且与more无冲突"></a>10.文本结束并且与more无冲突</h1><p>打开</p><pre class="line-numbers language-none"><code class="language-none">yourblog\themes\yilia\layout\_partial<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>文件夹，并编辑</p><pre class="line-numbers language-none"><code class="language-none">article.ejs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>文件</p><p>并在这段代码：</p><pre class="line-numbers language-none"><code class="language-none">&lt;% if (!post.noDate){ %&gt;        &lt;%- partial('post/date', {class_name: 'archive-article-date', date_format: null}) %&gt;        &lt;% } %&gt;      &lt;/header&gt;    &lt;% } %&gt;    &lt;div class="article-entry" itemprop="articleBody"&gt;      &lt;% if (post.excerpt &amp;&amp; index){ %&gt;        &lt;%- post.excerpt %&gt;        &lt;% if (theme.excerpt_link) { %&gt;          &lt;a class="article-more-a" href="&lt;%- url_for(post.path) %&gt;#more"&gt;&lt;%= theme.excerpt_link %&gt; &gt;&gt;&lt;/a&gt;        &lt;% } %&gt;      &lt;% } else { %&gt;        &lt;%- post.content %&gt;      &lt;% } %&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>的下面添加：</p><pre class="line-numbers language-none"><code class="language-none">http://dongshuyan.com/2019/05/24/hexo%E5%8D%9A%E5%AE%A2%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/#20%E6%96%87%E7%AB%A0%E9%A1%B6%E9%83%A8%E8%BD%AC%E8%BD%BD%E8%AF%B4%E6%98%8E%EF%BC%88%E5%8E%9F%E5%88%9B%EF%BC%89<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后在</p><pre class="line-numbers language-none"><code class="language-none">\theme\yilia\_config.yml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>文件中找到合适位置添加</p><pre class="line-numbers language-none"><code class="language-none">#文章结束essayending_type: 1 #0关闭文章结束提示 2全开 1需要在文章开头加上 essayending: true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这里<br>0表示关闭文章结束提示<br>2表示全开<br>1表示需要在文章开头加上 essayending: true 才会开启文章结束提示</p><h1 id="11-404-页面"><a href="#11-404-页面" class="headerlink" title="11. 404 页面"></a>11. 404 页面</h1><p>直接在hexo/source文件夹里面加一个404.html</p><h1 id="12-Sitemap方式提交网页"><a href="#12-Sitemap方式提交网页" class="headerlink" title="12. Sitemap方式提交网页"></a>12. Sitemap方式提交网页</h1><p>在 Hexo 根目录打开命令行工具，执行以下命令：</p><pre class="line-numbers language-none"><code class="language-none">npm install hexo-generator-sitemap --savehexo cleanhexo g<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>查看</p><pre class="line-numbers language-none"><code class="language-none">{your_hexo_path}/public<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>文件夹，可以看到</p><pre class="line-numbers language-none"><code class="language-none">sitmap.xml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>文件。<br>sitemap 的初衷是给搜索引擎看的，为了提高搜索引擎对自己站点的收录效果，我们最好手动到 google 和百度等搜索引擎提交 sitemap.xml。</p><p>baidu提交网址：<a href="https://ziyuan.baidu.com/?castk=LTE=">https://ziyuan.baidu.com/?castk=LTE%3D</a></p><h1 id="13-百度自动推送方式提交网页"><a href="#13-百度自动推送方式提交网页" class="headerlink" title="13.百度自动推送方式提交网页"></a>13.百度自动推送方式提交网页</h1><p>在本机</p><pre class="line-numbers language-none"><code class="language-none">&lt;博客根目录&gt;/themes/yilia/layout/_partial<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>目录下打开article.ejs文件，定位到如下这段代码：</p><pre class="line-numbers language-none"><code class="language-none">&lt;%        var sUrl = url.replace(/index\.html$/, '');        sUrl = /^(http:|https:)\/\//.test(sUrl) ? sUrl : 'https:' + sUrl;      %&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在它前面加上：</p><pre class="line-numbers language-none"><code class="language-none">&lt;!- 百度自动推送方式提交 --&gt;&lt;% if (1){ %&gt;  &lt;script&gt;  (function(){      var bp = document.createElement('script');      var curProtocol = window.location.protocol.split(':')[0];      if (curProtocol === 'https') {          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';      }      else {          bp.src = 'http://push.zhanzhang.baidu.com/push.js';      }      var s = document.getElementsByTagName("script")[0];      s.parentNode.insertBefore(bp, s);  })();  &lt;/script&gt;&lt;% } %&gt;&lt;!- 百度自动推送方式提交结束 --&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>即完成了新增博客文章页面（不包括其他页面）的自动推送方式提交。</p><h1 id="14-Hexo添加百度统计"><a href="#14-Hexo添加百度统计" class="headerlink" title="14.Hexo添加百度统计"></a>14.Hexo添加百度统计</h1><p>打开</p><pre class="line-numbers language-none"><code class="language-none">themes/yilia/layout/_partial/baidu-analytics.ejs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将你在百度统计里面得到的代码粘进去</p><p>然后打开</p><pre class="line-numbers language-none"><code class="language-none">themes/yilia/_config.yml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>里面</p><pre class="line-numbers language-none"><code class="language-none">baidu_analytics: ''<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>改为</p><pre class="line-numbers language-none"><code class="language-none">baidu_analytics: 'true'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="15链接提交"><a href="#15链接提交" class="headerlink" title="15链接提交"></a>15链接提交</h1><p>百度站长平台的链接提交方式分为自动提交和手动提交两种，此处只讲自动提交，手动提交按照要求操作即可。</p><h2 id="15-1-主动推送"><a href="#15-1-主动推送" class="headerlink" title="15.1 主动推送"></a>15.1 主动推送</h2><p>主动推送最为快速的提交方式，是被百度收录最快的推送方式。主动推送可以通过安装插件实现：</p><h3 id="15-1-1首先安装插件："><a href="#15-1-1首先安装插件：" class="headerlink" title="15.1.1首先安装插件："></a>15.1.1首先安装插件：</h3><pre class="line-numbers language-none"><code class="language-none">npm install hexo-baidu-url-submit --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改站点根目录下的配置文件_config.yml，添加以下内容：</p><pre class="line-numbers language-none"><code class="language-none">baidu_url_submit:  count: 20 ## 提交最新的20个链接  host: www.dongshuyan.com ## 百度站长平台中注册的域名  token:  ## 16位准入秘钥  path: baidu_urls.txt ## 文本文档的地址， 新链接会保存在此文本文档里<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="15-1-2准入秘钥获取"><a href="#15-1-2准入秘钥获取" class="headerlink" title="15.1.2准入秘钥获取"></a>15.1.2准入秘钥获取</h3><p>在如下图的网址中：<br><img src="https://mubu.com/document_image/e8d810a8-af7b-40ce-8a7d-1db0e61a8a14-3316715.jpg" alt="img"><br>下拉，找到这里：<br><img src="https://mubu.com/document_image/a94c8872-d402-4ce3-afc2-ea2705e95aeb-3316715.jpg" alt="img"><br>点击进去就是准入秘钥。</p><h3 id="15-1-3-检查"><a href="#15-1-3-检查" class="headerlink" title="15.1.3 检查"></a>15.1.3 检查</h3><p>其次，记得查看根目录下的_config.yml文件中url的值， 必须包含是百度站长平台注册的域名， 比如:</p><pre class="line-numbers language-none"><code class="language-none"># URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://dongshuyan.comroot: /permalink: :year/:month/:day/:title/permalink_defaults:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="最后，加入新的deployer"><a href="#最后，加入新的deployer" class="headerlink" title="最后，加入新的deployer"></a>最后，加入新的deployer</h3><p>最后，加入新的deployer:</p><pre class="line-numbers language-none"><code class="language-none">deploy:- type: git ## 这是我原来的deployer  repo:  branch:- type: baidu_url_submitter ## 添加这里内容即可<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里的”-“,必不可少！ 否则报错。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>其主动推送的实现原理如下：<br>新链接的产生， hexo generate 会产生一个文本文件，里面包含最新的链接<br>新链接的提交， hexo deploy 会从上述文件中读取链接，提交至百度搜索引擎</p><h2 id="15-2-自动推送"><a href="#15-2-自动推送" class="headerlink" title="15.2 自动推送"></a>15.2 自动推送</h2><p>安装自动推送JS代码的网页，在页面被访问时，页面URL将立即被推送给百度。</p><p>修改主题目录下的layout/post.ejs文件，末尾添加自动推送代码，代码如下：</p><pre class="line-numbers language-none"><code class="language-none">&lt;script&gt;(function(){    var bp = document.createElement('script');    var curProtocol = window.location.protocol.split(':')[0];    if (curProtocol === 'https') {        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';    }    else {        bp.src = 'http://push.zhanzhang.baidu.com/push.js';    }    var s = document.getElementsByTagName("script")[0];    s.parentNode.insertBefore(bp, s);})();&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="16-google收录"><a href="#16-google收录" class="headerlink" title="16 google收录"></a>16 google收录</h1><p><a href="https://www.google.com/webmasters/#?modal_active=none">网址</a><br>这里我选择的是右边的里面的html方式，把下载下来的网页放进根目录下的source文件夹里，然后</p><pre class="line-numbers language-none"><code class="language-none">hexo cleanhexo ghexo d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>不过google验证非常慢，我等了好几天，才验证成功。</p><p>验证成功之后，进去提交sitemap即可：<br><img src="https://mubu.com/document_image/02f8de29-192e-4dee-a35d-9c243bd41f1d-3316715.jpg" alt="img"></p><h1 id="17-Valine评论系统进阶"><a href="#17-Valine评论系统进阶" class="headerlink" title="17 Valine评论系统进阶"></a>17 Valine评论系统进阶</h1><h2 id="17-0-添加Valine评论"><a href="#17-0-添加Valine评论" class="headerlink" title="17.0 添加Valine评论"></a>17.0 添加Valine评论</h2><p>1.注册<br><a href="https://leancloud.cn/dashboard/login.html#/signup">点击这里登录或注册Leancloud</a><br>2.创建评论项目<br><a href="https://leancloud.cn/dashboard/applist.html#/newapp">点这里创建应用，应用名看个人喜好</a><br>3.找到key<br>选择刚刚创建的应用&gt;设置&gt;选择应用 Key，然后你就能看到你的APP ID和APP KEY了<br>4设置中的Web 安全域名<br>为了您的数据安全，请填写应用&gt;设置&gt;安全设置中的Web安全域名，例如：</p><pre class="line-numbers language-none"><code class="language-none">http://dongshuyan.comhttp://dongshuyan.github.iohttps://dongshuyan.comhttps://dongshuyan.github.io<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>5.修改主题配置<br>5.1首先在</p><pre class="line-numbers language-none"><code class="language-none">theme/yilia/_partial/article.ejs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>的最末尾加上</p><pre class="line-numbers language-none"><code class="language-none">&lt;% if ((theme.valine_type === 2 || (theme.valine_type === 1 &amp;&amp; post.valineenbale)) &amp;&amp; !index){ %&gt;  &lt;% if (theme.valine &amp;&amp; theme.valine.appid &amp;&amp; theme.valine.appkey){ %&gt;      &lt;section id="comments" class="comments"&gt;        &lt;style&gt;          .comments{margin:30px;padding:10px;background:#fff}          @media screen and (max-width:800px){.comments{margin:auto;padding:10px;background:#fff}}        &lt;/style&gt;        &lt;%- partial('post/valine', {          key: post.slug,          title: post.title,          url: config.url+url_for(post.path)          }) %&gt;    &lt;/section&gt;  &lt;% } %&gt;&lt;% } %&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>5.2然后在</p><pre class="line-numbers language-none"><code class="language-none">theme/yilia/_config.yml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>中找位置加入</p><pre class="line-numbers language-none"><code class="language-none">#6、Valine https://valine.js.orgvaline_type: 1 #0 关闭评论  2全开评论  1需要再文章md开头加入valineenbale:truevaline:  enable: true appid:  你在注册时候得到的id appkey:  你在注册时候得到的key verify: true #验证码 notify: true #评论回复提醒 avatar:  identicon #评论列表头像样式：''/mm/identicon/monsterid/wavatar/retro/hide placeholder: ヾﾉ≧∀≦)o来啊，快活啊!  guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果你的valine_type: 也是1，那么然后就需要在你文章抬头加上</p><pre class="line-numbers language-none"><code class="language-none">valineenbale:true<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="17-1-管理评论系统"><a href="#17-1-管理评论系统" class="headerlink" title="17.1 管理评论系统"></a>17.1 管理评论系统</h2><p><a href="https://leancloud.cn/">Valine管理界面</a><br>选择你的项目-存储-数据-Comment<br>在这里你就可以尽情地管理你的评论数据了。</p><p>据说有进阶版，不过我暂时还没有尝试，有兴趣的可以去看看教程：<br><a href="https://deserts.io/diy-a-comment-system/#%E8%AF%84%E8%AE%BA%E5%AE%89%E8%A3%85">Valine: 独立博客评论系统</a><br><a href="https://deserts.io/valine-admin-document/">Valine Admin 配置手册</a><br><a href="https://github.com/xCss/Valine/issues">github_Valine</a></p><h2 id="17-2-评论邮件通知（测试失败不知道为什么😂）"><a href="#17-2-评论邮件通知（测试失败不知道为什么😂）" class="headerlink" title="17.2 评论邮件通知（测试失败不知道为什么😂）"></a>17.2 评论邮件通知（测试失败不知道为什么😂）</h2><p>如果要开启email通知要将LeanCloud -&gt; 设置 -&gt; 邮件模板 -&gt; 用于重置密码的邮件主题进行修改<br>原来的是这样：</p><blockquote><p>用于重置密码的邮件主题</p><pre class="line-numbers language-none"><code class="language-none">重设 {{appname}} 的密码<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>内容</p><pre class="line-numbers language-none"><code class="language-none">&lt;p&gt;Hi, {{username}}&lt;/p&gt;&lt;p&gt;您请求重设应用 {{appname}} 的密码。点击下列链接来重设您的帐号密码（链接在 48 小时内有效）：&lt;/p&gt;&lt;p&gt;&lt;a href="{{link}}" target="_blank"&gt;{{link}}&lt;/a&gt;&lt;/p&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>自定义重置密码页面</p><pre class="line-numbers language-none"><code class="language-none">https://leancloud.cn/reset.html<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们把它改成这样：</p><blockquote><p>用于重置密码的邮件主题</p><pre class="line-numbers language-none"><code class="language-none">你在{{appname}} 的评论收到了新的回复<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>内容</p><pre class="line-numbers language-none"><code class="language-none">&lt;p&gt;Hi, {{username}}&lt;/p&gt;&lt;p&gt;你在 {{appname}} 的评论收到了新的回复，请点击查看：&lt;/p&gt;&lt;p&gt;&lt;a href="你的网址首页链接" style="display: inline-block; padding: 10px 20px; border-radius: 4px; background-color: #3090e4; color: #fff; text-decoration: none;"&gt;马上查看&lt;/a&gt;&lt;/p&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后在你本地博客 themes/yilia/_config.yml里面进行修改：把验证码和评论回复打开即可</p><pre class="line-numbers language-none"><code class="language-none">verify: true #验证码notify: true #评论回复提醒<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="17-3-CDN修改"><a href="#17-3-CDN修改" class="headerlink" title="17.3 CDN修改"></a>17.3 CDN修改</h2><p>建议将自带的CDN改成第三方CDN，为啥？？？10+s的加载那酸爽是在是过瘾。<br>文件目录：themes/yilia/layout/_partial/post/valine.ejs</p><pre class="line-numbers language-none"><code class="language-none">//cdn.jsdelivr.net/npm/valine/dist/Valine.min.js<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>官方的CDN是</p><pre class="line-numbers language-none"><code class="language-none">//unpkg.com/valine/dist/Valine.min.js<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="17-4-云引擎"><a href="#17-4-云引擎" class="headerlink" title="17.4 云引擎"></a>17.4 云引擎</h2><p>1.首先要在github上面新建一个项目，可以起名”Valine-Admin”<br>2.在leancloud中 云引擎 -&gt; 设置中找<br>2.1把你的github链接帖进去,例如：</p><pre class="line-numbers language-none"><code class="language-none">https://github.com/dongshuyan/Valine-Admin.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2.2复制出来Deploy Key<br>2.3在你github的这个项目里面的“settings”里面的“Deploy keys”添加这个Deploy key。<br>3.部署<br>剩下的有时间再搞吧，参考链接：<br><a href="https://github.com/DesertsP/Valine-Admin">DesertsP/Valine-Admin</a><br><a href="https://deserts.io/valine-admin-document/">Valine Admin 配置手册</a></p><h1 id="18添加板娘-有点占地方还是不要了"><a href="#18添加板娘-有点占地方还是不要了" class="headerlink" title="18添加板娘(有点占地方还是不要了)"></a>18添加板娘(有点占地方还是不要了)</h1><p>虽然我没有成功不过从<a href="https://ziven.cc/">Ziven</a>的主页来看，板娘在yilia是可以成功的。<br>可以参考:<br><a href="https://blog.csdn.net/Aoman_Hao/article/details/82049821">Hexo博客yilia主题首页添加helper-live2d模型插件</a><br><a href="https://qianlei6148.github.io/2018/10/11/hexo%E6%A8%A1%E7%89%88yilia%E6%B7%BB%E5%8A%A0%E5%8F%AF%E7%88%B1%E7%9A%84%E7%9C%8B%E6%9D%BF%E5%A8%98/">hexo模版yilia添加可爱的看板娘</a><br>1.博客根目录下安装（还是看上面的文档吧）</p><pre class="line-numbers language-none"><code class="language-none">npm install hexo-helper-live2d --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2.配置<br>打开根目录下的_config.yml文件,添加以下代码：</p><pre class="line-numbers language-none"><code class="language-none">live2d:  enable: true  scriptFrom: local  pluginRootPath: live2dw/  pluginJsPath: lib/  pluginModelPath: assets/  tagMode: false  log: false  model:    use: live2d-widget-model-z16  display:    position: left    width: 100    height: 200    hOffset: -10    vOffset: 40  mobile:    show: false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="下载更多模型"><a href="#下载更多模型" class="headerlink" title="下载更多模型"></a>下载更多模型</h2><p><a href="https://github.com/dongshuyan/live2dDemo">更多模型</a></p><p>把github模型下载到本地，解压后将assets目录拷贝到博客根目录中的live2d_models（自己新建，文件名不可改）里，再修改_config.yml 里的live2d中model.use即可（改为live2d_models中的模型名字就行）。<br><img src="https://mubu.com/document_image/64ef2c18-ea8b-46e2-bf96-052dbf875c92-3316715.jpg" alt="img"></p><h1 id="19刚发现一个标签的bug"><a href="#19刚发现一个标签的bug" class="headerlink" title="19刚发现一个标签的bug"></a>19刚发现一个标签的bug</h1><p>如果我一个标签A是B的前缀，那么搜索标签A的时候，属于标签B的文章也会被搜索出来。<br>举例，我有一个标签叫“Mac”还有一个标签叫“machine learning”<br>搜索“Mac”的时候属于“machine learning”的文章也会被搜出来。😂</p><h1 id="20文章顶部转载说明（原创）"><a href="#20文章顶部转载说明（原创）" class="headerlink" title="20文章顶部转载说明（原创）"></a>20文章顶部转载说明（原创）</h1><h2 id="20-1配置yilia主题文件"><a href="#20-1配置yilia主题文件" class="headerlink" title="20.1配置yilia主题文件"></a>20.1配置yilia主题文件</h2><p>在</p><pre class="line-numbers language-none"><code class="language-none">themes/yilia/layout/_partial/article.ejs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>中下面标注的位置添加代码</p><pre class="line-numbers language-none"><code class="language-none">&lt;% if (!post.noDate){ %&gt;        &lt;%- partial('post/date', {class_name: 'archive-article-date', date_format: null}) %&gt;        &lt;% } %&gt;      &lt;/header&gt;    &lt;% } %&gt;    &lt;div class="article-entry" itemprop="articleBody"&gt;    &lt;!--在这里添加新代码--&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>添加的代码如下</p><pre class="line-numbers language-none"><code class="language-none">&lt;!-- 文章头增加转载声明 --&gt;      &lt;%        var sUrl = url.replace(/index\.html$/, '');        sUrl = /^(http:|https:)\/\//.test(sUrl) ? sUrl : 'https:' + sUrl;      %&gt;      &lt;% if ((theme.topdeclare_type === 2 || (theme.topdeclare_type === 1 &amp;&amp; post.topdeclare)) &amp;&amp; !index){ %&gt;        &lt;div class="topdeclare"&gt;           &lt;hr&gt;          &lt;strong&gt;如需转载，请根据&lt;/strong&gt;          &lt;a rel="license" href="&lt;%= theme.toplicensee_url%&gt;"&gt;&lt;%= theme.toplicensee_name%&gt;&lt;/a&gt;          许可，附上本文作者及链接。          &lt;br&gt;          &lt;strong&gt;本文作者：&lt;/strong&gt;          &lt;% if(config.author != undefined){ %&gt;            &lt;%= config.author%&gt;          &lt;% }else{%&gt;            &lt;font color="red"&gt;请在博客根目录“_config.yml”中填入正确的“author”&lt;/font&gt;          &lt;%}%&gt;          &lt;br&gt;          &lt;strong&gt;作者昵称：&lt;/strong&gt;          &lt;% if(theme.topnickname!= undefined){ %&gt;            &lt;%= theme.topnickname%&gt;          &lt;% }else{%&gt;            &lt;font color="red"&gt;请在博客主题目录“_config.yml”中填入正确的“昵称”&lt;/font&gt;          &lt;%}%&gt;          &lt;br&gt;          &lt;strong&gt;本文链接：&lt;/strong&gt;          &lt;a rel="license" href="&lt;%=sUrl%&gt;"&gt;&lt;%=sUrl%&gt;&lt;/a&gt;          &lt;br&gt;          &lt;hr&gt;        &lt;/div&gt;      &lt;% } else {%&gt;        &lt;div class="topdeclare" hidden="hidden"&gt;&lt;/div&gt;      &lt;% } %&gt;            &lt;!-- 文章头增加转载声明结束 --&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建新文件</p><pre class="line-numbers language-none"><code class="language-none">themes/yilia/source-src/css/topdeclare.scss<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>并添加如下CSS代码。</p><pre class="line-numbers language-none"><code class="language-none">.declare {    background-color: #eaeaea;    margin-top: 2em;    border-left: 3px solid #ff1700;    padding: .5em 1em;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为</p><pre class="line-numbers language-none"><code class="language-none">themes/yilia/source-src/css/main.scss<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>添加如下代码：</p><pre class="line-numbers language-none"><code class="language-none">@import "./topdeclare";<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="20-2配置显示"><a href="#20-2配置显示" class="headerlink" title="20.2配置显示"></a>20.2配置显示</h2><p>修改为</p><pre class="line-numbers language-none"><code class="language-none">themes/yilia/_config.yml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在里面加入：</p><pre class="line-numbers language-none"><code class="language-none">#顶部版权基础设定：0-关闭声明； 1-文章对应的md文件里有topdeclare: true属性，才有版权声明； 2-所有文章均有版权声明#当前应用的版权协议地址。#昵称#版权协议的名称topdeclare_type: 1toplicensee_url: https://creativecommons.org/licenses/by-nc-sa/4.0/topnickname: 莫与 #你的昵称toplicensee_name: '知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后在需要进行版权声明的文章的md文件头部，设置属性</p><pre class="line-numbers language-none"><code class="language-none">topdeclare:true<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>即可。</p><h1 id="21-google广告"><a href="#21-google广告" class="headerlink" title="21 google广告"></a>21 google广告</h1><h2 id="21-1-前提条件"><a href="#21-1-前提条件" class="headerlink" title="21.1 前提条件"></a>21.1 前提条件</h2><p>1.首先你得有个网站<br>2.然后你得有几篇文章 最好是原创的<br>3.有一个google账户<br>4.<strong>你的google账户必须设置过生日，没设置的赶紧先把生日设置好</strong>（我估计可能是限制未成年人吧）</p><p>如果你达成以上条件 那么我们可以开始了</p><h2 id="21-2-注册-Google-Adsense"><a href="#21-2-注册-Google-Adsense" class="headerlink" title="21.2 注册 Google Adsense"></a>21.2 注册 Google Adsense</h2><p>去google Adsense官网即可，链接如下：<br><a href="https://www.google.com/adsense/">google Adsense官网</a></p><blockquote><p>ps.这个网站打开是真的慢</p></blockquote><p>打开网站之后就可以开始注册了（即使你有google账户也要注册！）<br>1.官网点击注册（sign up）,进入注册页面<br>2.在注册页面填写你的信息（网站地址不可以是二级域名）<br>3.在之后填写你的地址信息<br>4.地址信息填完毕之后会给你一串代码，类似如下：</p><pre class="line-numbers language-none"><code class="language-none">&lt;script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"&gt;&lt;/script&gt;&lt;script&gt;  (adsbygoogle = window.adsbygoogle || []).push({    google_ad_client: "ca-pub-8955547868703063",    enable_page_level_ads: true  });&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>5.把这一串代码放在</p><pre class="line-numbers language-none"><code class="language-none">博客目录\themes\yilia\layout\_partial\head.ejs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>文件的</p><pre class="line-numbers language-none"><code class="language-none">&lt;head&gt;与&lt;/head&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之间,然后在命令行里</p><pre class="line-numbers language-none"><code class="language-none">hexo cleanhexo ghexo d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>将网站同步好<br>6.同步好之后返回Google Adsense点击已经粘贴代码。<br>google从网站检测到这段代码即可，等待启动即可。</p><h2 id="21-3-审核通过"><a href="#21-3-审核通过" class="headerlink" title="21.3 审核通过"></a>21.3 审核通过</h2><p>稍等一天时间，如果没有问题，即可审核通过。<br>有问题就改问题，然后在申请。</p><h2 id="21-4-添加展示广告"><a href="#21-4-添加展示广告" class="headerlink" title="21.4 添加展示广告"></a>21.4 添加展示广告</h2><p>1.在网页上找到“广告” -&gt; “广告单元” -&gt; “创建新的广告单元” -&gt; “展示广告”<br>2.然后再界面里面先填写一个名字(例如ad_google_1)<br>3.点击创建<br>4.将生成的代码添加到</p><pre class="line-numbers language-none"><code class="language-none">博客目录\themes\yilia\layout\_partial\article.ejs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>中对应适当位置即可，注意别让广告扰乱了页面布局，影响全局美感。<br>添加代码如下：</p><pre class="line-numbers language-none"><code class="language-none">可以在文章开头添加：    &lt;!--文章头google图片--&gt;    &lt;% if ((theme.googlead_type === 2 || (theme.googlead_type === 1 &amp;&amp; post.googlead)) &amp;&amp; !index){ %&gt;        &lt;hr&gt;        &lt;strong&gt;⬇️下面这个看起来像广告的东西，其实是只个图片，根本打不开的。不过听说有时候⬇️&lt;/strong&gt;        &lt;br&gt;        &lt;script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"&gt;&lt;/script&gt;        &lt;!-- googlead1 --&gt;        &lt;ins class="adsbygoogle"             style="display:block"             data-ad-client="ca-pub-8955547868703063"             data-ad-slot="3853918361"             data-ad-format="auto"             data-full-width-responsive="true"&gt;&lt;/ins&gt;        &lt;script&gt;             (adsbygoogle = window.adsbygoogle || []).push({});        &lt;/script&gt;    &lt;% } %&gt;    &lt;!--文章头google图片结束--&gt;可以在结尾处添加：&lt;!-- 尾google广告 --&gt;      &lt;% if ((theme.googlead_type === 2 || (theme.googlead_type === 1 &amp;&amp; post.googlead)) &amp;&amp; !index){ %&gt;          &lt;hr&gt;          &lt;strong&gt;⬇️下面这个才是真正的广告哦，如果感觉真的从文章中有带走新东西的话，可以帮我点一下哦⬇️&lt;/strong&gt;        &lt;br&gt;          这里是google网页生成的代码      &lt;% } %&gt;&lt;!-- 尾google广告 --&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后还需要再</p><pre class="line-numbers language-none"><code class="language-none">/theme/yilia/_config.yml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>中合适位置添加</p><pre class="line-numbers language-none"><code class="language-none">#google广告基础设定：0-关闭广告； 1-文章对应的md文件里有googlead: true属性，才有广告； 2-所有文章均有广告googlead_type: 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使用教程如上面提示：<br>0-关闭广告；<br>1-文章对应的md文件里有googlead: true属性，才有广告；<br>2-所有文章均有广告</p><p>5.添加完毕<br>在网页中点击“大功告成”<br>6.想网页上传<br>hexo clean<br>hexo g<br>hexo d<br>7.等待一小时左右大约会出现广告</p><h1 id="22-Gitment-x2F-Gitalk评论系统"><a href="#22-Gitment-x2F-Gitalk评论系统" class="headerlink" title="22 Gitment/Gitalk评论系统"></a>22 Gitment/Gitalk评论系统</h1><p>感觉gitment 和 gitalk也不错<br>可以参考<br><a href="https://ziven.cc/2018/07/03/Hexo%E4%B8%BB%E9%A2%98yilia%E5%A2%9E%E5%8A%A0gitalk%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6/">Hexo主题yilia增加gitalk评论插件</a><br><a href="https://cloudy-liu.github.io/2018/07/14/Hexo%E6%9B%B4%E6%8D%A2%E4%B8%BAGitTalk%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/">Hexo-yilia使用gitment/gitalk评论系统</a><br><a href="https://zhuanlan.zhihu.com/p/58722547">Gitment给基于hexo的yilia主题的博客搭建免费评论系统</a></p><p>自己配置了一下gitalk</p><h2 id="22-1-注册-OAuth-Application"><a href="#22-1-注册-OAuth-Application" class="headerlink" title="22.1 注册 OAuth Application"></a>22.1 注册 OAuth Application</h2><p>注册网址：<a href="https://github.com/settings/applications/new">https://github.com/settings/applications/new</a></p><pre class="line-numbers language-none"><code class="language-none">Application nameDongBlogCommentsSomething users will recognize and trust.Homepage URLhttps://dongshuyan.github.io/The full URL to your application homepage.Application descriptionShuyan's BlogThis is displayed to all users of your application.Authorization callback URLhttp://dongshuyan.com/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注册成功后，会获取到 Client ID/scerct 。</p><h2 id="22-2配置"><a href="#22-2配置" class="headerlink" title="22.2配置"></a>22.2配置</h2><pre class="line-numbers language-none"><code class="language-none">layout/_partial/post目录下新增gitalk.ejs文件&lt;div id="gitalk-container" style="padding: 0px 30px 0px 30px;"&gt;&lt;/div&gt; &lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"&gt;&lt;script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt;if(&lt;%=theme.gitalk.enable%&gt;){  var gitalk = new Gitalk({    clientID: '&lt;%=theme.gitalk.ClientID%&gt;',    clientSecret: '&lt;%=theme.gitalk.ClientSecret%&gt;',    repo: '&lt;%=theme.gitalk.repo%&gt;',    owner: '&lt;%=theme.gitalk.githubID%&gt;',    admin: ['&lt;%=theme.gitalk.adminUser%&gt;'],    id: '&lt;%= page.date %&gt;',    distractionFreeMode: '&lt;%=theme.gitalk.distractionFreeMode%&gt;'})gitalk.render('gitalk-container') }&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改source-src/css/目录下comment.scss文件</p><pre class="line-numbers language-none"><code class="language-none">disqus_thread, .duoshuo, .cloud-tie-wrapper, #SOHUCS, #gitment-ctn, #gitalk-container {  padding: 0 30px !important;  min-height: 20px;}#SOHUCS {  #SOHU_MAIN .module-cmt-list .block-cont-gw {    border-bottom: 1px dashed #c8c8c8 !important;  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在</p><pre class="line-numbers language-none"><code class="language-none">layout/_partial<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>目录下的article.ejs文件内新增gitalk相关的配置代码：</p><pre class="line-numbers language-none"><code class="language-none">&lt;% if(theme.gitalk.enable){ %&gt;  &lt;%- partial('post/gitalk', {      key: post.slug,      title: post.title,      url: config.url+url_for(post.path)    }) %&gt;  &lt;% } %&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后在yilia主题配置文件中新增gitalk相关的配置：</p><pre class="line-numbers language-none"><code class="language-none">gitalk:  enable:  true  githubID:  'dongshuyan'     repo:  'DongBlogComments' #这里可以另开一个也可以就用你博客的那个repo  ClientID:  '刚才得到的code'  ClientSecret:  '刚才得到的code'  adminUser:  'dongshuyan'   distractionFreeMode: true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>踩坑教程：<br><a href="https://www.jianshu.com/p/57afa4844aaa">Gitment评论功能接入踩坑教程</a><br>[<a href="https://blog.csdn.net/w47_csdn/article/details/88858343">gitalk] 解决配置gitalk插件后初始化登录时跳转回首页</a><br><a href="https://github.com/gitalk/gitalk/issues/162">登录报错/?error=redirect_uri_mismatch&amp; #162</a></p><h1 id="23-tag中含有大写字母的bug"><a href="#23-tag中含有大写字母的bug" class="headerlink" title="23.tag中含有大写字母的bug"></a>23.tag中含有大写字母的bug</h1><p>总之tag别用大写字母！！！</p><h1 id="24-hexo-d上传失败"><a href="#24-hexo-d上传失败" class="headerlink" title="24 hexo d上传失败"></a>24 hexo d上传失败</h1><p>显示：</p><pre class="line-numbers language-none"><code class="language-none">INFO  Deploying: gitINFO  Clearing .deploy_git folder...INFO  Copying files from public folder...INFO  Copying files from extend dirs...On branch masternothing to commit, working tree cleanEnumerating objects: 396, done.Counting objects: 100% (396/396), done.Delta compression using up to 8 threadsCompressing objects: 100% (144/144), done.error: RPC failed; curl 56 LibreSSL SSL_read: SSL_ERROR_SYSCALL, errno 60fatal: the remote end hung up unexpectedlyWriting objects: 100% (235/235), 2.31 MiB | 14.00 KiB/s, done.Total 235 (delta 104), reused 0 (delta 0)fatal: the remote end hung up unexpectedlyEverything up-to-dateFATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlError: Spawn failed    at ChildProcess.&lt;anonymous&gt; (/Users/moyu/Desktop/learn/blog_new/node_modules/hexo-util/lib/spawn.js:52:19)    at emitTwo (events.js:126:13)    at ChildProcess.emit (events.js:214:7)    at Process.ChildProcess._handle.onexit (internal/child_process.js:198:12)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我这里是网络代理问题。</p><h1 id="25-跳转到指定位置"><a href="#25-跳转到指定位置" class="headerlink" title="25 跳转到指定位置"></a>25 跳转到指定位置</h1><p>html里面加上</p><pre class="line-numbers language-none"><code class="language-none">&lt;a name="printcenter1"&gt;&lt;/a&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后跳转xx.html#printcenter1</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.jianshu.com/p/bdd1239863de">Hexo文章置顶的方法</a><br><a href="https://blog.csdn.net/adobeid/article/details/82704982">Hexo增加置顶属性</a><br><a href="https://www.jianshu.com/p/adb7640c97c2">Hexo 基于yilia主题及其它插件优化</a><br><a href="https://blog.csdn.net/lynnbest/article/details/79845944">Hexo yilia 主题一揽子使用方案</a><br><a href="https://blog.zscself.com/posts/ee4d9ecb/">在Hexo中自动为Yilia主题增加版权声明</a><br><a href="https://blog.csdn.net/dta0502/article/details/89607895">Hexo-Yilia进阶笔记</a><br><a href="http://lawlite.me/2017/04/17/Hexo-yilia%E4%B8%BB%E9%A2%98%E5%AE%9E%E7%8E%B0%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95%E5%92%8C%E6%B7%BB%E5%8A%A0%E8%A7%86%E9%A2%91/#%E4%BA%8C%E3%80%81%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95%E5%8A%9F%E8%83%BD">Hexo+yilia主题实现文章目录和添加视频</a><br><a href="https://www.jianshu.com/p/f054333ac9e6">hexo的next主题个性化教程:打造炫酷网站</a><br><a href="https://gzx97.com/posts/20223/">Hexo博客Yilia主题修改记录</a><br><a href="https://blog.diqigan.cn/posts/hexo-theme-yilia-advanced-settings.html">Hexo Yilia 主题进阶配置</a><br><a href="https://zhuanlan.zhihu.com/p/28468742">Hexo博客提交百度和Google收录</a><br><a href="https://github.com/DesertsP/Valine-Admin">DesertsP/Valine-Admin</a><br><a href="https://deserts.io/valine-admin-document/">Valine Admin 配置手册</a><br><a href="https://deserts.io/diy-a-comment-system/#%E8%AF%84%E8%AE%BA%E5%AE%89%E8%A3%85">Valine: 独立博客评论系统</a><br><a href="https://github.com/xCss/Valine/issues">github_Valine</a><br><a href="https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md">动态版娘</a><br><a href="http://www.yueluo.xyz/archives/a24869c4.html">Hexo-添加看板娘(进阶版)</a><br><a href="https://zhuanlan.zhihu.com/p/66052182">hexo yilia 主题添加 google 广告</a><br><a href="https://kurumi.ink/index.php/archives/51/">Google AdSense 申请日志及教程</a><br><a href="https://cloudy-liu.github.io/2018/07/14/Hexo%E6%9B%B4%E6%8D%A2%E4%B8%BAGitTalk%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/">Hexo-yilia使用gitment/gitalk评论系统</a><br><a href="https://zhuanlan.zhihu.com/p/58722547">Gitment给基于hexo的yilia主题的博客搭建免费评论系统</a><br><a href="https://blog.csdn.net/Aoman_Hao/article/details/82049821">Hexo博客yilia主题首页添加helper-live2d模型插件</a><br><a href="https://qianlei6148.github.io/2018/10/11/hexo%E6%A8%A1%E7%89%88yilia%E6%B7%BB%E5%8A%A0%E5%8F%AF%E7%88%B1%E7%9A%84%E7%9C%8B%E6%9D%BF%E5%A8%98/">hexo模版yilia添加可爱的看板娘</a><br><a href="https://www.jianshu.com/p/57afa4844aaa">Gitment评论功能接入踩坑教程</a><br>[<a href="https://blog.csdn.net/w47_csdn/article/details/88858343">gitalk] 解决配置gitalk插件后初始化登录时跳转回首页</a><br><a href="https://github.com/gitalk/gitalk/issues/162">登录报错/?error=redirect_uri_mismatch&amp; #162</a><br><a href="https://ziven.cc/2018/07/03/Hexo%E4%B8%BB%E9%A2%98yilia%E5%A2%9E%E5%8A%A0gitalk%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6/">Hexo主题yilia增加gitalk评论插件</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> yilia配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo模版yilia头像增加旋转效果</title>
      <link href="/archives/e48a9d1b.html"/>
      <url>/archives/e48a9d1b.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在<code>themes\yilia\source\</code>文件夹下<br>增加一个css文件<code>avatarrotation.css</code>用来旋转360度<br>内容如下：</p><pre class="line-numbers language-none"><code class="language-none">.left-col #header .profilepic img {/* 控制旋转速度时间*/  -webkit-transition: -webkit-transform 1.0s ease-out;  -moz-transition: -moz-transform 1.0s ease-out;  transition: transform 1.0s ease-out;}.left-col #header .profilepic img:hover {/* 鼠标经过360% */  -webkit-transform: rotateZ(360deg);  -moz-transform: rotateZ(360deg);  transform: rotateZ(360deg);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><span id="more"></span><p>然后在<code>themes\yilia\layout\_partial\head.ejs</code>文件中添加进去创建的<code>css</code>文件：<br>找到<code>&lt;%- partial('css') %&gt;</code>，在它的下面添加代码，把刚才写的文件添加进去，<strong>注意！！是在它的下面添加，不然旋转速度将不会生效</strong></p><pre class="line-numbers language-none"><code class="language-none">&lt;% if (theme.avatarrotation){ %&gt;&lt;link rel="stylesheet" type="text/css" href="/./avatarrotation.css"&gt;&lt;% } %&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果<code>css</code>不生效，查看<code>css</code>中的<code>href</code>位置是否写错了，可根据你具体存放的位置写路径。<br>最后在<code>主题文件_config.yml</code>中添加</p><pre class="line-numbers language-none"><code class="language-none">#头像是否旋转(如果不要旋转取false)avatarrotation: true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>最终就可以旋转了！</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo相关</title>
      <link href="/archives/fbe1990d.html"/>
      <url>/archives/fbe1990d.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li><p>node_modules：文件夹中放依赖包</p></li><li><p>public：存放的是hexo根据source里的内容生成的页面</p></li><li><p>scaffolds：命令生成文章等的模板</p></li><li><p>source：用hexo命令创建的各种文章</p></li><li><p>themes：所下载的主题全放里面</p></li><li><p>_config.yml：整个博客站点的配置</p></li><li><p>db.json：source解析所得到的</p></li><li><p>package.json：项目所需模块项目的配置信息</p><span id="more"></span></li></ul><p>在<code>_config.yml</code>中添加配置, 部署到自己的GitHub网站上</p><pre class="line-numbers language-none"><code class="language-none">deploy:  type: git  repo: https://github.com/YourgithubName/YourgithubName.github.io.git  branch: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>常用hexo指令：<a href="https://hexo.io/zh-cn/docs/commands.html">（官网查看指令链接）</a></p></blockquote><p><code>hexo version</code>: 显示版本号<br><code>hexo init</code>: 初始化<br><code>hexo new &lt;title&gt;</code>: 新建文章(默认等同于<code>hexo new post &lt;title&gt;</code>)<br><code>hexo generate</code>或者<code>hexo g</code>: 静态文件生成<br><code>hexo publish</code>: 发布<br><code>hexo server</code>或者<code>hexo s</code>: 启动本地服务器<br><code>hexo deploy</code>或者<code>hexo d</code>: 自动生成静态文件并部署网站<br><code>hexo clean</code>: 清除缓存和已生成的静态文件(一般在更换主题或者修改没有生效的情况下)<br><code>hexo --safe/--debug/--slient</code>: 安全/调试/简洁模式<br><code>hexo new draft "&lt;title&gt;"</code>: 创建草稿，可以把不用的却不舍得删的文件已到这个目录下<br><code>hexo new tags "&lt;title&gt;"</code>: 创建标签<br><code>hexo new categories "&lt;title&gt;"</code>: 创建分类</p><blockquote><p>组合操作</p></blockquote><p><code>hexo deploy -g</code> 生成静态文件并部署网站<br><code>hexo server -g </code>生成静态文件并且启动本地服务器<br><code>hexo clean &amp;&amp; hexo s</code>: 清理并启动本地服务器<br><code>hexo clean &amp;&amp; hexo d</code>: 清理并部署网站</p><blockquote><p>标题、标签、分类</p></blockquote><p>在Markdown文件的开头添加</p><pre class="line-numbers language-none"><code class="language-none">---title: 标题category:  分类tags: 标签---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例子：</p><pre class="line-numbers language-none"><code class="language-none">---title: hexo相关date: 2018-09-29 13:05:30categories: [technology]tags: [hexo]---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果使用<code>hexo new</code>命令或者是用工具<code>hexoEdit.app</code>新建文章会自动生成上面的结构。<br><strong>（注：<a href="https://github.com/zhuzhuyule/HexoEditor">hexoEdit</a>是一款书写markdown的工具，在windows和mac上都有版本，这款工具内核是以<a href="https://moeditor.github.io/">moeditor</a>为基础改造成可以快速用于hexo blog。<br>在工具内的<code>设置</code>中配好<code>hexo配置文件</code>，<code>创建Post</code>就会创建hexo文章并把文件保存路径自动定位到hexo的目录中）</strong></p><p>多个标签的设置</p><p>方式一：仿照Hexo配置文件中的写法</p><pre class="line-numbers language-none"><code class="language-none">tags:  - Hexo  - java  - JavaScript<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>方式二：数组写法</p><pre class="line-numbers language-none"><code class="language-none">tags: [前端,Hexo,HTML,JavaScript]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hashmap的hash（）方法</title>
      <link href="/archives/e4931122.html"/>
      <url>/archives/e4931122.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>你知道HashMap中hash方法的具体实现吗？你知道HashTable、ConcurrentHashMap中hash方法的实现以及原因吗？你知道为什么要这么实现吗？你知道为什么JDK 7和JDK 8中hash方法实现的不同以及区别吗？如果你不能很好的回答这些问题，那么你需要好好看看这篇文章。文中涉及到大量代码和计算机底层原理知识。绝对的干货满满。整个互联网，把hash()分析的如此透彻的，别无二家。</p><h3 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h3><p><strong>Hash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入，通过散列算法，变换成固定长度的输出，该输出就是散列值。</strong>这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</p><span id="more"></span><p>所有散列函数都有如下一个基本特性：<strong>根据同一散列函数计算出的散列值如果不同，那么输入值肯定也不同。但是，根据同一散列函数计算出的散列值如果相同，输入值不一定相同。</strong></p><p><strong>两个不同的输入值，根据同一散列函数计算出的散列值相同的现象叫做碰撞。</strong></p><p>常见的Hash函数有以下几个：</p><blockquote><p>直接定址法：直接以关键字k或者k加上某个常数（k+c）作为哈希地址。</p><p>数字分析法：提取关键字中取值比较均匀的数字作为哈希地址。</p><p>除留余数法：用关键字k除以某个不大于哈希表长度m的数p，将所得余数作为哈希表地址。</p><p>分段叠加法：按照哈希表地址位数将关键字分成位数相等的几部分，其中最后一部分可以比较短。然后将这几部分相加，舍弃最高进位后的结果就是该关键字的哈希地址。</p><p>平方取中法：如果关键字各个部分分布都不均匀的话，可以先求出它的平方值，然后按照需求取中间的几位作为哈希地址。</p><p>伪随机数法：采用一个伪随机数当作哈希函数。</p></blockquote><p>上面介绍过碰撞。衡量一个哈希函数的好坏的重要指标就是发生碰撞的概率以及发生碰撞的解决方案。任何哈希函数基本都无法彻底避免碰撞，常见的解决碰撞的方法有以下几种：</p><ul><li>开放定址法：<ul><li>开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。</li></ul></li><li>链地址法<ul><li>将哈希表的每个单元作为链表的头结点，所有哈希地址为i的元素构成一个同义词链表。即发生冲突时就把该关键字链在以该单元为头结点的链表的尾部。</li></ul></li><li>再哈希法<ul><li>当哈希地址发生冲突用其他的函数计算另一个哈希函数地址，直到冲突不再产生为止。</li></ul></li><li>建立公共溢出区<ul><li>将哈希表分为基本表和溢出表两部分，发生冲突的元素都放入溢出表中。</li></ul></li></ul><h3 id="HashMap-的数据结构"><a href="#HashMap-的数据结构" class="headerlink" title="HashMap 的数据结构"></a>HashMap 的数据结构</h3><p>在Java中，保存数据有两种比较简单的数据结构：数组和链表。<strong>数组的特点是：寻址容易，插入和删除困难；而链表的特点是：寻址困难，插入和删除容易。</strong>上面我们提到过，常用的哈希函数的冲突解决办法中有一种方法叫做链地址法，其实就是将数组和链表组合在一起，发挥了两者的优势，我们可以将其理解为链表的数组。</p><p><a href="http://www.hollischuang.com/wp-content/uploads/2018/03/640.png"><img src="http://www.hollischuang.com/wp-content/uploads/2018/03/640.png" alt="640"></a></p><p>我们可以从上图看到，左边很明显是个数组，数组的每个成员是一个链表。该数据结构所容纳的所有元素均包含一个指针，用于元素间的链接。我们根据元素的自身特征把元素分配到不同的链表中去，反过来我们也正是通过这些特征找到正确的链表，再从链表中找出正确的元素。其中，根据元素特征计算元素数组下标的方法就是哈希算法，即本文的主角hash()函数（当然，还包括indexOf()函数）。</p><h3 id="hash方法"><a href="#hash方法" class="headerlink" title="hash方法"></a>hash方法</h3><p>我们拿JDK 1.7的HashMap为例，其中定义了一个final int hash(Object k) 方法，其主要被以下方法引用。</p><p><a href="http://www.hollischuang.com/wp-content/uploads/2018/03/hash-use.png"><img src="http://www.hollischuang.com/wp-content/uploads/2018/03/hash-use.png" alt="hash-use"></a></p><p>上面的方法主要都是增加和删除方法，这不难理解，当我们要对一个链表数组中的某个元素进行增删的时候，首先要知道他应该保存在这个链表数组中的哪个位置，即他在这个数组中的下标。而hash()方法的功能就是根据Key来定位其在HashMap中的位置。HashTable、ConcurrentHashMap同理。</p><h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><p>首先，在同一个版本的Jdk中，HashMap、HashTable以及ConcurrentHashMap里面的hash方法的实现是不同的。再不同的版本的JDK中（Java7 和 Java8）中也是有区别的。我会尽量全部介绍到。相信，看文这篇文章，你会彻底理解hash方法。</p><p>在上代码之前，我们先来做个简单分析。我们知道，hash方法的功能是根据Key来定位这个K-V在链表数组中的位置的。也就是hash方法的输入应该是个Object类型的Key，输出应该是个int类型的数组下标。如果让你设计这个方法，你会怎么做？</p><p>其实简单，我们只要调用Object对象的hashCode()方法，该方法会返回一个整数，然后用这个数对HashMap或者HashTable的容量进行取模就行了。没错，其实基本原理就是这个，只不过，在具体实现上，由两个方法<code>int hash(Object k)</code>和<code>int indexFor(int h, int length)</code>来实现。但是考虑到效率等问题，HashMap的实现会稍微复杂一点。</p><blockquote><p>hash ：该方法主要是将Object转换成一个整型。</p><p>indexFor ：该方法主要是将hash生成的整型转换成链表数组中的下标。</p></blockquote><h4 id="HashMap-In-Java-7"><a href="#HashMap-In-Java-7" class="headerlink" title="HashMap In Java 7"></a>HashMap In Java 7</h4><pre class="line-numbers language-none"><code class="language-none">final int hash(Object k) {    int h = hashSeed;    if (0 != h &amp;&amp; k instanceof String) {        return sun.misc.Hashing.stringHash32((String) k);    }    h ^= k.hashCode();    h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);}static int indexFor(int h, int length) {    return h &amp; (length-1);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>前面我说过，<code>indexFor</code>方法其实主要是将hash生成的整型转换成链表数组中的下标。那么<code>return h &amp; (length-1);</code>是什么意思呢？其实，他就是取模。Java之所有使用位运算(&amp;)来代替取模运算(%)，最主要的考虑就是效率。<strong>位运算(&amp;)效率要比代替取模运算(%)高很多，主要原因是位运算直接对内存数据进行操作，不需要转成十进制，因此处理速度非常快。</strong></p><p>那么，为什么可以使用位运算(&amp;)来实现取模运算(%)呢？这实现的原理如下：</p><blockquote><p>X % 2^n = X &amp; (2^n – 1)</p><p>2^n表示2的n次方，也就是说，一个数对2^n取模 == 一个数和(2^n – 1)做按位与运算 。</p><p>假设n为3，则2^3 = 8，表示成2进制就是1000。2^3 -1 = 7 ，即0111。</p><p>此时X &amp; (2^3 – 1) 就相当于取X的2进制的最后三位数。</p><p>从2进制角度来看，X / 8相当于 X &gt;&gt; 3，即把X右移3位，此时得到了X / 8的商，而被移掉的部分(后三位)，则是X % 8，也就是余数。</p></blockquote><p>上面的解释不知道你有没有看懂，没看懂的话其实也没关系，你只需要记住这个技巧就可以了。或者你可以找几个例子试一下。</p><blockquote><p>6 % 8 = 6 ，6 &amp; 7 = 6</p><p>10 &amp; 8 = 2 ，10 &amp; 7 = 2</p></blockquote><p><a href="http://www.hollischuang.com/wp-content/uploads/2018/03/640-1.png"><img src="http://www.hollischuang.com/wp-content/uploads/2018/03/640-1.png" alt="640 (1)"></a></p><p>所以，<code>return h &amp; (length-1);</code>只要保证length的长度是<code>2^n</code>的话，就可以实现取模运算了。而HashMap中的length也确实是2的倍数，初始值是16，之后每次扩充为原来的2倍。</p><p>分析完<code>indexFor</code>方法后，我们接下来准备分析<code>hash</code>方法的具体原理和实现。在深入分析之前，至此，先做个总结。</p><p>HashMap的数据是存储在链表数组里面的。在对HashMap进行插入/删除等操作时，都需要根据K-V对的键值定位到他应该保存在数组的哪个下标中。而这个通过键值求取下标的操作就叫做哈希。HashMap的数组是有长度的，Java中规定这个长度只能是2的倍数，初始值为16。简单的做法是先求取出键值的hashcode，然后在将hashcode得到的int值对数组长度进行取模。为了考虑性能，Java总采用按位与操作实现取模操作。</p><p>接下来我们会发现，无论是用取模运算还是位运算都无法直接解决冲突较大的问题。比如：<code>CA11 0000</code>和<code>0001 0000</code>在对<code>0000 1111</code>进行按位与运算后的值是相等的。<a href="http://www.hollischuang.com/wp-content/uploads/2018/03/640-2.png"><img src="http://www.hollischuang.com/wp-content/uploads/2018/03/640-2.png" alt="640 (2)"></a></p><p>两个不同的键值，在对数组长度进行按位与运算后得到的结果相同，这不就发生了冲突吗。那么如何解决这种冲突呢，来看下Java是如何做的。</p><p>其中的主要代码部分如下：</p><pre class="line-numbers language-none"><code class="language-none">h ^= k.hashCode();h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这段代码是为了对key的hashCode进行扰动计算，防止不同hashCode的高位不同但低位相同导致的hash冲突。简单点说，就是为了把高位的特征和低位的特征组合起来，降低哈希冲突的概率，也就是说，尽量做到任何一位的变化都能对最终得到的结果产生影响。</p><p>举个例子来说，我们现在想向一个HashMap中put一个K-V对，Key的值为“hollischuang”，经过简单的获取hashcode后，得到的值为“1011000110101110011111010011011”，如果当前HashTable的大小为16，即在不进行扰动计算的情况下，他最终得到的index结果值为11。由于15的二进制扩展到32位为“00000000000000000000000000001111”，所以，一个数字在和他进行按位与操作的时候，前28位无论是什么，计算结果都一样（因为0和任何数做与，结果都为0）。如下图所示。</p><p><a href="http://www.hollischuang.com/wp-content/uploads/2018/03/640-3.png"><img src="http://www.hollischuang.com/wp-content/uploads/2018/03/640-3.png" alt="640 (3)"></a></p><p>可以看到，后面的两个hashcode经过位运算之后得到的值也是11 ，虽然我们不知道哪个key的hashcode是上面例子中的那两个，但是肯定存在这样的key，这就产生了冲突。</p><p>那么，接下来，我看看一下经过扰动的算法最终的计算结果会如何。</p><p><a href="http://www.hollischuang.com/wp-content/uploads/2018/03/640-4.png"><img src="http://www.hollischuang.com/wp-content/uploads/2018/03/640-4.png" alt="640 (4)"></a></p><p>从上面图中可以看到，之前会产生冲突的两个hashcode，经过扰动计算之后，最终得到的index的值不一样了，这就很好的避免了冲突。</p><blockquote><p>其实，使用位运算代替取模运算，除了性能之外，还有一个好处就是可以很好的解决负数的问题。因为我们知道，hashcode的结果是int类型，而int的取值范围是-2^31 ~ 2^31 – 1，即[ -2147483648, 2147483647]；这里面是包含负数的，我们知道，对于一个负数取模还是有些麻烦的。如果使用二进制的位运算的话就可以很好的避免这个问题。首先，不管hashcode的值是正数还是负数。length-1这个值一定是个正数。那么，他的二进制的第一位一定是0（有符号数用最高位作为符号位，“0”代表“+”，“1”代表“-”），这样里两个数做按位与运算之后，第一位一定是个0，也就是，得到的结果一定是个正数。</p></blockquote><h3 id="HashTable-In-Java-7"><a href="#HashTable-In-Java-7" class="headerlink" title="HashTable In Java 7"></a>HashTable In Java 7</h3><p>上面是Java 7中HashMap的<code>hash</code>方法以及<code>indexOf</code>方法的实现，那么接下来我们要看下，线程安全的HashTable是如何实现的，和HashMap有何不同，并试着分析下不同的原因。以下是Java 7中HashTable的hash方法的实现。</p><pre class="line-numbers language-none"><code class="language-none">private int hash(Object k) {    // hashSeed will be zero if alternative hashing is disabled.    return hashSeed ^ k.hashCode();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以发现，很简单，相当于只是对k做了个简单的hash，取了一下其hashCode。而HashTable中也没有<code>indexOf</code>方法，取而代之的是这段代码：<code>int index = (hash &amp; 0x7FFFFFFF) % tab.length;</code>。也就是说，HashMap和HashTable对于计算数组下标这件事，采用了两种方法。HashMap采用的是位运算，而HashTable采用的是直接取模。</p><blockquote><p>为啥要把hash值和0x7FFFFFFF做一次按位与操作呢，主要是为了保证得到的index的第一位为0，也就是为了得到一个正数。因为有符号数第一位0代表正数，1代表负数。</p></blockquote><p>我们前面说过，HashMap之所以不用取模的原因是为了提高效率。有人认为，因为HashTable是个线程安全的类，本来就慢，所以Java并没有考虑效率问题，就直接使用取模算法了呢？但是其实并不完全是，Java这样设计还是有一定的考虑在的，虽然这样效率确实是会比HashMap慢一些。</p><p>其实，HashTable采用简单的取模是有一定的考虑在的。这就要涉及到HashTable的构造函数和扩容函数了。由于篇幅有限，这里就不贴代码了，直接给出结论：</p><blockquote><p>HashTable默认的初始大小为11，之后每次扩充为原来的2n+1。</p><p>也就是说，HashTable的链表数组的默认大小是一个素数、奇数。之后的每次扩充结果也都是奇数。</p><p>由于HashTable会尽量使用素数、奇数作为容量的大小。当哈希表的大小为素数时，简单的取模哈希的结果会更加均匀。（这个是可以证明出来的，由于不是本文重点，暂不详细介绍，可参考：<a href="http://zhaox.github.io/algorithm/2015/06/29/hash%EF%BC%89">http://zhaox.github.io/algorithm/2015/06/29/hash）</a></p></blockquote><p>至此，我们看完了Java 7中HashMap和HashTable中对于hash的实现，我们来做个简单的总结。</p><ul><li>HashMap默认的初始化大小为16，之后每次扩充为原来的2倍。</li><li>HashTable默认的初始大小为11，之后每次扩充为原来的2n+1。</li><li>当哈希表的大小为素数时，简单的取模哈希的结果会更加均匀，所以单从这一点上看，HashTable的哈希表大小选择，似乎更高明些。因为hash结果越分散效果越好。</li><li>在取模计算时，如果模数是2的幂，那么我们可以直接使用位运算来得到结果，效率要大大高于做除法。所以从hash计算的效率上，又是HashMap更胜一筹。</li><li>但是，HashMap为了提高效率使用位运算代替哈希，这又引入了哈希分布不均匀的问题，所以HashMap为解决这问题，又对hash算法做了一些改进，进行了扰动计算。</li></ul><h3 id="ConcurrentHashMap-In-Java-7"><a href="#ConcurrentHashMap-In-Java-7" class="headerlink" title="ConcurrentHashMap In Java 7"></a>ConcurrentHashMap In Java 7</h3><pre class="line-numbers language-none"><code class="language-none">private int hash(Object k) {    int h = hashSeed;    if ((0 != h) &amp;&amp; (k instanceof String)) {        return sun.misc.Hashing.stringHash32((String) k);    }    h ^= k.hashCode();    // Spread bits to regularize both segment and index locations,    // using variant of single-word Wang/Jenkins hash.    h += (h &lt;&lt;  15) ^ 0xffffcd7d;    h ^= (h &gt;&gt;&gt; 10);    h += (h &lt;&lt;   3);    h ^= (h &gt;&gt;&gt;  6);    h += (h &lt;&lt;   2) + (h &lt;&lt; 14);    return h ^ (h &gt;&gt;&gt; 16);}int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面这段关于ConcurrentHashMap的hash实现其实和HashMap如出一辙。都是通过位运算代替取模，然后再对hashcode进行扰动。区别在于，ConcurrentHashMap 使用了一种变种的Wang/Jenkins 哈希算法，其主要母的也是为了把高位和低位组合在一起，避免发生冲突。至于为啥不和HashMap采用同样的算法进行扰动，我猜这只是程序员自由意志的选择吧。至少我目前没有办法证明哪个更优。</p><h3 id="HashMap-In-Java-8"><a href="#HashMap-In-Java-8" class="headerlink" title="HashMap In Java 8"></a>HashMap In Java 8</h3><p>在Java 8 之前，HashMap和其他基于map的类都是通过链地址法解决冲突，它们使用单向链表来存储相同索引值的元素。在最坏的情况下，这种方式会将HashMap的get方法的性能从<code>O(1)</code>降低到<code>O(n)</code>。为了解决在频繁冲突时hashmap性能降低的问题，Java 8中使用平衡树来替代链表存储冲突的元素。这意味着我们可以将最坏情况下的性能从<code>O(n)</code>提高到<code>O(logn)</code>。关于HashMap在Java 8中的优化，我后面会有文章继续深入介绍。</p><p>如果恶意程序知道我们用的是Hash算法，则在纯链表情况下，它能够发送大量请求导致哈希碰撞，然后不停访问这些key导致HashMap忙于进行线性查找，最终陷入瘫痪，即形成了拒绝服务攻击（DoS）。</p><p>关于Java 8中的hash函数，原理和Java 7中基本类似。Java 8中这一步做了优化，只做一次16位右位移异或混合，而不是四次，但原理是不变的。</p><pre class="line-numbers language-none"><code class="language-none">static final int hash(Object key) {    int h;    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的。以上方法得到的int的hash值，然后再通过<code>h &amp; (table.length -1)</code>来得到该对象在数据中保存的位置。</p><p>HashTable In Java 8</p><p>在Java 8的HashTable中，已经不在有hash方法了。但是哈希的操作还是在的，比如在put方法中就有如下实现：</p><pre class="line-numbers language-none"><code class="language-none">int hash = key.hashCode();int index = (hash &amp; 0x7FFFFFFF) % tab.length;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这其实和Java 7中的实现几乎无差别，就不做过多的介绍了。</p><h3 id="ConcurrentHashMap-In-Java-8"><a href="#ConcurrentHashMap-In-Java-8" class="headerlink" title="ConcurrentHashMap In Java 8"></a>ConcurrentHashMap In Java 8</h3><p>Java 8 里面的求hash的方法从hash改为了spread。实现方式如下：</p><pre class="line-numbers language-none"><code class="language-none">static final int spread(int h) {    return (h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Java 8的ConcurrentHashMap同样是通过Key的哈希值与数组长度取模确定该Key在数组中的索引。同样为了避免不太好的Key的hashCode设计，它通过如下方法计算得到Key的最终哈希值。不同的是，Java 8的ConcurrentHashMap作者认为引入红黑树后，即使哈希冲突比较严重，寻址效率也足够高，所以作者并未在哈希值的计算上做过多设计，只是将Key的hashCode值与其高16位作异或并保证最高位为0（从而保证最终结果为正整数）。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>至此，我们已经分析完了HashMap、HashTable以及ConcurrentHashMap分别在Jdk 1.7 和 Jdk 1.8中的实现。我们可以发现，为了保证哈希的结果可以分散、为了提高哈希的效率，JDK在一个小小的hash方法上就有很多考虑，做了很多事情。当然，我希望我们不仅可以深入了解背后的原理，还要学会这种对代码精益求精的态度。</p><p>Jdk的源代码，每一行都很有意思，都值得花时间去钻研、推敲。</p><p><a href="https://www.jianshu.com/p/7e7f52a49ffc">哈希表（HashTable）的构造方法和冲突解决</a></p><p><a href="http://blog.csdn.net/justloveyou_/article/details/62893086">HashMap的数据结构</a></p><p><a href="http://zhaox.github.io/2016/07/05/hashmap-vs-hashtable">HashMap和HashTable到底哪不同？</a></p><p><a href="https://www.zhihu.com/question/51784530">知乎问题</a>中 @二大王 和 @Anra的答案</p>]]></content>
      
      
      <categories>
          
          <category> hashmap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hashmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DNS查询原理详解</title>
      <link href="/archives/6abaae53.html"/>
      <url>/archives/6abaae53.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>过 DNS 查询，得到域名的 IP 地址，才能访问网站。</p><p>那么，DNS 查询到底是怎么完成的？本文通过实例，详细介绍背后的步骤。</p><p><img src="https://cdn.beekka.com/blogimg/asset/202208/bg2022080102.webp" alt="img"></p><h2 id="一、DNS-服务器"><a href="#一、DNS-服务器" class="headerlink" title="一、DNS 服务器"></a>一、DNS 服务器</h2><p>域名对应的 IP 地址，都保存在 DNS 服务器。</p><span id="more"></span><p>我们输入域名，浏览器就会在后台，自动向 DNS 服务器发出请求，获取对应的 IP 地址。这就是 DNS 查询。</p><p><img src="https://cdn.beekka.com/blogimg/asset/202208/bg2022080103.webp" alt="img"></p><p>举例来说，我输入 <code>es6.ruanyifeng.com</code> 这个域名，浏览器就要向 DNS 服务器查询，它的 IP 地址是什么，然后向该 IP 发出访问请求。</p><p>网上有很多公用的 DNS 服务器，这篇文章选择 Cloudflare 公司提供的 1.1.1.1 进行演示。</p><p><img src="https://cdn.beekka.com/blogimg/asset/202208/bg2022080104.webp" alt="img"></p><h2 id="二、dig-命令"><a href="#二、dig-命令" class="headerlink" title="二、dig 命令"></a>二、dig 命令</h2><p>命令行工具 dig 可以跟 DNS 服务器互动，我们就用它演示 DNS 查询。如果你还没有安装，可以搜一下安装方法，在 Linux 系统下是非常容易的。</p><p>它的查询语法如下（美元符号<code>$</code>是命令行提示符）。</p><blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">dig</span> @<span class="token punctuation">[</span>DNS 服务器<span class="token punctuation">]</span> <span class="token punctuation">[</span>域名<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>向 1.1.1.1 查询域名，就执行下面的命令。</p><blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">dig</span> @1.1.1.1 es6.ruanyifeng.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>正常情况下，它会输出一大堆内容。</p><p><img src="https://cdn.beekka.com/blogimg/asset/202208/bg2022080105.webp" alt="img"></p><p>在其中找到 ANSWER SECTION 这个部分，它给出了查询的答案，域名对应的 IP 地址是 104.198.14.52。</p><h2 id="三、域名的树状结构"><a href="#三、域名的树状结构" class="headerlink" title="三、域名的树状结构"></a>三、域名的树状结构</h2><p>你可能会问，难道 DNS 服务器（比如 1.1.1.1）保存了世界上所有域名（包括二级域名、三级域名）的 IP 地址？</p><p>当然不是。DNS 是一个分布式系统，1.1.1.1 只是用户查询入口，它也需要再向其他 DNS 服务器查询，才能获得最终的 IP 地址。</p><p>要说清楚 DNS 完整的查询过程，就必须了解 <strong>域名是一个树状结构</strong>。</p><p>最顶层的域名是根域名（root），然后是顶级域名（top-level domain，简写 TLD），再是一级域名、二级域名、三级域名。</p><p><img src="https://cdn.beekka.com/blogimg/asset/202208/bg2022080106.webp" alt="img"></p><p><strong>（1）根域名</strong></p><p>所有域名的起点都是根域名，它写作一个点<code>.</code>，放在域名的结尾。因为这部分对于所有域名都是相同的，所以就省略不写了，比如<code>example.com</code>等同于<code>example.com.</code>（结尾多一个点）。</p><p>你可以试试，任何一个域名结尾加一个点，浏览器都可以正常解读。</p><p><strong>（2）顶级域名</strong></p><p>根域名的下一级是顶级域名。它分成两种：通用顶级域名（gTLD，比如 .com 和 .net）和国别顶级域名（ccTLD，比如 .cn 和 .us）。</p><p>顶级域名由国际域名管理机构 ICANN 控制，它委托商业公司管理 gTLD，委托各国管理自己的国别域名。</p><p><strong>（3）一级域名</strong></p><p>一级域名就是你在某个顶级域名下面，自己注册的域名。比如，<code>ruanyifeng.com</code>就是我在顶级域名<code>.com</code>下面注册的。</p><p><strong>（4）二级域名</strong></p><p>二级域名是一级域名的子域名，是域名拥有者自行设置的，不用得到许可。比如，<code>es6</code> 就是 <code>ruanyifeng.com</code> 的二级域名。</p><h2 id="四、域名的逐级查询"><a href="#四、域名的逐级查询" class="headerlink" title="四、域名的逐级查询"></a>四、域名的逐级查询</h2><p>这种树状结构的意义在于，<strong>只有上级域名，才知道下一级域名的 IP 地址，需要逐级查询。</strong></p><p>每一级域名都有自己的 DNS 服务器，存放下级域名的 IP 地址。</p><p>所以，如果想要查询二级域名 <code>es6.ruanyifeng.com</code> 的 IP 地址，需要三个步骤。</p><blockquote><p>第一步，查询根域名服务器，获得顶级域名服务器<code>.com</code>（又称 TLD 服务器）的 IP 地址。</p><p>第二步，查询 TLD 服务器 <code>.com</code>，获得一级域名服务器 <code>ruanyifeng.com</code> 的 IP 地址。</p><p>第三步，查询一级域名服务器 <code>ruanyifeng.com</code>，获得二级域名 <code>es6</code> 的 IP 地址。</p></blockquote><p>下面依次演示这三个步骤。</p><h2 id="五、根域名服务器"><a href="#五、根域名服务器" class="headerlink" title="五、根域名服务器"></a>五、根域名服务器</h2><p>根域名服务器全世界一共有13台（都是服务器集群）。它们的域名和 IP 地址如下。</p><p><img src="https://cdn.beekka.com/blogimg/asset/202208/bg2022080107.webp" alt="img"></p><p>根域名服务器的 IP 地址是不变的，集成在操作系统里面。</p><p>操作系统会选其中一台，查询 TLD 服务器的 IP 地址。</p><blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">dig</span> @192.33.4.12 es6.ruanyifeng.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>上面示例中，我们选择<code>192.33.4.12</code>，向它发出查询，询问<code>es6.ruanyifeng.com</code>的 TLD 服务器的 IP 地址。</p><p>dig 命令的输出结果如下。</p><p><img src="https://cdn.beekka.com/blogimg/asset/202208/bg2022080108.webp" alt="img"></p><p>因为它给不了 <code>es6.ruanyifeng.com</code> 的 IP 地址，所以输出结果中没有 ANSWER SECTION，只有一个 AUTHORITY SECTION，给出了<code>com.</code>的13台 TLD 服务器的域名。</p><p>下面还有一个 ADDITIONAL SECTION，给出了这13台 TLD 服务器的 IP 地址（包含 IPv4 和 IPv6 两个地址）。</p><h2 id="六、TLD-服务器"><a href="#六、TLD-服务器" class="headerlink" title="六、TLD 服务器"></a>六、TLD 服务器</h2><p>有了 TLD 服务器的 IP 地址以后，我们再选一台接着查询。</p><blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">dig</span> @192.41.162.30 es6.ruanyifeng.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>上面示例中，192.41.162.30 是随便选的一台 .com 的 TLD 服务器，我们向它询问 <code>es6.ruanyifeng.com</code> 的 IP 地址。</p><p>返回结果如下。</p><p><img src="https://cdn.beekka.com/blogimg/asset/202208/bg2022080109.webp" alt="img"></p><p>它依然没有 ANSWER SECTION 的部分，只有 AUTHORITY SECTION，给出了一级域名 ruanyifeng.com 的两台 DNS 服务器。</p><p>下面的 ADDITIONAL SECTION 就是这两台 DNS 服务器对应的 IP 地址。</p><h2 id="七、一级域名的-DNS-服务器"><a href="#七、一级域名的-DNS-服务器" class="headerlink" title="七、一级域名的 DNS 服务器"></a>七、一级域名的 DNS 服务器</h2><p>第三步，再向一级域名的 DNS 服务器查询二级域名的 IP 地址。</p><blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">dig</span> @172.64.32.123 es6.ruanyifeng.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>返回结果如下。</p><p><img src="https://cdn.beekka.com/blogimg/asset/202208/bg2022080110.webp" alt="img"></p><p>这次终于有了 ANSWER SECTION，得到了最终的二级域名的 IP 地址。</p><p>至此，三个步骤的 DNS 查询全部完成。</p><h2 id="八、DNS-服务器的种类"><a href="#八、DNS-服务器的种类" class="headerlink" title="八、DNS 服务器的种类"></a>八、DNS 服务器的种类</h2><p>总结一下，上面一共提到了四种服务器。</p><blockquote><ul><li>1.1.1.1</li><li>根域名服务器</li><li>TLD 服务器</li><li>一级域名服务器</li></ul></blockquote><p>它们都属于 DNS 服务器，都用来接受 DNS 查询。但是作用不一样，属于不同的类别。</p><h3 id="8-1-递归-DNS-服务器"><a href="#8-1-递归-DNS-服务器" class="headerlink" title="8.1 递归 DNS 服务器"></a>8.1 递归 DNS 服务器</h3><p>后三种服务器只用来查询下一级域名的 IP 地址，而 1.1.1.1 则把分步骤的查询过程自动化，方便用户一次性得到结果，所以它称为<strong>递归 DNS 服务器</strong>（recursive DNS server），即可以自动递归查询。</p><p>我们平常说的 DNS 服务器，一般都是指递归 DNS 服务器。它把 DNS 查询自动化了，只要向它查询就可以了。</p><p>它内部有缓存，可以保存以前查询的结果，下次再有人查询，就直接返回缓存里面的结果。所以它能加快查询，减轻源头 DNS 服务器的负担。</p><h3 id="8-2-权威-DNS-服务器"><a href="#8-2-权威-DNS-服务器" class="headerlink" title="8.2 权威 DNS 服务器"></a>8.2 权威 DNS 服务器</h3><p>一级域名服务器的正式名称叫做<strong>权威域名服务器</strong>（Authoritative Name Server）。</p><p>“权威”的意思是域名的 IP 地址由它给定，不像递归服务器自己做不了主。我们购买域名后，设置 DNS 服务器就是在设置该域名的权威服务器。</p><h3 id="8-3-四种-DNS-服务器"><a href="#8-3-四种-DNS-服务器" class="headerlink" title="8.3 四种 DNS 服务器"></a>8.3 四种 DNS 服务器</h3><p>综上所述，DNS 服务器可以分成四种：</p><blockquote><ul><li>根域名服务器</li><li>TLD 服务器</li><li>权威域名服务器</li><li>递归域名服务器</li></ul></blockquote><p>它们的关系如下图。</p><p><img src="https://cdn.beekka.com/blogimg/asset/202208/bg2022080112.webp" alt="img"></p><p>知道了 DNS 查询的原理，完全可以自己写一个 DNS 的递归服务器，这是不难的。网上有很多参考资料，有兴趣的话，大家可以试试看。</p><p><img src="https://cdn.beekka.com/blogimg/asset/202208/bg2022080111.webp" alt="img"></p><h2 id="九、参考网址"><a href="#九、参考网址" class="headerlink" title="九、参考网址"></a>九、参考网址</h2><ul><li><a href="https://timothya.com/blog/dns/">Building a Recursive DNS Resolver</a>, Timothy Andrew</li><li><a href="https://www.dnsfilter.com/blog/authoritative-vs-recursive-dns">Authoritative Vs Recursive DNS: What You Need To Know</a>, Serena Raymond</li><li><a href="https://www.cloudflare.com/zh-cn/learning/dns/dns-server-types/">DNS 服务器类型</a>，Cloudflare</li></ul>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DNS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hashmap笔记</title>
      <link href="/archives/46251.html"/>
      <url>/archives/46251.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>你知道的越多，你不知道的越多</p></blockquote><blockquote><p>本文 <strong>GitHub</strong> <a href="https://github.com/AobingJava/JavaFamily">https://github.com/JavaFamily</a> 上已经收录，大家面试可以参照考点复习，希望我们一起有点东西。</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>于是在一个寂寞难耐的夜晚，我痛定思痛，决定开始写互联网技术栈面试相关的文章，希望能帮助各位读者以后面试势如破竹，对面试官进行360°的反击，吊打问你的面试官，让一同面试的同僚瞠目结舌，疯狂收割大厂Offer！</p><p>希望大家怀着空杯心态好好学，一起进步。</p><span id="more"></span><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><blockquote><p>一个婀娜多姿，穿着衬衣的小姐姐，拿着一个精致的小笔记本，径直走过来坐在我的面前。</p><p>看着眼前这个美丽的女人，心想这不会就是Java基础系列的面试官吧，真香。</p><p>不过看样子这么年轻应该问不出什么深度的吧，嘻嘻。（哦？是么😏）</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9pbe6ko1mj30hk0dedmn.jpg"></p><blockquote><p>小伙子，听前面的面试官说了，你Redis和消息队列都回答得不错，看来还是有点东西。</p></blockquote><p>美丽迷人的面试官您好，您见笑了，全靠看了敖丙的《吊打面试官》系列，不然我还真的回答不上很多原本的知识盲区，他真的有点东西。</p><blockquote><p>面试官心想：哦，吊打面试官是么，那今天我就让你知道，吊打这两个字怎么写的吧，年轻人啊，提前为你感到惋惜。</p><p>嗯嗯小帅比，虽然前面的技术栈没啥太大的瑕疵，不过未来很长的一段时间我会用一期期的基础教你做人的，你要准备好哟！</p><p>好了我们开始今天的面试吧，小伙子你了解数据结构中的HashMap么？能跟我聊聊他的结构和底层原理么？</p></blockquote><p>切，这也太看不起我了吧，居然问这种低级问题，不过还是要好好回答。</p><p>嗯嗯面试官，我知道HashMap是我们非常常用的数据结构，由<strong>数组和链表组合构成</strong>的数据结构。</p><p>大概如下，数组里面每个地方都存了Key-Value这样的实例，在Java7叫Entry在Java8中叫Node。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9pchhbrp3j30ez02ngli.jpg"></p><p>因为他本身所有的位置都为null，在put插入的时候会根据key的hash去计算一个index值。</p><p>就比如我put（”帅丙“，520），我插入了为”帅丙“的元素，这个时候我们会通过哈希函数计算出插入的位置，计算出来index是2那结果如下。</p><blockquote><p>hash（“帅丙”）= 2</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9pcqyo35ij30et03d0sq.jpg"></p><blockquote><p>你提到了还有链表，为啥需要链表，链表又是怎么样子的呢？</p></blockquote><p>我们都知道数组长度是有限的，在有限的长度里面我们使用哈希，哈希本身就存在概率性，就是”帅丙“和”丙帅“我们都去hash有一定的概率会一样，就像上面的情况我再次哈希”丙帅“极端情况也会hash到一个值上，那就形成了链表。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9pd6ckj3dj30eq06mmx8.jpg"></p><p>每一个节点都会保存自身的hash、key、value、以及下个节点，我看看Node的源码。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9pcz67kemj30fv097759.jpg"></p><blockquote><p>说到链表我想问一下，你知道新的Entry节点在插入链表的时候，是怎么插入的么？</p></blockquote><p><strong>java8之前是头插法</strong>，就是说新来的值会取代原有的值，原有的值就顺推到链表中去，就像上面的例子一样，因为写这个代码的作者认为后来的值被查找的可能性更大一点，提升查找的效率。</p><p>但是，<strong>在java8之后，都是所用尾部插入了。</strong></p><blockquote><p>为啥改为尾部插入呢？</p></blockquote><p>这！！！这个问题，面试官可真会问！！！还好我饱读诗书，不然死定了！</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9qv6ra54qj3073073dfs.jpg"></p><p>有人认为是作者随性而为，没啥luan用，其实不然，其中暗藏玄机</p><p>首先我们看下HashMap的扩容机制：</p><p>帅丙提到过了，数组容量是有限的，数据多次插入的，到达一定的数量就会进行扩容，也就是resize。</p><blockquote><p>什么时候resize呢？</p></blockquote><p>有两个因素：</p><ul><li>Capacity：HashMap当前长度。</li><li>LoadFactor：负载因子，默认值0.75f。<img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9pdw39rwjj30xi056wf3.jpg"></li></ul><p>怎么理解呢，就比如当前的容量大小为100，当你存进第76个的时候，判断发现需要进行resize了，那就进行扩容，但是HashMap的扩容也不是简单的扩大点容量这么简单的。</p><blockquote><p>扩容？它是怎么扩容的呢？</p></blockquote><p>分为两步</p><ul><li>扩容：创建一个新的Entry空数组，长度是原数组的2倍。</li><li>ReHash：遍历原Entry数组，把所有的Entry重新Hash到新数组。</li></ul><blockquote><p>为什么要重新Hash呢，直接复制过去不香么？</p></blockquote><p>卧槽这个问题！有点知识盲区呀！</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9qv87tgslj306y05h74b.jpg"></p><p>1x1得 1  1x2 得 2  …. 有了，我想起来敖丙那天晚上在我耳边的话了：假如我年少有为不自卑，懂得什么是珍贵，那些美梦没给你，我一生有愧….什么鬼！</p><p>小姐姐：是因为长度扩大以后，Hash的规则也随之改变。</p><p>Hash的公式—&gt; index = HashCode（Key） &amp; （Length - 1）</p><p>原来长度（Length）是8你位运算出来的值是2 ，新的长度是16你位运算出来的值明显不一样了。</p><p>扩容前：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9pe8mz5zvj30en05jq30.jpg"></p><p>扩容后： <img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9ped28o4xj30m003jq2y.jpg"></p><blockquote><p>说完扩容机制我们言归正传，为啥之前用头插法，java8之后改成尾插了呢？</p></blockquote><p>卧槽，我以为她忘记了！居然还是被问到了！</p><p>我先举个例子吧，我们现在往一个容量大小为2的put两个值，负载因子是0.75是不是我们在put第二个的时候就会进行resize？</p><p>2*0.75 = 1 所以插入第二个就要resize了</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9pgqt9dmvj30zy01i74i.jpg"></p><p>现在我们要在容量为2的容器里面<strong>用不同线程</strong>插入A，B，C，假如我们在resize之前打个短点，那意味着数据都插入了但是还没resize那扩容前可能是这样的。</p><p>我们可以看到链表的指向A-&gt;B-&gt;C</p><p><strong>Tip：A的下一个指针是指向B的</strong></p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9pkaxgg5ij305007odfr.jpg"></p><p>因为resize的赋值方式，也就是使用了<strong>单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置</strong>，在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。</p><p>就可能出现下面的情况，大家发现问题没有？</p><p>B的下一个指针指向了A</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9phcpl968j309j054747.jpg"></p><p>一旦几个线程都调整完成，就可能出现环形链表</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9pkh8omjyj30al06pmx4.jpg"></p><p>如果这个时候去取值，悲剧就出现了——Infinite Loop。</p><blockquote><p>诶卧槽，小伙子难不倒他呀！</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9qvbtqdxbg305k05ka9y.gif"></p><p>小伙子有点东西呀，但是你都都说了头插是JDK1.7的那1.8的尾插是怎么样的呢？</p></blockquote><p>因为<strong>java8之后链表有红黑树</strong>的部分，大家可以看到代码已经多了很多if else的逻辑判断了，红黑树的引入巧妙的将原本O(n)的时间复杂度降低到了O(logn)。</p><p><strong>Tip</strong>：红黑树的知识点同样很重要，还是那句话<strong>不打没把握的仗</strong>，限于篇幅原因，我就不在这里过多描述了，以后写到数据结构再说吧，不过要面试的仔，还是要准备好，反正我是经常问到的。</p><p><strong>使用头插</strong>会改变链表的上的顺序，但是如果<strong>使用尾插</strong>，在扩容时会保持链表元素原本的顺序，就不会出现链表成环的问题了。</p><p>就是说原本是A-&gt;B，在扩容后那个链表还是A-&gt;B</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9plftqim3j309f04y0sn.jpg"></p><p>Java7在多线程操作HashMap时可能引起死循环，原因是扩容转移后前后链表顺序倒置，在转移过程中修改了原来链表中节点的引用关系。</p><p>Java8在同样的前提下并不会引起死循环，原因是扩容转移后前后链表顺序不变，保持之前节点的引用关系。</p><blockquote><p>那是不是意味着Java8就可以把HashMap用在多线程中呢？</p></blockquote><p>我认为即使不会出现死循环，但是通过源码看到put/get方法都没有加同步锁，多线程情况最容易出现的就是：无法保证上一秒put的值，下一秒get的时候还是原值，所以线程安全还是无法保证。</p><blockquote><p>小伙子回答得很好嘛，这都被你回答道了，面试这么多人都不知道头插和尾插，还是被你说出来了，可以可以。</p></blockquote><p>面试官谬赞啊，要不是你这样<strong>美若天仙</strong>的面试官面试我，我估计是想不起来了。</p><blockquote><p>我*，你套近乎？</p><p>小姐姐抿嘴一笑，小子你offer有了，耶稣都带不走你，我说的！</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9qvf9i9lcj308o08k3yh.jpg"></p><p>那我问你HashMap的默认初始化长度是多少？</p></blockquote><p>我记得我在看源码的时候初始化大小是16</p><blockquote><p>你那知道为啥是16么？</p></blockquote><p>卧*，这叫什么问题啊？他为啥是16我怎么知道？？？你确定你没逗我？</p><p>我努力回忆源码，不知道有没有漏掉什么细节，以前在学校熬夜看源码的一幕幕在脑海里闪过，想起那个晚上在操场上，<strong>跟我好了半个月的小绿</strong>拉着我的手说：你就要当爸爸了。</p><p>等等，这都是什么鬼，哦哦哦，想起来了！！！</p><p><strong>在JDK1.8的 236 行有1&lt;&lt;4就是16</strong>，为啥用位运算呢？直接写16不好么？</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9plqfeg1pj3174054jsb.jpg"></p><p>我再次陷入沉思，疯狂脑暴，叮！</p><p>有了！</p><p>面试官您好，我们在创建HashMap的时候，阿里巴巴规范插件会提醒我们最好赋初值，而且最好是2的幂。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9pluoz10nj30py052gma.jpg"></p><p>这样是为了位运算的方便，<strong>位与运算比算数计算的效率高了很多</strong>，之所以选择16，是为了服务将Key映射到index的算法。</p><p>我前面说了所有的key我们都会拿到他的hash，但是我们怎么尽可能的得到一个均匀分布的hash呢？</p><p>是的我们通过Key的HashCode值去做位运算。</p><p>我打个比方，key为”帅丙“的十进制为766132那二进制就是 10111011000010110100</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9pm4zheo1j30hc03yaac.jpg"></p><p>我们再看下index的计算公式：index = HashCode（Key） &amp; （Length- 1）</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9pmcjsou4j30ca01mjrd.jpg"></p><p>15的的二进制是1111，那10111011000010110100 &amp;1111 十进制就是4</p><p>之所以用位与运算效果与取模一样，性能也提高了不少！</p><blockquote><p>那为啥用16不用别的呢？</p></blockquote><p>因为在使用不是2的幂的数字的时候，Length-1的值是所有二进制位全为1，这种情况下，index的结果等同于HashCode后几位的值。</p><p>只要输入的HashCode本身分布均匀，Hash算法的结果就是均匀的。</p><p>这是为了<strong>实现均匀分布</strong>。</p><blockquote><p>哟小家伙，知道的确实很多，那我问你个问题，为啥我们重写equals方法的时候需要重写hashCode方法呢？</p><p>你能用HashMap给我举个例子么？</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9qvh4jpagj305i058745.jpg"></p><p>这都能被他问到，还好我看了敖丙的系列呀，不然真的完了！！！</p><p>但是我想拖延点时间，只能<strong>故做沉思</strong>，仰望天空片刻，45°仰望天空的样子，说实话，我看到面试官都流口水了！可惜我是他永远得不到的男人，好了不装逼了。</p><p>我想起来了面试官！</p><p>因为在java中，所有的对象都是继承于Object类。Object类中有两个方法equals、hashCode，这两个方法都是用来比较两个对象是否相等的。</p><p>在未重写equals方法我们是继承了object的equals方法，<strong>那里的 equals是比较两个对象的内存地址</strong>，显然我们new了2个对象内存地址肯定不一样</p><ul><li>对于值对象，==比较的是两个对象的值</li><li>对于引用对象，比较的是两个对象的地址</li></ul><p>大家是否还记得我说的HashMap是通过key的hashCode去寻找index的，那index一样就形成链表了，也就是说”帅丙“和”丙帅“的index都可能是2，在一个链表上的。</p><p>我们去get的时候，他就是根据key去hash然后计算出index，找到了2，那我怎么找到具体的”帅丙“还是”丙帅“呢？</p><p><strong>equals</strong>！是的，所以如果我们对equals方法进行了重写，建议一定要对hashCode方法重写，以保证相同的对象返回相同的hash值，不同的对象返回不同的hash值。</p><p>不然一个链表的对象，你哪里知道你要找的是哪个，到时候发现hashCode都一样，这不是完犊子嘛。</p><blockquote><p>可以可以小伙子，我记得你上面说过他是线程不安全的，那你能跟我聊聊你们是怎么处理HashMap在线程安全的场景么？</p></blockquote><p>面试官，在这样的场景，我们一般都会使用<strong>HashTable</strong>或者<strong>ConcurrentHashMap</strong>，但是因为前者的<strong>并发度</strong>的原因基本上没啥使用场景了，所以存在线程不安全的场景我们都使用的是ConcurrentHashMap。</p><p>HashTable我看过他的源码，很简单粗暴，直接在方法上锁，并发度很低，最多同时允许一个线程访问，ConcurrentHashMap就好很多了，1.7和1.8有较大的不同，不过并发度都比前者好太多了。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9qwe91q6lj30zo0e440r.jpg"></p><blockquote><p>那你能跟我聊聊ConcurrentHashMap么？</p></blockquote><p>好呀，不过今天天色已晚，我觉得我们要不改天再约？</p><p>再说最近敖丙好像双十二比较忙，一次怎么能怼这么多呢？</p><blockquote><p>好吧好吧，小伙子还挺会为别人着想，而且还喜欢这么优秀的作者，你我觉得来日可期，那我们改日再约，今天表现很好，希望下次能保持住！</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>HashMap绝对是最常问的集合之一</strong>，基本上所有点都要<strong>烂熟于心</strong>的那种，篇幅和时间的关系，我就不多介绍了，核心的点我基本上都讲到了，不过像红黑树这样的就没怎么聊了，但是不代表不重要。</p><p>篇幅和精力的原因我就介绍到了一部分的主要知识点，我总结了一些关于HashMap常见的面试题，大家问下自己能不能回答上来，不能的话要去查清楚哟。</p><p>HashMap常见面试题：</p><ul><li><p>HashMap的底层数据结构？</p></li><li><p>HashMap的存取原理？</p></li><li><p>Java7和Java8的区别？</p></li><li><p>为啥会线程不安全？</p></li><li><p>有什么线程安全的类代替么?</p></li><li><p>默认初始化大小是多少？为啥是这么多？为啥大小都是2的幂？</p></li><li><p>HashMap的扩容方式？负载因子是多少？为什是这么多？</p></li><li><p>HashMap的主要参数都有哪些？</p></li><li><p>HashMap是怎么处理hash碰撞的？</p></li><li><p>hash的计算规则？</p></li></ul><h2 id><a href="#" class="headerlink" title></a></h2><p>好了各位，以上就是这篇文章的全部内容了，能看到这里的人呀，都是<strong>人才</strong>。</p><p>敖丙 | 文  【原创】</p><hr><blockquote><p>文章每周持续更新，可以微信搜索「 <strong>三太子敖丙</strong> 」第一时间阅读和催更（比博客早一到两篇哟），本文 <strong>GitHub</strong> <a href="https://github.com/AobingJava/JavaFamily">https://github.com/JavaFamily</a> 已经收录，有一线大厂面试点思维导图，也整理了很多我的文档，欢迎Star和完善，大家面试可以参照考点复习，希望我们一起有点东西。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> hashmap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hashmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot学习笔记</title>
      <link href="/archives/9502.html"/>
      <url>/archives/9502.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-Spring-Boot是什么"><a href="#1-Spring-Boot是什么" class="headerlink" title="1. Spring Boot是什么"></a>1. Spring Boot是什么</h2><p>我们知道，从 2002 年开始，Spring 一直在飞速的发展，如今已经成为了在Java EE（Java Enterprise Edition）开发中真正意义上的标准，但是随着技术的发展，Java EE使用 Spring 逐渐变得笨重起来，大量的 XML 文件存在于项目之中。繁琐的配置，整合第三方框架的配置问题，导致了开发和部署效率的降低。</p><p>2012 年 10 月，Mike Youngstrom 在 Spring jira 中创建了一个功能请求，要求在 Spring 框架中支持无容器 Web 应用程序体系结构。他谈到了在主容器引导 spring 容器内配置 Web 容器服务。这是 jira 请求的摘录：</p><p>我认为 Spring 的 Web 应用体系结构可以大大简化，如果它提供了从上到下利用 Spring 组件和配置模型的工具和参考体系结构。在简单的 main()方法引导的 Spring 容器内嵌入和统一这些常用Web 容器服务的配置。</p><p>这一要求促使了 2013 年初开始的 Spring Boot 项目的研发，到今天，Spring Boot 的版本已经到了 2.0.3 RELEASE。Spring Boot 并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。</p><p>它集成了大量常用的第三方库配置，Spring Boot应用中这些第三方库几乎可以是零配置的开箱即用（out-of-the-box），大部分的 Spring Boot 应用都只需要非常少量的配置代码（基于 Java 的配置），开发者能够更加专注于业务逻辑。</p><span id="more"></span><h2 id="2-为什么学习Spring-Boot"><a href="#2-为什么学习Spring-Boot" class="headerlink" title="2.为什么学习Spring Boot"></a>2.为什么学习Spring Boot</h2><h3 id="2-1-从Spring官方来看"><a href="#2-1-从Spring官方来看" class="headerlink" title="2.1 从Spring官方来看"></a>2.1 从Spring官方来看</h3><p>我们打开 Spring 的官方网站，可以看到下图：<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMuZ2l0Ym9vay5jbi85OGZkYTdmMC04NjU2LTExZTgtODY3NS01NTM3YTcwMWFlN2Q?x-oss-process=image/format,png" alt="Spring官网首图"></p><p>我们可以看到图中官方对 Spring Boot 的定位：<em>Build Anything</em>， Build任何东西。Spring Boot旨在尽可能快地启动和运行，并且只需最少的 Spring 前期配置。 同时我们也来看一下官方对后面两个的定位：</p><p>SpringCloud：<em>Coordinate Anything</em>，协调任何事情；<br>SpringCloud Data Flow：<em>Connect everything</em>，连接任何东西。</p><p>仔细品味一下，Spring 官网对 Spring Boot、SpringCloud 和 SpringCloud Data Flow三者定位的措辞非常有味道，同时也可以看出，Spring 官方对这三个技术非常重视，是现在以及今后学习的重点（SpringCloud 相关达人课课程届时也会上线）。</p><h3 id="2-2-从Spring-Boot的优点来看"><a href="#2-2-从Spring-Boot的优点来看" class="headerlink" title="2.2 从Spring Boot的优点来看"></a>2.2 从Spring Boot的优点来看</h3><p>Spring Boot 有哪些优点？主要给我们解决了哪些问题呢？我们以下图来说明：<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMuZ2l0Ym9vay5jbi9lMTdiOGM0MC04NjU2LTExZTgtOGE5MS1kNzBiYzJkODQ3YzU?x-oss-process=image/format,png" alt="Spring Boot的优点"></p><h4 id="2-2-1-良好的基因"><a href="#2-2-1-良好的基因" class="headerlink" title="2.2.1 良好的基因"></a>2.2.1 良好的基因</h4><p>Spring Boot 是伴随着 Spring 4.0 诞生的，从字面理解，Boot是引导的意思，因此 Spring Boot 旨在帮助开发者快速搭建 Spring 框架。Spring Boot 继承了原有 Spring 框架的优秀基因，使 Spring 在使用中更加方便快捷。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMuZ2l0Ym9vay5jbi8wMDA3ODY1MC04NjU3LTExZTgtODdkZS1kOTEwYTNlZTA4N2U?x-oss-process=image/format,png" alt="Spring Boot与Spring"></p><h4 id="2-2-2-简化编码"><a href="#2-2-2-简化编码" class="headerlink" title="2.2.2 简化编码"></a>2.2.2 简化编码</h4><p>举个例子，比如我们要创建一个 web 项目，使用 Spring 的朋友都知道，在使用 Spring 的时候，需要在 pom 文件中添加多个依赖，而 Spring Boot 则会帮助开发着快速启动一个 web 容器，在 Spring Boot 中，我们只需要在 pom 文件中添加如下一个 starter-web 依赖即可。</p><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>我们点击进入该依赖后可以看到，Spring Boot 这个 starter-web 已经包含了多个依赖，包括之前在 Spring 工程中需要导入的依赖，我们看一下其中的一部分，如下：</p><pre class="line-numbers language-none"><code class="language-none">&lt;!-- .....省略其他依赖 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-web&lt;/artifactId&gt;    &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;    &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;    &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;    &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由此可以看出，Spring Boot 大大简化了我们的编码，我们不用一个个导入依赖，直接一个依赖即可。</p><h4 id="2-2-3-简化配置"><a href="#2-2-3-简化配置" class="headerlink" title="2.2.3 简化配置"></a>2.2.3 简化配置</h4><p>Spring 虽然使Java EE轻量级框架，但由于其繁琐的配置，一度被人认为是“配置地狱”。各种XML、Annotation配置会让人眼花缭乱，而且配置多的话，如果出错了也很难找出原因。Spring Boot更多的是采用 Java Config 的方式，对 Spring 进行配置。举个例子：</p><p>我新建一个类，但是我不用 <code>@Service</code>注解，也就是说，它是个普通的类，那么我们如何使它也成为一个 Bean 让 Spring 去管理呢？只需要<code>@Configuration</code> 和<code>@Bean</code>两个注解即可，如下：</p><pre class="line-numbers language-none"><code class="language-none">public class TestService {    public String sayHello () {        return "Hello Spring Boot!";    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class JavaConfig {    @Bean    public TestService getTestService() {        return new TestService();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>@Configuration</code>表示该类是个配置类，<code>@Bean</code>表示该方法返回一个 Bean。这样就把<code>TestService</code>作为 Bean 让 Spring 去管理了，在其他地方，我们如果需要使用该 Bean，和原来一样，直接使用<code>@Resource</code>注解注入进来即可使用，非常方便。</p><pre class="line-numbers language-none"><code class="language-none">@Resourceprivate TestService testService;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>另外，部署配置方面，原来 Spring 有多个 xml 和 properties配置，在 Spring Boot 中只需要个 application.yml即可。</p><h4 id="2-2-4-简化部署"><a href="#2-2-4-简化部署" class="headerlink" title="2.2.4 简化部署"></a>2.2.4 简化部署</h4><p>在使用 Spring 时，项目部署时需要我们在服务器上部署 tomcat，然后把项目打成 war 包扔到 tomcat里，在使用 Spring Boot 后，我们不需要在服务器上去部署 tomcat，因为 Spring Boot 内嵌了 tomcat，我们只需要将项目打成 jar 包，使用 <code>java -jar xxx.jar</code>一键式启动项目。</p><p>另外，也降低对运行环境的基本要求，环境变量中有JDK即可。</p><h4 id="2-2-5-简化监控"><a href="#2-2-5-简化监控" class="headerlink" title="2.2.5 简化监控"></a>2.2.5 简化监控</h4><p>我们可以引入 spring-boot-start-actuator 依赖，直接使用 REST 方式来获取进程的运行期性能参数，从而达到监控的目的，比较方便。但是 Spring Boot 只是个微框架，没有提供相应的服务发现与注册的配套功能，没有外围监控集成方案，没有外围安全管理方案，所以在微服务架构中，还需要 Spring Cloud 来配合一起使用。</p><h3 id="2-3-从未来发展的趋势来看"><a href="#2-3-从未来发展的趋势来看" class="headerlink" title="2.3 从未来发展的趋势来看"></a>2.3 从未来发展的趋势来看</h3><p>微服务是未来发展的趋势，项目会从传统架构慢慢转向微服务架构，因为微服务可以使不同的团队专注于更小范围的工作职责、使用独立的技术、更安全更频繁地部署。而 继承了 Spring 的优良特性，与 Spring 一脉相承，而且 支持各种REST API 的实现方式。Spring Boot 也是官方大力推荐的技术，可以看出，Spring Boot 是未来发展的一个大趋势。</p><h1 id="第01课：Spring-Boot开发环境搭建和项目启动"><a href="#第01课：Spring-Boot开发环境搭建和项目启动" class="headerlink" title="第01课：Spring Boot开发环境搭建和项目启动"></a>第01课：Spring Boot开发环境搭建和项目启动</h1><p>上一节对 SpringBoot 的特性做了一个介绍，本节主要对 <strong>jdk 的配置、Spring Boot工程的构建和项目的启动、Spring Boot 项目工程的结构做一下讲解和分析</strong>。</p><h2 id="1-jdk-的配置"><a href="#1-jdk-的配置" class="headerlink" title="1. jdk 的配置"></a>1. jdk 的配置</h2><p>本课程是使用 IDEA 进行开发，在IDEA 中配置 jdk 的方式很简单，打开<code>File-&gt;Project Structure</code>，如下图所：<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMuZ2l0Ym9vay5jbi85YmVmZGU4MC04NjU5LTExZTgtOWIwZC05NWRlNDQ5ZGMxMDc?x-oss-process=image/format,png" alt="IDEA中配置jdk"></p><ol><li>选择 SDKs</li><li>在 JDK home path 中选择本地 jdk 的安装目录</li><li>在 Name 中为 jdk 自定义名字</li></ol><p>通过以上三步骤，即可导入本地安装的 jdk。如果是使用 STS 或者 eclipse 的朋友，可以通过两步骤添加：</p><ul><li><code>window-&gt;preference-&gt;java-&gt;Instralled JRES</code>来添加本地 jdk。</li><li><code>window--&gt;preference--&gt;java--&gt;Compiler</code>选择 jre，和 jdk 保持一致。</li></ul><h2 id="2-Spring-Boot-工程的构建"><a href="#2-Spring-Boot-工程的构建" class="headerlink" title="2. Spring Boot 工程的构建"></a>2. Spring Boot 工程的构建</h2><h3 id="2-1-IDEA-快速构建"><a href="#2-1-IDEA-快速构建" class="headerlink" title="2.1 IDEA 快速构建"></a>2.1 IDEA 快速构建</h3><p>IDEA 中可以通过<code>File-&gt;New-&gt;Project</code>来快速构建 Spring Boot 工程。如下，选择 Spring Initializr，在 Project SDK 中选择刚刚我们导入的 jdk，点击 Next，到了项目的配置信息。</p><ul><li>Group：填企业域名，本课程使用com.itcodai</li><li>Artifact：填项目名称，本课程中每一课的工程名以<code>course+课号</code>命令，这里使用 course01</li><li>Dependencies：可以添加我们项目中所需要的依赖信息，根据实际情况来添加，本课程只需要选择 Web 即可。</li></ul><h3 id="2-2-官方构建"><a href="#2-2-官方构建" class="headerlink" title="2.2 官方构建"></a>2.2 官方构建</h3><p>第二种方式可以通过官方构建，步骤如下：</p><ul><li>访问 <a href="http://start.spring.io/%E3%80%82">http://start.spring.io/。</a></li><li>在页面上输入相应的 Spring Boot 版本、Group 和 Artifact 信息以及项目依赖，然后创建项目。</li><li><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMuZ2l0Ym9vay5jbi8wMTRhMWJhMC04NjViLTExZTgtOTU2ZS1mNTI4MTE0YjI4YmQ?x-oss-process=image/format,png" alt="创建Spring Boot工程"></li><li>解压后，使用 IDEA 导入该 maven 工程：<code>File-&gt;New-&gt;Model from Existing Source</code>，然后选择解压后的项目文件夹即可。如果是使用 eclipse 的朋友，可以通过<code>Import-&gt;Existing Maven Projects-&gt;Next</code>，然后选择解压后的项目文件夹即可。</li></ul><h3 id="2-3-maven配置"><a href="#2-3-maven配置" class="headerlink" title="2.3 maven配置"></a>2.3 maven配置</h3><p>创建了 Spring Boot 项目之后，需要进行 maven 配置。打开<code>File-&gt;settings</code>，搜索 maven，配置一下本地的 maven 信息。如下：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMuZ2l0Ym9vay5jbi8yZmY3YjkzMC04NjViLTExZTgtODY3NS01NTM3YTcwMWFlN2Q?x-oss-process=image/format,png" alt="maven配置"></p><p>在 Maven home directory 中选择本地 Maven 的安装路径；在 User settings file 中选择本地 Maven 的配置文件所在路径。在配置文件中，我们配置一下国内阿里的镜像，这样在下载 maven 依赖时，速度很快。</p><pre class="line-numbers language-none"><code class="language-none">xml&lt;mirror&gt;&lt;id&gt;nexus-aliyun&lt;/id&gt;&lt;mirrorOf&gt;*&lt;/mirrorOf&gt;&lt;name&gt;Nexus aliyun&lt;/name&gt;&lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;&lt;/mirror&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果是使用 eclipse 的朋友，可以通过<code>window--&gt;preference--&gt;Maven--&gt;User Settings</code>来配置，配置方式和上面一致。</p><h3 id="2-4-编码配置"><a href="#2-4-编码配置" class="headerlink" title="2.4 编码配置"></a>2.4 编码配置</h3><p>同样地，新建项目后，我们一般都需要配置编码，这点非常重要，很多初学者都会忘记这一步，所以要养成良好的习惯。</p><p>IDEA 中，仍然是打开<code>File-&gt;settings</code>，搜索 encoding，配置一下本地的编码信息。如下：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMuZ2l0Ym9vay5jbi81NzU2NGU2MC04NjViLTExZTgtOGE5MS1kNzBiYzJkODQ3YzU?x-oss-process=image/format,png" alt="编码配置"></p><p>如果是使用 eclipse 的朋友，有两个地方需要设置一下编码：</p><ul><li>window–&gt; perferences–&gt;General–&gt;Workspace，将Text file encoding改成utf-8</li><li>window–&gt;perferences–&gt;General–&gt;content types，选中Text，将Default encoding填入utf-8</li></ul><p>OK，编码设置完成即可启动项目工程了。</p><h2 id="3-Spring-Boot-项目工程结构"><a href="#3-Spring-Boot-项目工程结构" class="headerlink" title="3. Spring Boot 项目工程结构"></a>3. Spring Boot 项目工程结构</h2><p>Spring Boot 项目总共有三个模块，如下图所示：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMuZ2l0Ym9vay5jbi84YjMyZmE4MC04NjViLTExZTgtOWQxMy0wM2VhNGI0ZDg1MDQ?x-oss-process=image/format,png" alt="Spring Boot项目工程结构"></p><ul><li>src/main/java路径：主要编写业务程序</li><li>src/main/resources路径：存放静态文件和配置文件</li><li>src/test/java路径：主要编写测试程序</li></ul><p>默认情况下，如上图所示会创建一个启动类 Course01Application，该类上面有个<code>@SpringBootApplication</code>注解，该启动类中有个 main 方法，没错，Spring Boot 启动只要运行该 main 方法即可，非常方便。另外，Spring Boot 内部集成了 tomcat，不需要我们人为手动去配置 tomcat，开发者只需要关注具体的业务逻辑即可。</p><p>到此为止，Spring Boot 就启动成功了，为了比较清楚的看到效果，我们写一个 Controller 来测试一下，如下：</p><pre class="line-numbers language-none"><code class="language-none">javapackage com.itcodai.course01.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@RequestMapping("/start")public class StartController {    @RequestMapping("/springboot")    public String startSpringBoot() {        return "Welcome to the world of Spring Boot!";    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重新运行 main 方法启动项目，在浏览器中输入 <code>localhost:8080/start/springboot</code>，如果看到 <code>“Welcome to the world of Spring Boot!”</code>，那么恭喜你项目启动成功！Spring Boot 就是这么简单方便！端口号默认是8080，如果想要修改，可以在 application.yml 文件中使用 <code>server.port</code> 来人为指定端口，如8001端口：</p><pre class="line-numbers language-none"><code class="language-none">xmlserver:  port: 8001<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>本节我们快速学习了如何在 IDEA 中导入 jdk，以及使用 IDEA 如何配置 maven 和编码，如何快速的创建和启动 Spring Boot 工程。IDEA 对 Spring Boot 的支持非常友好，建议大家使用 IDEA 进行 Spring Boot 的开发，从下一课开始，我们真正进入 Spring Boot 的学习中。<br>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study">戳我下载</a></p><h1 id="第02课：Spring-Boot返回Json数据及数据封装"><a href="#第02课：Spring-Boot返回Json数据及数据封装" class="headerlink" title="第02课：Spring Boot返回Json数据及数据封装"></a>第02课：Spring Boot返回Json数据及数据封装</h1><p>在项目开发中，接口与接口之间，前后端之间数据的传输都使用 Json 格式，在 Spring Boot 中，接口返回 Json 格式的数据很简单，在 Controller 中使用<code>@RestController</code>注解即可返回 Json 格式的数据，<code>@RestController</code>也是 Spring Boot 新增的一个注解，我们点进去看一下该注解都包含了哪些东西。</p><pre class="line-numbers language-none"><code class="language-none">java@Target({ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documented@Controller@ResponseBodypublic @interface RestController {    String value() default "";}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出， <code>@RestController</code> 注解包含了原来的 <code>@Controller</code> 和 <code>@ResponseBody</code> 注解，使用过 Spring 的朋友对 <code>@Controller</code> 注解已经非常了解了，这里不再赘述， <code>@ResponseBody</code> 注解是将返回的数据结构转换为 Json 格式。所以在默认情况下，使用了 <code>@RestController</code> 注解即可将返回的数据结构转换成 Json 格式，Spring Boot 中默认使用的 Json 解析技术框架是 jackson。我们点开 pom.xml 中的 <code>spring-boot-starter-web</code> 依赖，可以看到一个 <code>spring-boot-starter-json</code> 依赖：</p><pre class="line-numbers language-none"><code class="language-none">xml&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-json&lt;/artifactId&gt;    &lt;version&gt;2.0.3.RELEASE&lt;/version&gt;    &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Spring Boot 中对依赖都做了很好的封装，可以看到很多 <code>spring-boot-starter-xxx</code> 系列的依赖，这是 Spring Boot 的特点之一，不需要人为去引入很多相关的依赖了，starter-xxx 系列直接都包含了所必要的依赖，所以我们再次点进去上面这个 <code>spring-boot-starter-json</code> 依赖，可以看到：</p><pre class="line-numbers language-none"><code class="language-none">xml&lt;dependency&gt;    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;    &lt;version&gt;2.9.6&lt;/version&gt;    &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt;    &lt;artifactId&gt;jackson-datatype-jdk8&lt;/artifactId&gt;    &lt;version&gt;2.9.6&lt;/version&gt;    &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt;    &lt;artifactId&gt;jackson-datatype-jsr310&lt;/artifactId&gt;    &lt;version&gt;2.9.6&lt;/version&gt;    &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.fasterxml.jackson.module&lt;/groupId&gt;    &lt;artifactId&gt;jackson-module-parameter-names&lt;/artifactId&gt;    &lt;version&gt;2.9.6&lt;/version&gt;    &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>到此为止，我们知道了 Spring Boot 中默认使用的 json 解析框架是 jackson。下面我们看一下默认的 jackson 框架对常用数据类型的转 Json 处理。</p><h2 id="1-Spring-Boot-默认对Json的处理"><a href="#1-Spring-Boot-默认对Json的处理" class="headerlink" title="1. Spring Boot 默认对Json的处理"></a>1. Spring Boot 默认对Json的处理</h2><p>在实际项目中，常用的数据结构无非有类对象、List对象、Map对象，我们看一下默认的 jackson 框架对这三个常用的数据结构转成 json 后的格式如何。</p><h3 id="1-1-创建-User-实体类"><a href="#1-1-创建-User-实体类" class="headerlink" title="1.1 创建 User 实体类"></a>1.1 创建 User 实体类</h3><p>为了测试，我们需要创建一个实体类，这里我们就用 User 来演示。</p><pre class="line-numbers language-none"><code class="language-none">javapublic class User {    private Long id;    private String username;    private String password;/* 省略get、set和带参构造方法 */}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-创建Controller类"><a href="#1-2-创建Controller类" class="headerlink" title="1.2 创建Controller类"></a>1.2 创建Controller类</h3><p>然后我们创建一个 Controller，分别返回 <code>User</code>对象、<code>List&lt;User&gt;</code> 和 <code>Map&lt;String, Object&gt;</code>。</p><pre class="line-numbers language-none"><code class="language-none">javaimport com.itcodai.course02.entity.User;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;@RestController@RequestMapping("/json")public class JsonController {    @RequestMapping("/user")    public User getUser() {        return new User(1, "倪升武", "123456");    }    @RequestMapping("/list")    public List&lt;User&gt; getUserList() {        List&lt;User&gt; userList = new ArrayList&lt;&gt;();        User user1 = new User(1, "倪升武", "123456");        User user2 = new User(2, "达人课", "123456");        userList.add(user1);        userList.add(user2);        return userList;    }    @RequestMapping("/map")    public Map&lt;String, Object&gt; getMap() {        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(3);        User user = new User(1, "倪升武", "123456");        map.put("作者信息", user);        map.put("博客地址", "http://blog.itcodai.com");        map.put("CSDN地址", "http://blog.csdn.net/eson_15");        map.put("粉丝数量", 4153);        return map;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-3-测试不同数据类型返回的json"><a href="#1-3-测试不同数据类型返回的json" class="headerlink" title="1.3 测试不同数据类型返回的json"></a>1.3 测试不同数据类型返回的json</h3><p>OK，写好了接口，分别返回了一个 User 对象、一个 List 集合和一个 Map 集合，其中 Map 集合中的 value 存的是不同的数据类型。接下来我们依次来测试一下效果。</p><p>在浏览器中输入：<code>localhost:8080/json/user</code> 返回 json 如下：</p><pre class="line-numbers language-none"><code class="language-none">json{"id":1,"username":"倪升武","password":"123456"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在浏览器中输入：<code>localhost:8080/json/list</code> 返回 json 如下：</p><pre class="line-numbers language-none"><code class="language-none">json[{"id":1,"username":"倪升武","password":"123456"},{"id":2,"username":"达人课","password":"123456"}]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在浏览器中输入：<code>localhost:8080/json/map</code> 返回 json 如下：</p><pre class="line-numbers language-none"><code class="language-none">json{"作者信息":{"id":1,"username":"倪升武","password":"123456"},"CSDN地址":"http://blog.csdn.net/eson_15","粉丝数量":4153,"博客地址":"http://blog.itcodai.com"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以看出，map 中不管是什么数据类型，都可以转成相应的 json 格式，这样就非常方便。</p><h3 id="1-4-jackson-中对null的处理"><a href="#1-4-jackson-中对null的处理" class="headerlink" title="1.4 jackson 中对null的处理"></a>1.4 jackson 中对null的处理</h3><p>在实际项目中，我们难免会遇到一些 null 值出现，我们转 json 时，是不希望有这些 null 出现的，比如我们期望所有的 null 在转 json 时都变成 “” 这种空字符串，那怎么做呢？在 Spring Boot 中，我们做一下配置即可，新建一个 jackson 的配置类：</p><pre class="line-numbers language-none"><code class="language-none">javaimport com.fasterxml.jackson.core.JsonGenerator;import com.fasterxml.jackson.databind.JsonSerializer;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.SerializerProvider;import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Primary;import org.springframework.http.converter.json.Jackson2ObjectMapperBuilder;import java.io.IOException;@Configurationpublic class JacksonConfig {    @Bean    @Primary    @ConditionalOnMissingBean(ObjectMapper.class)    public ObjectMapper jacksonObjectMapper(Jackson2ObjectMapperBuilder builder) {        ObjectMapper objectMapper = builder.createXmlMapper(false).build();        objectMapper.getSerializerProvider().setNullValueSerializer(new JsonSerializer&lt;Object&gt;() {            @Override            public void serialize(Object o, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException {                jsonGenerator.writeString("");            }        });        return objectMapper;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后我们修改一下上面返回 map 的接口，将几个值改成 null 测试一下：</p><pre class="line-numbers language-none"><code class="language-none">java@RequestMapping("/map")public Map&lt;String, Object&gt; getMap() {    Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(3);    User user = new User(1, "倪升武", null);    map.put("作者信息", user);    map.put("博客地址", "http://blog.itcodai.com");    map.put("CSDN地址", null);    map.put("粉丝数量", 4153);    return map;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重启项目，再次输入：<code>localhost:8080/json/map</code>，可以看到 jackson 已经将所有 null 字段转成了空字符串了。</p><pre class="line-numbers language-none"><code class="language-none">json{"作者信息":{"id":1,"username":"倪升武","password":""},"CSDN地址":"","粉丝数量":4153,"博客地址":"http://blog.itcodai.com"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="2-使用阿里巴巴FastJson的设置"><a href="#2-使用阿里巴巴FastJson的设置" class="headerlink" title="2. 使用阿里巴巴FastJson的设置"></a>2. 使用阿里巴巴FastJson的设置</h2><h3 id="2-1-jackson-和-fastJson-的对比"><a href="#2-1-jackson-和-fastJson-的对比" class="headerlink" title="2.1 jackson 和 fastJson 的对比"></a>2.1 jackson 和 fastJson 的对比</h3><p>有很多朋友习惯于使用阿里巴巴的 fastJson 来做项目中 json 转换的相关工作，目前我们项目中使用的就是阿里的 fastJson，那么 jackson 和 fastJson 有哪些区别呢？根据网上公开的资料比较得到下表。</p><table><thead><tr><th align="center">选项</th><th align="center">fastJson</th><th align="center">jackson</th></tr></thead><tbody><tr><td align="center">上手难易程度</td><td align="center">容易</td><td align="center">中等</td></tr><tr><td align="center">高级特性支持</td><td align="center">中等</td><td align="center">丰富</td></tr><tr><td align="center">官方文档、Example支持</td><td align="center">中文</td><td align="center">英文</td></tr><tr><td align="center">处理json速度</td><td align="center">略快</td><td align="center">快</td></tr></tbody></table><p>关于 fastJson 和 jackson 的对比，网上有很多资料可以查看，主要是根据自己实际项目情况来选择合适的框架。从扩展上来看，fastJson 没有 jackson 灵活，从速度或者上手难度来看，fastJson 可以考虑，我们项目中目前使用的是阿里的 fastJson，挺方便的。</p><h3 id="2-2-fastJson依赖导入"><a href="#2-2-fastJson依赖导入" class="headerlink" title="2.2 fastJson依赖导入"></a>2.2 fastJson依赖导入</h3><p>使用 fastJson 需要导入依赖，本课程使用 1.2.35 版本，依赖如下：</p><pre class="line-numbers language-none"><code class="language-none">xml&lt;dependency&gt;&lt;groupId&gt;com.alibaba&lt;/groupId&gt;&lt;artifactId&gt;fastjson&lt;/artifactId&gt;&lt;version&gt;1.2.35&lt;/version&gt;&lt;/dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-使用-fastJson-处理-null"><a href="#2-2-使用-fastJson-处理-null" class="headerlink" title="2.2 使用 fastJson 处理 null"></a>2.2 使用 fastJson 处理 null</h3><p>使用 fastJson 时，对 null 的处理和 jackson 有些不同，需要继承 <code>WebMvcConfigurationSupport</code> 类，然后覆盖 <code>configureMessageConverters</code> 方法，在方法中，我们可以选择对要实现 null 转换的场景，配置好即可。如下：</p><pre class="line-numbers language-none"><code class="language-none">javaimport com.alibaba.fastjson.serializer.SerializerFeature;import com.alibaba.fastjson.support.config.FastJsonConfig;import com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter;import org.springframework.context.annotation.Configuration;import org.springframework.http.MediaType;import org.springframework.http.converter.HttpMessageConverter;import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;import java.nio.charset.Charset;import java.util.ArrayList;import java.util.List;@Configurationpublic class fastJsonConfig extends WebMvcConfigurationSupport {    /**     * 使用阿里 FastJson 作为JSON MessageConverter     * @param converters     */    @Override    public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) {        FastJsonHttpMessageConverter converter = new FastJsonHttpMessageConverter();        FastJsonConfig config = new FastJsonConfig();        config.setSerializerFeatures(                // 保留map空的字段                SerializerFeature.WriteMapNullValue,                // 将String类型的null转成""                SerializerFeature.WriteNullStringAsEmpty,                // 将Number类型的null转成0                SerializerFeature.WriteNullNumberAsZero,                // 将List类型的null转成[]                SerializerFeature.WriteNullListAsEmpty,                // 将Boolean类型的null转成false                SerializerFeature.WriteNullBooleanAsFalse,                // 避免循环引用                SerializerFeature.DisableCircularReferenceDetect);        converter.setFastJsonConfig(config);        converter.setDefaultCharset(Charset.forName("UTF-8"));        List&lt;MediaType&gt; mediaTypeList = new ArrayList&lt;&gt;();        // 解决中文乱码问题，相当于在Controller上的@RequestMapping中加了个属性produces = "application/json"        mediaTypeList.add(MediaType.APPLICATION_JSON);        converter.setSupportedMediaTypes(mediaTypeList);        converters.add(converter);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-封装统一返回的数据结构"><a href="#3-封装统一返回的数据结构" class="headerlink" title="3. 封装统一返回的数据结构"></a>3. 封装统一返回的数据结构</h2><p>以上是 Spring Boot 返回 json 的几个代表的例子，但是在实际项目中，除了要封装数据之外，我们往往需要在返回的 json 中添加一些其他信息，比如返回一些状态码 code ，返回一些 msg 给调用者，这样调用者可以根据 code 或者 msg 做一些逻辑判断。所以在实际项目中，我们需要封装一个统一的 json 返回结构存储返回信息。</p><h3 id="3-1-定义统一的-json-结构"><a href="#3-1-定义统一的-json-结构" class="headerlink" title="3.1 定义统一的 json 结构"></a>3.1 定义统一的 json 结构</h3><p>由于封装的 json 数据的类型不确定，所以在定义统一的 json 结构时，我们需要用到泛型。统一的 json 结构中属性包括数据、状态码、提示信息即可，构造方法可以根据实际业务需求做相应的添加即可，一般来说，应该有默认的返回结构，也应该有用户指定的返回结构。如下：</p><pre class="line-numbers language-none"><code class="language-none">javapublic class JsonResult&lt;T&gt; {    private T data;    private String code;    private String msg;    /**     * 若没有数据返回，默认状态码为0，提示信息为：操作成功！     */    public JsonResult() {        this.code = "0";        this.msg = "操作成功！";    }    /**     * 若没有数据返回，可以人为指定状态码和提示信息     * @param code     * @param msg     */    public JsonResult(String code, String msg) {        this.code = code;        this.msg = msg;    }    /**     * 有数据返回时，状态码为0，默认提示信息为：操作成功！     * @param data     */    public JsonResult(T data) {        this.data = data;        this.code = "0";        this.msg = "操作成功！";    }    /**     * 有数据返回，状态码为0，人为指定提示信息     * @param data     * @param msg     */    public JsonResult(T data, String msg) {        this.data = data;        this.code = "0";        this.msg = msg;    }    // 省略get和set方法}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-修改-Controller-中的返回值类型及测试"><a href="#3-2-修改-Controller-中的返回值类型及测试" class="headerlink" title="3.2 修改 Controller 中的返回值类型及测试"></a>3.2 修改 Controller 中的返回值类型及测试</h3><p>由于 JsonResult 使用了泛型，所以所有的返回值类型都可以使用该统一结构，在具体的场景将泛型替换成具体的数据类型即可，非常方便，也便于维护。在实际项目中，还可以继续封装，比如状态码和提示信息可以定义一个枚举类型，以后我们只需要维护这个枚举类型中的数据即可（在本课程中就不展开了）。根据以上的 JsonResult，我们改写一下 Controller，如下：</p><pre class="line-numbers language-none"><code class="language-none">java@RestController@RequestMapping("/jsonresult")public class JsonResultController {    @RequestMapping("/user")    public JsonResult&lt;User&gt; getUser() {        User user = new User(1, "倪升武", "123456");        return new JsonResult&lt;&gt;(user);    }    @RequestMapping("/list")    public JsonResult&lt;List&gt; getUserList() {        List&lt;User&gt; userList = new ArrayList&lt;&gt;();        User user1 = new User(1, "倪升武", "123456");        User user2 = new User(2, "达人课", "123456");        userList.add(user1);        userList.add(user2);        return new JsonResult&lt;&gt;(userList, "获取用户列表成功");    }    @RequestMapping("/map")    public JsonResult&lt;Map&gt; getMap() {        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(3);        User user = new User(1, "倪升武", null);        map.put("作者信息", user);        map.put("博客地址", "http://blog.itcodai.com");        map.put("CSDN地址", null);        map.put("粉丝数量", 4153);        return new JsonResult&lt;&gt;(map);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们重新在浏览器中输入：<code>localhost:8080/jsonresult/user</code> 返回 json 如下：</p><pre class="line-numbers language-none"><code class="language-none">json{"code":"0","data":{"id":1,"password":"123456","username":"倪升武"},"msg":"操作成功！"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>输入：<code>localhost:8080/jsonresult/list</code>，返回 json 如下：</p><pre class="line-numbers language-none"><code class="language-none">json{"code":"0","data":[{"id":1,"password":"123456","username":"倪升武"},{"id":2,"password":"123456","username":"达人课"}],"msg":"获取用户列表成功"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>输入：<code>localhost:8080/jsonresult/map</code>，返回 json 如下：</p><pre class="line-numbers language-none"><code class="language-none">json{"code":"0","data":{"作者信息":{"id":1,"password":"","username":"倪升武"},"CSDN地址":null,"粉丝数量":4153,"博客地址":"http://blog.itcodai.com"},"msg":"操作成功！"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>通过封装，我们不但将数据通过 json 传给前端或者其他接口，还带上了状态码和提示信息，这在实际项目场景中应用非常广泛。</p><h2 id="4-总结-1"><a href="#4-总结-1" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>本节主要对 Spring Boot 中 json 数据的返回做了详细的分析，从 Spring Boot 默认的 jackson 框架到阿里巴巴的 fastJson 框架，分别对它们的配置做了相应的讲解。另外，结合实际项目情况，总结了实际项目中使用的 json 封装结构体，加入了状态码和提示信息，使得返回的 json 数据信息更加完整。<br>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study">戳我下载</a></p><h1 id="第03课：Spring-Boot使用slf4j进行日志记录"><a href="#第03课：Spring-Boot使用slf4j进行日志记录" class="headerlink" title="第03课：Spring Boot使用slf4j进行日志记录"></a>第03课：Spring Boot使用slf4j进行日志记录</h1><p>在开发中，我们经常使用 <code>System.out.println()</code> 来打印一些信息，但是这样不好，因为大量的使用 <code>System.out</code> 会增加资源的消耗。我们实际项目中使用的是 slf4j 的 logback 来输出日志，效率挺高的，Spring Boot 提供了一套日志系统，logback 是最优的选择。</p><h2 id="1-slf4j-介绍"><a href="#1-slf4j-介绍" class="headerlink" title="1. slf4j 介绍"></a>1. slf4j 介绍</h2><p>引用百度百科里的一段话：</p><blockquote><p>SLF4J，即简单日志门面（Simple Logging Facade for Java），不是具体的日志解决方案，它只服务于各种各样的日志系统。按照官方的说法，SLF4J是一个用于日志系统的简单Facade，允许最终用户在部署其应用时使用其所希望的日志系统。</p></blockquote><p>这段的大概意思是：你只需要按统一的方式写记录日志的代码，而无需关心日志是通过哪个日志系统，以什么风格输出的。因为它们取决于部署项目时绑定的日志系统。例如，在项目中使用了 slf4j 记录日志，并且绑定了 log4j（即导入相应的依赖），则日志会以 log4j 的风格输出；后期需要改为以 logback 的风格输出日志，只需要将 log4j 替换成 logback 即可，不用修改项目中的代码。这对于第三方组件的引入的不同日志系统来说几乎零学习成本，况且它的优点不仅仅这一个而已，还有简洁的占位符的使用和日志级别的判断。</p><p>正因为 sfl4j 有如此多的优点，阿里巴巴已经将 slf4j 作为他们的日志框架了。在《阿里巴巴Java开发手册(正式版)》中，日志规约一项第一条就强制要求使用 slf4j：</p><blockquote><p>1.【强制】应用中不可直接使用日志系统（Log4j、Logback）中的API，而应依赖使用日志框架SLF4J中的API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。</p></blockquote><p>“强制”两个字体现出了 slf4j 的优势，所以建议在实际项目中，使用 slf4j 作为自己的日志框架。使用 slf4j 记录日志非常简单，直接使用 LoggerFactory 创建即可。</p><pre class="line-numbers language-none"><code class="language-none">javaimport org.slf4j.Logger;import org.slf4j.LoggerFactory;public class Test {    private static final Logger logger = LoggerFactory.getLogger(Test.class);    // ……}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-application-yml-中对日志的配置"><a href="#2-application-yml-中对日志的配置" class="headerlink" title="2. application.yml 中对日志的配置"></a>2. application.yml 中对日志的配置</h2><p>Spring Boot 对 slf4j 支持的很好，内部已经集成了 slf4j，一般我们在使用的时候，会对slf4j 做一下配置。<code>application.yml</code> 文件是 Spring Boot 中唯一一个需要配置的文件，一开始创建工程的时候是 <code>application.properties</code> 文件，个人比较细化用 yml 文件，因为 yml 文件的层次感特别好，看起来更直观，但是 yml 文件对格式要求比较高，比如英文冒号后面必须要有个空格，否则项目估计无法启动，而且也不报错。用 properties 还是 yml 视个人习惯而定，都可以。本课程使用 yml。</p><p>我们看一下 application.yml 文件中对日志的配置：</p><pre class="line-numbers language-none"><code class="language-none">xmllogging:  config: logback.xml  level:    com.itcodai.course03.dao: trace<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>logging.config</code> 是用来指定项目启动的时候，读取哪个配置文件，这里指定的是日志配置文件是根路径下的 <code>logback.xml</code> 文件，关于日志的相关配置信息，都放在 <code>logback.xml</code> 文件中了。<code>logging.level</code> 是用来指定具体的 mapper 中日志的输出级别，上面的配置表示 <code>com.itcodai.course03.dao</code> 包下的所有 mapper 日志输出级别为 trace，会将操作数据库的 sql 打印出来，开发时设置成 trace 方便定位问题，在生产环境上，将这个日志级别再设置成 error 级别即可（本节课不讨论 mapper 层，在后面 Spring Boot 集成 MyBatis 时再详细讨论）。</p><p>常用的日志级别按照从高到低依次为：ERROR、WARN、INFO、DEBUG。</p><h2 id="3-logback-xml-配置文件解析"><a href="#3-logback-xml-配置文件解析" class="headerlink" title="3. logback.xml 配置文件解析"></a>3. logback.xml 配置文件解析</h2><p>在上面 <code>application.yml</code> 文件中，我们指定了日志配置文件 <code>logback.xml</code>，<code>logback.xml</code> 文件中主要用来做日志的相关配置。在 <code>logback.xml</code> 中，我们可以定义日志输出的格式、路径、控制台输出格式、文件大小、保存时长等等。下面来分析一下：</p><h3 id="3-1-定义日志输出格式和存储路径"><a href="#3-1-定义日志输出格式和存储路径" class="headerlink" title="3.1 定义日志输出格式和存储路径"></a>3.1 定义日志输出格式和存储路径</h3><pre class="line-numbers language-none"><code class="language-none">xml&lt;configuration&gt;&lt;property name="LOG_PATTERN" value="%date{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n" /&gt;&lt;property name="FILE_PATH" value="D:/logs/course03/demo.%d{yyyy-MM-dd}.%i.log" /&gt;&lt;/configuration&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们来看一下这个定义的含义：首先定义一个格式，命名为 “LOG_PATTERN”，该格式中 <code>%date</code> 表示日期，<code>%thread</code> 表示线程名，<code>%-5level</code> 表示级别从左显示5个字符宽度，<code>%logger{36}</code> 表示 logger 名字最长36个字符，<code>%msg</code> 表示日志消息，<code>%n</code> 是换行符。</p><p>然后再定义一下名为 “FILE_PATH” 文件路径，日志都会存储在该路径下。<code>%i</code> 表示第 i 个文件，当日志文件达到指定大小时，会将日志生成到新的文件里，这里的 i 就是文件索引，日志文件允许的大小可以设置，下面会讲解。这里需要注意的是，不管是 windows 系统还是 Linux 系统，日志存储的路径必须要是绝对路径。</p><h3 id="3-2-定义控制台输出"><a href="#3-2-定义控制台输出" class="headerlink" title="3.2 定义控制台输出"></a>3.2 定义控制台输出</h3><pre class="line-numbers language-none"><code class="language-none">xml&lt;configuration&gt;&lt;appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender"&gt;&lt;encoder&gt;            &lt;!-- 按照上面配置的LOG_PATTERN来打印日志 --&gt;&lt;pattern&gt;${LOG_PATTERN}&lt;/pattern&gt;&lt;/encoder&gt;&lt;/appender&gt;&lt;/configuration&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用 <code>&lt;appender&gt;</code> 节点设置个控制台输出（<code>class="ch.qos.logback.core.ConsoleAppender"</code>）的配置，定义为 “CONSOLE”。使用上面定义好的输出格式（LOG_PATTERN）来输出，使用 <code>${}</code> 引用进来即可。</p><h3 id="3-3-定义日志文件的相关参数"><a href="#3-3-定义日志文件的相关参数" class="headerlink" title="3.3 定义日志文件的相关参数"></a>3.3 定义日志文件的相关参数</h3><pre class="line-numbers language-none"><code class="language-none">xml&lt;configuration&gt;&lt;appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt;&lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt;&lt;!-- 按照上面配置的FILE_PATH路径来保存日志 --&gt;&lt;fileNamePattern&gt;${FILE_PATH}&lt;/fileNamePattern&gt;&lt;!-- 日志保存15天 --&gt;&lt;maxHistory&gt;15&lt;/maxHistory&gt;&lt;timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"&gt;&lt;!-- 单个日志文件的最大，超过则新建日志文件存储 --&gt;&lt;maxFileSize&gt;10MB&lt;/maxFileSize&gt;&lt;/timeBasedFileNamingAndTriggeringPolicy&gt;&lt;/rollingPolicy&gt;&lt;encoder&gt;&lt;!-- 按照上面配置的LOG_PATTERN来打印日志 --&gt;&lt;pattern&gt;${LOG_PATTERN}&lt;/pattern&gt;&lt;/encoder&gt;&lt;/appender&gt;&lt;/configuration&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用 <code>&lt;appender&gt;</code> 定义一个名为 “FILE” 的文件配置，主要是配置日志文件保存的时间、单个日志文件存储的大小、以及文件保存的路径和日志的输出格式。</p><h3 id="3-4-定义日志输出级别"><a href="#3-4-定义日志输出级别" class="headerlink" title="3.4 定义日志输出级别"></a>3.4 定义日志输出级别</h3><pre class="line-numbers language-none"><code class="language-none">xml&lt;configuration&gt;&lt;logger name="com.itcodai.course03" level="INFO" /&gt;&lt;root level="INFO"&gt;&lt;appender-ref ref="CONSOLE" /&gt;&lt;appender-ref ref="FILE" /&gt;&lt;/root&gt;&lt;/configuration&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有了上面那些定义后，最后我们使用 <code>&lt;logger&gt;</code> 来定义一下项目中默认的日志输出级别，这里定义级别为 INFO，然后针对 INFO 级别的日志，使用 <code>&lt;root&gt;</code> 引用上面定义好的控制台日志输出和日志文件的参数。这样 logback.xml 文件中的配置就设置完了。</p><h2 id="4-使用Logger在项目中打印日志"><a href="#4-使用Logger在项目中打印日志" class="headerlink" title="4. 使用Logger在项目中打印日志"></a>4. 使用Logger在项目中打印日志</h2><p>在代码中，我们一般使用 Logger 对象来打印出一些 log 信息，可以指定打印出的日志级别，也支持占位符，很方便。</p><pre class="line-numbers language-none"><code class="language-none">javaimport org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@RequestMapping("/test")public class TestController {    private final static Logger logger = LoggerFactory.getLogger(TestController.class);    @RequestMapping("/log")    public String testLog() {        logger.debug("=====测试日志debug级别打印====");        logger.info("======测试日志info级别打印=====");        logger.error("=====测试日志error级别打印====");        logger.warn("======测试日志warn级别打印=====");        // 可以使用占位符打印出一些参数信息        String str1 = "blog.itcodai.com";        String str2 = "blog.csdn.net/eson_15";        logger.info("======倪升武的个人博客：{}；倪升武的CSDN博客：{}", str1, str2);        return "success";    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>启动该项目，在浏览器中输入 <code>localhost:8080/test/log</code> 后可以看到控制台的日志记录：</p><blockquote><p>======测试日志info级别打印=====<br>=====测试日志error级别打印====<br>======测试日志warn级别打印=====<br>======倪升武的个人博客：blog.itcodai.com；倪升武的CSDN博客：blog.csdn.net/eson_15</p></blockquote><p>因为 INFO 级别比 DEBUG 级别高，所以 debug 这条没有打印出来，如果将 logback.xml 中的日志级别设置成 DEBUG，那么四条语句都会打印出来，这个大家自己去测试了。同时可以打开 D:\logs\course03\ 目录，里面有刚刚项目启动，以后后面生成的所有日志记录。在项目部署后，我们大部分都是通过查看日志文件来定位问题。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>本节课主要对 slf4j 做了一个简单的介绍，并且对 Spring Boot 中如何使用 slf4j 输出日志做了详细的说明，着重分析了 <code>logback.xml</code> 文件中对日志相关信息的配置，包括日志的不同级别。最后针对这些配置，在代码中使用 Logger 打印出一些进行测试。在实际项目中，这些日志都是排查问题的过程中非常重要的资料。<br>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study">戳我下载</a></p><h1 id="第04课：Spring-Boot中的项目属性配置"><a href="#第04课：Spring-Boot中的项目属性配置" class="headerlink" title="第04课：Spring Boot中的项目属性配置"></a>第04课：Spring Boot中的项目属性配置</h1><p>我们知道，在项目中，很多时候需要用到一些配置的信息，这些信息可能在测试环境和生产环境下会有不同的配置，后面根据实际业务情况有可能还会做修改，针对这种情况，我们不能将这些配置在代码中写死，最好就是写到配置文件中。比如可以把这些信息写到 <code>application.yml</code> 文件中。</p><h2 id="1-少量配置信息的情形"><a href="#1-少量配置信息的情形" class="headerlink" title="1. 少量配置信息的情形"></a>1. 少量配置信息的情形</h2><p>举个例子，在微服务架构中，最常见的就是某个服务需要调用其他服务来获取其提供的相关信息，那么在该服务的配置文件中需要配置被调用的服务地址，比如在当前服务里，我们需要调用订单微服务获取订单相关的信息，假设 订单服务的端口号是 8002，那我们可以做如下配置：</p><pre class="line-numbers language-none"><code class="language-none">xmlserver:  port: 8001# 配置微服务的地址url:  # 订单微服务的地址  orderUrl: http://localhost:8002<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后在业务代码中如何获取到这个配置的订单服务地址呢？我们可以使用 <code>@Value</code> 注解来解决。在对应的类中加上一个属性，在属性上使用 <code>@Value</code> 注解即可获取到配置文件中的配置信息，如下：</p><pre class="line-numbers language-none"><code class="language-none">javaimport org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@RequestMapping("/test")public class ConfigController {    private static final Logger LOGGER = LoggerFactory.getLogger(ConfigController.class);    @Value("${url.orderUrl}")    private String orderUrl;        @RequestMapping("/config")    public String testConfig() {        LOGGER.info("=====获取的订单服务地址为：{}", orderUrl);        return "success";    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>@Value</code> 注解上通过 <code>${key}</code> 即可获取配置文件中和 key 对应的 value 值。我们启动一下项目，在浏览器中输入 <code>localhost:8080/test/config</code> 请求服务后，可以看到控制台会打印出订单服务的地址：</p><pre class="line-numbers language-none"><code class="language-none">plain=====获取的订单服务地址为：http://localhost:8002<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>说明我们成功获取到了配置文件中的订单微服务地址，在实际项目中也是这么用的，后面如果因为服务器部署的原因，需要修改某个服务的地址，那么只要在配置文件中修改即可。</p><h2 id="2-多个配置信息的情形"><a href="#2-多个配置信息的情形" class="headerlink" title="2. 多个配置信息的情形"></a>2. 多个配置信息的情形</h2><p>这里再引申一个问题，随着业务复杂度的增加，一个项目中可能会有越来越多的微服务，某个模块可能需要调用多个微服务获取不同的信息，那么就需要在配置文件中配置多个微服务的地址。可是，在需要调用这些微服务的代码中，如果这样一个个去使用 <code>@Value</code> 注解引入相应的微服务地址的话，太过于繁琐，也不科学。</p><p>所以，在实际项目中，业务繁琐，逻辑复杂的情况下，需要考虑封装一个或多个配置类。举个例子：假如在当前服务中，某个业务需要同时调用订单微服务、用户微服务和购物车微服务，分别获取订单、用户和购物车相关信息，然后对这些信息做一定的逻辑处理。那么在配置文件中，我们需要将这些微服务的地址都配置好：</p><pre class="line-numbers language-none"><code class="language-none">xml# 配置多个微服务的地址url:  # 订单微服务的地址  orderUrl: http://localhost:8002  # 用户微服务的地址  userUrl: http://localhost:8003  # 购物车微服务的地址  shoppingUrl: http://localhost:8004<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也许实际业务中，远远不止这三个微服务，甚至十几个都有可能。对于这种情况，我们可以先定义一个 <code>MicroServiceUrl</code> 类来专门保存微服务的 url，如下：</p><pre class="line-numbers language-none"><code class="language-none">java@Component@ConfigurationProperties(prefix = "url")public class MicroServiceUrl {    private String orderUrl;    private String userUrl;    private String shoppingUrl;    // 省去get和set方法}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>细心的朋友应该可以看到，使用 <code>@ConfigurationProperties</code> 注解并且使用 prefix 来指定一个前缀，然后该类中的属性名就是配置中去掉前缀后的名字，一一对应即可。即：前缀名 + 属性名就是配置文件中定义的 key。同时，该类上面需要加上 <code>@Component</code> 注解，把该类作为组件放到Spring容器中，让 Spring 去管理，我们使用的时候直接注入即可。</p><p>需要注意的是，使用 <code>@ConfigurationProperties</code> 注解需要导入它的依赖：</p><pre class="line-numbers language-none"><code class="language-none">xml&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;&lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>OK，到此为止，我们将配置写好了，接下来写个 Controller 来测试一下。此时，不需要在代码中一个个引入这些微服务的 url 了，直接通过 <code>@Resource</code> 注解将刚刚写好配置类注入进来即可使用了，非常方便。如下：</p><pre class="line-numbers language-none"><code class="language-none">java@RestController@RequestMapping("/test")public class TestController {    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);    @Resource    private MicroServiceUrl microServiceUrl;        @RequestMapping("/config")    public String testConfig() {        LOGGER.info("=====获取的订单服务地址为：{}", microServiceUrl.getOrderUrl());        LOGGER.info("=====获取的用户服务地址为：{}", microServiceUrl.getUserUrl());        LOGGER.info("=====获取的购物车服务地址为：{}", microServiceUrl.getShoppingUrl());        return "success";    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再次启动项目，请求一下可以看到，控制台打印出如下信息，说明配置文件生效，同时正确获取配置文件内容：</p><pre class="line-numbers language-none"><code class="language-none">plain=====获取的订单服务地址为：http://localhost:8002=====获取的订单服务地址为：http://localhost:8002=====获取的用户服务地址为：http://localhost:8003=====获取的购物车服务地址为：http://localhost:8004<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-指定项目配置文件"><a href="#3-指定项目配置文件" class="headerlink" title="3. 指定项目配置文件"></a>3. 指定项目配置文件</h2><p>我们知道，在实际项目中，一般有两个环境：开发环境和生产环境。开发环境中的配置和生产环境中的配置往往不同，比如：环境、端口、数据库、相关地址等等。我们不可能在开发环境调试好之后，部署到生产环境后，又要将配置信息全部修改成生产环境上的配置，这样太麻烦，也不科学。</p><p>最好的解决方法就是开发环境和生产环境都有一套对用的配置信息，然后当我们在开发时，指定读取开发环境的配置，当我们将项目部署到服务器上之后，再指定去读取生产环境的配置。</p><p>我们新建两个配置文件： <code>application-dev.yml</code> 和 <code>application-pro.yml</code>，分别用来对开发环境和生产环境进行相关配置。这里为了方便，我们分别设置两个访问端口号，开发环境用 8001，生产环境用 8002.</p><pre class="line-numbers language-none"><code class="language-none">xml# 开发环境配置文件server:  port: 8001xml# 开发环境配置文件server:  port: 8002<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后在 <code>application.yml</code> 文件中指定读取哪个配置文件即可。比如我们在开发环境下，指定读取 <code>applicationn-dev.yml</code> 文件，如下：</p><pre class="line-numbers language-none"><code class="language-none">xmlspring:  profiles:    active:    - dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样就可以在开发的时候，指定读取 <code>application-dev.yml</code> 文件，访问的时候使用 8001 端口，部署到服务器后，只需要将 <code>application.yml</code> 中指定的文件改成 <code>application-pro.yml</code> 即可，然后使用 8002 端口访问，非常方便。</p><h2 id="4-总结-2"><a href="#4-总结-2" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>本节课主要讲解了 Spring Boot 中如何在业务代码中读取相关配置，包括单一配置和多个配置项，在微服务中，这种情况非常常见，往往会有很多其他微服务需要调用，所以封装一个配置类来接收这些配置是个很好的处理方式。除此之外，例如数据库相关的连接参数等等，也可以放到一个配置类中，其他遇到类似的场景，都可以这么处理。最后介绍了开发环境和生产环境配置的快速切换方式，省去了项目部署时，诸多配置信息的修改。<br>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study">戳我下载</a></p><h1 id="第05课：Spring-Boot中的MVC支持"><a href="#第05课：Spring-Boot中的MVC支持" class="headerlink" title="第05课：Spring Boot中的MVC支持"></a>第05课：Spring Boot中的MVC支持</h1><p>Spring Boot 的 MVC 支持主要来介绍实际项目中最常用的几个注解，包括 <code>@RestController</code>、 <code>@RequestMapping</code>、<code>@PathVariable</code>、<code>@RequestParam</code> 以及 <code>@RequestBody</code>。主要介绍这几个注解常用的使用方式和特点。</p><h2 id="1-RestController"><a href="#1-RestController" class="headerlink" title="1. @RestController"></a>1. @RestController</h2><p><code>@RestController</code> 是 Spring Boot 新增的一个注解，我们看一下该注解都包含了哪些东西。</p><pre class="line-numbers language-none"><code class="language-none">java@Target({ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documented@Controller@ResponseBodypublic @interface RestController {    String value() default "";}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出， <code>@RestController</code> 注解包含了原来的 <code>@Controller</code> 和 <code>@ResponseBody</code> 注解，使用过 Spring 的朋友对 <code>@Controller</code> 注解已经非常了解了，这里不再赘述， <code>@ResponseBody</code> 注解是将返回的数据结构转换为 Json 格式。所以 <code>@RestController</code> 可以看作是 <code>@Controller</code> 和 <code>@ResponseBody</code> 的结合体，相当于偷个懒，我们使用 <code>@RestController</code> 之后就不用再使用 <code>@Controller</code> 了。但是需要注意一个问题：如果是前后端分离，不用模板渲染的话，比如 Thymeleaf，这种情况下是可以直接使用<code>@RestController</code> 将数据以 json 格式传给前端，前端拿到之后解析；但如果不是前后端分离，需要使用模板来渲染的话，一般 Controller 中都会返回到具体的页面，那么此时就不能使用<code>@RestController</code>了，比如：</p><pre class="line-numbers language-none"><code class="language-none">javapublic String getUser() {return "user";}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实是需要返回到 user.html 页面的，如果使用 <code>@RestController</code> 的话，会将 user 作为字符串返回的，所以这时候我们需要使用 <code>@Controller</code> 注解。这在下一节 Spring Boot 集成 Thymeleaf 模板引擎中会再说明。</p><h2 id="2-RequestMapping"><a href="#2-RequestMapping" class="headerlink" title="2. @RequestMapping"></a>2. @RequestMapping</h2><p><code>@RequestMapping</code> 是一个用来处理请求地址映射的注解，它可以用于类上，也可以用于方法上。在类的级别上的注解会将一个特定请求或者请求模式映射到一个控制器之上，表示类中的所有响应请求的方法都是以该地址作为父路径；在方法的级别表示进一步指定到处理方法的映射关系。</p><p>该注解有6个属性，一般在项目中比较常用的有三个属性：value、method 和 produces。</p><ul><li>value 属性：指定请求的实际地址，value 可以省略不写</li><li>method 属性：指定请求的类型，主要有 GET、PUT、POST、DELETE，默认为 GET</li><li>produces属性：指定返回内容类型，如 produces = “application/json; charset=UTF-8”</li></ul><p><code>@RequestMapping</code> 注解比较简单，举个例子：</p><pre class="line-numbers language-none"><code class="language-none">java@RestController@RequestMapping(value = "/test", produces = "application/json; charset=UTF-8")public class TestController {    @RequestMapping(value = "/get", method = RequestMethod.GET)    public String testGet() {        return "success";    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个很简单，启动项目在浏览器中输入 <code>localhost:8080/test/get</code> 测试一下即可。</p><p>针对四种不同的请求方式，是有相应注解的，不用每次在 <code>@RequestMapping</code> 注解中加 method 属性来指定，上面的 GET 方式请求可以直接使用 <code>@GetMapping("/get")</code> 注解，效果一样。相应地，PUT 方式、POST 方式和 DELETE 方式对应的注解分别为 <code>@PutMapping</code>、<code>@PostMapping</code> 和 <code>DeleteMapping</code>。</p><h2 id="3-PathVariable"><a href="#3-PathVariable" class="headerlink" title="3. @PathVariable"></a>3. @PathVariable</h2><p><code>@PathVariable</code> 注解主要是用来获取 url 参数，Spring Boot 支持 restfull 风格的 url，比如一个 GET 请求携带一个参数 id 过来，我们将 id 作为参数接收，可以使用 <code>@PathVariable</code> 注解。如下：</p><pre class="line-numbers language-none"><code class="language-none">java@GetMapping("/user/{id}")public String testPathVariable(@PathVariable Integer id) {System.out.println("获取到的id为：" + id);return "success";}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里需要注意一个问题，如果想要 url 中占位符中的 id 值直接赋值到参数 id 中，需要保证 url 中的参数和方法接收参数一致，否则就无法接收。如果不一致的话，其实也可以解决，需要用 <code>@PathVariable</code> 中的 value 属性来指定对应关系。如下：</p><pre class="line-numbers language-none"><code class="language-none">java@RequestMapping("/user/{idd}")public String testPathVariable(@PathVariable(value = "idd") Integer id) {System.out.println("获取到的id为：" + id);return "success";}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于访问的 url，占位符的位置可以在任何位置，不一定非要在最后，比如这样也行：<code>/xxx/{id}/user</code>。另外，url 也支持多个占位符，方法参数使用同样数量的参数来接收，原理和一个参数是一样的，例如：</p><pre class="line-numbers language-none"><code class="language-none">java@GetMapping("/user/{idd}/{name}")    public String testPathVariable(@PathVariable(value = "idd") Integer id, @PathVariable String name) {        System.out.println("获取到的id为：" + id);        System.out.println("获取到的name为：" + name);        return "success";    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行项目，在浏览器中请求 <code>localhost:8080/test/user/2/zhangsan</code> 可以看到控制台输出如下信息：</p><pre class="line-numbers language-none"><code class="language-none">plain获取到的id为：2获取到的name为：zhangsan<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>所以支持多个参数的接收。同样地，如果 url 中的参数和方法中的参数名称不同的话，也需要使用 value 属性来绑定两个参数。</p><h2 id="4-RequestParam"><a href="#4-RequestParam" class="headerlink" title="4. @RequestParam"></a>4. @RequestParam</h2><p><code>@RequestParam</code> 注解顾名思义，也是获取请求参数的，上面我们介绍了 <code>@PathValiable</code> 注解也是获取请求参数的，那么 <code>@RequestParam</code> 和 <code>@PathVariable</code> 有什么不同呢？主要区别在于： <code>@PathValiable</code> 是从 url 模板中获取参数值， 即这种风格的 url：<code>http://localhost:8080/user/{id}</code> ；而 <code>@RequestParam</code> 是从 request 里面获取参数值，即这种风格的 url：<code>http://localhost:8080/user?id=1</code> 。我们使用该 url 带上参数 id 来测试一下如下代码：</p><pre class="line-numbers language-none"><code class="language-none">java@GetMapping("/user")public String testRequestParam(@RequestParam Integer id) {System.out.println("获取到的id为：" + id);return "success";}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以正常从控制台打印出 id 信息。同样地，url 上面的参数和方法的参数需要一致，如果不一致，也需要使用 value 属性来说明，比如 url 为：<code>http://localhost:8080/user?idd=1</code></p><pre class="line-numbers language-none"><code class="language-none">java@RequestMapping("/user")public String testRequestParam(@RequestParam(value = "idd", required = false) Integer id) {System.out.println("获取到的id为：" + id);return "success";}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了 value 属性外，还有个两个属性比较常用：</p><ul><li>required 属性：true 表示该参数必须要传，否则就会报 404 错误，false 表示可有可无。</li><li>defaultValue 属性：默认值，表示如果请求中没有同名参数时的默认值。</li></ul><p>从 url 中可以看出，<code>@RequestParam</code> 注解用于 GET 请求上时，接收拼接在 url 中的参数。除此之外，该注解还可以用于 POST 请求，接收前端表单提交的参数，假如前端通过表单提交 username 和 password 两个参数，那我们可以使用 <code>@RequestParam</code> 来接收，用法和上面一样。</p><pre class="line-numbers language-none"><code class="language-none">java@PostMapping("/form1")    public String testForm(@RequestParam String username, @RequestParam String password) {        System.out.println("获取到的username为：" + username);        System.out.println("获取到的password为：" + password);        return "success";    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们使用 postman 来模拟一下表单提交，测试一下接口：</p><p><img src="https://img-blog.csdnimg.cn/20200215043749282.png" alt="使用postman测试表单提交"></p><p>那么问题来了，如果表单数据很多，我们不可能在后台方法中写上很多参数，每个参数还要 <code>@RequestParam</code> 注解。针对这种情况，我们需要封装一个实体类来接收这些参数，实体中的属性名和表单中的参数名一致即可。</p><pre class="line-numbers language-none"><code class="language-none">javapublic class User {private String username;private String password;// set get}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用实体接收的话，我们不能在前面加 <code>@RequestParam</code> 注解了，直接使用即可。</p><pre class="line-numbers language-none"><code class="language-none">java@PostMapping("/form2")    public String testForm(User user) {        System.out.println("获取到的username为：" + user.getUsername());        System.out.println("获取到的password为：" + user.getPassword());        return "success";    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用 postman 再次测试一下表单提交，观察一下返回值和控制台打印出的日志即可。在实际项目中，一般都是封装一个实体类来接收表单数据，因为实际项目中表单数据一般都很多。</p><h2 id="5-RequestBody"><a href="#5-RequestBody" class="headerlink" title="5. @RequestBody"></a>5. @RequestBody</h2><p><code>@RequestBody</code> 注解用于接收前端传来的实体，接收参数也是对应的实体，比如前端通过 json 提交传来两个参数 username 和 password，此时我们需要在后端封装一个实体来接收。在传递的参数比较多的情况下，使用 <code>@RequestBody</code> 接收会非常方便。例如：</p><pre class="line-numbers language-none"><code class="language-none">javapublic class User {private String username;private String password;// set get}java@PostMapping("/user")public String testRequestBody(@RequestBody User user) {System.out.println("获取到的username为：" + user.getUsername());System.out.println("获取到的password为：" + user.getPassword());return "success";}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们使用 postman 工具来测试一下效果，打开 postman，然后输入请求地址和参数，参数我们用 json 来模拟，如下图所有，调用之后返回 success。</p><p><img src="https://img-blog.csdnimg.cn/20200215043853532.png" alt="使用Postman测试requestBody"></p><p>同时看一下后台控制台输出的日志：</p><pre class="line-numbers language-none"><code class="language-none">plain获取到的username为：倪升武获取到的password为：123456<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，<code>@RequestBody</code> 注解用于 POST 请求上，接收 json 实体参数。它和上面我们介绍的表单提交有点类似，只不过参数的格式不同，一个是 json 实体，一个是表单提交。在实际项目中根据具体场景和需要使用对应的注解即可。</p><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>本节课主要讲解了 Spring Boot 中对 MVC 的支持，分析了 <code>@RestController</code>、 <code>@RequestMapping</code>、<code>@PathVariable</code>、 <code>@RequestParam</code> 和 <code>@RequestBody</code> 四个注解的使用方式，由于 <code>@RestController</code> 中集成了 <code>@ResponseBody</code> 所以对返回 json 的注解不再赘述。以上四个注解是使用频率很高的注解，在所有的实际项目中基本都会遇到，要熟练掌握。</p><p>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study">戳我下载</a></p><h1 id="第06课：Spring-Boot集成-Swagger2-展现在线接口文档"><a href="#第06课：Spring-Boot集成-Swagger2-展现在线接口文档" class="headerlink" title="第06课：Spring Boot集成 Swagger2 展现在线接口文档"></a>第06课：Spring Boot集成 Swagger2 展现在线接口文档</h1><h2 id="1-Swagger-简介"><a href="#1-Swagger-简介" class="headerlink" title="1. Swagger 简介"></a>1. Swagger 简介</h2><h3 id="1-1-解决的问题"><a href="#1-1-解决的问题" class="headerlink" title="1.1 解决的问题"></a>1.1 解决的问题</h3><p>随着互联网技术的发展，现在的网站架构基本都由原来的后端渲染，变成了前后端分离的形态，而且前端技术和后端技术在各自的道路上越走越远。前端和后端的唯一联系，变成了 API 接口，所以 API 文档变成了前后端开发人员联系的纽带，变得越来越重要。</p><p>那么问题来了，随着代码的不断更新，开发人员在开发新的接口或者更新旧的接口后，由于开发任务的繁重，往往文档很难持续跟着更新，Swagger 就是用来解决该问题的一款重要的工具，对使用接口的人来说，开发人员不需要给他们提供文档，只要告诉他们一个 Swagger 地址，即可展示在线的 API 接口文档，除此之外，调用接口的人员还可以在线测试接口数据，同样地，开发人员在开发接口时，同样也可以利用 Swagger 在线接口文档测试接口数据，这给开发人员提供了便利。</p><h3 id="1-2-Swagger-官方"><a href="#1-2-Swagger-官方" class="headerlink" title="1.2 Swagger 官方"></a>1.2 Swagger 官方</h3><p>我们打开 <a href="https://swagger.io/">Swagger 官网</a>，官方对 Swagger 的定义为：</p><blockquote><p>The Best APIs are Built with Swagger Tools</p></blockquote><p>翻译成中文是：“最好的 API 是使用 Swagger 工具构建的”。由此可见，Swagger 官方对其功能和所处的地位非常自信，由于其非常好用，所以官方对其定位也合情合理。如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/20200215043936444.png" alt="官方对swagger的定位"></p><p>本文主要讲解在 Spring Boot 中如何导入 Swagger2 工具来展现项目中的接口文档。本节课使用的 Swagger 版本为 2.2.2。下面开始进入 Swagger2 之旅。</p><h2 id="2-Swagger2-的-maven-依赖"><a href="#2-Swagger2-的-maven-依赖" class="headerlink" title="2. Swagger2 的 maven 依赖"></a>2. Swagger2 的 maven 依赖</h2><p>使用 Swagger2 工具，必须要导入 maven 依赖，当前官方最高版本是 2.8.0，我尝试了一下，个人感觉页面展示的效果不太好，而且不够紧凑，不利于操作。另外，最新版本并不一定是最稳定版本，当前我们实际项目中使用的是 2.2.2 版本，该版本稳定，界面友好，所以本节课主要围绕着 2.2.2 版本来展开，依赖如下：</p><pre class="line-numbers language-none"><code class="language-none">xml&lt;dependency&gt;&lt;groupId&gt;io.springfox&lt;/groupId&gt;&lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;&lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;io.springfox&lt;/groupId&gt;&lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;&lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-Swagger2-的配置"><a href="#3-Swagger2-的配置" class="headerlink" title="3. Swagger2 的配置"></a>3. Swagger2 的配置</h2><p>使用 Swagger2 需要进行配置，Spring Boot 中对 Swagger2 的配置非常方便，新建一个配置类，Swagger2 的配置类上除了添加必要的 <code>@Configuration</code> 注解外，还需要添加 <code>@EnableSwagger2</code> 注解。</p><pre class="line-numbers language-none"><code class="language-none">javaimport org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;/** * @author shengwu ni */@Configuration@EnableSwagger2public class SwaggerConfig {    @Bean    public Docket createRestApi() {        return new Docket(DocumentationType.SWAGGER_2)                // 指定构建api文档的详细信息的方法：apiInfo()                .apiInfo(apiInfo())                .select()                // 指定要生成api接口的包路径，这里把controller作为包路径，生成controller中的所有接口                .apis(RequestHandlerSelectors.basePackage("com.itcodai.course06.controller"))                .paths(PathSelectors.any())                .build();    }    /**     * 构建api文档的详细信息     * @return     */    private ApiInfo apiInfo() {        return new ApiInfoBuilder()                // 设置页面标题                .title("Spring Boot集成Swagger2接口总览")                // 设置接口描述                .description("跟武哥一起学Spring Boot第06课")                // 设置联系方式                .contact("倪升武，" + "CSDN：http://blog.csdn.net/eson_15")                // 设置版本                .version("1.0")                // 构建                .build();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在该配置类中，已经使用注释详细解释了每个方法的作用了，在此不再赘述。到此为止，我们已经配置好了 Swagger2 了。现在我们可以测试一下配置有没有生效，启动项目，在浏览器中输入 <code>localhost:8080/swagger-ui.html</code>，即可看到 swagger2 的接口页面，如下图所示，说明Swagger2 集成成功。</p><p><img src="https://img-blog.csdnimg.cn/20200215044013383.png" alt="swagger2页面"></p><p>结合该图，对照上面的 Swagger2 配置文件中的配置，可以很明确的知道配置类中每个方法的作用。这样就很容易理解和掌握 Swagger2 中的配置了，也可以看出，其实 Swagger2 配置很简单。</p><p>【友情提示】可能有很多朋友在配置 Swagger 的时候会遇到下面的情况，而且还关不掉的，这是因为浏览器缓存引起的，清空一下浏览器缓存即可解决问题。</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-k3UNsYXM-1581914323088)(<a href="http://p99jlm9k5.bkt.clouddn.com/blog/images/1/error.png)]">http://p99jlm9k5.bkt.clouddn.com/blog/images/1/error.png)]</a></p><h2 id="4-Swagger2-的使用"><a href="#4-Swagger2-的使用" class="headerlink" title="4. Swagger2 的使用"></a>4. Swagger2 的使用</h2><p>上面我们已经配置好了 Swagger2，并且也启动测试了一下，功能正常，下面我们开始使用 Swagger2，主要来介绍 Swagger2 中的几个常用的注解，分别在实体类上、 Controller 类上以及 Controller 中的方法上，最后我们看一下 Swagger2 是如何在页面上呈现在线接口文档的，并且结合 Controller 中的方法在接口中测试一下数据。</p><h3 id="4-1-实体类注解"><a href="#4-1-实体类注解" class="headerlink" title="4.1 实体类注解"></a>4.1 实体类注解</h3><p>本节我们建一个 User 实体类，主要介绍一下 Swagger2 中的 <code>@ApiModel</code> 和 <code>@ApiModelProperty</code> 注解，同时为后面的测试做准备。</p><pre class="line-numbers language-none"><code class="language-none">javaimport io.swagger.annotations.ApiModel;import io.swagger.annotations.ApiModelProperty;@ApiModel(value = "用户实体类")public class User {    @ApiModelProperty(value = "用户唯一标识")    private Long id;    @ApiModelProperty(value = "用户姓名")    private String username;    @ApiModelProperty(value = "用户密码")    private String password;// 省略set和get方法}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解释下 <code>@ApiModel</code> 和 <code>@ApiModelProperty</code> 注解：</p><blockquote><p><code>@ApiModel</code> 注解用于实体类，表示对类进行说明，用于参数用实体类接收。<br><code>@ApiModelProperty</code> 注解用于类中属性，表示对 model 属性的说明或者数据操作更改。</p></blockquote><p>该注解在在线 API 文档中的具体效果在下文说明。</p><h3 id="4-2-Controller-类中相关注解"><a href="#4-2-Controller-类中相关注解" class="headerlink" title="4.2 Controller 类中相关注解"></a>4.2 Controller 类中相关注解</h3><p>我们写一个 TestController，再写几个接口，然后学习一下 Controller 中和 Swagger2 相关的注解。</p><pre class="line-numbers language-none"><code class="language-none">javaimport com.itcodai.course06.entiy.JsonResult;import com.itcodai.course06.entiy.User;import io.swagger.annotations.Api;import io.swagger.annotations.ApiOperation;import io.swagger.annotations.ApiParam;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@RequestMapping("/swagger")@Api(value = "Swagger2 在线接口文档")public class TestController {    @GetMapping("/get/{id}")    @ApiOperation(value = "根据用户唯一标识获取用户信息")    public JsonResult&lt;User&gt; getUserInfo(@PathVariable @ApiParam(value = "用户唯一标识") Long id) {        // 模拟数据库中根据id获取User信息        User user = new User(id, "倪升武", "123456");        return new JsonResult(user);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们来学习一下 <code>@Api</code> 、 <code>@ApiOperation</code> 和 <code>@ApiParam</code> 注解。</p><blockquote><p><code>@Api</code> 注解用于类上，表示标识这个类是 swagger 的资源。<br><code>@ApiOperation</code> 注解用于方法，表示一个 http 请求的操作。<br><code>@ApiParam</code> 注解用于参数上，用来标明参数信息。</p></blockquote><p>这里返回的是 JsonResult，是第02课中学习返回 json 数据时封装的实体。以上是 Swagger 中最常用的 5 个注解，接下来运行一下项目工程，在浏览器中输入 <code>localhost:8080/swagger-ui.html</code> 看一下 Swagger 页面的接口状态。</p><p><img src="https://img-blog.csdnimg.cn/20200215044156305.png" alt="swagger接口展示"></p><p>可以看出，Swagger 页面对该接口的信息展示的非常全面，每个注解的作用以及展示的地方在上图中已经标明，通过页面即可知道该接口的所有信息，那么我们直接在线测试一下该接口返回的信息，输入id为1，看一下返回数据：</p><p><img src="https://img-blog.csdnimg.cn/20200215044226292.png" alt="返回数据测试"></p><p>可以看出，直接在页面返回了 json 格式的数据，开发人员可以直接使用该在线接口来测试数据的正确与否，非常方便。上面是对于单个参数的输入，如果输入参数为某个对象这种情况，Swagger 是什么样子呢？我们再写一个接口。</p><pre class="line-numbers language-none"><code class="language-none">java@PostMapping("/insert")    @ApiOperation(value = "添加用户信息")    public JsonResult&lt;Void&gt; insertUser(@RequestBody @ApiParam(value = "用户信息") User user) {        // 处理添加逻辑        return new JsonResult&lt;&gt;();    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重启项目，在浏览器中输入 <code>localhost:8080/swagger-ui.html</code> 看一下效果：</p><p><img src="https://img-blog.csdnimg.cn/20200215044256579.png" alt="swagger接口展示"></p><h2 id="5-总结-1"><a href="#5-总结-1" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>OK，本节课详细分析了 Swagger 的优点，以及 Spring Boot 如何集成 Swagger2，包括配置，相关注解的讲解，涉及到了实体类和接口类，以及如何使用。最后通过页面测试，体验了 Swagger 的强大之处，基本上是每个项目组中必备的工具之一，所以要掌握该工具的使用，也不难。</p><p>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study">戳我下载</a></p><h1 id="第07课：Spring-Boot集成Thymeleaf模板引擎"><a href="#第07课：Spring-Boot集成Thymeleaf模板引擎" class="headerlink" title="第07课：Spring Boot集成Thymeleaf模板引擎"></a>第07课：Spring Boot集成Thymeleaf模板引擎</h1><h2 id="1-Thymeleaf-介绍"><a href="#1-Thymeleaf-介绍" class="headerlink" title="1. Thymeleaf 介绍"></a>1. Thymeleaf 介绍</h2><blockquote><p>Thymeleaf 是适用于 Web 和独立环境的现代服务器端 Java 模板引擎。<br>Thymeleaf 的主要目标是为您的开发工作流程带来优雅的自然模板 - 可以在浏览器中正确显示的HTML，也可以用作静态原型，从而在开发团队中实现更强大的协作。</p></blockquote><p>以上翻译自 Thymeleaf 官方网站。传统的 JSP+JSTL 组合是已经过去了，Thymeleaf 是现代服务端的模板引擎，与传统的 JSP 不同，Thymeleaf 可以使用浏览器直接打开，因为可以忽略掉拓展属性，相当于打开原生页面，给前端人员也带来一定的便利。</p><p>什么意思呢？就是说在本地环境或者有网络的环境下，Thymeleaf 均可运行。由于 thymeleaf 支持 html 原型，也支持在 html 标签里增加额外的属性来达到 “模板+数据” 的展示方式，所以美工可以直接在浏览器中查看页面效果，当服务启动后，也可以让后台开发人员查看带数据的动态页面效果。比如：</p><pre class="line-numbers language-none"><code class="language-none">html&lt;div class="ui right aligned basic segment"&gt;      &lt;div class="ui orange basic label" th:text="${blog.flag}"&gt;静态原创信息&lt;/div&gt;&lt;/div&gt;&lt;h2 class="ui center aligned header" th:text="${blog.title}"&gt;这是静态标题&lt;/h2&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类似与上面这样，在静态页面时，会展示静态信息，当服务启动后，动态获取数据库中的数据后，就可以展示动态数据，<code>th:text</code> 标签是用来动态替换文本的，这会在下文说明。该例子说明浏览器解释 html 时会忽略 html 中未定义的标签属性（比如 <code>th:text</code>），所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示数据。</p><h2 id="2-依赖导入"><a href="#2-依赖导入" class="headerlink" title="2. 依赖导入"></a>2. 依赖导入</h2><p>在 Spring Boot 中使用 thymeleaf 模板需要引入依赖，可以在创建项目工程时勾选 Thymeleaf，也可以创建之后再手动导入，如下：</p><pre class="line-numbers language-none"><code class="language-none">xml&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另外，在 html 页面上如果要使用 thymeleaf 模板，需要在页面标签中引入：</p><pre class="line-numbers language-none"><code class="language-none">html&lt;html xmlns:th="http://www.thymeleaf.org"&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="3-Thymeleaf相关配置"><a href="#3-Thymeleaf相关配置" class="headerlink" title="3. Thymeleaf相关配置"></a>3. Thymeleaf相关配置</h2><p>因为 Thymeleaf 中已经有默认的配置了，我们不需要再对其做过多的配置，有一个需要注意一下，Thymeleaf 默认是开启页面缓存的，所以在开发的时候，需要关闭这个页面缓存，配置如下。</p><pre class="line-numbers language-none"><code class="language-none">ymlspring:  thymeleaf:    cache: false #关闭缓存<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>否则会有缓存，导致页面没法及时看到更新后的效果。 比如你修改了一个文件，已经 update 到 tomcat 了，但刷新页面还是之前的页面，就是因为缓存引起的。</p><h2 id="4-Thymeleaf-的使用"><a href="#4-Thymeleaf-的使用" class="headerlink" title="4. Thymeleaf 的使用"></a>4. Thymeleaf 的使用</h2><h3 id="4-1-访问静态页面"><a href="#4-1-访问静态页面" class="headerlink" title="4.1 访问静态页面"></a>4.1 访问静态页面</h3><p>这个和 Thymeleaf 没啥关系，应该说是通用的，我把它一并写到这里的原因是一般我们做网站的时候，都会做一个 404 页面和 500 页面，为了出错时给用户一个友好的展示，而不至于一堆异常信息抛出来。Spring Boot 中会自动识别模板目录（templates/）下的 404.html 和 500.html 文件。我们在 templates/ 目录下新建一个 error 文件夹，专门放置错误的 html 页面，然后分别打印些信息。以 404.html 为例：</p><pre class="line-numbers language-none"><code class="language-none">html&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    这是404页面&lt;/body&gt;&lt;/html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们再写一个 controller 来测试一下 404 和 500 页面：</p><pre class="line-numbers language-none"><code class="language-none">java@Controller@RequestMapping("/thymeleaf")public class ThymeleafController {    @RequestMapping("/test404")    public String test404() {        return "index";    }    @RequestMapping("/test500")    public String test500() {        int i = 1 / 0;        return "index";    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>当我们在浏览器中输入 <code>localhost:8080/thymeleaf/test400</code> 时，故意输入错误，找不到对应的方法，就会跳转到 404.html 显示。<br>当我们在浏览器中输入 <code>localhost:8088/thymeleaf/test505</code> 时，会抛出异常，然后会自动跳转到 500.html 显示。</p></blockquote><p>【注】这里有个问题需要注意一下，前面的课程中我们说了微服务中会走向前后端分离，我们在 Controller 层上都是使用的 <code>@RestController</code> 注解，自动会把返回的数据转成 json 格式。但是在使用模板引擎时，Controller 层就不能用 <code>@RestController</code> 注解了，因为在使用 thymeleaf 模板时，返回的是视图文件名，比如上面的 Controller 中是返回到 index.html 页面，如果使用 <code>@RestController</code> 的话，会把 index 当作 String 解析了，直接返回到页面了，而不是去找 index.html 页面，大家可以试一下。所以在使用模板时要用 <code>@Controller</code> 注解。</p><h3 id="4-2-Thymeleaf-中处理对象"><a href="#4-2-Thymeleaf-中处理对象" class="headerlink" title="4.2 Thymeleaf 中处理对象"></a>4.2 Thymeleaf 中处理对象</h3><p>我们来看一下 thymeleaf 模板中如何处理对象信息，假如我们在做个人博客的时候，需要给前端传博主相关信息来展示，那么我们会封装成一个博主对象，比如：</p><pre class="line-numbers language-none"><code class="language-none">javapublic class Blogger {    private Long id;    private String name;    private String pass;// 省去set和get}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后在controller层中初始化一下：</p><pre class="line-numbers language-none"><code class="language-none">java@GetMapping("/getBlogger")public String getBlogger(Model model) {Blogger blogger = new Blogger(1L, "倪升武", "123456");model.addAttribute("blogger", blogger);return "blogger";}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们先初始化一个 Blogger 对象，然后将该对象放到 Model 中，然后返回到 blogger.html 页面去渲染。接下来我们再写一个 blogger.html 来渲染 blogger 信息：</p><pre class="line-numbers language-none"><code class="language-none">html&lt;!DOCTYPE html&gt;&lt;html xmlns:th="http://www.thymeleaf.org"&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;博主信息&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="" th:object="${blogger}" &gt;    用户编号：&lt;input name="id" th:value="${blogger.id}"/&gt;&lt;br&gt;    用户姓名：&lt;input type="text" name="username" th:value="${blogger.getName()}" /&gt;&lt;br&gt;    登陆密码：&lt;input type="text" name="password" th:value="*{pass}" /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，在 thymeleaf 模板中，使用 <code>th:object="${}"</code> 来获取对象信息，然后在表单里面可以有三种方式来获取对象属性。如下：</p><blockquote><p>使用 <code>th:value="*{属性名}"</code><br>使用 <code>th:value="${对象.属性名}"</code>，对象指的是上面使用 <code>th:object</code> 获取的对象<br>使用 <code>th:value="${对象.get方法}"</code>，对象指的是上面使用 <code>th:object</code> 获取的对象</p></blockquote><p>可以看出，在 Thymeleaf 中可以像写 java 一样写代码，很方便。我们在浏览器中输入 <code>localhost:8080/thymeleaf/getBlogger</code> 来测试一下数据：</p><p><img src="https://img-blog.csdnimg.cn/20200215044353803.jpg" alt="thymeleaf中处理对象"></p><h3 id="4-3-Thymeleaf-中处理-List"><a href="#4-3-Thymeleaf-中处理-List" class="headerlink" title="4.3 Thymeleaf 中处理 List"></a>4.3 Thymeleaf 中处理 List</h3><p>处理 List 的话，和处理上面介绍的对象差不多，但是需要在 thymeleaf 中进行遍历。我们先在 Controller 中模拟一个 List。</p><pre class="line-numbers language-none"><code class="language-none">java@GetMapping("/getList")public String getList(Model model) {    Blogger blogger1 = new Blogger(1L, "倪升武", "123456");    Blogger blogger2 = new Blogger(2L, "达人课", "123456");    List&lt;Blogger&gt; list = new ArrayList&lt;&gt;();    list.add(blogger1);    list.add(blogger2);    model.addAttribute("list", list);    return "list";}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来我们写一个 list.html 来获取该 list 信息，然后在 list.html 中遍历这个list。如下：</p><pre class="line-numbers language-none"><code class="language-none">html&lt;!DOCTYPE html&gt;&lt;html xmlns:th="http://www.thymeleaf.org"&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;博主信息&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="" th:each="blogger : ${list}" &gt;    用户编号：&lt;input name="id" th:value="${blogger.id}"/&gt;&lt;br&gt;    用户姓名：&lt;input type="text" name="password" th:value="${blogger.name}"/&gt;&lt;br&gt;    登录密码：&lt;input type="text" name="username" th:value="${blogger.getPass()}"/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，其实和处理单个对象信息差不多，Thymeleaf 使用 <code>th:each</code> 进行遍历，<code>${}</code> 取 model 中传过来的参数，然后自定义 list 中取出来的每个对象，这里定义为 blogger。表单里面可以直接使用 <code>${对象.属性名}</code> 来获取 list 中对象的属性值，也可以使用 <code>${对象.get方法}</code> 来获取，这点和上面处理对象信息是一样的，但是不能使用 <code>*{属性名}</code> 来获取对象中的属性，thymeleaf 模板获取不到。</p><h3 id="4-4-其他常用-thymeleaf-操作"><a href="#4-4-其他常用-thymeleaf-操作" class="headerlink" title="4.4 其他常用 thymeleaf 操作"></a>4.4 其他常用 thymeleaf 操作</h3><p>我们来总结一下 thymeleaf 中的一些常用的标签操作，如下：</p><table><thead><tr><th>标签</th><th>功能</th><th>例子</th></tr></thead><tbody><tr><td><code>th:value</code></td><td>给属性赋值</td><td><code>&lt;input th:value="${blog.name}" /&gt;</code></td></tr><tr><td><code>th:style</code></td><td>设置样式</td><td><code>th:style="'display:'+@{(${sitrue}?'none':'inline-block')} + ''"</code></td></tr><tr><td><code>th:onclick</code></td><td>点击事件</td><td><code>th:onclick="'getInfo()'"</code></td></tr><tr><td><code>th:if</code></td><td>条件判断</td><td><code>&lt;a th:if="${userId == collect.userId}" &gt;</code></td></tr><tr><td><code>th:href</code></td><td>超链接</td><td><code>&lt;a th:href="@{/blogger/login}"&gt;Login&lt;/a&gt; /&gt;</code></td></tr><tr><td><code>th:unless</code></td><td>条件判断和<code>th:if</code>相反</td><td><code>&lt;a th:href="@{/blogger/login}" th:unless=${session.user != null}&gt;Login&lt;/a&gt;</code></td></tr><tr><td><code>th:switch</code></td><td>配合<code>th:case</code></td><td><code>&lt;div th:switch="${user.role}"&gt;</code></td></tr><tr><td><code>th:case</code></td><td>配合<code>th:switch</code></td><td><code>&lt;p th:case="'admin'"&gt;administator&lt;/p&gt;</code></td></tr><tr><td><code>th:src</code></td><td>地址引入</td><td><code>&lt;img alt="csdn logo" th:src="@{/img/logo.png}" /&gt;</code></td></tr><tr><td><code>th:action</code></td><td>表单提交的地址</td><td><code>&lt;form th:action="@{/blogger/update}"&gt;</code></td></tr></tbody></table><p>Thymeleaf 还有很多其他用法，这里就不总结了，具体的可以参考Thymeleaf的<a href="https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html">官方文档（v3.0）</a>。主要要学会如何在 Spring Boot 中去使用 thymeleaf，遇到对应的标签或者方法，查阅官方文档即可。</p><h2 id="5-总结-2"><a href="#5-总结-2" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>Thymeleaf 在 Spring Boot 中使用非常广泛，本节课主要分析了 thymeleaf 的优点，以及如何在 Spring Boot 中集成并使用 thymeleaf 模板，包括依赖、配置，相关数据的获取、以及一些注意事项等等。最后列举了一些 thymeleaf 中常用的标签，在实际项目中多使用，多查阅就能熟练掌握，thymeleaf 中的一些标签或者方法不用死记硬背，用到什么去查阅什么，关键是要会在 Spring Boot 中集成，用的多了就熟能生巧。</p><p>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study">戳我下载</a></p><h1 id="第08课：Spring-Boot中的全局异常处理"><a href="#第08课：Spring-Boot中的全局异常处理" class="headerlink" title="第08课：Spring Boot中的全局异常处理"></a>第08课：Spring Boot中的全局异常处理</h1><p>在项目开发过程中，不管是对底层数据库的操作过程，还是业务层的处理过程，还是控制层的处理过程，都不可避免会遇到各种可预知的、不可预知的异常需要处理。如果对每个过程都单独作异常处理，那系统的代码耦合度会变得很高，此外，开发工作量也会加大而且不好统一，这也增加了代码的维护成本。<br>针对这种实际情况，我们需要将所有类型的异常处理从各处理过程解耦出来，这样既保证了相关处理过程的功能单一，也实现了异常信息的统一处理和维护。同时，我们也不希望直接把异常抛给用户，应该对异常进行处理，对错误信息进行封装，然后返回一个友好的信息给用户。这节主要总结一下项目中如何使用 Spring Boot 如何拦截并处理全局的异常。</p><h2 id="1-定义返回的统一-json-结构"><a href="#1-定义返回的统一-json-结构" class="headerlink" title="1. 定义返回的统一 json 结构"></a>1. 定义返回的统一 json 结构</h2><p>前端或者其他服务请求本服务的接口时，该接口需要返回对应的 json 数据，一般该服务只需要返回请求着需要的参数即可，但是在实际项目中，我们需要封装更多的信息，比如状态码 code、相关信息 msg 等等，这一方面是在项目中可以有个统一的返回结构，整个项目组都适用，另一方面是方便结合全局异常处理信息，因为异常处理信息中一般我们需要把状态码和异常内容反馈给调用方。<br>这个统一的 json 结构这可以参考<a href="https://gitbook.cn/gitchat/column/5b3c9f35a3442272491a176a">第02课：Spring Boot 返回 JSON 数据及数据封装</a>中封装的统一 json 结构，本节内容我们简化一下，只保留状态码 code 和异常信息 msg即可。如下：</p><pre class="line-numbers language-none"><code class="language-none">javapublic class JsonResult {    /**     * 异常码     */    protected String code;    /**     * 异常信息     */    protected String msg;    public JsonResult() {        this.code = "200";        this.msg = "操作成功";    }        public JsonResult(String code, String msg) {        this.code = code;        this.msg = msg;    }// get set}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-处理系统异常"><a href="#2-处理系统异常" class="headerlink" title="2. 处理系统异常"></a>2. 处理系统异常</h2><p>新建一个 GlobalExceptionHandler 全局异常处理类，然后加上 <code>@ControllerAdvice</code> 注解即可拦截项目中抛出的异常，如下：</p><pre class="line-numbers language-none"><code class="language-none">java@ControllerAdvice@ResponseBodypublic class GlobalExceptionHandler {// 打印log    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);    // ……}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们点开 <code>@ControllerAdvice</code> 注解可以看到，<code>@ControllerAdvice</code> 注解包含了 <code>@Component</code> 注解，说明在 Spring Boot 启动时，也会把该类作为组件交给 Spring 来管理。除此之外，该注解还有个 <code>basePackages</code> 属性，该属性是用来拦截哪个包中的异常信息，一般我们不指定这个属性，我们拦截项目工程中的所有异常。<code>@ResponseBody</code> 注解是为了异常处理完之后给调用方输出一个 json 格式的封装数据。<br>在项目中如何使用呢？Spring Boot 中很简单，在方法上通过 <code>@ExceptionHandler</code> 注解来指定具体的异常，然后在方法中处理该异常信息，最后将结果通过统一的 json 结构体返回给调用者。下面我们举几个例子来说明如何来使用。</p><h3 id="2-1-处理参数缺失异常"><a href="#2-1-处理参数缺失异常" class="headerlink" title="2.1 处理参数缺失异常"></a>2.1 处理参数缺失异常</h3><p>在前后端分离的架构中，前端请求后台的接口都是通过 rest 风格来调用，有时候，比如 POST 请求 需要携带一些参数，但是往往有时候参数会漏掉。另外，在微服务架构中，涉及到多个微服务之间的接口调用时，也可能出现这种情况，此时我们需要定义一个处理参数缺失异常的方法，来给前端或者调用方提示一个友好信息。</p><p>参数缺失的时候，会抛出 <code>HttpMessageNotReadableException</code>，我们可以拦截该异常，做一个友好处理，如下：</p><pre class="line-numbers language-none"><code class="language-none">java/*** 缺少请求参数异常* @param ex HttpMessageNotReadableException* @return*/@ExceptionHandler(MissingServletRequestParameterException.class)@ResponseStatus(value = HttpStatus.BAD_REQUEST)public JsonResult handleHttpMessageNotReadableException(    MissingServletRequestParameterException ex) {    logger.error("缺少请求参数，{}", ex.getMessage());    return new JsonResult("400", "缺少必要的请求参数");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们来写个简单的 Controller 测试一下该异常，通过 POST 请求方式接收两个参数：姓名和密码。</p><pre class="line-numbers language-none"><code class="language-none">java@RestController@RequestMapping("/exception")public class ExceptionController {    private static final Logger logger = LoggerFactory.getLogger(ExceptionController.class);    @PostMapping("/test")    public JsonResult test(@RequestParam("name") String name,                           @RequestParam("pass") String pass) {        logger.info("name：{}", name);        logger.info("pass：{}", pass);        return new JsonResult();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后使用 Postman 来调用一下该接口，调用的时候，只传姓名，不传密码，就会抛缺少参数异常，该异常被捕获之后，就会进入我们写好的逻辑，给调用方返回一个友好信息，如下：</p><p><img src="https://img-blog.csdnimg.cn/2020021504443480.png" alt="缺失参数异常"></p><h3 id="2-2-处理空指针异常"><a href="#2-2-处理空指针异常" class="headerlink" title="2.2 处理空指针异常"></a>2.2 处理空指针异常</h3><p>空指针异常是开发中司空见惯的东西了，一般发生的地方有哪些呢？<br>先来聊一聊一些注意的地方，比如在微服务中，经常会调用其他服务获取数据，这个数据主要是 json 格式的，但是在解析 json 的过程中，可能会有空出现，所以我们在获取某个 jsonObject 时，再通过该 jsonObject 去获取相关信息时，应该要先做非空判断。<br>还有一个很常见的地方就是从数据库中查询的数据，不管是查询一条记录封装在某个对象中，还是查询多条记录封装在一个 List 中，我们接下来都要去处理数据，那么就有可能出现空指针异常，因为谁也不能保证从数据库中查出来的东西就一定不为空，所以在使用数据时一定要先做非空判断。<br>对空指针异常的处理很简单，和上面的逻辑一样，将异常信息换掉即可。如下：</p><pre class="line-numbers language-none"><code class="language-none">java@ControllerAdvice@ResponseBodypublic class GlobalExceptionHandler {    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);    /**     * 空指针异常     * @param ex NullPointerException     * @return     */    @ExceptionHandler(NullPointerException.class)    @ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR)    public JsonResult handleTypeMismatchException(NullPointerException ex) {        logger.error("空指针异常，{}", ex.getMessage());        return new JsonResult("500", "空指针异常了");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个我就不测试了，代码中 ExceptionController 有个 <code>testNullPointException</code> 方法，模拟了一个空指针异常，我们在浏览器中请求一下对应的 url 即可看到返回的信息：</p><pre class="line-numbers language-none"><code class="language-none">json{"code":"500","msg":"空指针异常了"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2-3-一劳永逸？"><a href="#2-3-一劳永逸？" class="headerlink" title="2.3 一劳永逸？"></a>2.3 一劳永逸？</h3><p>当然了，异常很多，比如还有 RuntimeException，数据库还有一些查询或者操作异常等等。由于 Exception 异常是父类，所有异常都会继承该异常，所以我们可以直接拦截 Exception 异常，一劳永逸：</p><pre class="line-numbers language-none"><code class="language-none">java@ControllerAdvice@ResponseBodypublic class GlobalExceptionHandler {    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);    /**     * 系统异常 预期以外异常     * @param ex     * @return     */    @ExceptionHandler(Exception.class)    @ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR)    public JsonResult handleUnexpectedServer(Exception ex) {        logger.error("系统异常：", ex);        return new JsonResult("500", "系统发生异常，请联系管理员");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是项目中，我们一般都会比较详细的去拦截一些常见异常，拦截 Exception 虽然可以一劳永逸，但是不利于我们去排查或者定位问题。实际项目中，可以把拦截 Exception 异常写在 GlobalExceptionHandler 最下面，如果都没有找到，最后再拦截一下 Exception 异常，保证输出信息友好。</p><h2 id="3-拦截自定义异常"><a href="#3-拦截自定义异常" class="headerlink" title="3. 拦截自定义异常"></a>3. 拦截自定义异常</h2><p>在实际项目中，除了拦截一些系统异常外，在某些业务上，我们需要自定义一些业务异常，比如在微服务中，服务之间的相互调用很平凡，很常见。要处理一个服务的调用时，那么可能会调用失败或者调用超时等等，此时我们需要自定义一个异常，当调用失败时抛出该异常，给 GlobalExceptionHandler 去捕获。</p><h3 id="3-1-定义异常信息"><a href="#3-1-定义异常信息" class="headerlink" title="3.1 定义异常信息"></a>3.1 定义异常信息</h3><p>由于在业务中，有很多异常，针对不同的业务，可能给出的提示信息不同，所以为了方便项目异常信息管理，我们一般会定义一个异常信息枚举类。比如：</p><pre class="line-numbers language-none"><code class="language-none">java/** * 业务异常提示信息枚举类 * @author shengwu ni */public enum BusinessMsgEnum {    /** 参数异常 */    PARMETER_EXCEPTION("102", "参数异常!"),    /** 等待超时 */    SERVICE_TIME_OUT("103", "服务调用超时！"),    /** 参数过大 */    PARMETER_BIG_EXCEPTION("102", "输入的图片数量不能超过50张!"),    /** 500 : 一劳永逸的提示也可以在这定义 */    UNEXPECTED_EXCEPTION("500", "系统发生异常，请联系管理员！");    // 还可以定义更多的业务异常    /**     * 消息码     */    private String code;    /**     * 消息内容     */    private String msg;    private BusinessMsgEnum(String code, String msg) {        this.code = code;        this.msg = msg;    }// set get方法}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-拦截自定义异常"><a href="#3-2-拦截自定义异常" class="headerlink" title="3.2 拦截自定义异常"></a>3.2 拦截自定义异常</h3><p>然后我们可以定义一个业务异常，当出现业务异常时，我们就抛这个自定义的业务异常即可。比如我们定义一个 BusinessErrorException 异常，如下：</p><pre class="line-numbers language-none"><code class="language-none">java/** * 自定义业务异常 * @author shengwu ni */public class BusinessErrorException extends RuntimeException {        private static final long serialVersionUID = -7480022450501760611L;    /**     * 异常码     */    private String code;    /**     * 异常提示信息     */    private String message;    public BusinessErrorException(BusinessMsgEnum businessMsgEnum) {        this.code = businessMsgEnum.code();        this.message = businessMsgEnum.msg();    }// get set方法}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在构造方法中，传入我们上面自定义的异常枚举类，所以在项目中，如果有新的异常信息需要添加，我们直接在枚举类中添加即可，很方便，做到统一维护，然后再拦截该异常时获取即可。</p><pre class="line-numbers language-none"><code class="language-none">java@ControllerAdvice@ResponseBodypublic class GlobalExceptionHandler {    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);    /**     * 拦截业务异常，返回业务异常信息     * @param ex     * @return     */    @ExceptionHandler(BusinessErrorException.class)    @ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR)    public JsonResult handleBusinessError(BusinessErrorException ex) {        String code = ex.getCode();        String message = ex.getMessage();        return new JsonResult(code, message);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在业务代码中，我们可以直接模拟一下抛出业务异常，测试一下：</p><pre class="line-numbers language-none"><code class="language-none">java@RestController@RequestMapping("/exception")public class ExceptionController {    private static final Logger logger = LoggerFactory.getLogger(ExceptionController.class);    @GetMapping("/business")    public JsonResult testException() {        try {            int i = 1 / 0;        } catch (Exception e) {            throw new BusinessErrorException(BusinessMsgEnum.UNEXPECTED_EXCEPTION);        }        return new JsonResult();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行一下项目，测试一下，返回 json 如下，说明我们自定义的业务异常捕获成功：</p><pre class="line-numbers language-none"><code class="language-none">json{"code":"500","msg":"系统发生异常，请联系管理员！"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="4-总结-3"><a href="#4-总结-3" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>本节课程主要讲解了Spring Boot 的全局异常处理，包括异常信息的封装、异常信息的捕获和处理，以及在实际项目中，我们用到的自定义异常枚举类和业务异常的捕获与处理，在项目中运用的非常广泛，基本上每个项目中都需要做全局异常处理。</p><p>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study">戳我下载</a></p><h1 id="第09课：Spring-Boot中的切面AOP处理"><a href="#第09课：Spring-Boot中的切面AOP处理" class="headerlink" title="第09课：Spring Boot中的切面AOP处理"></a>第09课：Spring Boot中的切面AOP处理</h1><h2 id="1-什么是AOP"><a href="#1-什么是AOP" class="headerlink" title="1. 什么是AOP"></a>1. 什么是AOP</h2><p>AOP：Aspect Oriented Programming 的缩写，意为：面向切面编程。面向切面编程的目标就是分离关注点。什么是关注点呢？就是关注点，就是你要做的事情。假如你是一位公子哥，没啥人生目标，每天衣来伸手，饭来张口，整天只知道一件事：玩（这就是你的关注点，你只要做这一件事）！但是有个问题，你在玩之前，你还需要起床、穿衣服、穿鞋子、叠被子、做早饭等等等等，但是这些事情你不想关注，也不用关注，你只想想玩，那么怎么办呢？</p><p>对！这些事情通通交给下人去干。你有一个专门的仆人 A 帮你穿衣服，仆人 B 帮你穿鞋子，仆人 C 帮你叠好被子，仆人 D 帮你做饭，然后你就开始吃饭、去玩（这就是你一天的正事），你干完你的正事之后，回来，然后一系列仆人又开始帮你干这个干那个，然后一天就结束了！</p><p>这就是 AOP。AOP 的好处就是你只需要干你的正事，其它事情别人帮你干。也许有一天，你想裸奔，不想穿衣服，那么你把仆人 A 解雇就是了！也许有一天，出门之前你还想带点钱，那么你再雇一个仆人 E 专门帮你干取钱的活！这就是AOP。每个人各司其职，灵活组合，达到一种可配置的、可插拔的程序结构。</p><h2 id="2-Spring-Boot-中的-AOP-处理"><a href="#2-Spring-Boot-中的-AOP-处理" class="headerlink" title="2. Spring Boot 中的 AOP 处理"></a>2. Spring Boot 中的 AOP 处理</h2><h3 id="2-1-AOP-依赖"><a href="#2-1-AOP-依赖" class="headerlink" title="2.1 AOP 依赖"></a>2.1 AOP 依赖</h3><p>使用AOP，首先需要引入AOP的依赖。</p><pre class="line-numbers language-none"><code class="language-none">xml&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-实现-AOP-切面"><a href="#2-2-实现-AOP-切面" class="headerlink" title="2.2 实现 AOP 切面"></a>2.2 实现 AOP 切面</h3><p>Spring Boot 中使用 AOP 非常简单，假如我们要在项目中打印一些 log，在引入了上面的依赖之后，我们新建一个类 LogAspectHandler，用来定义切面和处理方法。只要在类上加个<code>@Aspect</code>注解即可。<code>@Aspect</code> 注解用来描述一个切面类，定义切面类的时候需要打上这个注解。<code>@Component</code> 注解让该类交给 Spring 来管理。</p><pre class="line-numbers language-none"><code class="language-none">java@Aspect@Componentpublic class LogAspectHandler {}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里主要介绍几个常用的注解及使用：</p><blockquote><p>1.@Pointcut：定义一个切面，即上面所描述的关注的某件事入口。<br>2.@Before：在做某件事之前做的事。<br>3.@After：在做某件事之后做的事。<br>4.@AfterReturning：在做某件事之后，对其返回值做增强处理。<br>5.@AfterThrowing：在做某件事抛出异常时，处理。</p></blockquote><h4 id="2-2-1-Pointcut-注解"><a href="#2-2-1-Pointcut-注解" class="headerlink" title="2.2.1 @Pointcut 注解"></a>2.2.1 @Pointcut 注解</h4><p><code>@Pointcut</code> 注解：用来定义一个切面（切入点），即上文中所关注的某件事情的入口。切入点决定了连接点关注的内容，使得我们可以控制通知什么时候执行。</p><pre class="line-numbers language-none"><code class="language-none">java@Aspect@Componentpublic class LogAspectHandler {    /**     * 定义一个切面，拦截com.itcodai.course09.controller包和子包下的所有方法     */    @Pointcut("execution(* com.itcodai.course09.controller..*.*(..))")    public void pointCut() {}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>@Pointcut</code> 注解指定一个切面，定义需要拦截的东西，这里介绍两个常用的表达式：一个是使用 <code>execution()</code>，另一个是使用 <code>annotation()</code>。<br>以 <code>execution(* com.itcodai.course09.controller..*.*(..)))</code> 表达式为例，语法如下：</p><blockquote><p><code>execution()</code> 为表达式主体<br>第一个 <code>*</code> 号的位置：表示返回值类型，<code>*</code> 表示所有类型<br>包名：表示需要拦截的包名，后面的两个句点表示当前包和当前包的所有子包，<code>com.itcodai.course09.controller</code> 包、子包下所有类的方法<br>第二个 <code>*</code> 号的位置：表示类名，<code>*</code> 表示所有类<br><code>*(..)</code> ：这个星号表示方法名，<code>*</code> 表示所有的方法，后面括弧里面表示方法的参数，两个句点表示任何参数</p></blockquote><p><code>annotation()</code> 方式是针对某个注解来定义切面，比如我们对具有<code>@GetMapping</code>注解的方法做切面，可以如下定义切面：</p><pre class="line-numbers language-none"><code class="language-none">java@Pointcut("@annotation(org.springframework.web.bind.annotation.GetMapping)")public void annotationCut() {}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后使用该切面的话，就会切入注解是 <code>@GetMapping</code> 的方法。因为在实际项目中，可能对于不同的注解有不同的逻辑处理，比如 <code>@GetMapping</code>、<code>@PostMapping</code>、<code>@DeleteMapping</code> 等。所以这种按照注解的切入方式在实际项目中也很常用。</p><h4 id="2-2-2-Before-注解"><a href="#2-2-2-Before-注解" class="headerlink" title="2.2.2 @Before 注解"></a>2.2.2 @Before 注解</h4><p><code>@Before</code> 注解指定的方法在切面切入目标方法之前执行，可以做一些 log 处理，也可以做一些信息的统计，比如获取用户的请求 url 以及用户的 ip 地址等等，这个在做个人站点的时候都能用得到，都是常用的方法。例如：</p><pre class="line-numbers language-none"><code class="language-none">java@Aspect@Componentpublic class LogAspectHandler {    private final Logger logger = LoggerFactory.getLogger(this.getClass());    /**     * 在上面定义的切面方法之前执行该方法     * @param joinPoint jointPoint     */    @Before("pointCut()")    public void doBefore(JoinPoint joinPoint) {        logger.info("====doBefore方法进入了====");        // 获取签名        Signature signature = joinPoint.getSignature();        // 获取切入的包名        String declaringTypeName = signature.getDeclaringTypeName();        // 获取即将执行的方法名        String funcName = signature.getName();        logger.info("即将执行方法为: {}，属于{}包", funcName, declaringTypeName);                // 也可以用来记录一些信息，比如获取请求的url和ip        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();        HttpServletRequest request = attributes.getRequest();        // 获取请求url        String url = request.getRequestURL().toString();        // 获取请求ip        String ip = request.getRemoteAddr();        logger.info("用户请求的url为：{}，ip地址为：{}", url, ip);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>JointPoint 对象很有用，可以用它来获取一个签名，然后利用签名可以获取请求的包名、方法名，包括参数（通过 <code>joinPoint.getArgs()</code> 获取）等等。</p><h4 id="2-2-3-After-注解"><a href="#2-2-3-After-注解" class="headerlink" title="2.2.3 @After 注解"></a>2.2.3 @After 注解</h4><p><code>@After</code> 注解和 <code>@Before</code> 注解相对应，指定的方法在切面切入目标方法之后执行，也可以做一些完成某方法之后的 log 处理。</p><pre class="line-numbers language-none"><code class="language-none">java@Aspect@Componentpublic class LogAspectHandler {    private final Logger logger = LoggerFactory.getLogger(this.getClass());    /**     * 定义一个切面，拦截com.itcodai.course09.controller包下的所有方法     */    @Pointcut("execution(* com.itcodai.course09.controller..*.*(..))")    public void pointCut() {}    /**     * 在上面定义的切面方法之后执行该方法     * @param joinPoint jointPoint     */    @After("pointCut()")    public void doAfter(JoinPoint joinPoint) {        logger.info("====doAfter方法进入了====");        Signature signature = joinPoint.getSignature();        String method = signature.getName();        logger.info("方法{}已经执行完", method);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>到这里，我们来写一个 Controller 来测试一下执行结果，新建一个 AopController 如下：</p><pre class="line-numbers language-none"><code class="language-none">java@RestController@RequestMapping("/aop")public class AopController {    @GetMapping("/{name}")    public String testAop(@PathVariable String name) {        return "Hello " + name;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>启动项目，在浏览器中输入 <code>localhost:8080/aop/CSDN</code>，观察一下控制台的输出信息：</p><pre class="line-numbers language-none"><code class="language-none">plain====doBefore方法进入了====  即将执行方法为: testAop，属于com.itcodai.course09.controller.AopController包  用户请求的url为：http://localhost:8080/aop/name，ip地址为：0:0:0:0:0:0:0:1  ====doAfter方法进入了====  方法testAop已经执行完<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从打印出来的 log 中可以看出程序执行的逻辑与顺序，可以很直观的掌握 <code>@Before</code> 和 <code>@After</code> 两个注解的实际作用。</p><h4 id="2-2-4-AfterReturning-注解"><a href="#2-2-4-AfterReturning-注解" class="headerlink" title="2.2.4 @AfterReturning 注解"></a>2.2.4 @AfterReturning 注解</h4><p><code>@AfterReturning</code> 注解和 <code>@After</code> 有些类似，区别在于 <code>@AfterReturning</code> 注解可以用来捕获切入方法执行完之后的返回值，对返回值进行业务逻辑上的增强处理，例如：</p><pre class="line-numbers language-none"><code class="language-none">java@Aspect@Componentpublic class LogAspectHandler {    private final Logger logger = LoggerFactory.getLogger(this.getClass());    /**     * 在上面定义的切面方法返回后执行该方法，可以捕获返回对象或者对返回对象进行增强     * @param joinPoint joinPoint     * @param result result     */    @AfterReturning(pointcut = "pointCut()", returning = "result")    public void doAfterReturning(JoinPoint joinPoint, Object result) {        Signature signature = joinPoint.getSignature();        String classMethod = signature.getName();        logger.info("方法{}执行完毕，返回参数为：{}", classMethod, result);        // 实际项目中可以根据业务做具体的返回值增强        logger.info("对返回参数进行业务上的增强：{}", result + "增强版");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是：在 <code>@AfterReturning</code>注解 中，属性 <code>returning</code> 的值必须要和参数保持一致，否则会检测不到。该方法中的第二个入参就是被切方法的返回值，在 <code>doAfterReturning</code> 方法中可以对返回值进行增强，可以根据业务需要做相应的封装。我们重启一下服务，再测试一下（多余的 log 我不贴出来了）：</p><pre class="line-numbers language-none"><code class="language-none">plain方法testAop执行完毕，返回参数为：Hello CSDN  对返回参数进行业务上的增强：Hello CSDN增强版<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-5-AfterThrowing-注解"><a href="#2-2-5-AfterThrowing-注解" class="headerlink" title="2.2.5 @AfterThrowing 注解"></a>2.2.5 @AfterThrowing 注解</h4><p>顾名思义，<code>@AfterThrowing</code> 注解是当被切方法执行时抛出异常时，会进入 <code>@AfterThrowing</code> 注解的方法中执行，在该方法中可以做一些异常的处理逻辑。要注意的是 <code>throwing</code> 属性的值必须要和参数一致，否则会报错。该方法中的第二个入参即为抛出的异常。</p><pre class="line-numbers language-none"><code class="language-none">java/** * 使用AOP处理log * @author shengwu ni * @date 2018/05/04 20:24 */@Aspect@Componentpublic class LogAspectHandler {    private final Logger logger = LoggerFactory.getLogger(this.getClass());    /**     * 在上面定义的切面方法执行抛异常时，执行该方法     * @param joinPoint jointPoint     * @param ex ex     */    @AfterThrowing(pointcut = "pointCut()", throwing = "ex")    public void afterThrowing(JoinPoint joinPoint, Throwable ex) {        Signature signature = joinPoint.getSignature();        String method = signature.getName();        // 处理异常的逻辑        logger.info("执行方法{}出错，异常为：{}", method, ex);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该方法我就不测试了，大家可以自行测试一下。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>本节课针对 Spring Boot 中的切面 AOP 做了详细的讲解，主要介绍了 Spring Boot 中 AOP 的引入，常用注解的使用，参数的使用，以及常用 api 的介绍。AOP 在实际项目中很有用，对切面方法执行前后都可以根据具体的业务，做相应的预处理或者增强处理，同时也可以用作异常捕获处理，可以根据具体业务场景，合理去使用 AOP。</p><p>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study">戳我下载</a></p><h1 id="第10课：Spring-Boot集成MyBatis"><a href="#第10课：Spring-Boot集成MyBatis" class="headerlink" title="第10课：Spring Boot集成MyBatis"></a>第10课：Spring Boot集成MyBatis</h1><h2 id="1-MyBatis-介绍"><a href="#1-MyBatis-介绍" class="headerlink" title="1. MyBatis 介绍"></a>1. MyBatis 介绍</h2><p>大家都知道，MyBatis 框架是一个持久层框架，是 Apache 下的顶级项目。Mybatis 可以让开发者的主要精力放在 sql 上，通过 Mybatis 提供的映射方式，自由灵活的生成满足需要的 sql 语句。使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs 映射成数据库中的记录，在国内可谓是占据了半壁江山。本节课程主要通过两种方式来对 Spring Boot 集成 MyBatis 做一讲解。重点讲解一下基于注解的方式。因为实际项目中使用注解的方式更多一点，更简洁一点，省去了很多 xml 配置（这不是绝对的，有些项目组中可能也在使用 xml 的方式）。</p><h2 id="2-MyBatis-的配置"><a href="#2-MyBatis-的配置" class="headerlink" title="2. MyBatis 的配置"></a>2. MyBatis 的配置</h2><h2 id="2-1-依赖导入"><a href="#2-1-依赖导入" class="headerlink" title="2.1 依赖导入"></a>2.1 依赖导入</h2><p>Spring Boot 集成 MyBatis，需要导入 <code>mybatis-spring-boot-starter</code> 和 mysql 的依赖，这里我们使用的版本时 1.3.2，如下：</p><pre class="line-numbers language-none"><code class="language-none">xml&lt;dependency&gt;&lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;&lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;&lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;mysql&lt;/groupId&gt;&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们点开 <code>mybatis-spring-boot-starter</code> 依赖，可以看到我们之前使用 Spring 时候熟悉的依赖，就像我在课程的一开始介绍的那样，Spring Boot 致力于简化编码，使用 starter 系列将相关依赖集成在一起，开发者不需要关注繁琐的配置，非常方便。</p><pre class="line-numbers language-none"><code class="language-none">xml&lt;!-- 省去其他 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;&lt;/dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-2-properties-yml配置"><a href="#2-2-properties-yml配置" class="headerlink" title="2.2 properties.yml配置"></a>2.2 properties.yml配置</h2><p>我们再来看一下，集成 MyBatis 时需要在 properties.yml 配置文件中做哪些基本配置呢？</p><pre class="line-numbers language-none"><code class="language-none">xml# 服务端口号server:  port: 8080# 数据库地址datasource:  url: localhost:3306/blog_testspring:  datasource: # 数据库配置    driver-class-name: com.mysql.jdbc.Driver    url: jdbc:mysql://${datasource.url}?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;allowMultiQueries=true&amp;autoReconnect=true&amp;failOverReadOnly=false&amp;maxReconnects=10    username: root    password: 123456    hikari:      maximum-pool-size: 10 # 最大连接池数      max-lifetime: 1770000mybatis:  # 指定别名设置的包为所有entity  type-aliases-package: com.itcodai.course10.entity  configuration:    map-underscore-to-camel-case: true # 驼峰命名规范  mapper-locations: # mapper映射文件位置    - classpath:mapper/*.xml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们来简单介绍一下上面的这些配置：关于数据库的相关配置，我就不详细的解说了，这点相信大家已经非常熟练了，配置一下用户名、密码、数据库连接等等，这里使用的连接池是 Spring Boot 自带的 hikari，感兴趣的朋友可以去百度或者谷歌搜一搜，了解一下。</p><p>这里说明一下 <code>map-underscore-to-camel-case: true</code>， 用来开启驼峰命名规范，这个比较好用，比如数据库中字段名为：<code>user_name</code>， 那么在实体类中可以定义属性为 <code>userName</code> （甚至可以写成 <code>username</code>，也能映射上），会自动匹配到驼峰属性，如果不这样配置的话，针对字段名和属性名不同的情况，会映射不到。</p><h2 id="3-基于-xml-的整合"><a href="#3-基于-xml-的整合" class="headerlink" title="3. 基于 xml 的整合"></a>3. 基于 xml 的整合</h2><p>使用原始的 xml 方式，需要新建 UserMapper.xml 文件，在上面的 application.yml 配置文件中，我们已经定义了 xml 文件的路径：<code>classpath:mapper/*.xml</code>，所以我们在 resources 目录下新建一个 mapper 文件夹，然后创建一个 UserMapper.xml 文件。</p><pre class="line-numbers language-none"><code class="language-none">xml&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.itcodai.course10.dao.UserMapper"&gt;  &lt;resultMap id="BaseResultMap" type="com.itcodai.course10.entity.User"&gt;    &lt;id column="id" jdbcType="BIGINT" property="id" /&gt;    &lt;result column="user_name" jdbcType="VARCHAR" property="username" /&gt;    &lt;result column="password" jdbcType="VARCHAR" property="password" /&gt;  &lt;/resultMap&gt;     &lt;select id="getUserByName" resultType="User" parameterType="String"&gt;       select * from user where user_name = #{username}  &lt;/select&gt;&lt;/mapper&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这和整合 Spring 一样的，namespace 中指定的是对应的 Mapper， <code>&lt;resultMap&gt;</code> 中指定对应的实体类，即 User。然后在内部指定表的字段和实体的属性相对应即可。这里我们写一个根据用户名查询用户的 sql。</p><p>实体类中有 id，username 和 password，我不在这贴代码，大家可以下载源码查看。UserMapper.java 文件中写一个接口即可：</p><pre class="line-numbers language-none"><code class="language-none">javaUser getUserByName(String username);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>中间省略 service 的代码，我们写一个 Controller 来测试一下：</p><pre class="line-numbers language-none"><code class="language-none">java@RestControllerpublic class TestController {    @Resource    private UserService userService;        @RequestMapping("/getUserByName/{name}")    public User getUserByName(@PathVariable String name) {        return userService.getUserByName(name);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>启动项目，在浏览器中输入：<code>http://localhost:8080/getUserByName/CSDN</code> 即可查询到数据库表中用户名为 CSDN 的用户信息（事先搞两个数据进去即可）：</p><pre class="line-numbers language-none"><code class="language-none">json{"id":2,"username":"CSDN","password":"123456"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里需要注意一下：Spring Boot 如何知道这个 Mapper 呢？一种方法是在上面的 mapper 层对应的类上面添加 <code>@Mapper</code> 注解即可，但是这种方法有个弊端，当我们有很多个 mapper 时，那么每一个类上面都得添加 <code>@Mapper</code> 注解。另一种比较简便的方法是在 Spring Boot 启动类上添加<code>@MaperScan</code> 注解，来扫描一个包下的所有 mapper。如下：</p><pre class="line-numbers language-none"><code class="language-none">java@SpringBootApplication@MapperScan("com.itcodai.course10.dao")public class Course10Application {public static void main(String[] args) {SpringApplication.run(Course10Application.class, args);}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样的话，<code>com.itcodai.course10.dao</code> 包下的所有 mapper 都会被扫描到了。</p><h2 id="4-基于注解的整合"><a href="#4-基于注解的整合" class="headerlink" title="4. 基于注解的整合"></a>4. 基于注解的整合</h2><p>基于注解的整合就不需要 xml 配置文件了，MyBatis 主要提供了 <code>@Select</code>， <code>@Insert</code>， <code>@Update</code>， <code>Delete</code> 四个注解。这四个注解是用的非常多的，也很简单，注解后面跟上对应的 sql 语句即可，我们举个例子：</p><pre class="line-numbers language-none"><code class="language-none">java@Select("select * from user where id = #{id}")User getUser(Long id);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这跟 xml 文件中写 sql 语句是一样的，这样就不需要 xml 文件了，但是有个问题，有人可能会问，如果是两个参数呢？如果是两个参数，我们需要使用 <code>@Param</code> 注解来指定每一个参数的对应关系，如下：</p><pre class="line-numbers language-none"><code class="language-none">java@Select("select * from user where id = #{id} and user_name=#{name}")User getUserByIdAndName(@Param("id") Long id, @Param("name") String username);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，<code>@Param</code> 指定的参数应该要和 sql 中 <code>#{}</code> 取的参数名相同，不同则取不到。可以在 controller 中自行测试一下，接口都在源码中，文章中我就不贴测试代码和结果了。</p><p>有个问题需要注意一下，一般我们在设计表字段后，都会根据自动生成工具生成实体类，这样的话，基本上实体类是能和表字段对应上的，最起码也是驼峰对应的，由于在上面配置文件中开启了驼峰的配置，所以字段都是能对的上的。但是，万一有对不上的呢？我们也有解决办法，使用 <code>@Results</code> 注解来解决。</p><pre class="line-numbers language-none"><code class="language-none">java@Select("select * from user where id = #{id}")@Results({        @Result(property = "username", column = "user_name"),        @Result(property = "password", column = "password")})User getUser(Long id);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>@Results</code> 中的 <code>@Result</code> 注解是用来指定每一个属性和字段的对应关系，这样的话就可以解决上面说的这个问题了。</p><p>当然了，我们也可以 xml 和注解相结合使用，目前我们实际的项目中也是采用混用的方式，因为有时候 xml 方便，有时候注解方便，比如就上面这个问题来说，如果我们定义了上面的这个 UserMapper.xml，那么我们完全可以使用 <code>@ResultMap</code> 注解来替代 <code>@Results</code> 注解，如下：</p><pre class="line-numbers language-none"><code class="language-none">java@Select("select * from user where id = #{id}")@ResultMap("BaseResultMap")User getUser(Long id);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>@ResultMap</code> 注解中的值从哪来呢？对应的是 UserMapper.xml 文件中定义的 <code>&lt;resultMap&gt;</code> 时对应的 id 值：</p><pre class="line-numbers language-none"><code class="language-none">xml&lt;resultMap id="BaseResultMap" type="com.itcodai.course10.entity.User"&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这种 xml 和注解结合着使用的情况也很常见，而且也减少了大量的代码，因为 xml 文件可以使用自动生成工具去生成，也不需要人为手动敲，所以这种使用方式也很常见。</p><h2 id="5-总结-3"><a href="#5-总结-3" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>本节课主要系统的讲解了 Spring Boot 集成 MyBatis 的过程，分为基于 xml 形式和基于注解的形式来讲解，通过实际配置手把手讲解了 Spring Boot 中 MyBatis 的使用方式，并针对注解方式，讲解了常见的问题已经解决方式，有很强的实战意义。在实际项目中，建议根据实际情况来确定使用哪种方式，一般 xml 和注解都在用。</p><p>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study">戳我下载</a></p><h1 id="第11课：Spring-Boot事务配置管理"><a href="#第11课：Spring-Boot事务配置管理" class="headerlink" title="第11课：Spring Boot事务配置管理"></a>第11课：Spring Boot事务配置管理</h1><h2 id="1-事务相关"><a href="#1-事务相关" class="headerlink" title="1. 事务相关"></a>1. 事务相关</h2><p>场景：我们在开发企业应用时，由于数据操作在顺序执行的过程中，线上可能有各种无法预知的问题，任何一步操作都有可能发生异常，异常则会导致后续的操作无法完成。此时由于业务逻辑并未正确的完成，所以在之前操作过数据库的动作并不可靠，需要在这种情况下进行数据的回滚。</p><p>事务的作用就是为了保证用户的每一个操作都是可靠的，事务中的每一步操作都必须成功执行，只要有发生异常就回退到事务开始未进行操作的状态。这很好理解，转账、购票等等，必须整个事件流程全部执行完才能人为该事件执行成功，不能转钱转到一半，系统死了，转账人钱没了，收款人钱还没到。</p><p>事务管理是 Spring Boot 框架中最为常用的功能之一，我们在实际应用开发时，基本上在 service 层处理业务逻辑的时候都要加上事务，当然了，有时候可能由于场景需要，也不用加事务（比如我们就要往一个表里插数据，相互没有影响，插多少是多少，不能因为某个数据挂了，把之前插的全部回滚）。</p><h2 id="2-Spring-Boot-事务配置"><a href="#2-Spring-Boot-事务配置" class="headerlink" title="2. Spring Boot 事务配置"></a>2. Spring Boot 事务配置</h2><h3 id="2-1-依赖导入-1"><a href="#2-1-依赖导入-1" class="headerlink" title="2.1 依赖导入"></a>2.1 依赖导入</h3><p>在 Spring Boot 中使用事务，需要导入 mysql 依赖：</p><pre class="line-numbers language-none"><code class="language-none">xml&lt;dependency&gt;&lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;&lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;&lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>导入了 mysql 依赖后，Spring Boot 会自动注入 DataSourceTransactionManager，我们不需要任何其他的配置就可以用 <code>@Transactional</code> 注解进行事务的使用。关于 mybatis 的配置，在上一节课中已经说明了，这里还是使用上一节课中的 mybatis 配置即可。</p><h3 id="2-2-事务的测试"><a href="#2-2-事务的测试" class="headerlink" title="2.2 事务的测试"></a>2.2 事务的测试</h3><p>我们首先在数据库表中插入一条数据：<br>|id|user_name|password|<br>|:–:|:–:|:–:|<br>|1|倪升武|123456|</p><p>然后我们写一个插入的 mapper：</p><pre class="line-numbers language-none"><code class="language-none">javapublic interface UserMapper {    @Insert("insert into user (user_name, password) values (#{username}, #{password})")    Integer insertUser(User user);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>OK，接下来我们来测试一下 Spring Boot 中的事务处理，在 service 层，我们手动抛出个异常来模拟实际中出现的异常，然后观察一下事务有没有回滚，如果数据库中没有新的记录，则说明事务回滚成功。</p><pre class="line-numbers language-none"><code class="language-none">java@Servicepublic class UserServiceImpl implements UserService {    @Resource    private UserMapper userMapper;    @Override    @Transactional    public void isertUser(User user) {        // 插入用户信息        userMapper.insertUser(user);        // 手动抛出异常        throw new RuntimeException();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们来测试一下：</p><pre class="line-numbers language-none"><code class="language-none">java@RestControllerpublic class TestController {    @Resource    private UserService userService;    @PostMapping("/adduser")    public String addUser(@RequestBody User user) throws Exception {        if (null != user) {            userService.isertUser(user);            return "success";        } else {            return "false";        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们使用 postman 调用一下该接口，因为在程序中抛出了个异常，会造成事务回滚，我们刷新一下数据库，并没有增加一条记录，说明事务生效了。事务很简单，我们平时在使用的时候，一般不会有多少问题，但是并不仅仅如此……</p><h2 id="3-常见问题总结"><a href="#3-常见问题总结" class="headerlink" title="3. 常见问题总结"></a>3. 常见问题总结</h2><p>从上面的内容中可以看出，Spring Boot 中使用事务非常简单，<code>@Transactional</code> 注解即可解决问题，说是这么说，但是在实际项目中，是有很多小坑在等着我们，这些小坑是我们在写代码的时候没有注意到，而且正常情况下不容易发现这些小坑，等项目写大了，某一天突然出问题了，排查问题非常困难，到时候肯定是抓瞎，需要费很大的精力去排查问题。</p><p>这一小节，我专门针对实际项目中经常出现的，和事务相关的细节做一下总结，希望读者在读完之后，能够落实到自己的项目中，能有所受益。</p><h3 id="3-1-异常并没有被-”捕获“-到"><a href="#3-1-异常并没有被-”捕获“-到" class="headerlink" title="3.1 异常并没有被 ”捕获“ 到"></a>3.1 异常并没有被 ”捕获“ 到</h3><p>首先要说的，就是异常并没有被 ”捕获“ 到，导致事务并没有回滚。我们在业务层代码中，也许已经考虑到了异常的存在，或者编辑器已经提示我们需要抛出异常，但是这里面有个需要注意的地方：并不是说我们把异常抛出来了，有异常了事务就会回滚，我们来看一个例子：</p><pre class="line-numbers language-none"><code class="language-none">java@Servicepublic class UserServiceImpl implements UserService {    @Resource    private UserMapper userMapper;        @Override    @Transactional    public void isertUser2(User user) throws Exception {        // 插入用户信息        userMapper.insertUser(user);        // 手动抛出异常        throw new SQLException("数据库异常");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们看上面这个代码，其实并没有什么问题，手动抛出一个 <code>SQLException</code> 来模拟实际中操作数据库发生的异常，在这个方法中，既然抛出了异常，那么事务应该回滚，实际却不如此，读者可以使用我源码中 controller 的接口，通过 postman 测试一下，就会发现，仍然是可以插入一条用户数据的。</p><p>那么问题出在哪呢？因为 Spring Boot 默认的事务规则是遇到运行异常（RuntimeException）和程序错误（Error）才会回滚。比如上面我们的例子中抛出的 RuntimeException 就没有问题，但是抛出 SQLException 就无法回滚了。针对非运行时异常，如果要进行事务回滚的话，可以在 <code>@Transactional</code> 注解中使用 <code>rollbackFor</code> 属性来指定异常，比如 <code>@Transactional(rollbackFor = Exception.class)</code>，这样就没有问题了，所以在实际项目中，一定要指定异常。</p><h3 id="3-2-异常被-”吃“-掉"><a href="#3-2-异常被-”吃“-掉" class="headerlink" title="3.2 异常被 ”吃“ 掉"></a>3.2 异常被 ”吃“ 掉</h3><p>这个标题很搞笑，异常怎么会被吃掉呢？还是回归到现实项目中去，我们在处理异常时，有两种方式，要么抛出去，让上一层来捕获处理；要么把异常 try catch 掉，在异常出现的地方给处理掉。就因为有这中 try…catch，所以导致异常被 ”吃“ 掉，事务无法回滚。我们还是看上面那个例子，只不过简单修改一下代码：</p><pre class="line-numbers language-none"><code class="language-none">java@Servicepublic class UserServiceImpl implements UserService {    @Resource    private UserMapper userMapper;    @Override    @Transactional(rollbackFor = Exception.class)    public void isertUser3(User user) {        try {            // 插入用户信息            userMapper.insertUser(user);            // 手动抛出异常            throw new SQLException("数据库异常");        } catch (Exception e) {// 异常处理逻辑        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>读者可以使用我源码中 controller 的接口，通过 postman 测试一下，就会发现，仍然是可以插入一条用户数据，说明事务并没有因为抛出异常而回滚。这个细节往往比上面那个坑更难以发现，因为我们的思维很容易导致 try…catch 代码的产生，一旦出现这种问题，往往排查起来比较费劲，所以我们平时在写代码时，一定要多思考，多注意这种细节，尽量避免给自己埋坑。</p><p>那这种怎么解决呢？直接往上抛，给上一层来处理即可，千万不要在事务中把异常自己 ”吃“ 掉。</p><h3 id="3-3-事务的范围"><a href="#3-3-事务的范围" class="headerlink" title="3.3 事务的范围"></a>3.3 事务的范围</h3><p>事务范围这个东西比上面两个坑埋的更深！我之所以把这个也写上，是因为这是我之前在实际项目中遇到的，该场景在这个课程中我就不模拟了，我写一个 demo 让大家看一下，把这个坑记住即可，以后在写代码时，遇到并发问题，就会注意这个坑了，那么这节课也就有价值了。</p><p>我来写个 demo：</p><pre class="line-numbers language-none"><code class="language-none">java@Servicepublic class UserServiceImpl implements UserService {    @Resource    private UserMapper userMapper;    @Override    @Transactional(rollbackFor = Exception.class)    public synchronized void isertUser4(User user) {        // 实际中的具体业务……        userMapper.insertUser(user);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，因为要考虑并发问题，我在业务层代码的方法上加了个 synchronized 关键字。我举个实际的场景，比如一个数据库中，针对某个用户，只有一条记录，下一个插入动作过来，会先判断该数据库中有没有相同的用户，如果有就不插入，就更新，没有才插入，所以理论上，数据库中永远就一条同一用户信息，不会出现同一数据库中插入了两条相同用户的信息。</p><p>但是在压测时，就会出现上面的问题，数据库中确实有两条同一用户的信息，分析其原因，在于事务的范围和锁的范围问题。</p><p>从上面方法中可以看到，方法上是加了事务的，那么也就是说，在执行该方法开始时，事务启动，执行完了后，事务关闭。但是 synchronized 没有起作用，其实根本原因是因为事务的范围比锁的范围大。也就是说，在加锁的那部分代码执行完之后，锁释放掉了，但是事务还没结束，此时另一个线程进来了，事务没结束的话，第二个线程进来时，数据库的状态和第一个线程刚进来是一样的。即由于mysql Innodb引擎的默认隔离级别是可重复读（在同一个事务里，SELECT的结果是事务开始时时间点的状态），线程二事务开始的时候，线程一还没提交完成，导致读取的数据还没更新。第二个线程也做了插入动作，导致了脏数据。</p><p>这个问题可以避免，第一，把事务去掉即可（不推荐）；第二，在调用该 service 的地方加锁，保证锁的范围比事务的范围大即可。</p><h2 id="4-总结-4"><a href="#4-总结-4" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>本章主要总结了 Spring Boot 中如何使用事务，只要使用 <code>@Transactional</code> 注解即可使用，非常简单方便。除此之外，重点总结了三个在实际项目中可能遇到的坑点，这非常有意义，因为事务这东西不出问题还好，出了问题比较难以排查，所以总结的这三点注意事项，希望能帮助到开发中的朋友。</p><p>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study">戳我下载</a></p><h1 id="第12课：Spring-Boot中使用监听器"><a href="#第12课：Spring-Boot中使用监听器" class="headerlink" title="第12课：Spring Boot中使用监听器"></a>第12课：Spring Boot中使用监听器</h1><h2 id="1-监听器介绍"><a href="#1-监听器介绍" class="headerlink" title="1. 监听器介绍"></a>1. 监听器介绍</h2><p>什么是 web 监听器？web 监听器是一种 Servlet 中特殊的类，它们能帮助开发者监听 web 中特定的事件，比如 ServletContext, HttpSession, ServletRequest 的创建和销毁；变量的创建、销毁和修改等。可以在某些动作前后增加处理，实现监控。</p><h2 id="2-Spring-Boot中监听器的使用"><a href="#2-Spring-Boot中监听器的使用" class="headerlink" title="2. Spring Boot中监听器的使用"></a>2. Spring Boot中监听器的使用</h2><p>web 监听器的使用场景很多，比如监听 servlet 上下文用来初始化一些数据、监听 http session 用来获取当前在线的人数、监听客户端请求的 servlet request 对象来获取用户的访问信息等等。这一节中，我们主要通过这三个实际的使用场景来学习一下 Spring Boot 中监听器的使用。</p><h3 id="2-1-监听Servlet上下文对象"><a href="#2-1-监听Servlet上下文对象" class="headerlink" title="2.1 监听Servlet上下文对象"></a>2.1 监听Servlet上下文对象</h3><p>监听 servlet 上下文对象可以用来初始化数据，用于缓存。什么意思呢？我举一个很常见的场景，比如用户在点击某个站点的首页时，一般都会展现出首页的一些信息，而这些信息基本上或者大部分时间都保持不变的，但是这些信息都是来自数据库。如果用户的每次点击，都要从数据库中去获取数据的话，用户量少还可以接受，如果用户量非常大的话，这对数据库也是一笔很大的开销。</p><p>针对这种首页数据，大部分都不常更新的话，我们完全可以把它们缓存起来，每次用户点击的时候，我们都直接从缓存中拿，这样既可以提高首页的访问速度，又可以降低服务器的压力。如果做的更加灵活一点，可以再加个定时器，定期的来更新这个首页缓存。就类似与 CSDN 个人博客首页中排名的变化一样。</p><p>下面我们针对这个功能，来写一个 demo，在实际中，读者可以完全套用该代码，来实现自己项目中的相关逻辑。首先写一个 Service，模拟一下从数据库查询数据：</p><pre class="line-numbers language-none"><code class="language-none">java@Servicepublic class UserService {    /**     * 获取用户信息     * @return     */    public User getUser() {        // 实际中会根据具体的业务场景，从数据库中查询对应的信息        return new User(1L, "倪升武", "123456");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后写一个监听器，实现 <code>ApplicationListener&lt;ContextRefreshedEvent&gt;</code> 接口，重写 <code>onApplicationEvent</code> 方法，将 ContextRefreshedEvent 对象传进去。如果我们想在加载或刷新应用上下文时，也重新刷新下我们预加载的资源，就可以通过监听 ContextRefreshedEvent 来做这样的事情。如下：</p><pre class="line-numbers language-none"><code class="language-none">java/** * 使用ApplicationListener来初始化一些数据到application域中的监听器 * @author shengni ni * @date 2018/07/05 */@Componentpublic class MyServletContextListener implements ApplicationListener&lt;ContextRefreshedEvent&gt; {    @Override    public void onApplicationEvent(ContextRefreshedEvent contextRefreshedEvent) {        // 先获取到application上下文        ApplicationContext applicationContext = contextRefreshedEvent.getApplicationContext();        // 获取对应的service        UserService userService = applicationContext.getBean(UserService.class);        User user = userService.getUser();        // 获取application域对象，将查到的信息放到application域中        ServletContext application = applicationContext.getBean(ServletContext.class);        application.setAttribute("user", user);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正如注释中描述的一样，首先通过 contextRefreshedEvent 来获取 application 上下文，再通过 application 上下文来获取 UserService 这个 bean，项目中可以根据实际业务场景，也可以获取其他的 bean，然后再调用自己的业务代码获取相应的数据，最后存储到 application 域中，这样前端在请求相应数据的时候，我们就可以直接从 application 域中获取信息，减少数据库的压力。下面写一个 Controller 直接从 application 域中获取 user 信息来测试一下。</p><pre class="line-numbers language-none"><code class="language-none">java@RestController@RequestMapping("/listener")public class TestController {    @GetMapping("/user")    public User getUser(HttpServletRequest request) {        ServletContext application = request.getServletContext();        return (User) application.getAttribute("user");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>启动项目，在浏览器中输入 <code>http://localhost:8080/listener/user</code> 测试一下即可，如果正常返回 user 信息，那么说明数据已经缓存成功。不过 application 这种是缓存在内存中，对内存会有消耗，后面的课程中我会讲到 redis，到时候再给大家介绍一下 redis 的缓存。</p><h3 id="2-2-监听HTTP会话-Session对象"><a href="#2-2-监听HTTP会话-Session对象" class="headerlink" title="2.2 监听HTTP会话 Session对象"></a>2.2 监听HTTP会话 Session对象</h3><p>监听器还有一个比较常用的地方就是用来监听 session 对象，来获取在线用户数量，现在有很多开发者都有自己的网站，监听 session 来获取当前在下用户数量是个很常见的使用场景，下面来介绍一下如何来使用。</p><pre class="line-numbers language-none"><code class="language-none">java/** * 使用HttpSessionListener统计在线用户数的监听器 * @author shengwu ni * @date 2018/07/05 */@Componentpublic class MyHttpSessionListener implements HttpSessionListener {    private static final Logger logger = LoggerFactory.getLogger(MyHttpSessionListener.class);    /**     * 记录在线的用户数量     */    public Integer count = 0;    @Override    public synchronized void sessionCreated(HttpSessionEvent httpSessionEvent) {        logger.info("新用户上线了");        count++;        httpSessionEvent.getSession().getServletContext().setAttribute("count", count);    }    @Override    public synchronized void sessionDestroyed(HttpSessionEvent httpSessionEvent) {        logger.info("用户下线了");        count--;        httpSessionEvent.getSession().getServletContext().setAttribute("count", count);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，首先该监听器需要实现 HttpSessionListener 接口，然后重写 <code>sessionCreated</code> 和 <code>sessionDestroyed</code> 方法，在 <code>sessionCreated</code> 方法中传递一个 HttpSessionEvent 对象，然后将当前 session 中的用户数量加1，<code>sessionDestroyed</code> 方法刚好相反，不再赘述。然后我们写一个 Controller 来测试一下。</p><pre class="line-numbers language-none"><code class="language-none">java@RestController@RequestMapping("/listener")public class TestController {    /**     * 获取当前在线人数，该方法有bug     * @param request     * @return     */    @GetMapping("/total")    public String getTotalUser(HttpServletRequest request) {        Integer count = (Integer) request.getSession().getServletContext().getAttribute("count");        return "当前在线人数：" + count;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该 Controller 中是直接获取当前 session 中的用户数量，启动服务器，在浏览器中输入 <code>localhost:8080/listener/total</code> 可以看到返回的结果是1，再打开一个浏览器，请求相同的地址可以看到 count 是 2 ，这没有问题。但是如果关闭一个浏览器再打开，理论上应该还是2，但是实际测试却是 3。原因是 session 销毁的方法没有执行（可以在后台控制台观察日志打印情况），当重新打开时，服务器找不到用户原来的 session，于是又重新创建了一个 session，那怎么解决该问题呢？我们可以将上面的 Controller 方法改造一下：</p><pre class="line-numbers language-none"><code class="language-none">java@GetMapping("/total2")public String getTotalUser(HttpServletRequest request, HttpServletResponse response) {    Cookie cookie;    try {        // 把sessionId记录在浏览器中        cookie = new Cookie("JSESSIONID", URLEncoder.encode(request.getSession().getId(), "utf-8"));        cookie.setPath("/");        //设置cookie有效期为2天，设置长一点        cookie.setMaxAge( 48*60 * 60);        response.addCookie(cookie);    } catch (UnsupportedEncodingException e) {        e.printStackTrace();    }    Integer count = (Integer) request.getSession().getServletContext().getAttribute("count");    return "当前在线人数：" + count;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，该处理逻辑是让服务器记得原来那个 session，即把原来的 sessionId 记录在浏览器中，下次再打开时，把这个 sessionId 传过去，这样服务器就不会重新再创建了。重启一下服务器，在浏览器中再次测试一下，即可避免上面的问题。</p><h3 id="2-3-监听客户端请求Servlet-Request对象"><a href="#2-3-监听客户端请求Servlet-Request对象" class="headerlink" title="2.3 监听客户端请求Servlet Request对象"></a>2.3 监听客户端请求Servlet Request对象</h3><p>使用监听器获取用户的访问信息比较简单，实现 ServletRequestListener 接口即可，然后通过 request 对象获取一些信息。如下：</p><pre class="line-numbers language-none"><code class="language-none">java/** * 使用ServletRequestListener获取访问信息 * @author shengwu ni * @date 2018/07/05 */@Componentpublic class MyServletRequestListener implements ServletRequestListener {    private static final Logger logger = LoggerFactory.getLogger(MyServletRequestListener.class);    @Override    public void requestInitialized(ServletRequestEvent servletRequestEvent) {        HttpServletRequest request = (HttpServletRequest) servletRequestEvent.getServletRequest();        logger.info("session id为：{}", request.getRequestedSessionId());        logger.info("request url为：{}", request.getRequestURL());        request.setAttribute("name", "倪升武");    }    @Override    public void requestDestroyed(ServletRequestEvent servletRequestEvent) {        logger.info("request end");        HttpServletRequest request = (HttpServletRequest) servletRequestEvent.getServletRequest();        logger.info("request域中保存的name值为：{}", request.getAttribute("name"));    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个比较简单，不再赘述，接下来写一个 Controller 测试一下即可。</p><pre class="line-numbers language-none"><code class="language-none">java@GetMapping("/request")public String getRequestInfo(HttpServletRequest request) {    System.out.println("requestListener中的初始化的name数据：" + request.getAttribute("name"));    return "success";}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-Spring-Boot中自定义事件监听"><a href="#3-Spring-Boot中自定义事件监听" class="headerlink" title="3. Spring Boot中自定义事件监听"></a>3. Spring Boot中自定义事件监听</h2><p>在实际项目中，我们往往需要自定义一些事件和监听器来满足业务场景，比如在微服务中会有这样的场景：微服务 A 在处理完某个逻辑之后，需要通知微服务 B 去处理另一个逻辑，或者微服务 A 处理完某个逻辑之后，需要将数据同步到微服务 B，这种场景非常普遍，这个时候，我们可以自定义事件以及监听器来监听，一旦监听到微服务 A 中的某事件发生，就去通知微服务 B 处理对应的逻辑。</p><h3 id="3-1-自定义事件"><a href="#3-1-自定义事件" class="headerlink" title="3.1 自定义事件"></a>3.1 自定义事件</h3><p>自定义事件需要继承 ApplicationEvent 对象，在事件中定义一个 User 对象来模拟数据，构造方法中将 User 对象传进来初始化。如下：</p><pre class="line-numbers language-none"><code class="language-none">java/** * 自定义事件 * @author shengwu ni * @date 2018/07/05 */public class MyEvent extends ApplicationEvent {    private User user;    public MyEvent(Object source, User user) {        super(source);        this.user = user;    }    // 省去get、set方法}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-自定义监听器"><a href="#3-2-自定义监听器" class="headerlink" title="3.2 自定义监听器"></a>3.2 自定义监听器</h3><p>接下来，自定义一个监听器来监听上面定义的 MyEvent 事件，自定义监听器需要实现 <code>ApplicationListener</code> 接口即可。如下：</p><pre class="line-numbers language-none"><code class="language-none">java/** * 自定义监听器，监听MyEvent事件 * @author shengwu ni * @date 2018/07/05 */@Componentpublic class MyEventListener implements ApplicationListener&lt;MyEvent&gt; {    @Override    public void onApplicationEvent(MyEvent myEvent) {        // 把事件中的信息获取到        User user = myEvent.getUser();        // 处理事件，实际项目中可以通知别的微服务或者处理其他逻辑等等        System.out.println("用户名：" + user.getUsername());        System.out.println("密码：" + user.getPassword());    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后重写 <code>onApplicationEvent</code> 方法，将自定义的 MyEvent 事件传进来，因为该事件中，我们定义了 User 对象（该对象在实际中就是需要处理的数据，在下文来模拟），然后就可以使用该对象的信息了。</p><p>OK，定义好了事件和监听器之后，需要手动发布事件，这样监听器才能监听到，这需要根据实际业务场景来触发，针对本文的例子，我写个触发逻辑，如下：</p><pre class="line-numbers language-none"><code class="language-none">java/** * UserService * @author shengwu ni */@Servicepublic class UserService {    @Resource    private ApplicationContext applicationContext;    /**     * 发布事件     * @return     */    public User getUser2() {        User user = new User(1L, "倪升武", "123456");        // 发布事件        MyEvent event = new MyEvent(this, user);        applicationContext.publishEvent(event);        return user;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 service 中注入 ApplicationContext，在业务代码处理完之后，通过 ApplicationContext 对象手动发布 MyEvent 事件，这样我们自定义的监听器就能监听到，然后处理监听器中写好的业务逻辑。</p><p>最后，在 Controller 中写一个接口来测试一下：</p><pre class="line-numbers language-none"><code class="language-none">java@GetMapping("/request")public String getRequestInfo(HttpServletRequest request) {    System.out.println("requestListener中的初始化的name数据：" + request.getAttribute("name"));    return "success";}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在浏览器中输入 <code>http://localhost:8080/listener/publish</code>，然后观察一下控制台打印的用户名和密码，即可说明自定义监听器已经生效。</p><h2 id="4-总结-5"><a href="#4-总结-5" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>本课系统的介绍了监听器原理，以及在 Spring Boot 中如何使用监听器，列举了监听器的三个常用的案例，有很好的实战意义。最后讲解了项目中如何自定义事件和监听器，并结合微服务中常见的场景，给出具体的代码模型，均能运用到实际项目中去，希望读者认真消化。</p><p>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study">戳我下载</a></p><h1 id="第13课：Spring-Boot中使用拦截器"><a href="#第13课：Spring-Boot中使用拦截器" class="headerlink" title="第13课：Spring Boot中使用拦截器"></a>第13课：Spring Boot中使用拦截器</h1><p>拦截器的原理很简单，是 AOP 的一种实现，专门拦截对动态资源的后台请求，即拦截对控制层的请求。使用场景比较多的是判断用户是否有权限请求后台，更拔高一层的使用场景也有，比如拦截器可以结合 websocket 一起使用，用来拦截 websocket 请求，然后做相应的处理等等。拦截器不会拦截静态资源，Spring Boot 的默认静态目录为 resources/static，该目录下的静态页面、js、css、图片等等，不会被拦截（也要看如何实现，有些情况也会拦截，我在下文会指出）。</p><h2 id="1-拦截器的快速使用"><a href="#1-拦截器的快速使用" class="headerlink" title="1. 拦截器的快速使用"></a>1. 拦截器的快速使用</h2><p>使用拦截器很简单，只需要两步即可：定义拦截器和配置拦截器。在配置拦截器中，Spring Boot 2.0 以后的版本和之前的版本有所不同，我会重点讲解一下这里可能出现的坑。</p><h3 id="1-1-定义拦截器"><a href="#1-1-定义拦截器" class="headerlink" title="1.1 定义拦截器"></a>1.1 定义拦截器</h3><p>定义拦截器，只需要实现 <code>HandlerInterceptor</code> 接口，<code>HandlerInterceptor</code> 接口是所有自定义拦截器或者 Spring Boot 提供的拦截器的鼻祖，所以，首先来了解下该接口。该接口中有三个方法： <code>preHandle(……)</code>、<code>postHandle(……)</code> 和 <code>afterCompletion(……)</code> 。</p><blockquote><p><code>preHandle(……)</code> 方法：该方法的执行时机是，当某个 url 已经匹配到对应的 Controller 中的某个方法，且在这个方法执行之前。所以 <code>preHandle(……)</code> 方法可以决定是否将请求放行，这是通过返回值来决定的，返回 true 则放行，返回 false 则不会向后执行。<br><code>postHandle(……)</code> 方法：该方法的执行时机是，当某个 url 已经匹配到对应的 Controller 中的某个方法，且在执行完了该方法，但是在 DispatcherServlet 视图渲染之前。所以在这个方法中有个 ModelAndView 参数，可以在此做一些修改动作。<br><code>afterCompletion(……)</code> 方法：顾名思义，该方法是在整个请求处理完成后（包括视图渲染）执行，这时做一些资源的清理工作，这个方法只有在 <code>preHandle(……)</code> 被成功执行后并且返回 true 才会被执行。</p></blockquote><p>了解了该接口，接下来自定义一个拦截器。</p><pre class="line-numbers language-none"><code class="language-none">java/** * 自定义拦截器 * @author shengwu ni * @date 2018/08/03 */public class MyInterceptor implements HandlerInterceptor {    private static final Logger logger = LoggerFactory.getLogger(MyInterceptor.class);    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {        HandlerMethod handlerMethod = (HandlerMethod) handler;        Method method = handlerMethod.getMethod();        String methodName = method.getName();        logger.info("====拦截到了方法：{}，在该方法执行之前执行====", methodName);        // 返回true才会继续执行，返回false则取消当前请求        return true;    }    @Override    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {        logger.info("执行完方法之后进执行(Controller方法调用之后)，但是此时还没进行视图渲染");    }    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {        logger.info("整个请求都处理完咯，DispatcherServlet也渲染了对应的视图咯，此时我可以做一些清理的工作了");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>OK，到此为止，拦截器已经定义完成，接下来就是对该拦截器进行拦截配置。</p><h3 id="1-2-配置拦截器"><a href="#1-2-配置拦截器" class="headerlink" title="1.2 配置拦截器"></a>1.2 配置拦截器</h3><p>在 Spring Boot 2.0 之前，我们都是直接继承 WebMvcConfigurerAdapter 类，然后重写 <code>addInterceptors</code> 方法来实现拦截器的配置。但是在 Spring Boot 2.0 之后，该方法已经被废弃了（当然，也可以继续用），取而代之的是 WebMvcConfigurationSupport 方法，如下：</p><pre class="line-numbers language-none"><code class="language-none">java@Configurationpublic class MyInterceptorConfig extends WebMvcConfigurationSupport {    @Override    protected void addInterceptors(InterceptorRegistry registry) {        registry.addInterceptor(new MyInterceptor()).addPathPatterns("/**");        super.addInterceptors(registry);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在该配置中重写 <code>addInterceptors</code> 方法，将我们上面自定义的拦截器添加进去，<code>addPathPatterns</code> 方法是添加要拦截的请求，这里我们拦截所有的请求。这样就配置好拦截器了，接下来写一个 Controller 测试一下：</p><pre class="line-numbers language-none"><code class="language-none">java@Controller@RequestMapping("/interceptor")public class InterceptorController {    @RequestMapping("/test")    public String test() {        return "hello";    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>让其跳转到 hello.html 页面，直接在 hello.html 中输出 <code>hello interceptor</code> 即可。启动项目，在浏览器中输入 <code>localhost:8080/interceptor/test</code> 看一下控制台的日志：</p><pre class="line-numbers language-none"><code class="language-none">plain====拦截到了方法：test，在该方法执行之前执行====  执行完方法之后进执行(Controller方法调用之后)，但是此时还没进行视图渲染  整个请求都处理完咯，DispatcherServlet也渲染了对应的视图咯，此时我可以做一些清理的工作了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出拦截器已经生效，并能看出其执行顺序。</p><h3 id="1-3-解决静态资源被拦截问题"><a href="#1-3-解决静态资源被拦截问题" class="headerlink" title="1.3 解决静态资源被拦截问题"></a>1.3 解决静态资源被拦截问题</h3><p>上文中已经介绍了拦截器的定义和配置，但是这样是否就没问题了呢？其实不然，如果使用上面这种配置的话，我们会发现一个缺陷，那就是静态资源被拦截了。可以在 resources/static/ 目录下放置一个图片资源或者 html 文件，然后启动项目直接访问，即可看到无法访问的现象。</p><p>也就是说，虽然 Spring Boot 2.0 废弃了WebMvcConfigurerAdapter，但是 WebMvcConfigurationSupport 又会导致默认的静态资源被拦截，这就需要我们手动将静态资源放开。</p><p>如何放开呢？除了在 MyInterceptorConfig 配置类中重写 <code>addInterceptors</code> 方法外，还需要再重写一个方法：<code>addResourceHandlers</code>，将静态资源放开：</p><pre class="line-numbers language-none"><code class="language-none">java/** * 用来指定静态资源不被拦截，否则继承WebMvcConfigurationSupport这种方式会导致静态资源无法直接访问 * @param registry */@Overrideprotected void addResourceHandlers(ResourceHandlerRegistry registry) {    registry.addResourceHandler("/**").addResourceLocations("classpath:/static/");    super.addResourceHandlers(registry);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样配置好之后，重启项目，静态资源也可以正常访问了。如果你是个善于学习或者研究的人，那肯定不会止步于此，没错，上面这种方式的确能解决静态资源无法访问的问题，但是，还有更方便的方式来配置。</p><p>我们不继承 WebMvcConfigurationSupport 类，直接实现 WebMvcConfigurer 接口，然后重写 <code>addInterceptors</code> 方法，将自定义的拦截器添加进去即可，如下：</p><pre class="line-numbers language-none"><code class="language-none">java@Configurationpublic class MyInterceptorConfig implements WebMvcConfigurer {    @Override    public void addInterceptors(InterceptorRegistry registry) {        // 实现WebMvcConfigurer不会导致静态资源被拦截        registry.addInterceptor(new MyInterceptor()).addPathPatterns("/**");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样就非常方便了，实现 WebMvcConfigure 接口的话，不会拦截 Spring Boot 默认的静态资源。</p><p>这两种方式都可以，具体他们之间的细节，感兴趣的读者可以做进一步的研究，由于这两种方式的不同，继承 WebMvcConfigurationSupport 类的方式可以用在前后端分离的项目中，后台不需要访问静态资源（就不需要放开静态资源了）；实现 WebMvcConfigure 接口的方式可以用在非前后端分离的项目中，因为需要读取一些图片、css、js文件等等。</p><h2 id="2-拦截器使用实例"><a href="#2-拦截器使用实例" class="headerlink" title="2. 拦截器使用实例"></a>2. 拦截器使用实例</h2><h3 id="2-1-判断用户有没有登录"><a href="#2-1-判断用户有没有登录" class="headerlink" title="2.1 判断用户有没有登录"></a>2.1 判断用户有没有登录</h3><p>一般用户登录功能我们可以这么做，要么往 session 中写一个 user，要么针对每个 user 生成一个 token，第二种要更好一点，那么针对第二种方式，如果用户登录成功了，每次请求的时候都会带上该用户的 token，如果未登录，则没有该 token，服务端可以检测这个 token 参数的有无来判断用户有没有登录，从而实现拦截功能。我们改造一下 <code>preHandle</code> 方法，如下：</p><pre class="line-numbers language-none"><code class="language-none">java@Overridepublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {    HandlerMethod handlerMethod = (HandlerMethod) handler;    Method method = handlerMethod.getMethod();    String methodName = method.getName();    logger.info("====拦截到了方法：{}，在该方法执行之前执行====", methodName);    // 判断用户有没有登陆，一般登陆之后的用户都有一个对应的token    String token = request.getParameter("token");    if (null == token || "".equals(token)) {        logger.info("用户未登录，没有权限执行……请登录");        return false;    }    // 返回true才会继续执行，返回false则取消当前请求    return true;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重启项目，在浏览器中输入 <code>localhost:8080/interceptor/test</code> 后查看控制台日志，发现被拦截，如果在浏览器中输入 <code>localhost:8080/interceptor/test?token=123</code> 即可正常往下走。</p><h3 id="2-2-取消拦截操作"><a href="#2-2-取消拦截操作" class="headerlink" title="2.2 取消拦截操作"></a>2.2 取消拦截操作</h3><p>根据上文，如果我要拦截所有 <code>/admin</code> 开头的 url 请求的话，需要在拦截器配置中添加这个前缀，但是在实际项目中，可能会有这种场景出现：某个请求也是 <code>/admin</code> 开头的，但是不能拦截，比如 <code>/admin/login</code> 等等，这样的话又需要去配置。那么，可不可以做成一个类似于开关的东西，哪里不需要拦截，我就在哪里弄个开关上去，做成这种灵活的可插拔的效果呢？</p><p>是可以的，我们可以定义一个注解，该注解专门用来取消拦截操作，如果某个 Controller 中的方法我们不需要拦截掉，即可在该方法上加上我们自定义的注解即可，下面先定义一个注解：</p><pre class="line-numbers language-none"><code class="language-none">java/** * 该注解用来指定某个方法不用拦截 */@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface UnInterception {}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后在 Controller 中的某个方法上添加该注解，在拦截器处理方法中添加该注解取消拦截的逻辑，如下：</p><pre class="line-numbers language-none"><code class="language-none">java@Overridepublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {    HandlerMethod handlerMethod = (HandlerMethod) handler;    Method method = handlerMethod.getMethod();    String methodName = method.getName();    logger.info("====拦截到了方法：{}，在该方法执行之前执行====", methodName);    // 通过方法，可以获取该方法上的自定义注解，然后通过注解来判断该方法是否要被拦截    // @UnInterception 是我们自定义的注解    UnInterception unInterception = method.getAnnotation(UnInterception.class);    if (null != unInterception) {        return true;    }    // 返回true才会继续执行，返回false则取消当前请求    return true;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Controller 中的方法代码可以参见源码，重启项目在浏览器中输入 <code>http://localhost:8080/interceptor/test2?token=123</code> 测试一下，可以看出，加了该注解的方法不会被拦截。</p><h2 id="3-总结-1"><a href="#3-总结-1" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>本节主要介绍了 Spring Boot 中拦截器的使用，从拦截器的创建、配置，到拦截器对静态资源的影响，都做了详细的分析。Spring Boot 2.0 之后拦截器的配置支持两种方式，可以根据实际情况选择不同的配置方式。最后结合实际中的使用，举了两个常用的场景，希望读者能够认真消化，掌握拦截器的使用。</p><p>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study">戳我下载</a></p><h1 id="第14课：Spring-Boot-中集成Redis"><a href="#第14课：Spring-Boot-中集成Redis" class="headerlink" title="第14课：Spring Boot 中集成Redis"></a>第14课：Spring Boot 中集成Redis</h1><h2 id="1-Redis-介绍"><a href="#1-Redis-介绍" class="headerlink" title="1. Redis 介绍"></a>1. Redis 介绍</h2><p>Redis 是一种非关系型数据库（NoSQL），NoSQL 是以 key-value 的形式存储的，和传统的关系型数据库不一样，不一定遵循传统数据库的一些基本要求，比如说 SQL 标准，ACID 属性，表结构等等，这类数据库主要有以下特点：非关系型的、分布式的、开源的、水平可扩展的。<br>NoSQL 使用场景有：对数据高并发读写、对海量数据的高效率存储和访问、对数据的高可扩展性和高可用性等等。<br>Redis 的 key 可以是字符串、哈希、链表、集合和有序集合。value 类型很多，包括 String、list、set、zset。这些数据类型都支持 push/pop、add/remove、取交集和并集以及更多更丰富的操作，Redis 也支持各种不同方式的排序。为了保证效率，数据都是在缓存在内存中，它也可以周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件中。 有了 redis 有哪些好处呢？举个比较简单的例子，看下图：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMuZ2l0Ym9vay5jbi80MjU4YjljMC05ZjkzLTExZTgtYTM0Zi1kOTNkYTkyMzQ3ZWE?x-oss-process=image/format,png" alt="Redis使用场景"></p><p>Redis 集群和 Mysql 是同步的，首先会从 redis 中获取数据，如果 redis 挂了，再从 mysql 中获取数据，这样网站就不会挂掉。更多关于 redis 的介绍以及使用场景，可以谷歌和百度，在这就不赘述了。</p><h2 id="2-Redis-安装"><a href="#2-Redis-安装" class="headerlink" title="2. Redis 安装"></a>2. Redis 安装</h2><p>本课程是在 vmvare 虚拟机中来安装的 redis （centos 7），学习的时候如果有自己的阿里云服务器，也可以在阿里云中来安装 redis，都可以。只要能 ping 的通云主机或者虚拟机的 ip，然后在虚拟机或者云主机中放行对应的端口（或者关掉防火墙）即可访问 redis。下面来介绍一下 redis 的安装过程：</p><ul><li>安装 gcc 编译</li></ul><p>因为后面安装redis的时候需要编译，所以事先得先安装gcc编译。阿里云主机已经默认安装了 gcc，如果是自己安装的虚拟机，那么需要先安装一下 gcc：</p><pre class="line-numbers language-none"><code class="language-none">plainyum install gcc-c++<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>下载 redis</li></ul><p>有两种方式下载安装包，一种是去官网上下载（<a href="https://redis.xn--io">https://redis.io），然后将安装包考到</a>%2C-tm9f47b82cz61ae6ax52l797aw7v/) centos 中，另种方法是直接使用 wget 来下载：</p><pre class="line-numbers language-none"><code class="language-none">plainwget http://download.redis.io/releases/redis-3.2.8.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果没有安装过 wget，可以通过如下命令安装：</p><pre class="line-numbers language-none"><code class="language-none">plainyum install wget<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>解压安装</li></ul><p>解压安装包：</p><pre class="line-numbers language-none"><code class="language-none">plaintar –vzxf redis-3.2.8.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后将解压的文件夹 redis-3.2.8 放到 <code>/usr/local/</code> 下，一般安装软件都放在 <code>/usr/local</code> 下。然后进入 <code>/usr/local/redis-3.2.8/</code> 文件夹下，执行 <code>make</code> 命令即可完成安装。<br>【注】如果 make 失败，可以尝试如下命令：</p><pre class="line-numbers language-none"><code class="language-none">plainmake MALLOC=libcmake install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>修改配置文件</li></ul><p>安装成功之后，需要修改一下配置文件，包括允许接入的 ip，允许后台执行，设置密码等等。<br>打开 redis 配置文件：<code>vi redis.conf</code><br>在命令模式下输入 <code>/bind</code> 来查找 bind 配置，按 n 来查找下一个，找到配置后，将 bind 配置成 0.0.0.0，允许任意服务器来访问 redis，即：</p><pre class="line-numbers language-none"><code class="language-none">plainbind 0.0.0.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用同样的方法，将 daemonize 改成 yes （默认为 no），允许 redis 在后台执行。<br>将 requirepass 注释打开，并设置密码为 123456（密码自己设置）。</p><ul><li>启动 redis</li></ul><p>在 redis-3.2.8 目录下，指定刚刚修改好的配置文件 redis.conf 来启动 redis：</p><pre class="line-numbers language-none"><code class="language-none">plainredis-server ./redis.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>再启动 redis 客户端：</p><pre class="line-numbers language-none"><code class="language-none">plainredis-cli<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>由于我们设置了密码，在启动客户端之后，输入 <code>auth 123456</code> 即可登录进入客户端。<br>然后我们来测试一下，往 redis 中插入一个数据：</p><pre class="line-numbers language-none"><code class="language-none">plainset name CSDN<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后来获取 name</p><pre class="line-numbers language-none"><code class="language-none">plainget name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果正常获取到 CSDN，则说明没有问题。</p><h2 id="3-Spring-Boot-集成-Redis"><a href="#3-Spring-Boot-集成-Redis" class="headerlink" title="3. Spring Boot 集成 Redis"></a>3. Spring Boot 集成 Redis</h2><h3 id="3-1-依赖导入"><a href="#3-1-依赖导入" class="headerlink" title="3.1 依赖导入"></a>3.1 依赖导入</h3><p>Spring Boot 集成 redis 很方便，只需要导入一个 redis 的 starter 依赖即可。如下：</p><pre class="line-numbers language-none"><code class="language-none">xml&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--阿里巴巴fastjson --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;    &lt;version&gt;1.2.35&lt;/version&gt;&lt;/dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里也导入阿里巴巴的 fastjson 是为了在后面我们要存一个实体，为了方便把实体转换成 json 字符串存进去。</p><h3 id="3-2-Redis-配置"><a href="#3-2-Redis-配置" class="headerlink" title="3.2 Redis 配置"></a>3.2 Redis 配置</h3><p>导入了依赖之后，我们在 application.yml 文件里配置 redis：</p><pre class="line-numbers language-none"><code class="language-none">ymlserver:  port: 8080spring:  #redis相关配置  redis:    database: 5    # 配置redis的主机地址，需要修改成自己的    host: 192.168.48.190    port: 6379    password: 123456    timeout: 5000    jedis:      pool:        # 连接池中的最大空闲连接，默认值也是8。        max-idle: 500        # 连接池中的最小空闲连接，默认值也是0。        min-idle: 50        # 如果赋值为-1，则表示不限制；如果pool已经分配了maxActive个jedis实例，则此时pool的状态为exhausted(耗尽)        max-active: 1000        # 等待可用连接的最大时间，单位毫秒，默认值为-1，表示永不超时。如果超过等待时间，则直接抛出JedisConnectionException        max-wait: 2000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-常用-api-介绍"><a href="#3-3-常用-api-介绍" class="headerlink" title="3.3 常用 api 介绍"></a>3.3 常用 api 介绍</h3><p>Spring Boot 对 redis 的支持已经非常完善了，丰富的 api 已经足够我们日常的开发，这里我介绍几个最常用的供大家学习，其他 api 希望大家自己多学习，多研究。用到会去查即可。</p><p>有两个 redis 模板：RedisTemplate 和 StringRedisTemplate。我们不使用 RedisTemplate，RedisTemplate 提供给我们操作对象，操作对象的时候，我们通常是以 json 格式存储，但在存储的时候，会使用 Redis 默认的内部序列化器；导致我们存进里面的是乱码之类的东西。当然了，我们可以自己定义序列化，但是比较麻烦，所以使用 StringRedisTemplate 模板。StringRedisTemplate 主要给我们提供字符串操作，我们可以将实体类等转成 json 字符串即可，在取出来后，也可以转成相应的对象，这就是上面我导入了阿里 fastjson 的原因。</p><h4 id="3-3-1-redis-string-类型"><a href="#3-3-1-redis-string-类型" class="headerlink" title="3.3.1 redis:string 类型"></a>3.3.1 redis:string 类型</h4><p>新建一个 RedisService，注入 StringRedisTemplate，使用 <code>stringRedisTemplate.opsForValue()</code> 可以获取 <code>ValueOperations&lt;String, String&gt;</code> 对象，通过该对象即可读写 redis 数据库了。如下：</p><pre class="line-numbers language-none"><code class="language-none">javapublic class RedisService {    @Resource    private StringRedisTemplate stringRedisTemplate;    /**     * set redis: string类型     * @param key key     * @param value value     */    public void setString(String key, String value){        ValueOperations&lt;String, String&gt; valueOperations = stringRedisTemplate.opsForValue();        valueOperations.set(key, value);    }    /**     * get redis: string类型     * @param key key     * @return     */    public String getString(String key){        return stringRedisTemplate.opsForValue().get(key);    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该对象操作的是 string，我们也可以存实体类，只需要将实体类转换成 json 字符串即可。下面来测试一下：</p><pre class="line-numbers language-none"><code class="language-none">java@RunWith(SpringRunner.class)@SpringBootTestpublic class Course14ApplicationTests {    private static final Logger logger = LoggerFactory.getLogger(Course14ApplicationTests.class);@Resourceprivate RedisService redisService;@Testpublic void contextLoads() {        //测试redis的string类型        redisService.setString("weichat","程序员私房菜");        logger.info("我的微信公众号为：{}", redisService.getString("weichat"));        // 如果是个实体，我们可以使用json工具转成json字符串，        User user = new User("CSDN", "123456");        redisService.setString("userInfo", JSON.toJSONString(user));        logger.info("用户信息：{}", redisService.getString("userInfo"));    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先启动 redis，然后运行这个测试用例，观察控制台打印的日志如下：</p><pre class="line-numbers language-none"><code class="language-none">plain我的微信公众号为：程序员私房菜用户信息：{"password":"123456","username":"CSDN"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-3-2-redis-hash-类型"><a href="#3-3-2-redis-hash-类型" class="headerlink" title="3.3.2 redis:hash 类型"></a>3.3.2 redis:hash 类型</h4><p>hash 类型其实原理和 string 一样的，但是有两个 key，使用 <code>stringRedisTemplate.opsForHash()</code> 可以获取 <code>HashOperations&lt;String, Object, Object&gt;</code> 对象。比如我们要存储订单信息，所有订单信息都放在 order 下，针对不同用户的订单实体，可以通过用户的 id 来区分，这就相当于两个 key 了。</p><pre class="line-numbers language-none"><code class="language-none">java@Servicepublic class RedisService {    @Resource    private StringRedisTemplate stringRedisTemplate;    /**     * set redis: hash类型     * @param key key     * @param filedKey filedkey     * @param value value     */    public void setHash(String key, String filedKey, String value){        HashOperations&lt;String, Object, Object&gt; hashOperations = stringRedisTemplate.opsForHash();        hashOperations.put(key,filedKey, value);    }    /**     * get redis: hash类型     * @param key key     * @param filedkey filedkey     * @return     */    public String getHash(String key, String filedkey){        return (String) stringRedisTemplate.opsForHash().get(key, filedkey);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，hash 和 string 没啥两样，只不过多了个参数，Spring Boot 中操作 redis 非常简单方便。来测试一下：</p><pre class="line-numbers language-none"><code class="language-none">java@SpringBootTestpublic class Course14ApplicationTests {    private static final Logger logger = LoggerFactory.getLogger(Course14ApplicationTests.class);@Resourceprivate RedisService redisService;@Testpublic void contextLoads() {        //测试redis的hash类型        redisService.setHash("user", "name", JSON.toJSONString(user));        logger.info("用户姓名：{}", redisService.getHash("user","name"));    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-3-3-redis-list-类型"><a href="#3-3-3-redis-list-类型" class="headerlink" title="3.3.3 redis:list 类型"></a>3.3.3 redis:list 类型</h4><p>使用 <code>stringRedisTemplate.opsForList()</code> 可以获取 <code>ListOperations&lt;String, String&gt; listOperations</code> redis 列表对象，该列表是个简单的字符串列表，可以支持从左侧添加，也可以支持从右侧添加，一个列表最多包含 2 ^ 32 -1 个元素。</p><pre class="line-numbers language-none"><code class="language-none">java@Servicepublic class RedisService {    @Resource    private StringRedisTemplate stringRedisTemplate;    /**     * set redis:list类型     * @param key key     * @param value value     * @return     */    public long setList(String key, String value){        ListOperations&lt;String, String&gt; listOperations = stringRedisTemplate.opsForList();        return listOperations.leftPush(key, value);    }    /**     * get redis:list类型     * @param key key     * @param start start     * @param end end     * @return     */    public List&lt;String&gt; getList(String key, long start, long end){        return stringRedisTemplate.opsForList().range(key, start, end);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，这些 api 都是一样的形式，方便记忆也方便使用。具体的 api 细节我就不展开了，大家可以自己看 api 文档。其实，这些 api 根据参数和返回值也能知道它们是做什么用的。来测试一下：</p><pre class="line-numbers language-none"><code class="language-none">java@RunWith(SpringRunner.class)@SpringBootTestpublic class Course14ApplicationTests {    private static final Logger logger = LoggerFactory.getLogger(Course14ApplicationTests.class);@Resourceprivate RedisService redisService;@Testpublic void contextLoads() {        //测试redis的list类型        redisService.setList("list", "football");        redisService.setList("list", "basketball");        List&lt;String&gt; valList = redisService.getList("list",0,-1);        for(String value :valList){            logger.info("list中有：{}", value);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-总结-6"><a href="#4-总结-6" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>本节主要介绍了 redis 的使用场景、安装过程，以及 Spring Boot 中集成 redis 的详细步骤。在实际项目中，通常都用 redis 作为缓存，在查询数据库的时候，会先从 redis 中查找，如果有信息，则从 redis 中取；如果没有，则从数据库中查，并且同步到 redis 中，下次 redis 中就有了。更新和删除也是如此，都需要同步到 redis。redis 在高并发场景下运用的很多。</p><p>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study">戳我下载</a></p><h1 id="第15课：-Spring-Boot中集成ActiveMQ"><a href="#第15课：-Spring-Boot中集成ActiveMQ" class="headerlink" title="第15课： Spring Boot中集成ActiveMQ"></a>第15课： Spring Boot中集成ActiveMQ</h1><h2 id="1-JMS-和-ActiveMQ-介绍"><a href="#1-JMS-和-ActiveMQ-介绍" class="headerlink" title="1. JMS 和 ActiveMQ 介绍"></a>1. JMS 和 ActiveMQ 介绍</h2><h3 id="1-1-JMS-是啥"><a href="#1-1-JMS-是啥" class="headerlink" title="1.1 JMS 是啥"></a>1.1 JMS 是啥</h3><p>百度百科的解释：</p><blockquote><p>JMS 即 Java 消息服务（Java Message Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的 API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。Java 消息服务是一个与具体平台无关的 API，绝大多数 MOM 提供商都对 JMS 提供支持。</p></blockquote><p>JMS 只是接口，不同的提供商或者开源组织对其有不同的实现，ActiveMQ 就是其中之一，它支持JMS，是 Apache 推出的。JMS 中有几个对象模型：</p><blockquote><p>连接工厂：ConnectionFactory<br>JMS连接：Connection<br>JMS会话：Session<br>JMS目的：Destination<br>JMS生产者：Producer<br>JMS消费者：Consumer<br>JMS消息两种类型：点对点和发布/订阅。</p></blockquote><p>可以看出 JMS 实际上和 JDBC 有点类似，JDBC 是可以用来访问许多不同关系数据库的 API，而 JMS 则提供同样与厂商无关的访问方法，以访问消息收发服务。本文主要使用 ActiveMQ。</p><h3 id="1-2-ActiveMQ"><a href="#1-2-ActiveMQ" class="headerlink" title="1.2 ActiveMQ"></a>1.2 ActiveMQ</h3><p>ActiveMQ 是 Apache 的一个能力强劲的开源消息总线。ActiveMQ 完全支持JMS1.1和J2EE 1.4规范，尽管 JMS 规范出台已经是很久的事情了，但是 JMS 在当今的 Java EE 应用中间仍然扮演着特殊的地位。ActiveMQ 用在异步消息的处理上，所谓异步消息即消息发送者无需等待消息接收者的处理以及返回，甚至无需关心消息是否发送成功。</p><p>异步消息主要有两种目的地形式，队列（queue）和主题（topic），队列用于点对点形式的消息通信，主题用于发布/订阅式的消息通信。本章节主要来学习一下在 Spring Boot 中如何使用这两种形式的消息。</p><h2 id="2-ActiveMQ安装"><a href="#2-ActiveMQ安装" class="headerlink" title="2. ActiveMQ安装"></a>2. ActiveMQ安装</h2><p>使用 ActiveMQ 首先需要去官网下载，官网地址为：<a href="http://activemq.apache.org/">http://activemq.apache.org/</a><br>本课程使用的版本是 apache-activemq-5.15.3，下载后解压缩会有一个名为 apache-activemq-5.15.3 的文件夹，没错，这就安装好了，非常简单，开箱即用。打开文件夹会看到里面有个 <code>activemq-all-5.15.3.jar</code>，这个 jar 我们是可以加进工程里的，但是使用 maven 的话，这个 jar 我们不需要。</p><p>在使用 ActiveMQ 之前，首先得先启动，刚才解压后的目录中有个 bin 目录，里面有 win32 和 win64 两个目录，根据自己电脑选择其中一个打开运行里面的 activemq.bat 即可启动 ActiveMQ。<br>消息生产者生产消息发布到queue中，然后消息消费者从queue中取出，并且消费消息。这里需要注意：消息被消费者消费以后，queue中不再有存储，所以消息消费者不可消费到已经被消费的消息。Queue支持存在多个消息消费者，但是对一个消息而言，只会有一个消费者可以消费<br>启动完成后，在浏览器中输入 <code>http://127.0.0.1:8161/admin/</code> 来访问 ActiveMQ 的服务器，用户名和密码是 admin/admin。如下：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMuZ2l0Ym9vay5jbi9jZmI5YzQ2MC1hYTk0LTExZTgtODg4Zi1kZjMzYmU4ZWQxOTE?x-oss-process=image/format,png" alt="activemq"></p><p>我们可以看到有 Queues 和 Topics 这两个选项，这两个选项分别是点对点消息和发布/订阅消息的查看窗口。何为点对点消息和发布/订阅消息呢？</p><p>点对点消息：消息生产者生产消息发布到 queue 中，然后消息消费者从 queue 中取出，并且消费消息。这里需要注意：消息被消费者消费以后，queue 中不再有存储，所以消息消费者不可消费到已经被消费的消息。Queue 支持存在多个消息消费者，但是对一个消息而言，只会有一个消费者可以消费。</p><p>发布/订阅消息：消息生产者（发布）将消息发布到 topic 中，同时有多个消息消费者（订阅）消费该消息。和点对点方式不同，发布到 topic 的消息会被所有订阅者消费。下面分析具体的实现方式。</p><h2 id="3-ActiveMQ集成"><a href="#3-ActiveMQ集成" class="headerlink" title="3. ActiveMQ集成"></a>3. ActiveMQ集成</h2><h3 id="3-1-依赖导入和配置"><a href="#3-1-依赖导入和配置" class="headerlink" title="3.1 依赖导入和配置"></a>3.1 依赖导入和配置</h3><p>在 Spring Boot 中集成 ActiveMQ 需要导入如下 starter 依赖：</p><pre class="line-numbers language-none"><code class="language-none">xml&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-activemq&lt;/artifactId&gt;&lt;/dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后在 application.yml 配置文件中，对 activemq 做一下配置：</p><pre class="line-numbers language-none"><code class="language-none">ymlspring:  activemq:  # activemq url    broker-url: tcp://localhost:61616    in-memory: true    pool:      # 如果此处设置为true，需要添加activemq-pool的依赖包，否则会自动配置失败，无法注入JmsMessagingTemplate      enabled: false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-Queue-和-Topic-的创建"><a href="#3-2-Queue-和-Topic-的创建" class="headerlink" title="3.2 Queue 和 Topic 的创建"></a>3.2 Queue 和 Topic 的创建</h3><p>首先我们需要创建两种消息 Queue 和 Topic，这两种消息的创建，我们放到 ActiveMqConfig 中来创建，如下：</p><pre class="line-numbers language-none"><code class="language-none">java/** * activemq的配置 * @author  shengwu ni */@Configurationpublic class ActiveMqConfig {    /**     * 发布/订阅模式队列名称     */    public static final String TOPIC_NAME = "activemq.topic";    /**     * 点对点模式队列名称     */    public static final String QUEUE_NAME = "activemq.queue";    @Bean    public Destination topic() {        return new ActiveMQTopic(TOPIC_NAME);    }    @Bean    public Destination queue() {        return new ActiveMQQueue(QUEUE_NAME);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出创建 Queue 和 Topic 两种消息，分别使用 <code>new ActiveMQQueue</code> 和 <code>new ActiveMQTopic</code> 来创建，分别跟上对应消息的名称即可。这样在其他地方就可以直接将这两种消息作为组件注入进来了。</p><h3 id="3-3-消息的发送接口"><a href="#3-3-消息的发送接口" class="headerlink" title="3.3 消息的发送接口"></a>3.3 消息的发送接口</h3><p>在 Spring Boot 中，我们只要注入 JmsMessagingTemplate 模板即可快速发送消息，如下：</p><pre class="line-numbers language-none"><code class="language-none">java/** * 消息发送者 * @author shengwu ni */@Servicepublic class MsgProducer {    @Resource    private JmsMessagingTemplate jmsMessagingTemplate;    public void sendMessage(Destination destination, String msg) {        jmsMessagingTemplate.convertAndSend(destination, msg);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>convertAndSend</code> 方法中第一个参数是消息发送的目的地，第二个参数是具体的消息内容。</p><h3 id="3-4-点对点消息生产与消费"><a href="#3-4-点对点消息生产与消费" class="headerlink" title="3.4 点对点消息生产与消费"></a>3.4 点对点消息生产与消费</h3><h4 id="3-4-1-点对点消息的生产"><a href="#3-4-1-点对点消息的生产" class="headerlink" title="3.4.1 点对点消息的生产"></a>3.4.1 点对点消息的生产</h4><p>消息的生产，我们放到 Controller 中来做，由于上面已经生成了 Queue 消息的组件，所以在 Controller 中我们直接注入进来即可。然后调用上文的消息发送方法 <code>sendMessage</code> 即可成功生产一条消息。</p><pre class="line-numbers language-none"><code class="language-none">java/** * ActiveMQ controller * @author shengwu ni */@RestController@RequestMapping("/activemq")public class ActiveMqController {    private static final Logger logger = LoggerFactory.getLogger(ActiveMqController.class);    @Resource    private MsgProducer producer;    @Resource    private Destination queue;    @GetMapping("/send/queue")    public String sendQueueMessage() {        logger.info("===开始发送点对点消息===");        producer.sendMessage(queue, "Queue: hello activemq!");        return "success";    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-4-2-点对点消息的消费"><a href="#3-4-2-点对点消息的消费" class="headerlink" title="3.4.2 点对点消息的消费"></a>3.4.2 点对点消息的消费</h4><p>点对点消息的消费很简单，只要我们指定目的地即可，jms 监听器一直在监听是否有消息过来，如果有，则消费。</p><pre class="line-numbers language-none"><code class="language-none">java/** * 消息消费者 * @author shengwu ni */@Servicepublic class QueueConsumer {    /**     * 接收点对点消息     * @param msg     */    @JmsListener(destination = ActiveMqConfig.QUEUE_NAME)    public void receiveQueueMsg(String msg) {        System.out.println("收到的消息为：" + msg);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，使用 <code>@JmsListener</code> 注解来指定要监听的目的地，在消息接收方法内部，我们可以根据具体的业务需求做相应的逻辑处理即可。</p><h4 id="3-4-3-测试一下"><a href="#3-4-3-测试一下" class="headerlink" title="3.4.3 测试一下"></a>3.4.3 测试一下</h4><p>启动项目，在浏览器中输入：<code>http://localhost:8081/activemq/send/queue</code>，观察控制台的输出日志，出现下面的日志说明消息发送和消费成功。</p><pre class="line-numbers language-none"><code class="language-none">plain收到的消息为：Queue: hello activemq!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="3-5-发布-x2F-订阅消息的生产和消费"><a href="#3-5-发布-x2F-订阅消息的生产和消费" class="headerlink" title="3.5 发布/订阅消息的生产和消费"></a>3.5 发布/订阅消息的生产和消费</h3><h4 id="3-5-1-发布-x2F-订阅消息的生产"><a href="#3-5-1-发布-x2F-订阅消息的生产" class="headerlink" title="3.5.1 发布/订阅消息的生产"></a>3.5.1 发布/订阅消息的生产</h4><p>和点对点消息一样，我们注入 topic 并调用 producer 的 <code>sendMessage</code> 方法即可发送订阅消息，如下，不再赘述：</p><pre class="line-numbers language-none"><code class="language-none">java@RestController@RequestMapping("/activemq")public class ActiveMqController {    private static final Logger logger = LoggerFactory.getLogger(ActiveMqController.class);    @Resource    private MsgProducer producer;    @Resource    private Destination topic;    @GetMapping("/send/topic")    public String sendTopicMessage() {        logger.info("===开始发送订阅消息===");        producer.sendMessage(topic, "Topic: hello activemq!");        return "success";    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-5-2-发布-x2F-订阅消息的消费"><a href="#3-5-2-发布-x2F-订阅消息的消费" class="headerlink" title="3.5.2 发布/订阅消息的消费"></a>3.5.2 发布/订阅消息的消费</h4><p>发布/订阅消息的消费和点对点不同，订阅消息支持多个消费者一起消费。其次，Spring Boot 中默认的时点对点消息，所以在使用 topic 时，会不起作用，我们需要在配置文件 application.yml 中添加一个配置：</p><pre class="line-numbers language-none"><code class="language-none">ymlspring:  jms:    pub-sub-domain: true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该配置是 false 的话，则为点对点消息，也是 Spring Boot 默认的。这样是可以解决问题，但是如果这样配置的话，上面提到的点对点消息又不能正常消费了。所以二者不可兼得，这并非一个好的解决办法。</p><p>比较好的解决办法是，我们定义一个工厂，<code>@JmsListener</code> 注解默认只接收 queue 消息，如果要接收 topic 消息，需要设置一下 containerFactory。我们还在上面的那个 ActiveMqConfig 配置类中添加：</p><pre class="line-numbers language-none"><code class="language-none">java/** * activemq的配置 * * @author shengwu ni */@Configurationpublic class ActiveMqConfig {    // 省略其他内容    /**     * JmsListener注解默认只接收queue消息,如果要接收topic消息,需要设置containerFactory     */    @Bean    public JmsListenerContainerFactory topicListenerContainer(ConnectionFactory connectionFactory) {        DefaultJmsListenerContainerFactory factory = new DefaultJmsListenerContainerFactory();        factory.setConnectionFactory(connectionFactory);        // 相当于在application.yml中配置：spring.jms.pub-sub-domain=true        factory.setPubSubDomain(true);        return factory;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>经过这样的配置之后，我们在消费的时候，在 <code>@JmsListener</code> 注解中指定这个容器工厂即可消费 topic 消息。如下：</p><pre class="line-numbers language-none"><code class="language-none">java/** * Topic消息消费者 * @author shengwu ni */@Servicepublic class TopicConsumer1 {    /**     * 接收订阅消息     * @param msg     */    @JmsListener(destination = ActiveMqConfig.TOPIC_NAME, containerFactory = "topicListenerContainer")    public void receiveTopicMsg(String msg) {        System.out.println("收到的消息为：" + msg);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>指定 containerFactory 属性为上面我们自己配置的 topicListenerContainer 即可。由于 topic 消息可以多个消费，所以该消费的类可以拷贝几个一起测试一下，这里我就不贴代码了，可以参考我的源码测试。</p><h4 id="3-5-3-测试一下"><a href="#3-5-3-测试一下" class="headerlink" title="3.5.3 测试一下"></a>3.5.3 测试一下</h4><p>启动项目，在浏览器中输入：<code>http://localhost:8081/activemq/send/topic</code>，观察控制台的输出日志，出现下面的日志说明消息发送和消费成功。</p><pre class="line-numbers language-none"><code class="language-none">plain收到的消息为：Topic: hello activemq!收到的消息为：Topic: hello activemq!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-总结-7"><a href="#4-总结-7" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>本章主要介绍了 jms 和 activemq 的相关概念、activemq 的安装与启动。详细分析了 Spring Boot 中点对点消息和发布/订阅消息两种方式的配置、消息生产和消费方式。ActiveMQ 是能力强劲的开源消息总线，在异步消息的处理上很有用，希望大家好好消化一下。</p><p>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study">戳我下载</a></p><h1 id="第16课：Spring-Boot中集成-Shiro"><a href="#第16课：Spring-Boot中集成-Shiro" class="headerlink" title="第16课：Spring Boot中集成 Shiro"></a>第16课：Spring Boot中集成 Shiro</h1><p>Shiro 是一个强大、简单易用的 Java 安全框架，主要用来更便捷的认证，授权，加密，会话管等等，可为任何应用提供安全保障。本课程主要来介绍 Shiro 的认证和授权功能。</p><h2 id="1-Shiro-三大核心组件"><a href="#1-Shiro-三大核心组件" class="headerlink" title="1. Shiro 三大核心组件"></a>1. Shiro 三大核心组件</h2><p>Shiro 有三大核心的组件：<code>Subject</code>、<code>SecurityManager</code> 和 <code>Realm</code>。先来看一下它们之间的关系。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMuZ2l0Ym9vay5jbi8yZGQwZjVmMC1hZjRhLTExZTgtYTUxYy05M2MzOWYyNzg1YjE?x-oss-process=image/format,png" alt="三大核心组件的关系"></p><ol><li><p>Subject：认证主体。它包含两个信息：Principals 和 Credentials。看一下这两个信息具体是什么。</p><blockquote><p>Principals：身份。可以是用户名，邮件，手机号码等等，用来标识一个登录主体身份；<br>Credentials：凭证。常见有密码，数字证书等等。</p></blockquote></li></ol><p>说白了，就是需要认证的东西，最常见的就是用户名密码了，比如用户在登录的时候，Shiro 需要去进行身份认证，就需要 Subject 认证主体。</p><ol><li>SecurityManager：安全管理员。这是 Shiro 架构的核心，它就像 Shiro 内部所有原件的保护伞一样。我们在项目中一般都会配置 SecurityManager，开发人员大部分精力主要是在 Subject 认证主体上面。我们在与 Subject 进行交互的时候，实际上是 SecurityManager 在背后做一些安全操作。</li><li>Realms：Realms 是一个域，它是连接 Shiro 和具体应用的桥梁，当需要与安全数据交互的时候，比如用户账户、访问控制等，Shiro 就会从一个或多个 Realms 中去查找。我们一般会自己定制 Realm，这在下文会详细说明。</li></ol><h2 id="1-Shiro-身份和权限认证"><a href="#1-Shiro-身份和权限认证" class="headerlink" title="1. Shiro 身份和权限认证"></a>1. Shiro 身份和权限认证</h2><h3 id="1-2-Shiro-身份认证"><a href="#1-2-Shiro-身份认证" class="headerlink" title="1.2 Shiro 身份认证"></a>1.2 Shiro 身份认证</h3><p>我们来分析一下 Shiro 身份认证的过程，看一下官方的一个认证图：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMuZ2l0Ym9vay5jbi9mMjFjNTNhMC1hZjRmLTExZTgtYTUxYy05M2MzOWYyNzg1YjE?x-oss-process=image/format,png" alt="认证过程"></p><p>Step1：应用程序代码在调用 <code>Subject.login(token)</code> 方法后，传入代表最终用户的身份和凭证的 AuthenticationToken 实例 token。</p><p>Step2：将 Subject 实例委托给应用程序的 SecurityManager（Shiro的安全管理）来开始实际的认证工作。这里开始真正的认证工作了。</p><p>Step3，4，5：然后 SecurityManager 就会根据具体的 realm 去进行安全认证了。 从图中可以看出，realm 可以自定义（Custom Realm）。</p><h3 id="1-3-Shiro-权限认证"><a href="#1-3-Shiro-权限认证" class="headerlink" title="1.3 Shiro 权限认证"></a>1.3 Shiro 权限认证</h3><p>权限认证，也就是访问控制，即在应用中控制谁能访问哪些资源。在权限认证中，最核心的三个要素是：权限，角色和用户。</p><blockquote><p>权限（permission）：即操作资源的权利，比如访问某个页面，以及对某个模块的数据的添加，修改，删除，查看的权利；<br>角色（role）：指的是用户担任的的角色，一个角色可以有多个权限；<br>用户（user）：在 Shiro 中，代表访问系统的用户，即上面提到的 Subject 认证主体。</p></blockquote><p>它们之间的的关系可以用下图来表示：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMuZ2l0Ym9vay5jbi80NGE2OGJjMC1hZjc1LTExZTgtODVlZi1kZDk4NmRhMzUxMWU?x-oss-process=image/format,png" alt="用户、角色和权限的关系"></p><p>一个用户可以有多个角色，而不同的角色可以有不同的权限，也可由有相同的权限。比如说现在有三个角色，1是普通角色，2也是普通角色，3是管理员，角色1只能查看信息，角色2只能添加信息，管理员都可以，而且还可以删除信息，类似于这样。</p><h2 id="2-Spring-Boot-集成-Shiro-过程"><a href="#2-Spring-Boot-集成-Shiro-过程" class="headerlink" title="2. Spring Boot 集成 Shiro 过程"></a>2. Spring Boot 集成 Shiro 过程</h2><h3 id="2-1-依赖导入-2"><a href="#2-1-依赖导入-2" class="headerlink" title="2.1 依赖导入"></a>2.1 依赖导入</h3><p>Spring Boot 2.0.3 集成 Shiro 需要导入如下 starter 依赖：</p><pre class="line-numbers language-none"><code class="language-none">xml&lt;dependency&gt;    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;    &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;    &lt;version&gt;1.4.0&lt;/version&gt;&lt;/dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-数据库表数据初始化"><a href="#2-2-数据库表数据初始化" class="headerlink" title="2.2 数据库表数据初始化"></a>2.2 数据库表数据初始化</h3><p>这里主要涉及到三张表：用户表、角色表和权限表，其实在 demo 中，我们完全可以自己模拟一下，不用建表，但是为了更加接近实际情况，我们还是加入 mybatis，来操作数据库。下面是数据库表的脚本。</p><pre class="line-numbers language-none"><code class="language-none">sqlCREATE TABLE `t_role` (  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',  `rolename` varchar(20) DEFAULT NULL COMMENT '角色名称',  PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8CREATE TABLE `t_user` (  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '用户主键',  `username` varchar(20) NOT NULL COMMENT '用户名',  `password` varchar(20) NOT NULL COMMENT '密码',  `role_id` int(11) DEFAULT NULL COMMENT '外键关联role表',  PRIMARY KEY (`id`),  KEY `role_id` (`role_id`),  CONSTRAINT `t_user_ibfk_1` FOREIGN KEY (`role_id`) REFERENCES `t_role` (`id`)) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8CREATE TABLE `t_permission` (  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',  `permissionname` varchar(50) NOT NULL COMMENT '权限名',  `role_id` int(11) DEFAULT NULL COMMENT '外键关联role',  PRIMARY KEY (`id`),  KEY `role_id` (`role_id`),  CONSTRAINT `t_permission_ibfk_1` FOREIGN KEY (`role_id`) REFERENCES `t_role` (`id`)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，t_user，t_role 和 t_permission，分别存储用户信息，角色信息和权限信息，表建立好了之后，我们往表里插入一些测试数据。<br>t_user 表：<br>|id|username|password|role_id|<br>|:–:|:–:|:–:|:–:|<br>|1|csdn1|123456|1|<br>|2|csdn2|123456|2|<br>|3|csdn3|123456|3|</p><p>t_role 表：<br>|id|rolename|<br>|:–:|:–:|<br>|1|admin|<br>|2|teacher|<br>|3|student|</p><p>t_permission 表：<br>|id|permissionname|role_id|<br>|:–:|:–:|:–:|<br>|1|<code>user:*</code>|1|<br>|2|<code>student:*</code>|2|</p><p>解释一下这里的权限：<code>user:*</code>表示权限可以是 <code>user:create</code> 或者其他，<code>*</code> 处表示一个占位符，我们可以自己定义，具体的会在下文 Shiro 配置那里说明。</p><h3 id="2-2-自定义-Realm"><a href="#2-2-自定义-Realm" class="headerlink" title="2.2 自定义 Realm"></a>2.2 自定义 Realm</h3><p>有了数据库表和数据之后，我们开始自定义 realm，自定义 realm 需要继承 AuthorizingRealm 类，因为该类封装了很多方法，它也是一步步继承自 Realm 类的，继承了 AuthorizingRealm 类后，需要重写两个方法：</p><blockquote><p><code>doGetAuthenticationInfo()</code> 方法：用来验证当前登录的用户，获取认证信息<br><code>doGetAuthorizationInfo()</code> 方法：用来为当前登陆成功的用户授予权限和角色</p></blockquote><p>具体实现如下，相关的解释我放在代码的注释中，这样更加方便直观：</p><pre class="line-numbers language-none"><code class="language-none">java/** * 自定义realm * @author shengwu ni */public class MyRealm extends AuthorizingRealm {    @Resource    private UserService userService;    @Override    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {        // 获取用户名        String username = (String) principalCollection.getPrimaryPrincipal();        SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo();        // 给该用户设置角色，角色信息存在t_role表中取        authorizationInfo.setRoles(userService.getRoles(username));        // 给该用户设置权限，权限信息存在t_permission表中取        authorizationInfo.setStringPermissions(userService.getPermissions(username));        return authorizationInfo;    }    @Override    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {        // 根据token获取用户名，如果您不知道该该token怎么来的，先可以不管，下文会解释        String username = (String) authenticationToken.getPrincipal();        // 根据用户名从数据库中查询该用户        User user = userService.getByUsername(username);        if(user != null) {            // 把当前用户存到session中            SecurityUtils.getSubject().getSession().setAttribute("user", user);            // 传入用户名和密码进行身份认证，并返回认证信息            AuthenticationInfo authcInfo = new SimpleAuthenticationInfo(user.getUsername(), user.getPassword(), "myRealm");            return authcInfo;        } else {            return null;        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面两个方法中可以看出：验证身份的时候是根据用户输入的用户名先从数据库中查出该用户名对应的用户，这时候并没有涉及到密码，也就是说到这一步的时候，即使用户输入的密码不对，也是可以查出来该用户的，然后将该用户的正确信息封装到 authcInfo 中返回给 Shiro，接下来就是Shiro的事了，它会根据这里面的真实信息与用户前台输入的用户名和密码进行校验， 这个时候也要校验密码了，如果校验通过就让用户登录，否则跳转到指定页面。同理，权限验证的时候也是先根据用户名从数据库中获取与该用户名有关的角色和权限，然后封装到 authorizationInfo 中返回给 Shiro。</p><h3 id="2-3-Shiro-配置"><a href="#2-3-Shiro-配置" class="headerlink" title="2.3 Shiro 配置"></a>2.3 Shiro 配置</h3><p>自定义的 realm 写好了，接下来需要对 Shiro 进行配置了。我们主要配置三个东西：自定义 realm、安全管理器 SecurityManager 和 Shiro 过滤器。如下：</p><p>配置自定义 realm：</p><pre class="line-numbers language-none"><code class="language-none">java@Configurationpublic class ShiroConfig {    private static final Logger logger = LoggerFactory.getLogger(ShiroConfig.class);    /**     * 注入自定义的realm     * @return MyRealm     */    @Bean    public MyRealm myAuthRealm() {        MyRealm myRealm = new MyRealm();        logger.info("====myRealm注册完成=====");        return myRealm;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置安全管理器 SecurityManager：</p><pre class="line-numbers language-none"><code class="language-none">java@Configurationpublic class ShiroConfig {    private static final Logger logger = LoggerFactory.getLogger(ShiroConfig.class);    /**     * 注入安全管理器     * @return SecurityManager     */    @Bean    public SecurityManager securityManager() {        // 将自定义realm加进来        DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(myAuthRealm());        logger.info("====securityManager注册完成====");        return securityManager;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置 SecurityManager 时，需要将上面的自定义 realm 添加进来，这样的话 Shiro 才会走到自定义的 realm 中。</p><p>配置 Shiro 过滤器：</p><pre class="line-numbers language-none"><code class="language-none">java@Configurationpublic class ShiroConfig {    private static final Logger logger = LoggerFactory.getLogger(ShiroConfig.class);        /**     * 注入Shiro过滤器     * @param securityManager 安全管理器     * @return ShiroFilterFactoryBean     */    @Bean    public ShiroFilterFactoryBean shiroFilter(SecurityManager securityManager) {        // 定义shiroFactoryBean        ShiroFilterFactoryBean shiroFilterFactoryBean=new ShiroFilterFactoryBean();        // 设置自定义的securityManager        shiroFilterFactoryBean.setSecurityManager(securityManager);        // 设置默认登录的url，身份认证失败会访问该url        shiroFilterFactoryBean.setLoginUrl("/login");        // 设置成功之后要跳转的链接        shiroFilterFactoryBean.setSuccessUrl("/success");        // 设置未授权界面，权限认证失败会访问该url        shiroFilterFactoryBean.setUnauthorizedUrl("/unauthorized");        // LinkedHashMap是有序的，进行顺序拦截器配置        Map&lt;String,String&gt; filterChainMap = new LinkedHashMap&lt;&gt;();        // 配置可以匿名访问的地址，可以根据实际情况自己添加，放行一些静态资源等，anon表示放行        filterChainMap.put("/css/**", "anon");        filterChainMap.put("/imgs/**", "anon");        filterChainMap.put("/js/**", "anon");        filterChainMap.put("/swagger-*/**", "anon");        filterChainMap.put("/swagger-ui.html/**", "anon");        // 登录url 放行        filterChainMap.put("/login", "anon");        // “/user/admin” 开头的需要身份认证，authc表示要身份认证        filterChainMap.put("/user/admin*", "authc");        // “/user/student” 开头的需要角色认证，是“admin”才允许        filterChainMap.put("/user/student*/**", "roles[admin]");        // “/user/teacher” 开头的需要权限认证，是“user:create”才允许        filterChainMap.put("/user/teacher*/**", "perms[\"user:create\"]");        // 配置logout过滤器        filterChainMap.put("/logout", "logout");        // 设置shiroFilterFactoryBean的FilterChainDefinitionMap        shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainMap);        logger.info("====shiroFilterFactoryBean注册完成====");        return shiroFilterFactoryBean;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置 Shiro 过滤器时会传入一个安全管理器，可以看出，这是一环套一环，reaml -&gt; SecurityManager -&gt; filter。在过滤器中，我们需要定义一个 shiroFactoryBean，然后将 SecurityManager 添加进来，结合上面代码可以看出，要配置的东西主要有：</p><blockquote><p>默认登录的 url：身份认证失败会访问该 url<br>认证成功之后要跳转的 url<br>权限认证失败会访问该 url<br>需要拦截或者放行的 url：这些都放在一个 map 中</p></blockquote><p>从上述代码中可以看出，在 map 中，针对不同的 url，有不同的权限要求，这里总结一下常用的几个权限。<br>|Filter|说明|<br>|:–:|:–:|<br>|anon|开放权限，可以理解为匿名用户或游客，可以直接访问的|<br>|authc|需要身份认证的|<br>|logout|注销，执行后会直接跳转到 <code>shiroFilterFactoryBean.setLoginUrl();</code> 设置的 url，即登录页面|<br>|roles[admin]|参数可写多个，表示是某个或某些角色才能通过，多个参数时写 roles[“admin，user”]，当有多个参数时必须每个参数都通过才算通过|<br>|perms[user]|参数可写多个，表示需要某个或某些权限才能通过，多个参数时写 perms[“user, admin”]，当有多个参数时必须每个参数都通过才算通过|</p><h3 id="2-4-使用-Shiro-进行认证"><a href="#2-4-使用-Shiro-进行认证" class="headerlink" title="2.4 使用 Shiro 进行认证"></a>2.4 使用 Shiro 进行认证</h3><p>到这里，我们对 Shiro 的准备工作都做完了，接下来开始使用 Shiro 进行认证工作。我们首先来设计几个接口：</p><blockquote><p>接口一： 使用 <code>http://localhost:8080/user/admin</code> 来验证身份认证<br>接口二： 使用 <code>http://localhost:8080/user/student</code> 来验证角色认证<br>接口三： 使用 <code>http://localhost:8080/user/teacher</code> 来验证权限认证<br>接口四： 使用 <code>http://localhost:8080/user/login</code> 来实现用户登录</p></blockquote><p>然后来一下认证的流程：</p><blockquote><p>流程一： 直接访问接口一（此时还未登录），认证失败，跳转到 login.html 页面让用户登录，登录会请求接口四，实现用户登录功能，此时 Shiro 已经保存了用户信息了。<br>流程二： 再次访问接口一（此时用户已经登录），认证成功，跳转到 success.html 页面，展示用户信息。<br>流程三： 访问接口二，测试角色认证是否成功。<br>流程四： 访问接口三，测试权限认证是否成功。</p></blockquote><h4 id="2-4-1-身份、角色、权限认证接口"><a href="#2-4-1-身份、角色、权限认证接口" class="headerlink" title="2.4.1 身份、角色、权限认证接口"></a>2.4.1 身份、角色、权限认证接口</h4><pre class="line-numbers language-none"><code class="language-none">java@Controller@RequestMapping("/user")public class UserController {    /**     * 身份认证测试接口     * @param request     * @return     */    @RequestMapping("/admin")    public String admin(HttpServletRequest request) {        Object user = request.getSession().getAttribute("user");        return "success";    }    /**     * 角色认证测试接口     * @param request     * @return     */    @RequestMapping("/student")    public String student(HttpServletRequest request) {        return "success";    }    /**     * 权限认证测试接口     * @param request     * @return     */    @RequestMapping("/teacher")    public String teacher(HttpServletRequest request) {        return "success";    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这三个接口很简单，直接返回到指定页面展示即可，只要认证成功就会正常跳转，如果认证失败，就会跳转到上文 ShrioConfig 中配置的页面进行展示。</p><h4 id="2-4-2-用户登录接口"><a href="#2-4-2-用户登录接口" class="headerlink" title="2.4.2 用户登录接口"></a>2.4.2 用户登录接口</h4><pre class="line-numbers language-none"><code class="language-none">java@Controller@RequestMapping("/user")public class UserController {    /**     * 用户登录接口     * @param user user     * @param request request     * @return string     */    @PostMapping("/login")    public String login(User user, HttpServletRequest request) {        // 根据用户名和密码创建token        UsernamePasswordToken token = new UsernamePasswordToken(user.getUsername(), user.getPassword());        // 获取subject认证主体        Subject subject = SecurityUtils.getSubject();        try{            // 开始认证，这一步会跳到我们自定义的realm中            subject.login(token);            request.getSession().setAttribute("user", user);            return "success";        }catch(Exception e){            e.printStackTrace();            request.getSession().setAttribute("user", user);            request.setAttribute("error", "用户名或密码错误！");            return "login";        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们重点分析一下这个登录接口，首先会根据前端传过来的用户名和密码，创建一个 token，然后使用 SecurityUtils 来创建一个认证主体，接下来开始调用 <code>subject.login(token)</code> 开始进行身份认证了，注意这里传了刚刚创建的 token，就如注释中所述，这一步会跳转到我们自定义的 realm 中，进入 <code>doGetAuthenticationInfo</code> 方法，所以到这里，您就会明白该方法中那个参数 token 了。然后就是上文分析的那样，开始进行身份认证。</p><h4 id="2-4-3-测试一下"><a href="#2-4-3-测试一下" class="headerlink" title="2.4.3 测试一下"></a>2.4.3 测试一下</h4><p>最后，启动项目，测试一下：<br>浏览器请求 <code>http://localhost:8080/user/admin</code> 会进行身份认证，因为此时未登录，所以会跳转到 IndexController 中的 <code>/login</code> 接口，然后跳转到 <code>login.html</code> 页面让我们登录，使用用户名密码为 csdn/123456 登录之后，我们在浏览器中请求 <code>http://localhost:8080/user/student</code> 接口，会进行角色认证，因为数据库中 csdn1 的用户角色是 admin，所以和配置中的吻合，认证通过；我们再请求 <code>http://localhost:8080/user/teacher</code> 接口，会进行权限认证，因为数据库中 csdn1 的用户权限为 <code>user:*</code>，满足配置中的 <code>user:create</code>，所以认证通过。</p><p>接下来，我们点退出，系统会注销重新让我们登录，我们使用 csdn2 这个用户来登录，重复上述操作，当在进行角色认证和权限认证这两步时，就认证不通过了，因为数据库中 csdn2 这个用户存的角色和权限与配置中的不同，所以认证不通过。</p><h2 id="3-总结-2"><a href="#3-总结-2" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>本节主要介绍了 Shiro 安全框架与 Spring Boot 的整合。先介绍了 Shiro 的三大核心组件已经它们的作用；然后介绍了 Shiro 的身份认证、角色认证和权限认证；最后结合代码，详细介绍了 Spring Boot 中是如何整合 Shiro 的，并设计了一套测试流程，逐步分析 Shiro 的工作流程和原理，让读者更直观地体会出 Shiro 的整套工作流程。Shiro 使用的很广泛，希望读者将其掌握，并能运用到实际项目中。</p><p>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study">戳我下载</a></p><h1 id="第17课：Spring-Boot中集成Lucence"><a href="#第17课：Spring-Boot中集成Lucence" class="headerlink" title="第17课：Spring Boot中集成Lucence"></a>第17课：Spring Boot中集成Lucence</h1><h2 id="1-Lucence-和全文检索"><a href="#1-Lucence-和全文检索" class="headerlink" title="1. Lucence 和全文检索"></a>1. Lucence 和全文检索</h2><p>Lucene 是什么？看一下百度百科：</p><blockquote><p>Lucene是一套用于全文检索和搜寻的开源程式库，由 Apache 软件基金会支持和提供。Lucene 提供了一个简单却强大的应用程式接口，能够做全文索引和搜寻。在 Java 开发环境里 Lucene 是一个成熟的免费开源工具。就其本身而言，Lucene 是当前以及最近几年最受欢迎的免费 Java 信息检索程序库。——《百度百科》</p></blockquote><h3 id="1-1-全文检索"><a href="#1-1-全文检索" class="headerlink" title="1.1 全文检索"></a>1.1 全文检索</h3><p>这里提到了全文检索的概念，我们先来分析一下什么是全文检索，理解了全文检索之后，再理解 Lucene 的原理就非常简单了。</p><p>何为全文检索？举个例子，比如现在要在一个文件中查找某个字符串，最直接的想法就是从头开始检索，查到了就OK，这种对于小数据量的文件来说，很实用，但是对于大数据量的文件来说，就有点吃力了。或者说找包含某个字符串的文件，也是这样，如果在一个拥有几十个 G 的硬盘中找那效率可想而知，是很低的。</p><p>文件中的数据是属于非结构化数据，也就是说它没有什么结构可言，要解决上面提到的效率问题，首先我们得将非结构化数据中的一部分信息提取出来，重新组织，使其变得有一定结构，然后对这些有一定结构的数据进行搜索，从而达到搜索相对较快的目的。这就叫全文搜索。即先建立索引，再对索引进行搜索的过程。</p><h3 id="1-2-Lucene-建立索引的方式"><a href="#1-2-Lucene-建立索引的方式" class="headerlink" title="1.2 Lucene 建立索引的方式"></a>1.2 Lucene 建立索引的方式</h3><p>那么 Lucene 中是如何建立索引的呢？假设现在有两篇文章，内容如下：</p><blockquote><p>文章1的内容为：Tom lives in Guangzhou, I live in Guangzhou too.<br>文章2的内容为：He once lived in Shanghai.</p></blockquote><p>首先第一步是将文档传给分词组件（Tokenizer），分词组件会将文档分成一个个单词，并去除标点符号和停词。所谓的停词指的是没有特别意义的词，比如英文中的 a，the，too 等。经过分词后，得到词元（Token） 。如下：</p><blockquote><p>文章1经过分词后的结果：<code>[Tom]</code> <code>[lives]</code> <code>[Guangzhou]</code> <code>[I]</code> <code>[live]</code> <code>[Guangzhou]</code><br>文章2经过分词后的结果：<code>[He]</code> <code>[lives]</code> <code>[Shanghai]</code></p></blockquote><p>然后将词元传给语言处理组件（Linguistic Processor），对于英语，语言处理组件一般会将字母变为小写，将单词缩减为词根形式，如 ”lives” 到 ”live” 等，将单词转变为词根形式，如 ”drove” 到 ”drive” 等。然后得到词（Term）。如下：</p><blockquote><p>文章1经过处理后的结果：<code>[tom]</code> <code>[live]</code> <code>[guangzhou]</code> <code>[i]</code> <code>[live]</code> <code>[guangzhou]</code><br>文章2经过处理后的结果：<code>[he]</code> <code>[live]</code> <code>[shanghai]</code></p></blockquote><p>最后将得到的词传给索引组件（Indexer），索引组件经过处理，得到下面的索引结构：</p><table><thead><tr><th>关键词</th><th>文章号[出现频率]</th><th>出现位置</th></tr></thead><tbody><tr><td>guangzhou</td><td>1[2]</td><td>3,6</td></tr><tr><td>he</td><td>2[1]</td><td>1</td></tr><tr><td>i</td><td>1[1]</td><td>4</td></tr><tr><td>live</td><td>1[2],2[1]</td><td>2,5,2</td></tr><tr><td>shanghai</td><td>2[1]</td><td>3</td></tr><tr><td>tom</td><td>1[1]</td><td>1</td></tr></tbody></table><p>以上就是Lucene 索引结构中最核心的部分。它的关键字是按字符顺序排列的，因此 Lucene 可以用二元搜索算法快速定位关键词。实现时 Lucene 将上面三列分别作为词典文件（Term Dictionary）、频率文件（frequencies）和位置文件（positions）保存。其中词典文件不仅保存有每个关键词，还保留了指向频率文件和位置文件的指针，通过指针可以找到该关键字的频率信息和位置信息。<br>搜索的过程是先对词典二元查找、找到该词，通过指向频率文件的指针读出所有文章号，然后返回结果，然后就可以在具体的文章中根据出现位置找到该词了。所以 Lucene 在第一次建立索引的时候可能会比较慢，但是以后就不需要每次都建立索引了，就快了。</p><p>理解了 Lucene 的分词原理，接下来我们在 Spring Boot 中集成 Lucene 并实现索引和搜索的功能。</p><h2 id="2-Spring-Boot-中集成-Lucence"><a href="#2-Spring-Boot-中集成-Lucence" class="headerlink" title="2. Spring Boot 中集成 Lucence"></a>2. Spring Boot 中集成 Lucence</h2><h3 id="2-1-依赖导入-3"><a href="#2-1-依赖导入-3" class="headerlink" title="2.1 依赖导入"></a>2.1 依赖导入</h3><p>首先需要导入 Lucene 的依赖，它的依赖有好几个，如下：</p><pre class="line-numbers language-none"><code class="language-none">xml&lt;!-- Lucence核心包 --&gt;&lt;dependency&gt;&lt;groupId&gt;org.apache.lucene&lt;/groupId&gt;&lt;artifactId&gt;lucene-core&lt;/artifactId&gt;&lt;version&gt;5.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Lucene查询解析包 --&gt;&lt;dependency&gt;&lt;groupId&gt;org.apache.lucene&lt;/groupId&gt;&lt;artifactId&gt;lucene-queryparser&lt;/artifactId&gt;&lt;version&gt;5.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 常规的分词（英文） --&gt;&lt;dependency&gt;&lt;groupId&gt;org.apache.lucene&lt;/groupId&gt;&lt;artifactId&gt;lucene-analyzers-common&lt;/artifactId&gt;&lt;version&gt;5.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;!--支持分词高亮  --&gt;&lt;dependency&gt;&lt;groupId&gt;org.apache.lucene&lt;/groupId&gt;&lt;artifactId&gt;lucene-highlighter&lt;/artifactId&gt;&lt;version&gt;5.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;!--支持中文分词  --&gt;&lt;dependency&gt;&lt;groupId&gt;org.apache.lucene&lt;/groupId&gt;&lt;artifactId&gt;lucene-analyzers-smartcn&lt;/artifactId&gt;&lt;version&gt;5.3.1&lt;/version&gt;&lt;/dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后一个依赖是用来支持中文分词的，因为默认是支持英文的。那个高亮的分词依赖是最后我要做一个搜索，然后将搜到的内容高亮显示，模拟当前互联网上的做法，大家可以运用到实际项目中去。</p><h3 id="2-2-快速入门"><a href="#2-2-快速入门" class="headerlink" title="2.2 快速入门"></a>2.2 快速入门</h3><p>根据上文的分析，全文检索有两个步骤，先建立索引，再检索。所以为了测试这个过程，我新建两个 java 类，一个用来建立索引的，另一个用来检索。</p><h4 id="2-2-1-建立索引"><a href="#2-2-1-建立索引" class="headerlink" title="2.2.1 建立索引"></a>2.2.1 建立索引</h4><p>我们自己弄几个文件，放到 <code>D:\lucene\data</code> 目录下，新建一个 Indexer 类来实现建立索引功能。首先在构造方法中初始化标准分词器和写索引实例。</p><pre class="line-numbers language-none"><code class="language-none">javapublic class Indexer {    /**     * 写索引实例     */    private IndexWriter writer;    /**     * 构造方法，实例化IndexWriter     * @param indexDir     * @throws Exception     */    public Indexer(String indexDir) throws Exception {        Directory dir = FSDirectory.open(Paths.get(indexDir));        //标准分词器，会自动去掉空格啊，is a the等单词        Analyzer analyzer = new StandardAnalyzer();        //将标准分词器配到写索引的配置中        IndexWriterConfig config = new IndexWriterConfig(analyzer);        //实例化写索引对象        writer = new IndexWriter(dir, config);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在构造放发中传一个存放索引的文件夹路径，然后构建标准分词器（这是英文的），再使用标准分词器来实例化写索引对象。接下来就开始建立索引了，我将解释放到代码注释里，方便大家跟进。</p><pre class="line-numbers language-none"><code class="language-none">java/** * 索引指定目录下的所有文件 * @param dataDir * @return * @throws Exception */public int indexAll(String dataDir) throws Exception {    // 获取该路径下的所有文件    File[] files = new File(dataDir).listFiles();    if (null != files) {        for (File file : files) {            //调用下面的indexFile方法，对每个文件进行索引            indexFile(file);        }    }    //返回索引的文件数    return writer.numDocs();}/** * 索引指定的文件 * @param file * @throws Exception */private void indexFile(File file) throws Exception {    System.out.println("索引文件的路径：" + file.getCanonicalPath());    //调用下面的getDocument方法，获取该文件的document    Document doc = getDocument(file);    //将doc添加到索引中    writer.addDocument(doc);}/** * 获取文档，文档里再设置每个字段，就类似于数据库中的一行记录 * @param file * @return * @throws Exception */private Document getDocument(File file) throws Exception {    Document doc = new Document();    //开始添加字段    //添加内容    doc.add(new TextField("contents", new FileReader(file)));    //添加文件名，并把这个字段存到索引文件里    doc.add(new TextField("fileName", file.getName(), Field.Store.YES));    //添加文件路径    doc.add(new TextField("fullPath", file.getCanonicalPath(), Field.Store.YES));    return doc;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样就建立好索引了，我们在该类中写一个 main 方法测试一下：</p><pre class="line-numbers language-none"><code class="language-none">javapublic static void main(String[] args) {        //索引保存到的路径        String indexDir = "D:\\lucene";        //需要索引的文件数据存放的目录        String dataDir = "D:\\lucene\\data";        Indexer indexer = null;        int indexedNum = 0;        //记录索引开始时间        long startTime = System.currentTimeMillis();        try {            // 开始构建索引            indexer = new Indexer(indexDir);            indexedNum = indexer.indexAll(dataDir);        } catch (Exception e) {            e.printStackTrace();        } finally {            try {                if (null != indexer) {                    indexer.close();                }            } catch (Exception e) {                e.printStackTrace();            }        }        //记录索引结束时间        long endTime = System.currentTimeMillis();        System.out.println("索引耗时" + (endTime - startTime) + "毫秒");        System.out.println("共索引了" + indexedNum + "个文件");    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我搞了两个 tomcat 相关的文件放到 <code>D:\lucene\data</code> 下了，执行完之后，看到控制台输出：</p><pre class="line-numbers language-none"><code class="language-none">plain索引文件的路径：D:\lucene\data\catalina.properties索引文件的路径：D:\lucene\data\logging.properties索引耗时882毫秒共索引了2个文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后我们去 <code>D:\lucene\</code> 目录下可以看到一些索引文件，这些文件不能删除，删除了就需要重新构建索引，否则没了索引，就无法去检索内容了。</p><p>####2.2.2 检索内容</p><p>上面把这两个文件的索引建立好了，接下来我们就可以写检索程序了，在这两个文件中查找特定的词。</p><pre class="line-numbers language-none"><code class="language-none">javapublic class Searcher {    public static void search(String indexDir, String q) throws Exception {        //获取要查询的路径，也就是索引所在的位置        Directory dir = FSDirectory.open(Paths.get(indexDir));        IndexReader reader = DirectoryReader.open(dir);        //构建IndexSearcher        IndexSearcher searcher = new IndexSearcher(reader);        //标准分词器，会自动去掉空格啊，is a the等单词        Analyzer analyzer = new StandardAnalyzer();        //查询解析器        QueryParser parser = new QueryParser("contents", analyzer);        //通过解析要查询的String，获取查询对象，q为传进来的待查的字符串        Query query = parser.parse(q);        //记录索引开始时间        long startTime = System.currentTimeMillis();        //开始查询，查询前10条数据，将记录保存在docs中        TopDocs docs = searcher.search(query, 10);        //记录索引结束时间        long endTime = System.currentTimeMillis();        System.out.println("匹配" + q + "共耗时" + (endTime-startTime) + "毫秒");        System.out.println("查询到" + docs.totalHits + "条记录");        //取出每条查询结果        for(ScoreDoc scoreDoc : docs.scoreDocs) {            //scoreDoc.doc相当于docID,根据这个docID来获取文档            Document doc = searcher.doc(scoreDoc.doc);            //fullPath是刚刚建立索引的时候我们定义的一个字段，表示路径。也可以取其他的内容，只要我们在建立索引时有定义即可。            System.out.println(doc.get("fullPath"));        }        reader.close();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ok，这样我们检索的代码就写完了，每一步解释我写在代码中的注释上了，下面写个 main 方法来测试一下：</p><pre class="line-numbers language-none"><code class="language-none">javapublic static void main(String[] args) {    String indexDir = "D:\\lucene";    //查询这个字符串    String q = "security";    try {        search(indexDir, q);    } catch (Exception e) {        e.printStackTrace();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查一下 <code>security</code> 这个字符串，执行一下看控制台打印的结果：</p><pre class="line-numbers language-none"><code class="language-none">plain匹配security共耗时23毫秒查询到1条记录D:\lucene\data\catalina.properties<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，耗时了23毫秒在两个文件中找到了 security 这个字符串，并输出了文件的名称。上面的代码我写的很详细，这个代码已经比较全了，可以用在生产环境上。</p><h3 id="2-3-中文分词检索高亮实战"><a href="#2-3-中文分词检索高亮实战" class="headerlink" title="2.3 中文分词检索高亮实战"></a>2.3 中文分词检索高亮实战</h3><p>上文已经写了建立索引和检索的代码，但是在实际项目中，我们往往是结合页面做一些查询结果的展示，比如我要查某个关键字，查到了之后，将相关的信息点展示出来，并将查询的关键字高亮等等。这种需求在实际项目中非常常见，而且大多数网站中都会有这种效果。所以这一小节我们就使用 Lucene 来实现这种效果。</p><h4 id="2-3-1-中文分词"><a href="#2-3-1-中文分词" class="headerlink" title="2.3.1 中文分词"></a>2.3.1 中文分词</h4><p>我们新建一个 ChineseIndexer 类来建立中文索引，建立过程和英文索引一样的，不同的地方在于使用的是中文分词器。除此之外，这里我们不用通过读取文件去建立索引，我们模拟一下用字符串来建立，因为在实际项目中，绝大部分情况是获取到一些文本字符串，然后根据一些关键字去查询相关内容等等。代码如下：</p><pre class="line-numbers language-none"><code class="language-none">javapublic class ChineseIndexer {    /**     * 存放索引的位置     */    private Directory dir;    //准备一下用来测试的数据    //用来标识文档    private Integer ids[] = {1, 2, 3};    private String citys[] = {"上海", "南京", "青岛"};    private String descs[] = {            "上海是个繁华的城市。",            "南京是一个文化的城市南京，简称宁，是江苏省会，地处中国东部地区，长江下游，濒江近海。全市下辖11个区，总面积6597平方公里，2013年建成区面积752.83平方公里，常住人口818.78万，其中城镇人口659.1万人。[1-4] “江南佳丽地，金陵帝王州”，南京拥有着6000多年文明史、近2600年建城史和近500年的建都史，是中国四大古都之一，有“六朝古都”、“十朝都会”之称，是中华文明的重要发祥地，历史上曾数次庇佑华夏之正朔，长期是中国南方的政治、经济、文化中心，拥有厚重的文化底蕴和丰富的历史遗存。[5-7] 南京是国家重要的科教中心，自古以来就是一座崇文重教的城市，有“天下文枢”、“东南第一学”的美誉。截至2013年，南京有高等院校75所，其中211高校8所，仅次于北京上海；国家重点实验室25所、国家重点学科169个、两院院士83人，均居中国第三。[8-10] 。",            "青岛是一个美丽的城市。"    };    /**     * 生成索引     * @param indexDir     * @throws Exception     */    public void index(String indexDir) throws Exception {        dir = FSDirectory.open(Paths.get(indexDir));        // 先调用 getWriter 获取IndexWriter对象        IndexWriter writer = getWriter();        for(int i = 0; i &lt; ids.length; i++) {            Document doc = new Document();            // 把上面的数据都生成索引，分别用id、city和desc来标识            doc.add(new IntField("id", ids[i], Field.Store.YES));            doc.add(new StringField("city", citys[i], Field.Store.YES));            doc.add(new TextField("desc", descs[i], Field.Store.YES));            //添加文档            writer.addDocument(doc);        }        //close了才真正写到文档中        writer.close();    }    /**     * 获取IndexWriter实例     * @return     * @throws Exception     */    private IndexWriter getWriter() throws Exception {        //使用中文分词器        SmartChineseAnalyzer analyzer = new SmartChineseAnalyzer();        //将中文分词器配到写索引的配置中        IndexWriterConfig config = new IndexWriterConfig(analyzer);        //实例化写索引对象        IndexWriter writer = new IndexWriter(dir, config);        return writer;    }    public static void main(String[] args) throws Exception {        new ChineseIndexer().index("D:\\lucene2");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里我们用 id、city、desc 分别代表 id、城市名称和城市描述，用他们作为关键字来建立索引，后面我们获取内容的时候，主要来获取城市描述。南京的描述我故意写的长一点，因为下文检索的时候，根据不同的关键字会检索到不同部分的信息，有个权重的概念在里面。<br>然后执行一下 main 方法，将索引保存到 <code>D:\lucene2\</code> 中。</p><h4 id="2-3-2-中文分词查询"><a href="#2-3-2-中文分词查询" class="headerlink" title="2.3.2 中文分词查询"></a>2.3.2 中文分词查询</h4><p>中文分词查询代码逻辑和默认的查询差不多，有一些区别在于，我们需要将查询出来的关键字标红加粗等需要处理，需要计算出一个得分片段，这是什么意思呢？比如我搜索 “南京文化” 跟搜索 “南京文明”，这两个搜索结果应该根据关键字出现的位置，返回的结果不一样才对，这在下文会测试。我们先看一下代码和注释：</p><pre class="line-numbers language-none"><code class="language-none">javapublic class ChineseSearch {    private static final Logger logger = LoggerFactory.getLogger(ChineseSearch.class);    public static List&lt;String&gt; search(String indexDir, String q) throws Exception {        //获取要查询的路径，也就是索引所在的位置        Directory dir = FSDirectory.open(Paths.get(indexDir));        IndexReader reader = DirectoryReader.open(dir);        IndexSearcher searcher = new IndexSearcher(reader);        //使用中文分词器        SmartChineseAnalyzer analyzer = new SmartChineseAnalyzer();        //由中文分词器初始化查询解析器        QueryParser parser = new QueryParser("desc", analyzer);        //通过解析要查询的String，获取查询对象        Query query = parser.parse(q);        //记录索引开始时间        long startTime = System.currentTimeMillis();        //开始查询，查询前10条数据，将记录保存在docs中        TopDocs docs = searcher.search(query, 10);        //记录索引结束时间        long endTime = System.currentTimeMillis();        logger.info("匹配{}共耗时{}毫秒", q, (endTime - startTime));        logger.info("查询到{}条记录", docs.totalHits);        //如果不指定参数的话，默认是加粗，即&lt;b&gt;&lt;b/&gt;        SimpleHTMLFormatter simpleHTMLFormatter = new SimpleHTMLFormatter("&lt;b&gt;&lt;font color=red&gt;","&lt;/font&gt;&lt;/b&gt;");        //根据查询对象计算得分，会初始化一个查询结果最高的得分        QueryScorer scorer = new QueryScorer(query);        //根据这个得分计算出一个片段        Fragmenter fragmenter = new SimpleSpanFragmenter(scorer);        //将这个片段中的关键字用上面初始化好的高亮格式高亮        Highlighter highlighter = new Highlighter(simpleHTMLFormatter, scorer);        //设置一下要显示的片段        highlighter.setTextFragmenter(fragmenter);        //取出每条查询结果        List&lt;String&gt; list = new ArrayList&lt;&gt;();        for(ScoreDoc scoreDoc : docs.scoreDocs) {            //scoreDoc.doc相当于docID,根据这个docID来获取文档            Document doc = searcher.doc(scoreDoc.doc);            logger.info("city:{}", doc.get("city"));            logger.info("desc:{}", doc.get("desc"));            String desc = doc.get("desc");            //显示高亮            if(desc != null) {                TokenStream tokenStream = analyzer.tokenStream("desc", new StringReader(desc));                String summary = highlighter.getBestFragment(tokenStream, desc);                logger.info("高亮后的desc:{}", summary);                list.add(summary);            }        }        reader.close();        return list;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每一步的注释我写的很详细，在这就不赘述了。接下来我们来测试一下效果。</p><h4 id="2-3-3-测试一下"><a href="#2-3-3-测试一下" class="headerlink" title="2.3.3 测试一下"></a>2.3.3 测试一下</h4><p>这里我们使用 thymeleaf 来写个简单的页面来展示获取到的数据，并高亮展示。在 controller 中我们指定索引的目录和需要查询的字符串，如下：</p><pre class="line-numbers language-none"><code class="language-none">java@Controller@RequestMapping("/lucene")public class IndexController {    @GetMapping("/test")    public String test(Model model) {        // 索引所在的目录        String indexDir = "D:\\lucene2";        // 要查询的字符//        String q = "南京文明";        String q = "南京文化";        try {            List&lt;String&gt; list = ChineseSearch.search(indexDir, q);            model.addAttribute("list", list);        } catch (Exception e) {            e.printStackTrace();        }        return "result";    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>直接返回到 result.html 页面，该页面主要来展示一下 model 中的数据即可。</p><pre class="line-numbers language-none"><code class="language-none">xml&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div th:each="desc : ${list}"&gt;    &lt;div th:utext="${desc}"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里注意一下，不能使用 <code>th:test</code>，否则字符串中的 html 标签都会被转义，不会被渲染到页面。下面启动服务，在浏览器中输入 <code>http://localhost:8080/lucene/test</code>，测试一下效果，我们搜索的是 “南京文化”。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMuZ2l0Ym9vay5jbi84M2IzZjgxMC1iMzc3LTExZTgtODhiZi0yM2NiNzhkMWZiNGY?x-oss-process=image/format,png" alt="南京文化"></p><p>再将 controller 中的搜索关键字改成 “南京文明”，看下命中的效果。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMuZ2l0Ym9vay5jbi84ZWY4YTRhMC1iMzc3LTExZTgtOTExZC0yN2NjNWYwNTk4Mjk?x-oss-process=image/format,png" alt="南京文明"></p><p>可以看出，不同的关键词，它会计算一个得分片段，也就是说不同的关键字会命中不同位置的内容，然后将关键字根据我们自己设定的形式高亮显示。从结果中可以看出，Lucene 也可以很智能的将关键字拆分命中，这在实际项目中会很好用。</p><h2 id="3-总结-3"><a href="#3-总结-3" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>本节课首先详细的分析了全文检索的理论规则，然后结合 Lucene，系统的讲述了在 Spring Boot 的集成步骤，首先快速带领大家从直观上感受 Lucene 如何建立索引已经如果检索，其次通过中文检索的具体实例，展示了 Lucene 在全文检索中的广泛应用。Lucene 不难，主要就是步骤比较多，代码不用死记硬背，拿到项目中根据实际情况做对应的修改即可。</p><p>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study">戳我下载</a></p><h1 id="第18课：Spring-Boot搭建实际项目开发中的架构"><a href="#第18课：Spring-Boot搭建实际项目开发中的架构" class="headerlink" title="第18课：Spring Boot搭建实际项目开发中的架构"></a>第18课：Spring Boot搭建实际项目开发中的架构</h1><p>前面的课程中，我主要给大家讲解了 Spring Boot 中常用的一些技术点，这些技术点在实际项目中可能不会全部用得到，因为不同的项目可能使用的技术不同，但是希望大家都能掌握如何使用，并能自己根据实际项目中的需求进行相应的扩展。</p><p>不知道大家了不了解单片机，单片机里有个最小系统，这个最小系统搭建好了之后，就可以在此基础上进行人为的扩展。这节课我们要做的就是搭建一个 “Spring Boot 最小系统架构” 。拿着这个架构，可以在此基础上根据实际需求做相应的扩展。</p><p>从零开始搭建一个环境，主要要考虑几点：统一封装的数据结构、可调式的接口、json的处理、模板引擎的使用（本文不写该项，因为现在大部分项目都前后端分离了，但是考虑到也还有非前后端分离的项目，所以我在源代码里也加上了 thymeleaf）、持久层的集成、拦截器（这个也是可选的）和全局异常处理。一般包括这些东西的话，基本上一个 Spring Boot 项目环境就差不多了，然后就是根据具体情况来扩展了。</p><p>结合前面的课程和以上的这些点，本节课手把手带领大家搭建一个实际项目开发中可用的 Spring Boot 架构。整个项目工程如下图所示，学习的时候，可以结合我的源码，这样效果会更好。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMuZ2l0Ym9vay5jbi82ZjIzYzk4MC1iODllLTExZTgtODdmMS01NTljOWI0NTY3NTQ?x-oss-process=image/format,png" alt="工程架构"></p><h2 id="1-统一的数据封装"><a href="#1-统一的数据封装" class="headerlink" title="1. 统一的数据封装"></a>1. 统一的数据封装</h2><p>由于封装的 json 数据的类型不确定，所以在定义统一的 json 结构时，我们需要用到泛型。统一的 json 结构中属性包括数据、状态码、提示信息即可，构造方法可以根据实际业务需求做相应的添加即可，一般来说，应该有默认的返回结构，也应该有用户指定的返回结构。如下：</p><pre class="line-numbers language-none"><code class="language-none">java/** * 统一返回对象 * @author shengwu ni * @param &lt;T&gt; */public class JsonResult&lt;T&gt; {    private T data;    private String code;    private String msg;    /**     * 若没有数据返回，默认状态码为0，提示信息为：操作成功！     */    public JsonResult() {        this.code = "0";        this.msg = "操作成功！";    }    /**     * 若没有数据返回，可以人为指定状态码和提示信息     * @param code     * @param msg     */    public JsonResult(String code, String msg) {        this.code = code;        this.msg = msg;    }    /**     * 有数据返回时，状态码为0，默认提示信息为：操作成功！     * @param data     */    public JsonResult(T data) {        this.data = data;        this.code = "0";        this.msg = "操作成功！";    }    /**     * 有数据返回，状态码为0，人为指定提示信息     * @param data     * @param msg     */    public JsonResult(T data, String msg) {        this.data = data;        this.code = "0";        this.msg = msg;    }        /**     * 使用自定义异常作为参数传递状态码和提示信息     * @param msgEnum     */    public JsonResult(BusinessMsgEnum msgEnum) {        this.code = msgEnum.code();        this.msg = msgEnum.msg();    }    // 省去get和set方法}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>大家可以根据自己项目中所需要的一些东西，合理的修改统一结构中的字段信息。</p><h2 id="2-json的处理"><a href="#2-json的处理" class="headerlink" title="2. json的处理"></a>2. json的处理</h2><p>Json 处理工具很多，比如阿里巴巴的 fastjson，不过 fastjson 对有些未知类型的 null 无法转成空字符串，这可能是 fastjson 自身的缺陷，可扩展性也不是太好，但是使用起来方便，使用的人也蛮多的。这节课里面我们主要集成 Spring Boot 自带的 jackson。主要是对 jackson 做一下对 null 的配置即可，然后就可以在项目中使用了。</p><pre class="line-numbers language-none"><code class="language-none">java/** * jacksonConfig * @author shengwu ni */@Configurationpublic class JacksonConfig {    @Bean    @Primary    @ConditionalOnMissingBean(ObjectMapper.class)    public ObjectMapper jacksonObjectMapper(Jackson2ObjectMapperBuilder builder) {        ObjectMapper objectMapper = builder.createXmlMapper(false).build();        objectMapper.getSerializerProvider().setNullValueSerializer(new JsonSerializer&lt;Object&gt;() {            @Override            public void serialize(Object o, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException {                jsonGenerator.writeString("");            }        });        return objectMapper;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里先不测试，等下面 swagger2 配置好了之后，我们一起来测试一下。</p><h2 id="3-swagger2在线可调式接口"><a href="#3-swagger2在线可调式接口" class="headerlink" title="3. swagger2在线可调式接口"></a>3. swagger2在线可调式接口</h2><p>有了 swagger，开发人员不需要给其他人员提供接口文档，只要告诉他们一个 Swagger 地址，即可展示在线的 API 接口文档，除此之外，调用接口的人员还可以在线测试接口数据，同样地，开发人员在开发接口时，同样也可以利用 Swagger 在线接口文档测试接口数据，这给开发人员提供了便利。使用 swagger 需要对其进行配置：</p><pre class="line-numbers language-none"><code class="language-none">java/** * swagger配置 * @author shengwu ni */@Configuration@EnableSwagger2public class SwaggerConfig {    @Bean    public Docket createRestApi() {        return new Docket(DocumentationType.SWAGGER_2)                // 指定构建api文档的详细信息的方法：apiInfo()                .apiInfo(apiInfo())                .select()                // 指定要生成api接口的包路径，这里把controller作为包路径，生成controller中的所有接口                .apis(RequestHandlerSelectors.basePackage("com.itcodai.course18.controller"))                .paths(PathSelectors.any())                .build();    }    /**     * 构建api文档的详细信息     * @return     */    private ApiInfo apiInfo() {        return new ApiInfoBuilder()                // 设置页面标题                .title("Spring Boot搭建实际项目中开发的架构")                // 设置接口描述                .description("跟武哥一起学Spring Boot第18课")                // 设置联系方式                .contact("倪升武，" + "微信公众号：程序员私房菜")                // 设置版本                .version("1.0")                // 构建                .build();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>到这里，可以先测试一下，写一个 Controller，弄一个静态的接口测试一下上面集成的内容。</p><pre class="line-numbers language-none"><code class="language-none">java@RestController@Api(value = "用户信息接口")public class UserController {    @Resource    private UserService userService;    @GetMapping("/getUser/{id}")    @ApiOperation(value = "根据用户唯一标识获取用户信息")    public JsonResult&lt;User&gt; getUserInfo(@PathVariable @ApiParam(value = "用户唯一标识") Long id) {        User user = new User(id, "倪升武", "123456");        return new JsonResult&lt;&gt;(user);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后启动项目，在浏览器中输入 <code>localhost:8080/swagger-ui.html</code> 即可看到 swagger 接口文档页面，调用一下上面这个接口，即可看到返回的 json 数据。</p><h2 id="4-持久层集成"><a href="#4-持久层集成" class="headerlink" title="4. 持久层集成"></a>4. 持久层集成</h2><p>每个项目中是必须要有持久层的，与数据库交互，这里我们主要来集成 mybatis，集成 mybatis 首先要在 application.yml 中进行配置。</p><pre class="line-numbers language-none"><code class="language-none">yml# 服务端口号server:  port: 8080# 数据库地址datasource:  url: localhost:3306/blog_testspring:  datasource: # 数据库配置    driver-class-name: com.mysql.jdbc.Driver    url: jdbc:mysql://${datasource.url}?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;allowMultiQueries=true&amp;autoReconnect=true&amp;failOverReadOnly=false&amp;maxReconnects=10    username: root    password: 123456    hikari:      maximum-pool-size: 10 # 最大连接池数      max-lifetime: 1770000mybatis:  # 指定别名设置的包为所有entity  type-aliases-package: com.itcodai.course18.entity  configuration:    map-underscore-to-camel-case: true # 驼峰命名规范  mapper-locations: # mapper映射文件位置    - classpath:mapper/*.xml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置好了之后，接下来我们来写一下 dao 层，实际中我们使用注解比较多，因为比较方便，当然也可以使用 xml 的方式，甚至两种同时使用都行，这里我们主要使用注解的方式来集成，关于 xml 的方式，大家可以查看前面课程，实际中根据项目情况来定。</p><pre class="line-numbers language-none"><code class="language-none">javapublic interface UserMapper {    @Select("select * from user where id = #{id}")    @Results({            @Result(property = "username", column = "user_name"),            @Result(property = "password", column = "password")    })    User getUser(Long id);    @Select("select * from user where id = #{id} and user_name=#{name}")    User getUserByIdAndName(@Param("id") Long id, @Param("name") String username);    @Select("select * from user")    List&lt;User&gt; getAll();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关于 service 层我就不在文章中写代码了，大家可以结合我的源代码学习，这一节主要带领大家来搭建一个 Spring Boot 空架构。最后别忘了在启动类上添加注解扫描 <code>@MapperScan("com.itcodai.course18.dao")</code></p><h2 id="5-拦截器"><a href="#5-拦截器" class="headerlink" title="5. 拦截器"></a>5. 拦截器</h2><p>拦截器在项目中使用的是非常多的（但不是绝对的），比如拦截一些置顶的 url，做一些判断和处理等等。除此之外，还需要将常用的静态页面或者 swagger 页面放行，不能将这些静态资源给拦截了。首先先自定义一个拦截器。</p><pre class="line-numbers language-none"><code class="language-none">javapublic class MyInterceptor implements HandlerInterceptor {    private static final Logger logger = LoggerFactory.getLogger(MyInterceptor.class);    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {        logger.info("执行方法之前执行(Controller方法调用之前)");        return true;    }    @Override    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {        logger.info("执行完方法之后进执行(Controller方法调用之后)，但是此时还没进行视图渲染");    }    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {        logger.info("整个请求都处理完咯，DispatcherServlet也渲染了对应的视图咯，此时我可以做一些清理的工作了");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后将自定义的拦截器加入到拦截器配置中。</p><pre class="line-numbers language-none"><code class="language-none">java@Configurationpublic class MyInterceptorConfig implements WebMvcConfigurer {    @Override    public void addInterceptors(InterceptorRegistry registry) {        // 实现WebMvcConfigurer不会导致静态资源被拦截        registry.addInterceptor(new MyInterceptor())                // 拦截所有url                .addPathPatterns("/**")                // 放行swagger                .excludePathPatterns("/swagger-resources/**");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 Spring Boot 中，我们通常会在如下目录里存放一些静态资源：</p><blockquote><p>classpath:/static<br>classpath:/public<br>classpath:/resources<br>classpath:/META-INF/resources</p></blockquote><p>上面代码中配置的 <code>/**</code> 是对所有 url 都进行了拦截，但我们实现了 WebMvcConfigurer 接口，不会导致 Spring Boot 对上面这些目录下的静态资源实施拦截。但是我们平时访问的 swagger 会被拦截，所以要将其放行。swagger 页面在 swagger-resources 目录下，放行该目录下所有文件即可。</p><p>然后在浏览器中输入一下 swagger 页面，若能正常显示 swagger，说明放行成功。同时可以根据后台打印的日志判断代码执行的顺序。</p><h2 id="6-全局异常处理"><a href="#6-全局异常处理" class="headerlink" title="6. 全局异常处理"></a>6. 全局异常处理</h2><p>全局异常处理是每个项目中必须用到的东西，在具体的异常中，我们可能会做具体的处理，但是对于没有处理的异常，一般会有一个统一的全局异常处理。在异常处理之前，最好维护一个异常提示信息枚举类，专门用来保存异常提示信息的。如下：</p><pre class="line-numbers language-none"><code class="language-none">javapublic enum BusinessMsgEnum {    /** 参数异常 */    PARMETER_EXCEPTION("102", "参数异常!"),    /** 等待超时 */    SERVICE_TIME_OUT("103", "服务调用超时！"),    /** 参数过大 */    PARMETER_BIG_EXCEPTION("102", "输入的图片数量不能超过50张!"),    /** 500 : 发生异常 */    UNEXPECTED_EXCEPTION("500", "系统发生异常，请联系管理员！");    /**     * 消息码     */    private String code;    /**     * 消息内容     */    private String msg;    private BusinessMsgEnum(String code, String msg) {        this.code = code;        this.msg = msg;    }    public String code() {        return code;    }    public String msg() {        return msg;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在全局统一异常处理类中，我们一般会对自定义的业务异常最先处理，然后去处理一些常见的系统异常，最后会来一个一劳永逸（Exception 异常）。</p><pre class="line-numbers language-none"><code class="language-none">java@ControllerAdvice@ResponseBodypublic class GlobalExceptionHandler {    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);    /**     * 拦截业务异常，返回业务异常信息     * @param ex     * @return     */    @ExceptionHandler(BusinessErrorException.class)    @ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR)    public JsonResult handleBusinessError(BusinessErrorException ex) {        String code = ex.getCode();        String message = ex.getMessage();        return new JsonResult(code, message);    }    /**     * 空指针异常     * @param ex NullPointerException     * @return     */    @ExceptionHandler(NullPointerException.class)    @ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR)    public JsonResult handleTypeMismatchException(NullPointerException ex) {        logger.error("空指针异常，{}", ex.getMessage());        return new JsonResult("500", "空指针异常了");    }    /**     * 系统异常 预期以外异常     * @param ex     * @return     */    @ExceptionHandler(Exception.class)    @ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR)    public JsonResult handleUnexpectedServer(Exception ex) {        logger.error("系统异常：", ex);        return new JsonResult(BusinessMsgEnum.UNEXPECTED_EXCEPTION);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，BusinessErrorException 是自定义的业务异常，继承一下 RuntimeException 即可，具体可以看我的源代码，文章中就不贴代码了。<br>在 UserController 中有个 testException 方法，用来测试全局异常的，打开 swagger 页面，调用一下该接口，可以看出返回用户提示信息：”系统发生异常，请联系管理员！“。当然了，实际情况中，需要根据不同的业务提示不同的信息。</p><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><p>本文主要手把手带领大家快速搭建一个项目中可以使用的 Spring Boot 空架构，主要从统一封装的数据结构、可调式的接口、json的处理、模板引擎的使用（代码中体现）、持久层的集成、拦截器和全局异常处理。一般包括这些东西的话，基本上一个 Spring Boot 项目环境就差不多了，然后就是根据具体情况来扩展了。</p><p>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study">戳我下载</a></p><p>ct * from user”)<br>List getAll();<br>}</p><pre class="line-numbers language-none"><code class="language-none">plain关于 service 层我就不在文章中写代码了，大家可以结合我的源代码学习，这一节主要带领大家来搭建一个 Spring Boot 空架构。最后别忘了在启动类上添加注解扫描 `@MapperScan("com.itcodai.course18.dao")`## 5. 拦截器拦截器在项目中使用的是非常多的（但不是绝对的），比如拦截一些置顶的 url，做一些判断和处理等等。除此之外，还需要将常用的静态页面或者 swagger 页面放行，不能将这些静态资源给拦截了。首先先自定义一个拦截器。```javapublic class MyInterceptor implements HandlerInterceptor {    private static final Logger logger = LoggerFactory.getLogger(MyInterceptor.class);    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {        logger.info("执行方法之前执行(Controller方法调用之前)");        return true;    }    @Override    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {        logger.info("执行完方法之后进执行(Controller方法调用之后)，但是此时还没进行视图渲染");    }    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {        logger.info("整个请求都处理完咯，DispatcherServlet也渲染了对应的视图咯，此时我可以做一些清理的工作了");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后将自定义的拦截器加入到拦截器配置中。</p><pre class="line-numbers language-none"><code class="language-none">java@Configurationpublic class MyInterceptorConfig implements WebMvcConfigurer {    @Override    public void addInterceptors(InterceptorRegistry registry) {        // 实现WebMvcConfigurer不会导致静态资源被拦截        registry.addInterceptor(new MyInterceptor())                // 拦截所有url                .addPathPatterns("/**")                // 放行swagger                .excludePathPatterns("/swagger-resources/**");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 Spring Boot 中，我们通常会在如下目录里存放一些静态资源：</p><blockquote><p>classpath:/static<br>classpath:/public<br>classpath:/resources<br>classpath:/META-INF/resources</p></blockquote><p>上面代码中配置的 <code>/**</code> 是对所有 url 都进行了拦截，但我们实现了 WebMvcConfigurer 接口，不会导致 Spring Boot 对上面这些目录下的静态资源实施拦截。但是我们平时访问的 swagger 会被拦截，所以要将其放行。swagger 页面在 swagger-resources 目录下，放行该目录下所有文件即可。</p><p>然后在浏览器中输入一下 swagger 页面，若能正常显示 swagger，说明放行成功。同时可以根据后台打印的日志判断代码执行的顺序。</p><h2 id="6-全局异常处理-1"><a href="#6-全局异常处理-1" class="headerlink" title="6. 全局异常处理"></a>6. 全局异常处理</h2><p>全局异常处理是每个项目中必须用到的东西，在具体的异常中，我们可能会做具体的处理，但是对于没有处理的异常，一般会有一个统一的全局异常处理。在异常处理之前，最好维护一个异常提示信息枚举类，专门用来保存异常提示信息的。如下：</p><pre class="line-numbers language-none"><code class="language-none">javapublic enum BusinessMsgEnum {    /** 参数异常 */    PARMETER_EXCEPTION("102", "参数异常!"),    /** 等待超时 */    SERVICE_TIME_OUT("103", "服务调用超时！"),    /** 参数过大 */    PARMETER_BIG_EXCEPTION("102", "输入的图片数量不能超过50张!"),    /** 500 : 发生异常 */    UNEXPECTED_EXCEPTION("500", "系统发生异常，请联系管理员！");    /**     * 消息码     */    private String code;    /**     * 消息内容     */    private String msg;    private BusinessMsgEnum(String code, String msg) {        this.code = code;        this.msg = msg;    }    public String code() {        return code;    }    public String msg() {        return msg;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在全局统一异常处理类中，我们一般会对自定义的业务异常最先处理，然后去处理一些常见的系统异常，最后会来一个一劳永逸（Exception 异常）。</p><pre class="line-numbers language-none"><code class="language-none">java@ControllerAdvice@ResponseBodypublic class GlobalExceptionHandler {    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);    /**     * 拦截业务异常，返回业务异常信息     * @param ex     * @return     */    @ExceptionHandler(BusinessErrorException.class)    @ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR)    public JsonResult handleBusinessError(BusinessErrorException ex) {        String code = ex.getCode();        String message = ex.getMessage();        return new JsonResult(code, message);    }    /**     * 空指针异常     * @param ex NullPointerException     * @return     */    @ExceptionHandler(NullPointerException.class)    @ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR)    public JsonResult handleTypeMismatchException(NullPointerException ex) {        logger.error("空指针异常，{}", ex.getMessage());        return new JsonResult("500", "空指针异常了");    }    /**     * 系统异常 预期以外异常     * @param ex     * @return     */    @ExceptionHandler(Exception.class)    @ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR)    public JsonResult handleUnexpectedServer(Exception ex) {        logger.error("系统异常：", ex);        return new JsonResult(BusinessMsgEnum.UNEXPECTED_EXCEPTION);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，BusinessErrorException 是自定义的业务异常，继承一下 RuntimeException 即可，具体可以看我的源代码，文章中就不贴代码了。<br>在 UserController 中有个 testException 方法，用来测试全局异常的，打开 swagger 页面，调用一下该接口，可以看出返回用户提示信息：”系统发生异常，请联系管理员！“。当然了，实际情况中，需要根据不同的业务提示不同的信息。</p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot摘录学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇文章</title>
      <link href="/archives/62824.html"/>
      <url>/archives/62824.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>简单的说一下Java的垃圾回收机制，解决了什么问题？</p></blockquote><p>在c语言和c++中，对于内存的管理是非常的让人头疼的，也是很多人放弃的原因，因此，在后面的一些高级语言中，设计者就想解决这一个问题，让开发者专注于自己的业务开发即可，因此，在Java中也引入了垃圾回收机制，它使得开发者在编写程序的时候不再需要考虑内存管理，由于有个垃圾回收机制，Java中的对象不再有“作用域”的概念，只有对象的引用才有“作用域”。垃圾回收可以有效的防止内存泄露，有效的使用空闲的内存。</p><blockquote><p>了解JVM的内存模型吗？</p></blockquote><p>JVM载执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。</p><p>Java 虚拟机所管理的内存一共分为Method Area（方法区）、VM Stack（虚拟机栈）、Native Method Stack（本地方法栈）、Heap（堆）、Program Counter Register（程序计数器）五个区域。</p><span id="more"></span><p>这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。具体如下图所示：</p><p><img src="http://image.ouyangsihai.cn/FhxTjHOieWt_ugomW5L33YNkJlJQ"></p><p>上图介绍的是JDK1.8  JVM运行时内存数据区域划分。1.8同1.7比，最大的差别就是：<strong>元数据区取代了永久代</strong>。元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：<strong>元数据空间并不在虚拟机中，而是使用本地内存</strong>。</p><h4 id="1-程序计数器（Program-Counter-Register）"><a href="#1-程序计数器（Program-Counter-Register）" class="headerlink" title="1 程序计数器（Program Counter Register）"></a>1 程序计数器（Program Counter Register）</h4><p><strong>程序计数器（Program Counter Register）</strong>是一块较小的内存空间，可以看作是当前线程所执行的字节码的<strong>行号指示器</strong>。在虚拟机概念模型中，<strong>字节码解释器</strong>工作时就是通过改变计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><p>程序计数器是一块 <strong>“线程私有”</strong> 的内存，每条线程都有一个独立的程序计数器，能够将切换后的线程恢复到正确的执行位置。</p><ul><li>执行的是一个<strong>Java方法</strong></li></ul><p>计数器记录的是正在执行的<strong>虚拟机字节码指令的地址</strong>。</p><ul><li>执行的是<strong>Native方法</strong></li></ul><p><strong>计数器为空（Undefined）</strong>，因为native方法是java通过JNI直接调用本地C/C++库，可以近似的认为native方法相当于C/C++暴露给java的一个接口，java通过调用这个接口从而调用到C/C++方法。由于该方法是通过C/C++而不是java进行实现。那么自然无法产生相应的字节码，并且C/C++执行时的内存分配是由自己语言决定的，而不是由JVM决定的。</p><ul><li>程序计数器也是唯一一个在Java虚拟机规范中没有规定任何<strong>OutOfMemoryError</strong>情况的内存区域。</li></ul><p>其实，我感觉这块区域，作为我们开发人员来说是不能过多的干预的，我们只需要了解有这个区域的存在就可以，并且也没有虚拟机相应的参数可以进行设置及控制。</p><h4 id="2-Java虚拟机栈（Java-Virtual-Machine-Stacks）"><a href="#2-Java虚拟机栈（Java-Virtual-Machine-Stacks）" class="headerlink" title="2 Java虚拟机栈（Java Virtual Machine Stacks）"></a>2 Java虚拟机栈（Java Virtual Machine Stacks）</h4><p><img src="http://image.ouyangsihai.cn/FksaMoFlAkSPkTB84bV4cK7xa8L3"></p><p><strong>Java虚拟机栈（Java Virtual Machine Stacks）</strong>描述的是<strong>Java方法执行的内存模型</strong>：每个方法在执行的同时都会创建一个<strong>栈帧（Stack Frame）</strong>，从上图中可以看出，栈帧中存储着<strong>局部变量表</strong>、<strong>操作数栈</strong>、<strong>动态链接</strong>、<strong>方法出口</strong>等信息。每一个方法从调用直至执行完成的过程，会对应一个栈帧在虚拟机栈中入栈到出栈的过程。</p><p>与程序计数器一样，Java虚拟机栈也是<strong>线程私有</strong>的。</p><p>而<strong>局部变量表</strong>中存放了编译期可知的各种：</p><ul><li><strong>基本数据类型</strong>(boolen、byte、char、short、int、 float、 long、double）</li><li><strong>对象引用</strong>（reference类型，它不等于对象本身，可能是一个指向对象起始地址的指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）</li><li><strong>returnAddress类型</strong>（指向了一条字节码指令的地址）</li></ul><p>其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余数据类型只占用1个。<strong>局部变量表所需的内存空间在编译期间完成分配</strong>，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p><p>Java虚拟机规范中对这个区域规定了两种异常状况：</p><ul><li><strong>StackOverflowError</strong>：线程请求的栈深度大于虚拟机所允许的深度，将会抛出此异常。</li><li><strong>OutOfMemoryError</strong>：当可动态扩展的虚拟机栈在扩展时无法申请到足够的内存，就会抛出该异常。</li></ul><p>一直觉得上面的概念性的知识还是比较抽象的，下面我们通过JVM参数的方式来控制栈的内存容量，模拟StackOverflowError异常现象。</p><h4 id="3-本地方法栈（Native-Method-Stack）"><a href="#3-本地方法栈（Native-Method-Stack）" class="headerlink" title="3 本地方法栈（Native Method Stack）"></a>3 本地方法栈（Native Method Stack）</h4><p><strong>本地方法栈（Native Method Stack）</strong> 与Java虚拟机栈作用很相似，它们的区别在于虚拟机栈为虚拟机执行Java方法（即字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。</p><p>在虚拟机规范中对本地方法栈中使用的语言、方式和数据结构并无强制规定，因此具体的虚拟机可实现它。甚至<strong>有的虚拟机（Sun HotSpot虚拟机）直接把本地方法栈和虚拟机栈合二为一</strong>。与虚拟机一样，本地方法栈会抛出<strong>StackOverflowError</strong>和<strong>OutOfMemoryError</strong>异常。</p><ul><li>使用-Xss参数减少栈内存容量（更多的JVM参数可以参考这篇文章：<a href="https://blog.ouyangsihai.cn/shen-ru-li-jie-java-xu-ni-ji-chang-yong-vm-can-shu-fen-xi.html">深入理解Java虚拟机-常用vm参数分析</a>）</li></ul><p>这个例子中，我们将栈内存的容量设置为<code>256K</code>（默认1 M），并且再定义一个变量查看栈递归的深度。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * @ClassName Test_02 * @Description 设置Jvm参数：-Xss256k * @Author 欧阳思海 * @Date 2019/9/30 11:05 * @Version 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test_02</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">stackTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        len<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"stack len:"</span> <span class="token operator">+</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">stackTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Test_02</span> test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test_02</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            test<span class="token punctuation">.</span><span class="token function">stackTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行时设置JVM参数</p><p><img src="http://image.ouyangsihai.cn/Fp8Z9xGi-AN7k7laSOHupU7htMg9"></p><p>输出结果：</p><p><img src="http://image.ouyangsihai.cn/FuHgFTcCaWlFjEtorqUbRF3RI_Cx"></p><h4 id="4-Java堆（Heap）"><a href="#4-Java堆（Heap）" class="headerlink" title="4 Java堆（Heap）"></a>4 Java堆（Heap）</h4><p>对于大多数应用而言，<strong>Java堆（Heap）</strong>是Java虚拟机所管理的内存中最大的一块，它<strong>被所有线程共享的</strong>，在虚拟机启动时创建。此内存区域<strong>唯一的目的</strong>是<strong>存放对象实例</strong>，几乎所有的对象实例都在这里分配内存，且每次分配的空间是<strong>不定长</strong>的。在Heap 中分配一定的内存来保存对象实例，实际上只是保存<strong>对象实例的属性值</strong>，<strong>属性的类型</strong>和<strong>对象本身的类型标记</strong>等，<strong>并不保存对象的方法（方法是指令，保存在Stack中）</strong>，在Heap 中分配一定的内存保存对象实例和对象的序列化比较类似。</p><p>Java堆是垃圾收集器管理的主要区域，因此也被称为 <strong>“GC堆（Garbage Collected Heap）”</strong> 。从内存回收的角度看内存空间可如下划分：</p><p><img src="http://image.ouyangsihai.cn/FvwbMlmR_k5r4xwnpH5LXDN-4qok" alt="图片摘自https://blog.csdn.net/bruce128/article/details/79357870"></p><ul><li><strong>新生代（Young）</strong>： 新生成的对象优先存放在新生代中，新生代对象朝生夕死，存活率很低。在新生代中，常规应用进行一次垃圾收集一般可以回收70% ~ 95% 的空间，回收效率很高。</li></ul><p>如果把新生代再分的细致一点，新生代又可细分为<strong>Eden空间</strong>、<strong>From Survivor空间</strong>、<strong>To Survivor空间</strong>，默认比例为8 : 1 : 1。</p><ul><li><strong>老年代（Tenured/Old）</strong>：在新生代中经历了多次（具体看虚拟机配置的阀值）GC后仍然存活下来的对象会进入老年代中。老年代中的对象生命周期较长，存活率比较高，在老年代中进行GC的频率相对而言较低，而且回收的速度也比较慢。</li><li><strong>永久代（Perm）</strong>：永久代存储类信息、常量、静态变量、即时编译器编译后的代码等数据，对这一区域而言，Java虚拟机规范指出可以不进行垃圾收集，一般而言不会进行垃圾回收。</li></ul><p>其中<strong>新生代和老年代组成了Java堆的全部内存区域</strong>，而<strong>永久代不属于堆空间，它在JDK 1.8以前被Sun HotSpot虚拟机用作方法区的实现</strong></p><p>另外，再强调一下堆空间内存分配的大体情况，这对于后面一些Jvm优化的技巧还是有帮助的。</p><ul><li>老年代 ： 三分之二的堆空间</li><li>年轻代 ： 三分之一的堆空间<br>eden区： 8/10 的年轻代空间<br>survivor0 : 1/10 的年轻代空间<br>survivor1 : 1/10 的年轻代空间</li></ul><p>最后，我们再通过一个简单的例子更加形象化的展示一下<strong>堆溢出</strong>的情况。</p><ul><li>JVM参数设置：-Xms10m -Xmx10m</li></ul><p>这里将堆的最小值和最大值都设置为10 m，如果不了解这些参数的含义，可以参考这篇文章：<a href="https://blog.ouyangsihai.cn/shen-ru-li-jie-java-xu-ni-ji-chang-yong-vm-can-shu-fen-xi.html">深入理解Java虚拟机-常用v m参数分析</a> </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * VM Args：-Xms10m -Xmx10m -XX:+HeapDumpOnOutOfMemoryError * @author zzm */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HeapTest</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">HeapObject</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HeapObject</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HeapObject</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//不断的向堆中添加对象</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HeapObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果：<br><img src="http://image.ouyangsihai.cn/Fhky14SMLxHjx9R9ZCcY0jAJ8ljg"></p><p>图中出现了<code>java.lang.OutOfMemoryError</code>，并且提示了<code>Java heap space</code>，这就说明是Java堆内存溢出的情况。</p><p><strong>堆的Dump文件分析</strong></p><p>我的使用的是VisualVM工具进行分析，关于如何使用这个工具查看这篇文章（<a href="https://blog.ouyangsihai.cn/shen-ru-li-jie-java-xu-ni-ji-ru-he-li-yong-visualvm-dui-gao-bing-fa-xiang-mu-jin-xing-xing-neng-fen-xi.html">深入理解Java虚拟机-如何利用VisualVM对高并发项目进行性能分析 </a>）。在运行程序之后，会同时打开VisualVM工具，查看堆内存的变化情况。</p><p><img src="http://image.ouyangsihai.cn/Fhdj0VggJwgP-qAOdWBBrWmO5XrM"></p><p>在上图中，可以看到，堆的最大值是30 m，但是使用的堆的容量也快接近30 m了，所以很容易发生堆内存溢出的情况。</p><p>接着查看dump文件。</p><p><img src="http://image.ouyangsihai.cn/FpYV2YbCGR3ByPy3vFNJbVNpoLdW"></p><p>如上图，堆中的大部分的对象都是HeapObject，所以，就是因为这个对象的一直产生，所以导致堆内存不够分配，所以出现内存溢出。</p><p>我们再看GC情况。</p><p><img src="http://image.ouyangsihai.cn/FpB0KxmFAtZOx7g95dlfyAp8mLEV"></p><p>如上图，Eden新生代总共48次minor gc，耗时 s，基本满足要求，但是survivor却没有，这不正常，同时Old Gen老年代总共27次full gc，耗时4.266s，耗时长，gc多，这正是因为大量的大对象进入到老年代导致的，所以，导致full gc频繁。</p><h4 id="5-方法区（Method-Area）"><a href="#5-方法区（Method-Area）" class="headerlink" title="5 方法区（Method Area）"></a>5 方法区（Method Area）</h4><p><strong>方法区（Method Area）</strong> 与Java堆一样，是各个线程共享的内存区域。它用于存储一杯<code>虚拟机加载</code>的<strong>类信息、常量、静态变量、及时编译器编译后的代码</strong>等数据。正因为方法区所存储的数据与堆有一种类比关系，所以它还被称为 <strong>Non-Heap</strong>。</p><p><big><strong>运行时常量池（Runtime Constant Pool）</strong></big></p><p><strong>运行时常量池（Runtime Constant Pool）</strong>是方法区的一部分。<strong>Class文件</strong>中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是<strong>常量池（Constant Pool Table）</strong>，用于存放编译期生成的各种字面量和符号引用，<strong>这部分内容将在类加载后进入方法区的运行时常量池存放</strong>。</p><p>Java虚拟机对Class文件每一部分（自然包括常量池）的格式有严格规定，每一个字节用于存储那种数据都必须符合规范上的要求才会被虚拟机认可、装载和执行。但<strong>对于运行时常量池，Java虚拟机规范没有做任何有关细节的要求</strong>，不同的提供商实现的虚拟机可以按照自己的需求来实现此内存区域。不过一般而言，除了保存<strong>Class文件中的描述符号引用</strong>外，还会把<strong>翻译出的直接引用</strong>也存储在运行时常量池中。</p><p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备<strong>动态性</strong>，Java语言并不要求常量一定只有编译器才能产生，也就是<strong>并非置入Class文件中的常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中</strong>。</p><h4 id="运行时常量池举例"><a href="#运行时常量池举例" class="headerlink" title="运行时常量池举例"></a>运行时常量池举例</h4><p>上面的<strong>动态性</strong>在开发中用的比较多的便是String类的<code>intern()</code> 方法。所以，我们以<code>intern()</code> 方法举例，讲解一下<strong>运行时常量池</strong>。</p><p><code>String.intern()</code>是一个<code>native</code>方法，作用是：如果字符串常量池中已经包含有一个等于此String对象的字符串，则直接返回池中的字符串；否则，加入到池中，并返回。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * @ClassName MethodTest * @Description vm参数设置：-Xms512m -Xmx512m -Xmn128m -XX:PermSize=10M -XX:MaxPermSize=10M -XX:NewRatio=4 -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=15 -XX:-HeapDumpOnOutOfMemoryError -XX:+UseParNewGC -XX:+UseConcMarkSweepGC * @Author 欧阳思海 * @Date 2019/11/25 20:06 * @Version 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MethodTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">1000000000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>vm参数介绍：</p><blockquote><p>-Xms512m -Xmx512m -Xmn128m -XX:PermSize=10M -XX:MaxPermSize=10M -XX:NewRatio=4 -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=15 -XX:-HeapDumpOnOutOfMemoryError -XX:+UseParNewGC -XX:+UseConcMarkSweepGC<br>开始堆内存和最大堆内存都是512m，永久代大小10m，新生代和老年代1：4，E:S1:S2=8:1:1，最大经过15次survivor进入老年代，使用的，垃圾收集器是新生代ParNew，老年代CMS。</p></blockquote><p>通过这样的设置之后，查看运行结果：<br><img src="http://image.ouyangsihai.cn/FlpAIczI0f-h26J5QGYXdUkW2hbw"></p><p>首先堆内存耗完，然后看看GC情况，设置这些参数之后，GC情况应该会不错，拭目以待。</p><p><img src="http://image.ouyangsihai.cn/FvkHjwUTJcMK0j7KvrgLVWJOHODY"></p><p>上图是GC情况，我们可以看到<strong>新生代</strong> 21 次minor gc，用了1.179秒，平均不到50ms一次，性能不错，<strong>老年代</strong> 117 次full gc，用了45.308s，平均一次不到1s，性能也不错，说明jvm运行是不错的。</p><blockquote><p><strong>注意：</strong> 在JDK1.6及以前的版本中运行以上代码，因为我们通过<code>-XX:PermSize=10M -XX:MaxPermSize=10M</code>设置了方法区的大小，所以也就是设置了常量池的容量，所以运行之后，会报错：<code>java.lang.OutOfMemoryError:PermGen space</code>，这说明常量池溢出；在JDK1.7及以后的版本中，将会一直运行下去，不会报错，在前面也说到，JDK1.7及以后，去掉了永久代。</p></blockquote><h4 id="6-直接内存"><a href="#6-直接内存" class="headerlink" title="6 直接内存"></a>6 直接内存</h4><p><strong>直接内存（Direct Memory）</strong>并不是虚拟机<strong>运行时数据区</strong>的一部分，也不是Java虚拟机规范中定义的内存区域。但这部分内存也被频繁运用，而却可能导致<strong>OutOfMemoryError</strong>异常出现。</p><p>这个我们实际中主要接触到的就是NIO，在NIO中，我们为了能够加快IO操作，采用了一种直接内存的方式，使得相比于传统的IO快了很多。</p><p>在NIO引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配<strong>堆外内存</strong>，然后通过一个存储在Java堆中的<code>DirectByteBuffer</code>对象作为这块内存的引用进行操作。这样能避免在Java堆和Native堆中来回复制数据，在一些场景里显著提高性能。</p><p>在配置虚拟机参数时，会根据实际内存设置-Xmx等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统的限制），从而导致动态扩展时出现<strong>OutOfMemoryError</strong>异常。</p><blockquote><p>JVM的四种引用？</p></blockquote><p>Java把对象的引用分为四种级别，从而使程序能更加灵活的控制对象的生命周期。这四种级别由高到低依次为：强引用、软引用、弱引用和虚引用。</p><ul><li>强引用</li></ul><p>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。 </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token string">"sihai"</span><span class="token punctuation">;</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Arraylist</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>以上就是一个强引用的例子，及时内存不足，该对象也不会被回收。</p><ul><li>软引用</li></ul><p>如果一个对象只具有软引用，那就类似于可有可物的生活用品。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p><p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA虚拟机就会把这个软引用加入到与之关联的引用队列中。 </p><p>当内存足够大时可以把数组存入软引用，取数据时就可从内存里取数据，提高运行效率。</p><ul><li>弱引用</li></ul><p>如果一个对象只具有弱引用，那就类似于可有可物的生活用品。弱引用与软引用的区别在于：<strong>只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存</strong>。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。</p><p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。 </p><ul><li>虚引用</li></ul><p>如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与软引用和弱引用的一个区别在于：<strong>虚引用必须和引用队列（ReferenceQueue）联合使用。</strong></p><p>当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p><p><strong>注意:</strong> 在实际程序设计中一般很少使用弱引用与虚引用，使用软用的情况较多，这是因为软引用可以加速JVM对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生。</p><blockquote><p>GC用的可达性分析算法中，哪些对象可以作为GC Roots对象？</p></blockquote><ul><li>虚拟机栈（栈帧中的局部变量表，Local Variable Table）中引用的对象。</li><li>方法区中类静态属性引用的对象。</li><li>方法区中常量引用的对象。</li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象。</li></ul><blockquote><p>如何判断对象是不是垃圾？</p></blockquote><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>先讲讲第一个算法：<strong>引用计数算法</strong>。</p><p>其实，这个算法的思想非常的简单，一句话就是：<strong>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器加1；当引用失效时，计数器减1；任何时刻计数器为0的对象就是不可能再被使用的。</strong></p><p>这些简单的算法现在是否还被大量的使用呢，其实，现在用的已经不多，没有被使用的最主要的原因是他有一个很大的<strong>缺点</strong>：<strong>很难解决对象之间循环引用的问题</strong>。</p><p><strong>循环引用</strong>：当A有B的引用，B又有A的引用的时候，这个时候，即使A和B对象都为null，这个时候，引用计数算法也不会将他们进行垃圾回收。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * @ClassName Test_02 * @Description * @Author 欧阳思海 * @Date 2019/12/5 16:59 * @Version 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test_02</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Instance</span> instanceA <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Instance</span> instanceB <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        instanceA<span class="token punctuation">.</span>instance <span class="token operator">=</span> instanceB<span class="token punctuation">;</span>        instanceB<span class="token punctuation">.</span>instance <span class="token operator">=</span> instanceA<span class="token punctuation">;</span>        instanceA <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        instanceB <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Scanner</span> scanner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>        scanner<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Instance</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> instance <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果使用的是<strong>引用计数算法</strong>，这是不能被回收的，当然，现在的JVM是可以被回收的。</p><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>这个算法的思想也是很简单的，这里有一个概念叫做<strong>可达性分析</strong>，如果知道图的数据结构，这里可以把每一个对象当做图中的一个节点，我们把一个节点叫做<strong>GC Roots</strong>，如果一个节点到<strong>GC Roots</strong>没有任何的相连的路径，那么就说明这个节点不可达，也就是这个节点可以被回收。</p><p><img src="http://image.ouyangsihai.cn/FqyjRBThJ5HhXAIEH4UE7znJhOuk"></p><p>上面图中，虽然obj7、8、9相互引用，但是到GC Roots不可达，所以，这种对象也是会被当做垃圾收集的。</p><p>在Java中，可以作为<code>GC Roots</code>的对象包括以下几种：</p><ul><li>虚拟机栈（栈帧中的局部变量表，Local Variable Table）中引用的对象。</li><li>方法区中类静态属性引用的对象。</li><li>方法区中常量引用的对象。</li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象。</li></ul><blockquote><p>介绍一下JVM的堆</p></blockquote><p>这个面试题其实和上面的有点重合，但是，这里单独拿出来再介绍一下，因为这个确实是比较常见的，这样大家也都有印象。</p><p>对于大多数应用而言，<strong>Java堆（Heap）</strong>是Java虚拟机所管理的内存中最大的一块，它<strong>被所有线程共享的</strong>，在虚拟机启动时创建。此内存区域<strong>唯一的目的</strong>是<strong>存放对象实例</strong>，几乎所有的对象实例都在这里分配内存，且每次分配的空间是<strong>不定长</strong>的。在Heap 中分配一定的内存来保存对象实例，实际上只是保存<strong>对象实例的属性值</strong>，<strong>属性的类型</strong>和<strong>对象本身的类型标记</strong>等，<strong>并不保存对象的方法（方法是指令，保存在Stack中）</strong>，在Heap 中分配一定的内存保存对象实例和对象的序列化比较类似。</p><p>Java堆是垃圾收集器管理的主要区域，因此也被称为 <strong>“GC堆（Garbage Collected Heap）”</strong> 。从内存回收的角度看内存空间可如下划分：</p><p><img src="http://image.ouyangsihai.cn/FvwbMlmR_k5r4xwnpH5LXDN-4qok" alt="图片摘自https://blog.csdn.net/bruce128/article/details/79357870"></p><ul><li><strong>新生代（Young）</strong>： 新生成的对象优先存放在新生代中，新生代对象朝生夕死，存活率很低。在新生代中，常规应用进行一次垃圾收集一般可以回收70% ~ 95% 的空间，回收效率很高。</li></ul><p>如果把新生代再分的细致一点，新生代又可细分为<strong>Eden空间</strong>、<strong>From Survivor空间</strong>、<strong>To Survivor空间</strong>，默认比例为8:1:1。</p><ul><li><strong>老年代（Tenured/Old）</strong>：在新生代中经历了多次（具体看虚拟机配置的阀值）GC后仍然存活下来的对象会进入老年代中。老年代中的对象生命周期较长，存活率比较高，在老年代中进行GC的频率相对而言较低，而且回收的速度也比较慢。</li><li><strong>永久代（Perm）</strong>：永久代存储类信息、常量、静态变量、即时编译器编译后的代码等数据，对这一区域而言，Java虚拟机规范指出可以不进行垃圾收集，一般而言不会进行垃圾回收。</li></ul><p>其中<strong>新生代和老年代组成了Java堆的全部内存区域</strong>，而<strong>永久代不属于堆空间，它在JDK 1.8以前被Sun HotSpot虚拟机用作方法区的实现</strong></p><p>另外，再强调一下堆空间内存分配的大体情况，这对于后面一些Jvm优化的技巧还是有帮助的。</p><ul><li>老年代 ： 三分之二的堆空间</li><li>年轻代 ： 三分之一的堆空间<br>eden区： 8/10 的年轻代空间<br>survivor0 : 1/10 的年轻代空间<br>survivor1 : 1/10 的年轻代空间</li></ul><p>最后，我们再通过一个简单的例子更加形象化的展示一下<strong>堆溢出</strong>的情况。</p><ul><li>JVM参数设置：-Xms10m -Xmx10m</li></ul><p>这里将堆的最小值和最大值都设置为10m，如果不了解这些参数的含义，可以参考这篇文章：<a href="https://blog.ouyangsihai.cn/shen-ru-li-jie-java-xu-ni-ji-chang-yong-vm-can-shu-fen-xi.html">深入理解Java虚拟机-常用vm参数分析</a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * VM Args：-Xms10m -Xmx10m -XX:+HeapDumpOnOutOfMemoryError * @author zzm */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HeapTest</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">HeapObject</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HeapObject</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HeapObject</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//不断的向堆中添加对象</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HeapObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果：<br><img src="http://image.ouyangsihai.cn/Fhky14SMLxHjx9R9ZCcY0jAJ8ljg"></p><p>图中出现了<code>java.lang.OutOfMemoryError</code>，并且提示了<code>Java heap space</code>，这就说明是Java堆内存溢出的情况。</p><blockquote><p>介绍一下Minor GC和Full GC</p></blockquote><p>这个概念首先我们要了解JVM的内存分区，在上面的面试题中已经做了介绍，这里就不再介绍了。</p><p>新生代 GC（Minor GC）:指发生新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。</p><p>老年代 GC（Major GC/Full GC）:指发生在老年代的 GC，出现了 Major GC 经常会伴随至少一次的 Minor GC（并非绝对），Major GC 的速度一般会比 Minor GC 的慢 10 倍以上。</p><p><strong>内存分配规则</strong></p><ul><li>对象优先分配到Eden区，如果Eden区空间不够，则执行一次minor GC；</li><li>大对象直接进入到老年代；</li><li>长期存活的对象可以进入到老年代；</li><li>动态判断对象年龄。如果在Survivor空间中相同年龄所有对象的大小的总和大于Survivor空间的一半，年龄大于等于该年龄的对象直接进入到老年代。</li></ul><p>在这里更加详细的规则介绍可以参考这篇文章：<a href="https://blog.ouyangsihai.cn/shen-ru-li-jie-java-xu-ni-ji-jvm-nei-cun-fen-pei-yu-hui-shou-ce-lue-yuan-li-cong-ci-gao-bie-jvm-nei-cun-fen-pei-wen-mang.html">深入理解Java虚拟机-JVM内存分配与回收策略原理，从此告别JVM内存分配文盲</a></p><blockquote><p>说一下Java对象创建的方法</p></blockquote><p>这个问题其实很简单，但是很多人却只知道new的方式。</p><ul><li>new的方法，最常见；</li><li>调用对象的clone方法；</li><li>使用反射，Class.forName();</li><li>运用反序列化机制，java.io.ObjectInputStream对象的readObject()方法。</li></ul><blockquote><p>介绍一下几种垃圾收集算法？</p></blockquote><h4 id="标记－清除（Mark-Sweep）算法"><a href="#标记－清除（Mark-Sweep）算法" class="headerlink" title="标记－清除（Mark-Sweep）算法"></a>标记－清除（Mark-Sweep）算法</h4><p><strong>标记－清除（Mark-Sweep）</strong> 算法是最基础的垃圾收集算法，后续的收集算法都是基于它的思路并对其不足进行改进而得到的。顾名思义，算法分成“标记”、“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，标记过程在前一节讲述对象标记判定时已经讲过了。</p><p>标记－清除算法的不足主要有以下两点：</p><ul><li><strong>空间问题</strong>，标记清除之后会产生大量不连续的<strong>内存碎片</strong>，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不触发另一次垃圾收集动作。</li><li><strong>效率问题</strong>，因为内存碎片的存在，操作会变得更加费时，因为查找下一个可用空闲块已不再是一个简单操作。</li></ul><p>标记－清除算法的执行过程如下图所示：</p><p><img src="http://image.ouyangsihai.cn/Fn_nJ2vQKuX47-8rBn7IZrV5LfoH"></p><h4 id="复制（Copying）算法"><a href="#复制（Copying）算法" class="headerlink" title="复制（Copying）算法"></a>复制（Copying）算法</h4><p>为了解决标记-清除算法的效率问题，一种称为<strong>“复制”（Copying）</strong>的收集算法出现了，思想为：它<strong>将可用内存按容量分成大小相等的两块</strong>，每次只使用其中的一块。<strong>当这一块内存用完，就将还存活着的对象复制到另一块上面</strong>，然后再把已使用过的内存空间一次清理掉。</p><p>这样做使得<strong>每次都是对整个半区进行内存回收</strong>，内存分配时也就<strong>不用考虑内存碎片</strong>等复杂情况，只要<strong>移动堆顶指针，按顺序分配内存</strong>即可，实现简单，运行高效。只是这种算法的代价是<strong>将内存缩小为原来的一半</strong>，代价可能过高了。复制算法的执行过程如下图所示：</p><p><img src="http://image.ouyangsihai.cn/FoyNQk9dft20afZSCIzC7oVoJIHQ"></p><h5 id="标记－整理（Mark-Compact）算法"><a href="#标记－整理（Mark-Compact）算法" class="headerlink" title="标记－整理（Mark-Compact）算法"></a>标记－整理（Mark-Compact）算法</h5><p>复制算法在对象存活率较高时要进行较多的复制操作，效率将会变低。更关键的是：如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在<strong>老年代一般不能直接选用复制算法</strong>。</p><p>根据老年代的特点，<strong>标记－整理（Mark-Compact）</strong>算法被提出来，主要思想为：此算法的标记过程与<strong>标记－清除</strong>算法一样，但后续步骤不是直接对可回收对象进行清理，而是<strong>让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。</strong> 具体示意图如下所示：</p><p><img src="http://image.ouyangsihai.cn/Fov_rN7qL6R_DbGUNChUUOC4lqHS"></p><h5 id="分代收集（Generational-Collection）算法"><a href="#分代收集（Generational-Collection）算法" class="headerlink" title="分代收集（Generational Collection）算法"></a>分代收集（Generational Collection）算法</h5><p>当前商业虚拟机的垃圾收集都采用<strong>分代收集（Generational Collection）算法</strong>，此算法相较于前几种没有什么新的特征，主要思想为：根据对象存活周期的不同将内存划分为几块，一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适合的收集算法：</p><ul><li><p><strong>新生代</strong> 在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用<strong>复制算法</strong>，只需要付出少量存活对象的复制成本就可以完成收集。</p></li><li><p><strong>老年代</strong> 在老年代中，因为对象存活率高、没有额外空间对它进行分配担保，就必须使用<strong>标记-清除</strong>或<strong>标记-整理</strong>算法来进行回收。</p></li></ul><blockquote><p>如何减少gc出现的次数</p></blockquote><p>上面的面试题已经讲解到了，从年轻代空间（包括Eden和 Survivor 区域）回收内存被称为Minor GC，对老年代GC称为Major GC，而Full GC是对整个堆来说的，在最近几个版本的JDK里默认包括了对永生带即方法区的回收（JDK8中无永生带了），出现Full GC的时候经常伴随至少一次的Minor GC，但非绝对的。Major GC的速度一般会比Minor GC慢10倍以上。</p><p>GC会stop the world。会暂停程序的执行，带来延迟的代价。所以在开发中，我们不希望GC的次数过多。</p><ul><li>对象不用时最好显式置为 Null</li></ul><p>一般而言，为 Null 的对象都会被作为垃圾处理，所以将不用的对象显式地设为 Null，有利于 GC 收集器判定垃圾，从而提高了 GC 的效率。</p><ul><li>尽量少用 System.gc()</li></ul><p>此函数建议 JVM 进行主 GC，虽然只是建议而非一定，但很多情况下它会触发主 GC，从而增加主 GC 的频率，也即增加了间歇性停顿的次数。</p><ul><li>尽量少用静态变量</li></ul><p>静态变量属于全局变量，不会被 GC 回收，它们会一直占用内存。</p><ul><li>尽量使用 StringBuffer，而不用 String 来累加字符串</li></ul><p>由于 String 是固定长的字符串对象。累加 String 对象时，并非在一个 String对象中扩增，而是重新创建新的 String 对象，如 Str5=Str1+Str2+Str3+Str4，这条语句执行过程中会产生多个垃圾对象，因为对次作“+”操作时都必须创建新的 String 对象，但这些过渡对象对系统来说是没有实际意义的，只会增加更多的垃圾。 避免这种情况可以改用 StringBuffer 来累加字符串，因 StringBuffer是可变长的，它在原有基础上进行扩增，不会产生中间对象</p><ul><li>分散对象创建或删除的时间</li></ul><p>集中在短时间内大量创建新对象，特别是大对象，会导致突然需要大量内存，JVM 在面临这种情况时，只能进行主 GC，以回收内存或整合内存碎片，从而增加主 GC 的频率。</p><p>集中删除对象，道理也是一样的。 它使得突然出现了大量的垃圾对象，空闲空间必然减少，从而大大增加了下一次创建新对象时强制主 GC 的机会。</p><ul><li>尽量少用 finalize 函数</li></ul><p>因为它会加大 GC 的工作量，因此尽量少用finalize 方式回收资源。</p><ul><li>使用软引用类型</li></ul><p>如果需要使用经常用到的图片，可以使用软引用类型，它可以尽可能将图片保存在内存中，供程序调用，而不引起 OutOfMemory。</p><ul><li>尽量少用 finalize 函数。</li></ul><p>因为它会加大 GC 的工作量，因此尽量少用finalize 方式回收资源。</p><p>如果需要使用经常用到的图片，可以使用软引用类型，它可以尽可能将图片保存在内存中，供程序调用，而不引起 OutOfMemory。</p><ul><li>能用基本类型如 int，long，就不用 Integer，Long 对象</li></ul><p>基本类型变量占用的内存资源比相应包装类对象占用的少得多，如果没有必要，最好使用基本变量。</p><ul><li><p>增大-Xmx </p></li><li><p>老年代代空间不足</p></li></ul><p>老年代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，当执行Full GC后空间仍然不足，则抛出如下错误：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>OutOfMemoryError</span><span class="token operator">:</span> <span class="token class-name">Java</span> heap space<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>为避免以上两种状况引起的Full GC，调优时应尽量做到让对象在Minor GC阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。</p><ul><li>永生区空间不足</li></ul><p>JVM规范中运行时数据区域中的方法区，在HotSpot虚拟机中又被习惯称为永生代或者永生区，<code>Permanet Generation</code>中存放的为一些class的信息、常量、静态变量等数据，当系统中要加载的类、反射的类和调用的方法较多时，<code>Permanet Generation</code>可能会被占满，在未配置为采用CMS GC的情况下也会执行Full GC。如果经过Full GC仍然回收不了，那么JVM会抛出如下错误信息：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>OutOfMemoryError</span><span class="token operator">:</span> <span class="token class-name">PermGen</span> space<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>为避免Perm Gen占满造成Full GC现象，可采用的方法为增大Perm Gen空间或转为使用CMS GC。</p><ul><li>CMS GC时出现<code>promotion failed</code>和<code>concurrent mode failure</code></li></ul><p>对于采用CMS进行老年代GC的程序而言，尤其要注意GC日志中是否有<code>promotion failed</code>和<code>concurrent mode failure</code>两种状况，当这两种状况出现时可能会触发Full GC。</p><p>promotion failed是在进行Minor GC时，<code>survivor space</code>放不下、对象只能放入老年代，而此时老年代也放不下造成的；<code>concurrent mode failure</code>是在执行CMS GC的过程中同时有对象要放入老年代，而此时老年代空间不足造成的（有时候“空间不足”是CMS GC时当前的浮动垃圾过多导致暂时性的空间不足触发Full GC）。</p><p>对措施为：增大survivor space、老年代空间或调低触发并发GC的比率，但在JDK 5.0+、6.0+的版本中有可能会由于JDK的bug29导致CMS在remark完毕后很久才触发sweeping动作。对于这种状况，可通过设置<code>-XX: CMSMaxAbortablePrecleanTime=5</code>（单位为ms）来避免。</p><ul><li>统计得到的Minor GC晋升到旧生代的平均大小大于老年代的剩余空间</li></ul><p>这是一个较为复杂的触发情况，Hotspot为了避免由于新生代对象晋升到旧生代导致旧生代空间不足的现象，在进行Minor GC时，做了一个判断，如果之前统计所得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间，那么就直接触发Full GC。</p><p>例如程序第一次触发Minor GC后，有6MB的对象晋升到旧生代，那么当下一次Minor GC发生时，首先检查旧生代的剩余空间是否大于6MB，如果小于6MB，则执行Full GC。</p><p>当新生代采用PS GC时，方式稍有不同，PS GC是在Minor GC后也会检查，例如上面的例子中第一次Minor GC后，PS GC会检查此时旧生代的剩余空间是否大于6MB，如小于，则触发对旧生代的回收。</p><p>除了以上4种状况外，对于使用RMI来进行RPC或管理的Sun JDK应用而言，默认情况下会一小时执行一次Full GC。可通过在启动时通过<code>java -Dsun.rmi.dgc.client.gcInterval=3600000</code>来设置Full GC执行的间隔时间或通过<code>-XX:+ DisableExplicitGC</code>来禁止RMI调用<code>System.gc</code>。</p><ul><li>堆中分配很大的对象</li></ul><p>所谓大对象，是指需要大量连续内存空间的java对象，例如很长的数组，此种对象会直接进入老年代，而老年代虽然有很大的剩余空间，但是无法找到足够大的连续空间来分配给当前对象，此种情况就会触发JVM进行Full GC。</p><p>为了解决这个问题，CMS垃圾收集器提供了一个可配置的参数，即<code>-XX:+UseCMSCompactAtFullCollection</code>开关参数，用于在“享受”完Full GC服务之后额外免费赠送一个碎片整理的过程，内存整理的过程无法并发的，空间碎片问题没有了，但提顿时间不得不变长了，JVM设计者们还提供了另外一个参数 <code>-XX:CMSFullGCsBeforeCompaction</code>，这个参数用于设置在执行多少次不压缩的Full GC后，跟着来一次带压缩的。</p><blockquote><p>数组多大会放在JVM老年代，永久代对象如何GC？如果想不被GC怎么办？如果想在GC中生存一次怎么办？</p></blockquote><p>虚拟机提供了一个<code>-XX:PretenureSizeThreshold</code>参数（通常是3MB），令大于这个设置值的对象直接在老年代分配。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制。（新生代采用复制算法收集内存）</p><p>垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完成垃圾回收（Full GC）。如果仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。</p><p>让对象实现finalize()方法，一次对象的自我拯救。</p><blockquote><p>JVM 常见的参数有哪些，介绍几个常见的，并说说在你工作中实际用到的地方？</p></blockquote><p>首先，JVM 中的参数是非常多的，而且可以分为不同的类型，主要可以分为以下三种类型：</p><ul><li><code>标准参数（-）</code>，所有的JVM实现都必须实现这些参数的功能，而且向后兼容。</li><li><code>非标准参数（-X）</code>，默认JVM实现这些参数的功能，但是并不保证所有JVM实现都满足，且不保证向后兼容。</li><li><code>非Stable参数（-XX）</code>，此类参数各个JVM实现会有所不同，将来可能会随时取消，需要慎重使用。</li></ul><p>虽然是这么分类的，实际上呢，非标准参数和非稳定的参数实际的使用中还是用的非常的多的。</p><h4 id="标准参数"><a href="#标准参数" class="headerlink" title="标准参数"></a>标准参数</h4><p>这一类参数可以说是我们刚刚开始Java是就用的非常多的参数了，比如<code>java -version</code>、<code>java -jar</code>等等，我们在CMD中输入<code>java -help</code>就可以获得Java当前版本的所有标准参数了。</p><p><img src="http://image.ouyangsihai.cn/FsGtetpK2vpkQRFke44AyrDqbsl2"></p><p>如上图就是JDK1.8的所有标准参数了，下面我们将介绍一些我们会用的比较多的参数。</p><ul><li>-client</li></ul><p>以client模式启动JVM，这种方式启动速度快，但运行时性能和内存管理效率不高，适合客户端程序或者开发调试。</p><ul><li>-server</li></ul><p>以server模式启动JVM，与client情况恰好相反。适合生产环境，适用于服务器。64位的JVM自动以server模式启动。</p><ul><li>-classpath或者-cp</li></ul><p>通知JVM类搜索路径。如果指定了<code>-classpath</code>，则JVM就忽略<code>CLASSPATH</code>中指定的路径。各路径之间以分号隔开。如果<code>-classpath</code>和<code>CLASSPATH</code>都没有指定，则JVM从当前路径寻找class。</p><p>JVM搜索路径的顺序：</p><p><strong>1.先搜索JVM自带的jar或zip包。</strong></p><p>Bootstrap，搜索路径可以用<code>System.getProperty("sun.boot.class.path")</code>获得；</p><p><strong>2.搜索<code>JRE_HOME/lib/ext</code>下的jar包。</strong></p><p>Extension，搜索路径可以用<code>System.getProperty("java.ext.dirs")</code>获得；</p><p><strong>3.搜索用户自定义目录，顺序为：当前目录（.），CLASSPATH，-cp。</strong></p><p>搜索路径用<code>System.getProperty("java.class.path")</code>获得。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"sun.boot.class.path"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"java.ext.dirs"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"java.class.path"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="http://image.ouyangsihai.cn/FnHtFC8cd9UucBd39nAiLcCrT5mY"></p><p>如上就是我电脑的JVM的路径。</p><ul><li>-DpropertyName=value</li></ul><p>定义系统的全局属性值，如配置文件地址等，如果value有空格，则需要使用双引号。</p><p>另外用<code>System.getProperty("hello")</code>可以获得这些定义的属性值，在代码中也可以用<code>System.setProperty("hello","world")</code>的形式来定义属性。</p><p>如键值对设置为hello=world。<br><img src="http://image.ouyangsihai.cn/Fp74h47lvnSt4LAq4S7bKH_Qcilr"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行结果就是：<br><img src="http://image.ouyangsihai.cn/Fu6bGzdxxsaJ_bOzjDbd1RUxFKIM"></p><ul><li>-verbose</li></ul><p>查询GC问题最常用的命令之一，参数如下：<br><strong>-verbose:class</strong><br>输出JVM载入类的相关信息，当JVM报告说找不到类或者类冲突时可此进行诊断。<br><strong>-verbose:gc</strong><br>输出每次GC的相关情况。<br><strong>-verbose:jni</strong><br>输出native方法调用的相关情况，一般用于诊断jni调用错误信息。</p><p>另外，控制台<strong>输出GC信息</strong>还可以使用如下命令：</p><p>在JVM的启动参数中加入<code>-XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCApplicationStoppedTime</code>，按照参数的顺序分别输出GC的简要信息，GC的详细信息、GC的时间信息及GC造成的应用暂停的时间。</p><h4 id="非标准参数"><a href="#非标准参数" class="headerlink" title="非标准参数"></a>非标准参数</h4><p>非标准的参数主要是关于Java内存区域的设置参数，所以在看这些参数之前，应该先查看Java内存区域的基础知识，可以查看这篇文章：<a href="https://blog.ouyangsihai.cn/shen-ru-li-jie-java-xu-ni-ji-java-nei-cun-qu-yu-tou-che-fen-xi.html">深入理解Java虚拟机-Java内存区域透彻分析</a>。</p><p>非标准参数实在标准参数的基础上的一些扩充参数，可以输入<code>java -X</code>，获得当前JVM支持的非标准参数。</p><p><img src="http://image.ouyangsihai.cn/FkMW25ImmKNr7dZDD0pyysui2wYl"></p><p>从图片中可以看出来，这些非标准的参数其实不多的，下面我们再 讲解一些比较常用的参数。</p><ul><li>-Xmn</li></ul><p>新生代内存大小的最大值，包括E区和两个S区的总和。设置方法：<code>-Xmn512m、-Xmn2g</code>。</p><ul><li>-Xms</li></ul><p>初始堆的大小，也是堆大小的最小值，默认值是总共的物理内存/64（且小于1G）。默认情况下，当堆中可用内存小于40%，堆内存会开始增加，一直增加到-Xmx的大小。</p><ul><li>-Xmx</li></ul><p>堆的最大值，默认值是总共的物理内存/64（且小于1G），默认情况下，当堆中可用内存大于70%，堆内存会开始减少，一直减小到-Xms的大小。</p><p>因此，为了避免这种浮动，所以在设置<code>-Xms</code>和<code>-Xmx</code>参数时，一般会设置成一样的，能够提高性能。</p><p>另外，官方默认的配置为<strong>年老代大小:年轻代大小=2:1</strong>左右，使用<code>-XX:NewRatio</code>可以设置年老代和年轻代之比，例如，<code>-XX:NewRatio=4</code>，表示<strong>年老代:年轻代=4:1</strong></p><ul><li>-Xss</li></ul><p>设置每个线程的栈内存，默认1M，一般来说是不需要改的。</p><ul><li>-Xprof</li></ul><p>跟踪正运行的程序，并将跟踪数据在标准输出输出；适合于开发环境调试。</p><ul><li>-Xnoclassgc</li></ul><p>禁用类垃圾收集，关闭针对class的gc功能；因为其阻止内存回收，所以可能会导致OutOfMemoryError错误，慎用。</p><ul><li>-Xincgc</li></ul><p>开启增量gc（默认为关闭）；这有助于减少长时间GC时应用程序出现的停顿；但由于可能和应用程序并发执行，所以会降低CPU对应用的处理能力。</p><ul><li>-Xloggc:file</li></ul><p>与<code>-verbose:gc</code>功能类似，只是将每次GC事件的相关情况记录到一个文件中，文件的位置最好在本地，以避免网络的潜在问题。<br> 若与verbose命令同时出现在命令行中，则以-Xloggc为准。</p><h4 id="4-非Stable参数"><a href="#4-非Stable参数" class="headerlink" title="4 非Stable参数"></a>4 非Stable参数</h4><p>这类参数你一看官网以为不能使用呢，官网给你的建议就是这些参数不稳定，慎用，其实这主要的原因还是因为每个公司的实现都是不一样的，所以就是导致不稳定。但是呢，在实际的使用中却是非常的多的，而且这部分的参数很重要。</p><p>这些参数大致可以分为三类：</p><ul><li>性能参数（Performance Options）：用于JVM的性能调优和内存分配控制，如初始化内存大小的设置；</li><li>行为参数（Behavioral Options）：用于改变JVM的基础行为，如GC的方式和算法的选择；</li><li>调试参数（Debugging Options）：用于监控、打印、输出等jvm参数，用于显示jvm更加详细的信息；</li></ul><p><strong>注意：以下参数都是JDK1.7及以下可以使用。</strong></p><ul><li>性能参数</li></ul><table><thead><tr><th>参数及其默认值</th><th>描述</th></tr></thead><tbody><tr><td>-XX:LargePageSizeInBytes=4m</td><td>设置用于Java堆的大页面尺寸</td></tr><tr><td>-XX:MaxHeapFreeRatio=70</td><td>GC后java堆中空闲量占的最大比例</td></tr><tr><td>-XX:MinHeapFreeRatio=40</td><td>GC后java堆中空闲量占的最小比例</td></tr><tr><td><strong>-XX:MaxNewSize=size</strong></td><td>新生成对象能占用内存的最大值</td></tr><tr><td><strong>-XX:MaxPermSize=64m</strong></td><td>老生代对象能占用内存的最大值</td></tr><tr><td><strong>-XX:NewRatio=2</strong></td><td>新生代内存容量与老生代内存容量的比例</td></tr><tr><td><strong>-XX:NewSize=2.125m</strong></td><td>新生代对象生成时占用内存的默认值</td></tr><tr><td>-XX:ReservedCodeCacheSize=32m</td><td>保留代码占用的内存容量</td></tr><tr><td>-XX:ThreadStackSize=512</td><td>设置线程栈大小，若为0则使用系统默认值</td></tr><tr><td>-XX:+UseLargePages</td><td>使用大页面内存</td></tr></tbody></table><ul><li>行为参数</li></ul><table><thead><tr><th>参数及其默认值</th><th>描述</th></tr></thead><tbody><tr><td>-XX:+ScavengeBeforeFullGC</td><td>新生代GC优先于Full GC执行</td></tr><tr><td>-XX:+UseGCOverheadLimit</td><td>在抛出OOM之前限制jvm耗费在GC上的时间比例</td></tr><tr><td><strong>-XX:-UseParNewGC</strong></td><td>打开此开关，使用<code>ParNew+Serial Old</code>收集器</td></tr><tr><td><strong>-XX:-UseConcMarkSweepGC</strong></td><td>使用<code>ParNew+CMS+Serial Old</code>收集器对老生代采用并发标记交换算法进行GC</td></tr><tr><td><strong>-XX:-UseParallelGC</strong></td><td>启用并行GC，使用<code>ParallelScavenge+Serial Old</code>收集器</td></tr><tr><td><strong>-XX:-UseParallelOldGC</strong></td><td>对Full GC启用并行，当<code>-XX:-UseParallelGC</code>启用时该项自动启用，<code>ParallelScavenge+Parallel Old</code>收集器</td></tr><tr><td><strong>-XX:-UseSerialGC</strong></td><td>启用串行GC</td></tr><tr><td><strong>-XX:+UseG1GC</strong></td><td>使用垃圾优先（G1）收集器</td></tr><tr><td>-XX:SurvivorRatio=n</td><td>Eden区域与Survivor区域大小之比。预设值为8</td></tr><tr><td>-XX:PretenureSizeThreshold=n</td><td>直接晋升到老年代的<strong>对象大小</strong>，设置这个参数之后，大于这个参数的对象直接进入到老年代分配</td></tr><tr><td>-XX:MaxTenuringThreshold=n</td><td>晋升到老年代的<strong>对象年龄</strong>，每个对象在坚持过一次Minor GC之后，年龄加1，当超过这个值之后就进入老年代。预设值为15</td></tr><tr><td>-XX:+UseAdaptiveSizePolicy</td><td>动态调整Java堆中各个区域的大小以及进入老年代的年龄</td></tr><tr><td>-XX:ParallelGCThreads=n</td><td>设置并行收集器收集时使用的CPU数。并行收集线程数</td></tr><tr><td>-XX:MaxGCPauseMillis=n</td><td>设置并行收集最大暂停时间</td></tr><tr><td>-XX:GCTimeRatio=n</td><td>设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+N)</td></tr><tr><td>-XX:+UseThreadPriorities</td><td>启用本地线程优先级</td></tr><tr><td>-XX:-DisableExplicitGC</td><td>禁止调用<code>System.gc()</code>；但jvm的gc仍然有效</td></tr><tr><td>-XX:+MaxFDLimit</td><td>最大化文件描述符的数量限制</td></tr></tbody></table><p>前面6个参数都是关于<strong>垃圾收集器</strong>的行为参数，也是经常会用到的参数。</p><ul><li>调试参数</li></ul><table><thead><tr><th>参数及其默认值</th><th>描述</th></tr></thead><tbody><tr><td>-XX:-CITime</td><td>打印消耗在JIT编译的时间</td></tr><tr><td>-XX:ErrorFile=./hs_err_pid&lt;pid&gt;.log</td><td>保存错误日志或者数据到文件中</td></tr><tr><td>-XX:HeapDumpPath=./java_pid&lt;pid&gt;.hprof</td><td>指定导出堆信息时的路径或文件名</td></tr><tr><td><strong>-XX:-HeapDumpOnOutOfMemoryError</strong></td><td>当首次遭遇OOM时导出此时堆中相关信息</td></tr><tr><td>-XX:OnError=”&lt;cmd args&gt;;&lt;cmd args&gt;“</td><td>出现致命ERROR之后运行自定义命令</td></tr><tr><td>-XX:OnOutOfMemoryError=”&lt;cmd args&gt;;&lt;cmd args&gt;“</td><td>当首次遭遇OOM时执行自定义命令</td></tr><tr><td>-XX:-PrintClassHistogram</td><td>遇到Ctrl-Break后打印类实例的柱状信息，与<code>jmap -histo</code>功能相同</td></tr><tr><td>-XX:-PrintConcurrentLocks</td><td>遇到Ctrl-Break后打印并发锁的相关信息，与<code>jstack -l</code>功能相同</td></tr><tr><td>-XX:-PrintCommandLineFlags</td><td>打印在命令行中出现过的标记</td></tr><tr><td>-XX:-PrintCompilation</td><td>当一个方法被编译时打印相关信息</td></tr><tr><td><strong>-XX:-PrintGC</strong></td><td>每次GC时打印相关信息</td></tr><tr><td><strong>-XX:-PrintGCDetails</strong></td><td>每次GC时打印详细信息</td></tr><tr><td>-XX:-PrintGCTimeStamps</td><td>打印每次GC的时间戳</td></tr><tr><td>-XX:-TraceClassLoading</td><td>跟踪类的加载信息</td></tr><tr><td>-XX:-TraceClassLoadingPreorder</td><td>跟踪被引用到的所有类的加载信息</td></tr><tr><td>-XX:-TraceClassResolution</td><td>跟踪常量池</td></tr><tr><td>-XX:-TraceClassUnloading</td><td>跟踪类的卸载信息</td></tr><tr><td>-XX:-TraceLoaderConstraints</td><td>跟踪类加载器约束的相关信息</td></tr></tbody></table><p>以上标黑的就是常用的一些参数。</p><p>最后，给大家一个实例，看看在工作中是怎么去运用这些参数的，怎么在工作中去解决这些问题的。</p><h4 id="参数实例"><a href="#参数实例" class="headerlink" title="参数实例"></a><strong>参数实例</strong></h4><p>设置<code>-Xms</code>、<code>-Xmn</code>和<code>-Xmx</code>参数分别为<code>-Xms512m -Xmx512m -Xmn128m</code>。同时设置新生代和老生代之比为1:4，E:S0:S1=8:1:1。除此之外，当然，你还可以设置一些其他的参数，比如，前面说到的，性能参数 <code>-XX:MaxNewSize</code>、 <code>-XX:NewRatio=</code>、，行为参数 <code>-XX:-UseParNewGC</code>，调试参数 <code>-XX:-PrintGCDetails</code>。</p><p>这些参数都是可以在 IDEA 中启动时直接设置的。</p><pre class="line-numbers language-none"><code class="language-none">** * @ClassName MethodTest * @Description vm参数设置：-Xms512m -Xmx512m -Xmn128m -XX:NewRatio=4 -XX:SurvivorRatio=8  * @Author 欧阳思海 * @Date 2019/11/25 20:06 * @Version 1.0 **/public class MethodTest {    public static void main(String[] args) {        List&lt;String&gt; list = new ArrayList&lt;String&gt;();        long i = 0;        while (i &lt; 1000000000) {            System.out.println(i);            list.add(String.valueOf(i++).intern());        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行之后，用VisualVM查看相关信息是否正确。</p><p>当我们<strong>没有设置</strong><code>-XX:NewRatio=4 -XX:SurvivorRatio=8</code>时，使用官方默认的情况如下： </p><p><img src="http://image.ouyangsihai.cn/FgIr8Niw2F9Cs1IK6ABn74oEi66T"></p><p>上图可以看出，<strong>新生代（Eden Space + Survivor 0 + Survivor 1）:老年代（Old Gen）≈ 1:2</strong>。</p><p>当我们<strong>设置了</strong><code>-XX:NewRatio=4 -XX:SurvivorRatio=8</code>时，情况如下：</p><p><img src="http://image.ouyangsihai.cn/Fkc4DTkISF1LA9fpO54VEinaYvlc"></p><p>变成了<strong>新生代（Eden Space + Survivor 0 + Survivor 1）:老年代（Old Gen）≈ 1:4</strong>，Eden Space:Survivor 0: Survivor 1 = 8:1:1。</p><p><img src="http://image.ouyangsihai.cn/FphOpfRSOQYu-pcR6xf6rDPcQAF9"></p><p>从上图可知，堆的信息是正确的。</p><p>更多的使用方法可以参考这篇文章 <a href="http://www.java1000.com/shen-ru-li-jie-java-xu-ni-ji-ru-he-li-yong-visualvm-dui-gao-bing-fa-xiang-mu-jin-xing-xing-neng-fen-xi.html">如何利用VisualVM对高并发项目进行性能分析</a>，有更加细致的介绍。</p><blockquote><p>说说你了解的常见的内存调试工具：jps、jmap、jhat等。</p></blockquote><table><thead><tr><th>名称</th><th>解释</th></tr></thead><tbody><tr><td>jps</td><td>显示指定系统内所有的HotSpot虚拟机的进程</td></tr><tr><td>jstat</td><td>用于收集HotSpot虚拟机各方面的运行数据</td></tr><tr><td>jinfo</td><td>显示虚拟机配置信息</td></tr><tr><td>jmap</td><td>生成虚拟机的内存转存储快照（heapdump文件），利用这个文件就可以分析内存等情况</td></tr><tr><td>jhat</td><td>用于分析上面jmap生成的heapdump文件，它会建立一个HTTP/HTML服务器，让用户可以在浏览器上查看分析结果</td></tr><tr><td>jstack</td><td>显示虚拟机的线程快照</td></tr></tbody></table><h4 id="1-jps：虚拟机进程状况工具"><a href="#1-jps：虚拟机进程状况工具" class="headerlink" title="1 jps：虚拟机进程状况工具"></a>1 jps：虚拟机进程状况工具</h4><p>这个工具使用的频率还是非常高的，因为你需要查看你的程序的运行情况的时候，首先需要知道的就是程序所运行的<strong>进程本地虚拟机唯一ID（LVMID）</strong>，知道这个ID之后，才可以进行其他监控的操作。</p><ul><li>命令格式：</li></ul><pre class="line-numbers language-none"><code class="language-none">jps [选项] [主机id]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>jps主要选项：</li></ul><table><thead><tr><th>选项</th><th>解释</th></tr></thead><tbody><tr><td>-q</td><td>只输出LVMID，省略主类名称</td></tr><tr><td>-m</td><td>输出虚拟机进程启动时传递给主类main()函数的参数</td></tr><tr><td>-l</td><td>输出主类的全名</td></tr><tr><td>-v</td><td>输出虚拟机进程启动时的 JVM 参数</td></tr></tbody></table><ul><li>实例</li></ul><pre class="line-numbers language-none"><code class="language-none">jps -ljps -v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="http://image.ouyangsihai.cn/Fq2nwxo46q4EpQ08Ba_qKIU2JN-J"></p><p><img src="http://image.ouyangsihai.cn/FmEvrlfb6kTEk8u_Hc-NcGHg8wW9"></p><h4 id="2-jinfo：Java配置信息工具"><a href="#2-jinfo：Java配置信息工具" class="headerlink" title="2 jinfo：Java配置信息工具"></a>2 jinfo：Java配置信息工具</h4><p>jinfo的功能很简单，主要就是显示和查看调整虚拟机的各种参数。</p><ul><li>jinfo命令格式：</li></ul><pre class="line-numbers language-none"><code class="language-none">jinfo [选项] pid<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>相关选项</li></ul><p><img src="http://image.ouyangsihai.cn/FpSz04ZVzS6K6FJ3zVtnoYqMdLt7"></p><ul><li>实例</li></ul><p>我们在启动程序的时候设置一些JVM参数：<code>-Xms512m -Xmx512m -Xmn128m -XX:NewRatio=4 -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=15</code>。</p><p>我们先使用<code>jps -l</code>查看虚拟机进程ID；<br><img src="http://image.ouyangsihai.cn/FtsaKW9WE0lT-Vn_OH4CjpqWXqwz"></p><p>再使用pid为1584进行查询参数；</p><p><img src="http://image.ouyangsihai.cn/FgOjSz1U0kS2yt2V-k_huM-f0zJ_"></p><h4 id="3-jmap：Java内存映射工具"><a href="#3-jmap：Java内存映射工具" class="headerlink" title="3 jmap：Java内存映射工具"></a>3 jmap：Java内存映射工具</h4><p>jmap的主要功能就是生成<strong>堆转存储快照</strong>，之后，我们再利用这个快照文件进行分析。</p><ul><li>jmap命令格式：</li></ul><pre class="line-numbers language-none"><code class="language-none">jmap [选项] vmid<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>相关选项</li></ul><table><thead><tr><th>选项</th><th>解释</th></tr></thead><tbody><tr><td>-dump</td><td>生成Java堆转存储快照，格式：<code>-dump:[live,]format=b,file=&lt;filename&gt;</code>,其中<code>live</code>子参数说明是否只dump出存活的对象</td></tr><tr><td>-finalizerinfo</td><td>显示在F-Queue中等待Finalizer线程执行finalize方法的对象，<strong>只在linux/Solaris有效</strong></td></tr><tr><td>-heap</td><td>显示Java堆详细信息，如使用哪种回收期、参数配置、分代状况等等。<strong>只在Linux/Solaris有效</strong></td></tr><tr><td>-histo</td><td>显示堆中对象统计信息，包括类、实例数量、合计容量</td></tr><tr><td>-permstat</td><td>以ClassLoader为统计口径显示永久代内存状态，<strong>只在Linux/Solaris有效</strong></td></tr><tr><td>-F</td><td>当虚拟机进程对-dump选项没有响应时，可使用这个选项强制生成dump快照，<strong>只在Linux/Solaris有效</strong></td></tr></tbody></table><ul><li>实例</li></ul><p>首先还是查看虚拟机ID；</p><p><img src="http://image.ouyangsihai.cn/FtuNhdGkitnyOGWFegoT2ETIOidf"></p><p>然后再运行下面命令行；<br><img src="http://image.ouyangsihai.cn/Fvi9c3BD9bSt4Qi1ptDkHaVH6jA1"></p><p>打开这个dump文件如下；<br><img src="http://image.ouyangsihai.cn/Fvd2a3KTLCykCyBX7fAosH65tvCw"></p><p>ok，现在已经有了生成的dump文件，所以，我们就需要对这个文件进行解析，看看<strong>jhat命令</strong>。</p><h4 id="4-jhat：虚拟机堆转存储快照分析工具"><a href="#4-jhat：虚拟机堆转存储快照分析工具" class="headerlink" title="4 jhat：虚拟机堆转存储快照分析工具"></a>4 jhat：虚拟机堆转存储快照分析工具</h4><p>虽然好像这个命令挺牛逼，但是，其实，由于这个工具的功能不太够，分析也得不到太多的结果，所以我们一般可以会将得到的dump文件用其他的工具进行分析，比如，可视化工具VisualVM等等。</p><p>所以，这里简单的做一个例子。</p><ul><li>实例</li></ul><pre class="line-numbers language-none"><code class="language-none">jhat D:\dump.bin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="http://image.ouyangsihai.cn/FsLOf6D2M9Ta8YiA9DCJ-zj6I-_X"></p><p>如果有兴趣查看如何利用VisualVM进行查看，可以查看这篇文章：<a href="https://blog.ouyangsihai.cn/shen-ru-li-jie-java-xu-ni-ji-ru-he-li-yong-visualvm-dui-gao-bing-fa-xiang-mu-jin-xing-xing-neng-fen-xi.html">深入理解Java虚拟机-如何利用VisualVM对高并发项目进行性能分析</a>。</p><h4 id="5-jstack：Java堆栈跟踪工具"><a href="#5-jstack：Java堆栈跟踪工具" class="headerlink" title="5 jstack：Java堆栈跟踪工具"></a>5 jstack：Java堆栈跟踪工具</h4><p><code>jstack</code> 命令主要用于生成虚拟机当前时刻的<strong>线程快照</strong>。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的<strong>主要目的</strong>：定位线程出现长时间停顿的原因、请求外部资源导致的长时间等待等这些原因。</p><ul><li>jstack命令格式：</li></ul><pre class="line-numbers language-none"><code class="language-none">jstack [选项] vmid<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>相关选项</li></ul><table><thead><tr><th>选项</th><th>解释</th></tr></thead><tbody><tr><td>-F</td><td>当正常输出的请求不被响应时，强制输出线程堆栈</td></tr><tr><td>-l</td><td>除堆栈外，显示关于锁的附加信息</td></tr><tr><td>-m</td><td>如果调用到本地方法的话，可以显示C/C++的堆栈</td></tr></tbody></table><ul><li>实例</li></ul><pre class="line-numbers language-none"><code class="language-none">jstack -l 6708<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="http://image.ouyangsihai.cn/FrcFS7iWpybtIg48OoDjrdmsSDJa"></p><h4 id="6-jstat：虚拟机统计信息监视工具"><a href="#6-jstat：虚拟机统计信息监视工具" class="headerlink" title="6 jstat：虚拟机统计信息监视工具"></a>6 jstat：虚拟机统计信息监视工具</h4><p>jstat这个工具还是很有作用的，他可以显示本地或者远程<strong>虚拟机进程中的类装载、内存、垃圾收集、JIT编译</strong>等运行数据，在服务器上，他是运行期定位虚拟机性能问题的首选工具。</p><ul><li>jstat命令格式：</li></ul><pre class="line-numbers language-none"><code class="language-none">jstat [选项 vmid [interval[s|ms] [count]]]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>相关选项</li></ul><table><thead><tr><th>选项</th><th>解释</th></tr></thead><tbody><tr><td><strong>-class</strong></td><td>监视类装载、卸载数量、总空间以及类装载所耗费的时间</td></tr><tr><td><strong>-gc</strong></td><td>监视Java堆状况，包括Eden区、两个Survivor区、老年代、永久代等容量、已用空间、GC时间合计等信息</td></tr><tr><td>-gccapacity</td><td>监视内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大、最小空间</td></tr><tr><td><strong>-gcutil</strong></td><td>监视内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比</td></tr><tr><td>-gccause</td><td>与-gcutil功能一样，但是会输出额外导致上一次GC产生的原因</td></tr><tr><td>-gcnew</td><td>监视新生代GC状况</td></tr><tr><td>-gcnewcapacity</td><td>监控内容与-gcnew一样，输出主要关注使用到的最大最小空间</td></tr><tr><td>-gcold</td><td>监控老年代GC状况</td></tr><tr><td>-gcoldcapacity</td><td>监控内容与-gcold一样，输出主要关注使用到的最大最小空间</td></tr><tr><td>-gcpermcapacity</td><td>输出永久代使用到的最大最小空间</td></tr><tr><td>-compiler</td><td>输出JIT编译器编译过的方法、耗时等信息</td></tr><tr><td>-printcompilation</td><td>输出已经被JIT编译过的方法</td></tr></tbody></table><ul><li>实例</li></ul><p>我们这里还关注一下虚拟机GC的状况。</p><pre class="line-numbers language-none"><code class="language-none">jstat -gcutil 9676<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="http://image.ouyangsihai.cn/FkelCR8JIup_jpEFY9UQvqD2l0EC"></p><p>上面参数的含义：</p><blockquote><p>S0：第一个Survivor区的空间使用（%）大小<br>S1：第二个Survivor区的空间使用（%）大小<br>E：Eden区的空间使用（%）大小<br>O：老年代空间使用（%）大小<br>M：方法区空间使用（%）大小<br>CCS:压缩类空间使用（%）大小<br>YGC：年轻代垃圾回收次数<br>YGCT：年轻代垃圾回收消耗时间<br>FGC：老年代垃圾回收次数<br>FGCT：老年代垃圾回收消耗时间<br>GCT：垃圾回收消耗总时间</p></blockquote><p>了解了这些参数的意义之后，我们就可以对虚拟机GC状况进行分析。我们发现年轻代回收次数<code>12</code>次，使用时间<code>1.672</code>s，老年代回收<code>0</code>次，使用时间<code>0</code>s，所有GC总耗时<code>1.672</code>s。</p><p>通过以上参数分析，发现老年代Full GC没有，说明没有大对象进入到老年代，整个老年代的GC情况还是不错的。另外，年轻代回收次数<code>12</code>次，使用时间<code>1.672</code>s，每次用时100ms左右，这个时间稍微长了一点，可以将新生代的空间调低一点，以降低每一次的GC时间。</p><blockquote><p>常见的垃圾回收器有哪些？</p></blockquote><p>先上一张图，这张图是Java虚拟机的jdk1.7及以前版本的所有垃圾回收器，也可以说是比较成熟的垃圾回收器，除了这些垃圾回收器，面试的时候最多也就再怼怼G1和ZGC了。</p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltYWdlLm91eWFuZ3NpaGFpLmNuL0ZoNE1EWTdQLVRPMXRRZ3RVUVFKeXlramliQ1o?x-oss-process=image/format,png" alt><p>上面的表示是年轻代的垃圾回收器：Serial、ParNew、Parallel Scavenge，下面表示是老年代的垃圾回收器：CMS、Parallel Old、Serial Old，以及不分老年代和年轻代的G1。之间的相互的连线表示可以相互配合使用。</p><p>说完是不是一篇明朗，其实也就是那么回事。</p><h4 id="新生代垃圾回收器"><a href="#新生代垃圾回收器" class="headerlink" title="新生代垃圾回收器"></a>新生代垃圾回收器</h4><h5 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h5><p>Serial（串行）收集器是<strong>最基本、发展历史最悠久</strong>的收集器，它是采用<strong>复制算法</strong>的新生代收集器，曾经（JDK 1.3.1之前）是虚拟机新生代收集的唯一选择。它是一个<strong>单线程收集器</strong>，只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集时，必须暂停其他所有的工作线程，直至Serial收集器收集结束为止（“Stop The World”）。</p><p>其实对于这个垃圾回收器，你只要记住是一个<strong>单线程、采用复制算法的，会进行“Stop The World”</strong> 即可，因为面试官一般不问这个，为什么，因为太简单了，没什么可问的呗。</p><p>好了，再放一张图好吧，说明一下Serial的回收过程，完事。</p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltYWdlLm91eWFuZ3NpaGFpLmNuL0Z0SXctUHozUEROSmxScDJ2ODlYZkl6eEpja0c?x-oss-process=image/format,png" alt><p>说明：这张图的意思就是<strong>单线程，新生代使用复制算法标记、老年代使用标记整理算法标记</strong>，就是这么简单。</p><h5 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h5><p><strong>ParNew收集器就是Serial收集器的</strong>多线程<strong>版本</strong>，它也是一个新生代收集器。除了使用多线程进行垃圾收集外，其余行为包括Serial收集器可用的所有控制参数、收集算法（复制算法）、Stop The World、对象分配规则、回收策略等与Serial收集器完全相同。</p><p>需要注意一点是：<strong>除了Serial收集器外，目前只有它能和CMS收集器（Concurrent Mark Sweep）配合工作。</strong></p><p>最后再放一张回收过程图；</p><p><img src="http://image.ouyangsihai.cn/FvsKnXGzEQd6WYdUmIgLcWoSHG4H"></p><p>*** 是不是很简单，我在这里讲这些知识点并不是为了深入去了解这些原理，基本的知道对于工作已经够了，其实，主要还是应付面试官，哈哈。</p><h5 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a>Parallel Scavenge</h5><p>Parallel Scavenge收集器也是一个<strong>并行</strong>的<strong>多线程</strong>新生代收集器，它也使用<strong>复制算法</strong>。</p><p>Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。</p><p>这里需要注意的唯一的区别是：Parallel Scavenge收集器的目标是<strong>达到一个可控制的吞吐量（Throughput）</strong>。</p><p>我们知道，停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而<strong>高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务</strong>。</p><h4 id="老年代垃圾回收器"><a href="#老年代垃圾回收器" class="headerlink" title="老年代垃圾回收器"></a>老年代垃圾回收器</h4><h5 id="Serial-Old"><a href="#Serial-Old" class="headerlink" title="Serial Old"></a>Serial Old</h5><p>Serial Old 是Serial收集器的老年代版本，它同样是一个<strong>单线程</strong>收集器，使用“<strong>标记-整理</strong>”（Mark-Compact）算法。</p><p>在这里就可以出一个面试题了。</p><ul><li>为什么Serial使用的是<strong>复制算法</strong>，而Serial Old使用是<strong>标记-整理</strong>算法？<br>同一个爸爸，儿子长的天差地别，当然也有啊，哈哈。</li></ul><blockquote><p>  其实，看了我前面的文章你可能就知道了，因为在新生代绝大多数的内存都是会被回收的，所以留下来的需要回收的垃圾就很少了，所以复制算法更合适，你可以发现，基本的老年代的都是使用标记整理算法，当然，CMS是个杂种哈。 </p></blockquote><p>它的工作流程与Serial收集器相同，下图是Serial/Serial Old配合使用的工作流程图：</p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltYWdlLm91eWFuZ3NpaGFpLmNuL0Z0SXctUHozUEROSmxScDJ2ODlYZkl6eEpja0c?x-oss-process=image/format,png" alt><h5 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h5><p>Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用<strong>多线程</strong>和“<strong>标记-整理</strong>”算法，是不是前面说的，老年代出了杂种CMS不是“<strong>标记-整理</strong>”算法，其他都是。</p><p>另外，有了Parallel Old垃圾回收器后，就出现了以“<strong>吞吐量优先</strong>”著称的“男女朋友”收集器了，这就是：<strong>Parallel Old和Parallel Scavenge收集器的组合</strong>。</p><p>Parallel Old收集器的工作流程与Parallel Scavenge相同，这里给出Parallel Scavenge/Parallel Old收集器配合使用的流程图：</p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltYWdlLm91eWFuZ3NpaGFpLmNuL0Z2OTZmbmtTbmJWODVCUzJFNm1yX1pGQmQ5V2U?x-oss-process=image/format,png" alt><p>你是不是以为我还要讲CMS和G1，我任性，我就是要接着讲，哈哈哈。</p><h4 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h4><h5 id="小伙子，你说一下-CMS-垃圾回收器吧！"><a href="#小伙子，你说一下-CMS-垃圾回收器吧！" class="headerlink" title="小伙子，你说一下 CMS 垃圾回收器吧！"></a>小伙子，你说一下 CMS 垃圾回收器吧！</h5><p>这个题目一来，吓出一身冷汗，差点就没有复习这个CMS，还好昨晚抱佛脚看了一下哈。</p><p>于是我。。。一顿操作猛如虎。</p><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，它是基于“标记-清除”算法实现的，并且常见的应用场景是<strong>互联网站或者B/S系统的服务端上的Java应用</strong>。</p><p>结果就一紧张就记得这么多，面试官肯定不满意了，这个时候，面试官的常规操作是，<strong>继续严刑拷打，他想，你可能忘记了，我来提醒提醒你！</strong></p><h5 id="CMS收集器工作的整个流程是怎么样的，你能给我讲讲吗？"><a href="#CMS收集器工作的整个流程是怎么样的，你能给我讲讲吗？" class="headerlink" title="CMS收集器工作的整个流程是怎么样的，你能给我讲讲吗？"></a>CMS收集器工作的整个流程是怎么样的，你能给我讲讲吗？</h5><p>这个时候，面试官还会安慰你说不用紧张，但是，安慰归安慰，最后挂不挂可是另一回事。</p><p>于是，我又开始回答问题。</p><p>CMS 处理过程有七个步骤：</p><ul><li><strong>初始标记</strong>，会导致stw;</li><li><strong>并发标记</strong>，与用户线程同时运行；</li><li><strong>预清理</strong>，与用户线程同时运行；</li><li><strong>可被终止的预清理</strong>，与用户线程同时运行；</li><li><strong>重新标记</strong> ，会导致swt；</li><li><strong>并发清除</strong>，与用户线程同时运行；</li></ul><p>其实，只要回答四个就差不多了，是这几个。</p><ul><li><strong>初始标记</strong>：仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，需要“Stop The World”。</li><li><strong>并发标记</strong>：进行GC Roots Tracing的过程，在整个过程中耗时最长。</li><li><strong>重新标记</strong>：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。此阶段也需要“Stop The World”。</li><li><strong>并发清除</strong>。</li></ul><p>你以为这样子就可以了，面试官就会说可以了，如果可以了，那估计你凉了！</p><h5 id="面试官说：CMS这么好，那有没有什么缺点呢？"><a href="#面试官说：CMS这么好，那有没有什么缺点呢？" class="headerlink" title="面试官说：CMS这么好，那有没有什么缺点呢？"></a>面试官说：CMS这么好，那有没有什么缺点呢？</h5><p>我。。。好吧，谁怪我这么强呢，对吧。</p><p>其实，CMS虽然经过这么些年的考验，已经是一个值得信赖的GC回收器了，但是，其实也是有一些他的不足的，</p><p>第一，<strong>垃圾碎片的问题</strong>，我们都知道CMS是使用的是<strong>标记-清除</strong>算法的，所以不可避免的就是会出现垃圾碎片的问题。<br>第二，<strong>一般CMS的GC耗时80%都在remark阶段，remark阶段停顿时间会很长</strong>，在CMS的这四个主要的阶段中，最费时间的就是重新标记阶段。<br>第三，<strong>concurrent mode failure</strong>，说出这个的时候，面试官就会觉得，小伙子，哎呦，不错哟，掌握的比较清楚，那这个是什么意思呢，其实是说：</p><blockquote><p>这个异常发生在cms正在回收的时候。执行CMS GC的过程中，同时业务线程也在运行，当年轻带空间满了，执行ygc时，需要将存活的对象放入到老年代，而此时老年代空间不足，这时CMS还没有机会回收老年带产生的，或者在做Minor GC的时候，新生代救助空间放不下，需要放入老年代，而老年代也放不下而产生的。</p></blockquote><p>第四，<strong>promotion failed</strong>，这个问题是指，在进行Minor GC时，Survivor空间不足，对象只能放入老年代，而此时老年代也放不下造成的，多数是由于老年代有足够的空闲空间，但是由于碎片较多，新生代要转移到老年带的对象比较大，找不到一段连续区域存放这个对象导致的。</p><p>面试官看到你掌握的这么好，心里已经给你竖起来大拇指，但是，面试官觉得你优秀啊，就还想看看你到底还有多少东西。</p><h5 id="既然你知道有这么多的缺点，那么你知道怎么解决这些问题吗？"><a href="#既然你知道有这么多的缺点，那么你知道怎么解决这些问题吗？" class="headerlink" title="既然你知道有这么多的缺点，那么你知道怎么解决这些问题吗？"></a>既然你知道有这么多的缺点，那么你知道怎么解决这些问题吗？</h5><p>这个真的被问蒙了，你以为我什么都会吗！！！！</p><p>但是，我还是得给大家讲讲，不然下次被问到，可能会把锅甩给我。</p><ul><li><p><strong>垃圾碎片的问题</strong>：针对这个问题，这时候我们需要用到这个参数：<code>-XX:CMSFullGCsBeforeCompaction=n</code> 意思是说在上一次CMS并发GC执行过后，到底还要再执行多少次<code>full GC</code>才会做压缩。默认是0，也就是在默认配置下每次CMS GC顶不住了而要转入full GC的时候都会做压缩。</p></li><li><p><strong>concurrent mode failure</strong></p></li></ul><p>解决这个问题其实很简单，只需要设置两个参数即可</p><p><code>-XX:+UseCMSInitiatingOccupancyOnly</code><br><code>-XX:CMSInitiatingOccupancyFraction=60</code>：是指设定CMS在对内存占用率达到60%的时候开始GC。</p><p>为什么设置这两个参数呢？由于在垃圾收集阶段用户线程还需要运行，那也就还需要<strong>预留有足够的内存空间给用户线程使用</strong>，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集。</p><p>当然也不能设置过高，比如90%，这时候虽然GC次数少，但是，却会导致用于用户线程空间小，效率不高，太低10%，你自己想想会怎么样，体会体会！</p><p><strong>哈哈，万事大吉，这一点说出了，估计面试官已经爱上我了吧，赶紧把我招进去干活吧。</strong></p><ul><li><strong>remark阶段停顿时间会很长的问题</strong>：解决这个问题巨简单，加入<code>-XX:+CMSScavengeBeforeRemark</code>。在执行remark操作之前先做一次<code>Young GC</code>，目的在于减少年轻代对老年代的无效引用，降低remark时的开销。</li></ul><h4 id="G1-Garbage-First"><a href="#G1-Garbage-First" class="headerlink" title="G1 (Garbage-First)"></a>G1 (Garbage-First)</h4><p>G1 (Garbage-First)是一款面向服务器的垃圾收集器，主要针对配备多颗处理器及大容量内存的机器。以极高概率满足 GC 停顿时间要求的同时，还具备高吞吐量性能特征。</p><ul><li>可以像CMS收集器一样， GC 操作与应用的线程一起并发执行</li><li>紧凑的空闲内存区间且没有很长的 GC 停顿时间</li><li>需要可预测的GC暂停耗时</li><li>不想牺牲太多吞吐量性能.</li><li>启动后不需要请求更大的Java堆</li></ul><p>那么 G1 相对于 CMS 的区别在：</p><ul><li><p>G1 在压缩空间方面有优势</p></li><li><p>G1 通过将内存空间分成区域（Region）的方式避免内存碎片问题</p></li><li><p>Eden， Survivor， Old 区不再固定、在内存使用效率上来说更灵活</p></li><li><p>G1 可以通过设置预期停顿时间（Pause Time）来控制垃圾收集时间避免应用雪崩现象</p></li><li><p>G1 在回收内存后会马上同时做合并空闲内存的工作、而 CMS 默认是在STW（stop the world）的时候做</p></li><li><p>G1 会在 Young GC 中使用，而 CMS 只能在O区使用</p></li></ul><p>就目前而言、CMS 还是默认首选的 GC 策略、可能在以下场景下 G1 更适合：</p><ul><li><p>服务端多核 CPU、JVM 内存占用较大的应用（至少大于4G）</p></li><li><p>应用在运行过程中会产生大量内存碎片、需要经常压缩空间</p></li><li><p>想要更可控、可预期的 GC 停顿周期；防止高并发下应用雪崩现象</p></li></ul><p>G1的内存使用示意图：<br><img src="http://image.ouyangsihai.cn/FgFGLjZMCGmjKscUAj3hBfK1HLKM"></p><p>G1在运行过程中主要包含如下4种操作方式：</p><ul><li><p>YGC（不同于CMS）</p></li><li><p>并发阶段</p></li><li><p>混合模式</p></li><li><p>full GC （一般是G1出现问题时发生）</p></li></ul><h5 id="YGC（年轻代GC）"><a href="#YGC（年轻代GC）" class="headerlink" title="YGC（年轻代GC）"></a>YGC（年轻代GC）</h5><p>下面是一次 YGC 前后内存区域是示意图：<br><img src="http://image.ouyangsihai.cn/FjX3b5ZidxSGhDRF-qiJ4SXm-ji5"></p><p>图中每个小区块都代表 G1 的一个区域（Region），区块里面的字母代表不同的分代内存空间类型（如[E]Eden，[O]Old，[S]Survivor）空白的区块不属于任何一个分区；G1 可以在需要的时候任意指定这个区域属于 Eden 或是 O 区之类的。</p><p>YoungGC 在 Eden 充满时触发，在回收之后所有之前属于 Eden 的区块全变成空白。然后至少有一个区块是属于 S 区的（如图半满的那个区域），同时可能有一些数据移到了 O 区。</p><p>目前大都使用 PrintGCDetails 参数打出GC日志、这个参数对G1同样有效、但日志内容颇为不同。</p><p>下面是一个Young GC的例子：</p><pre class="line-numbers language-none"><code class="language-none">23.430: [GC pause (young)， 0.23094400 secs]...[Eden: 1286M(1286M)-&gt;0B(1212M)Survivors: 78M-&gt;152M Heap: 1454M(4096M)-&gt;242M(4096M)][Times: user=0.85 sys=0.05, real=0.23 secs]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面日志的内容解析：Young GC实际占用230毫秒、其中GC线程占用850毫秒的CPU时间</p><ul><li>E：内存占用从 1286MB 变成 0、都被移出</li><li>S：从 78M 增长到了 152M、说明从 Eden 移过来 74M</li><li>Heap: 占用从 1454 变成 242M、说明这次 Young GC 一共释放了 1212M 内存空间</li></ul><p>很多情况下，S 区的对象会有部分晋升到 Old 区，另外如果 S 区已满、Eden 存活的对象会直接晋升到 Old 区，这种情况下 Old 的空间就会涨。</p><h5 id="并发阶段"><a href="#并发阶段" class="headerlink" title="并发阶段"></a>并发阶段</h5><p>一个并发G1回收周期前后内存占用情况如下图所示：<br><img src="http://image.ouyangsihai.cn/Flo526oI2G_UIbkT-Jibo5ZoX27u"></p><p>从上面的图表可以看出以下几点：</p><ul><li>Young 区发生了变化、这意味着在 G1 并发阶段内至少发生了一次 YGC（这点和 CMS 就有区别），Eden 在标记之前已经被完全清空，因为在并发阶段应用线程同时在工作、所以可以看到 Eden 又有新的占用</li><li>一些区域被X标记，这些区域属于 O 区，此时仍然有数据存放、不同之处在 G1 已标记出这些区域包含的垃圾最多、也就是回收收益最高的区域</li><li>在并发阶段完成之后实际上 O 区的容量变得更大了（O+X 的方块）。这时因为这个过程中发生了 YGC 有新的对象进入所致。此外，这个阶段在 O 区没有回收任何对象：它的作用主要是标记出垃圾最多的区块出来。对象实际上是在后面的阶段真正开始被回收</li></ul><p>G1 并发标记周期可以分成几个阶段、其中有些需要暂停应用线程。第一个阶段是初始标记阶段。这个阶段会暂停所有应用线程-部分原因是这个过程会执行一次 YGC、下面是一个日志示例：</p><pre class="line-numbers language-none"><code class="language-none">50.541: [GC pause (young) (initial-mark), 0.27767100 secs][Eden: 1220M(1220M)-&gt;0B(1220M)Survivors: 144M-&gt;144M Heap: 3242M(4096M)-&gt;2093M(4096M)][Times: user=1.02 sys=0.04, real=0.28 secs]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上面的日志表明发生了 YGC 、应用线程为此暂停了 280 毫秒，Eden 区被清空（71MB 从 Young 区移到了 O 区）。</p><p>日志里面 initial-mark 的字样表明后台的并发 GC 阶段开始了。因为初始标记阶段本身也是要暂停应用线程的，G1 正好在 YGC 的过程中把这个事情也一起干了。为此带来的额外开销不是很大、增加了 20% 的 CPU ，暂停时间相应的略微变长了些。</p><p>接下来，G1 开始扫描根区域、日志示例：</p><pre class="line-numbers language-none"><code class="language-none">50.819: [GC concurrent-root-region-scan-start]51.408: [GC concurrent-root-region-scan-end, 0.5890230]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>一共花了 580 毫秒，这个过程没有暂停应用线程；是后台线程并行处理的。这个阶段不能被 YGC 所打断、因此后台线程有足够的 CPU 时间很关键。如果 Young 区空间恰好在 Root 扫描的时候满了、YGC 必须等待 root 扫描之后才能进行。带来的影响是 YGC 暂停时间会相应的增加。这时的 GC 日志是这样的： </p><pre class="line-numbers language-none"><code class="language-none">350.994: [GC pause (young)351.093: [GC concurrent-root-region-scan-end, 0.6100090]351.093: [GC concurrent-mark-start],0.37559600 secs]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>GC 暂停这里可以看出在 root 扫描结束之前就发生了，表明 YGC 发生了等待，等待时间大概是100毫秒。</p><p>在 root 扫描完成后，G1 进入了一个并发标记阶段。这个阶段也是完全后台进行的；GC 日志里面下面的信息代表这个阶段的开始和结束：</p><pre class="line-numbers language-none"><code class="language-none">111.382: [GC concurrent-mark-start]....120.905: [GC concurrent-mark-end, 9.5225160 sec]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>并发标记阶段是可以被打断的，比如这个过程中发生了 YGC 就会。这个阶段之后会有一个二次标记阶段和清理阶段：</p><pre class="line-numbers language-none"><code class="language-none">120.910: [GC remark 120.959:[GC ref-PRC, 0.0000890 secs], 0.0718990 secs][Times: user=0.23 sys=0.01, real=0.08 secs]120.985: [GC cleanup 3510M-&gt;3434M(4096M), 0.0111040 secs][Times: user=0.04 sys=0.00, real=0.01 secs]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这两个阶段同样会暂停应用线程，但时间很短。接下来还有额外的一次并发清理阶段：</p><pre class="line-numbers language-none"><code class="language-none">120.996: [GC concurrent-cleanup-start]120.996: [GC concurrent-cleanup-end, 0.0004520]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>到此为止，正常的一个 G1 周期已完成–这个周期主要做的是发现哪些区域包含可回收的垃圾最多（标记为 X ），实际空间释放较少。</p><h5 id="混合-GC"><a href="#混合-GC" class="headerlink" title="混合 GC"></a>混合 GC</h5><p>接下来 G1 执行一系列的混合 GC。这个时期因为会同时进行 YGC 和清理上面已标记为 X 的区域，所以称之为混合阶段，下面是一个混合 GC 执行的前后示意图：<br><img src="http://image.ouyangsihai.cn/Flo526oI2G_UIbkT-Jibo5ZoX27u"></p><p>像普通的 YGC 那样、G1 完全清空掉 Eden 同时调整 survivor 区。另外，两个标记也被回收了，他们有个共同的特点是包含最多可回收的对象，因此这两个区域绝对部分空间都被释放了。这两个区域任何存活的对象都被移到了其他区域（和 YGC 存活对象晋升到 O 区类似）。这就是为什么 G1 的堆比 CMS 内存碎片要少很多的原因——移动这些对象的同时也就是在压缩对内存。下面是一个混合GC的日志：</p><pre class="line-numbers language-none"><code class="language-none">79.826: [GC pause (mixed), 0.26161600 secs]....[Eden: 1222M(1222M)-&gt;0B(1220M)Survivors: 142M-&gt;144M Heap: 3200M(4096M)-&gt;1964M(4096M)][Times: user=1.01 sys=0.00, real=0.26 secs]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的日志可以注意到 Eden 释放了 1222 MB、但整个堆的空间释放内存要大于这个数目。数量相差看起来比较少、只有 16 MB，但是要考虑同时有 survivor 区的对象晋升到 O 区；另外，每次混合 GC 只是清理一部分的 O 区内存，整个 GC 会一直持续到几乎所有的标记区域垃圾对象都被回收，这个阶段完了之后 G1 会重新回到正常的 YGC 阶段。周期性的，当O区内存占用达到一定数量之后 G1 又会开启一次新的并行 GC 阶段.</p><p>G1来源：<a href="https://blog.51cto.com/lqding/1770055">https://blog.51cto.com/lqding/1770055</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这里把上面的这些垃圾回收器做个总结，看完这个，面试给面试官讲的时候思路就非常清晰了。</p><table><thead><tr><th>收集器</th><th>串行、并行or并发</th><th>新生代/老年代</th><th>算法</th><th>目标</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>Serial</strong></td><td>串行</td><td>新生代</td><td>复制算法</td><td>响应速度优先</td><td>单CPU环境下的Client模式</td></tr><tr><td><strong>Serial Old</strong></td><td>串行</td><td>老年代</td><td>标记-整理</td><td>响应速度优先</td><td>单CPU环境下的Client模式、CMS的后备预案</td></tr><tr><td><strong>ParNew</strong></td><td>并行</td><td>新生代</td><td>复制算法</td><td>响应速度优先</td><td>多CPU环境时在Server模式下与CMS配合</td></tr><tr><td><strong>Parallel Scavenge</strong></td><td>并行</td><td>新生代</td><td>复制算法</td><td>吞吐量优先</td><td>在后台运算而不需要太多交互的任务</td></tr><tr><td><strong>Parallel Old</strong></td><td>并行</td><td>老年代</td><td>标记-整理</td><td>吞吐量优先</td><td>在后台运算而不需要太多交互的任务</td></tr><tr><td><strong>CMS</strong></td><td>并发</td><td>老年代</td><td>标记-清除</td><td>一种以获取最短回收停顿时间为目标的收集器</td><td>互联网站或者B/S系统的服务端上的Java应用</td></tr><tr><td><strong>G1</strong></td><td>并发</td><td>老年代</td><td>标记-整理</td><td>高吞吐量</td><td>面向服务器的垃圾收集器，主要针对配备多颗处理器及大容量内存的机器</td></tr></tbody></table><blockquote><p>内存泄漏和内存溢出，什么时候会出现，怎么解决？</p></blockquote><p>内存泄漏：(Memory Leak)  不再会被使用的对象的内存不能被回收，就是内存泄露。</p><p>强引用所指向的对象不会被回收，可能导致内存泄漏，虚拟机宁愿抛出OOM也不会去回收他指向的对象。</p><p>意思就是你用资源的时候为他开辟了一块空间，当你用完时忘记释放资源了，这时内存还被占用着，一次没关系，但是内存泄漏次数多了就会导致内存溢出。</p><p>内存溢出：(Out Of Memory —— OOM) 指程序申请内存时，没有足够的内存供申请者使用，或者说，给了你一块存储 int 类型数据的存储空间，但是你却存储 long 类型的数据，那么结果就是内存不够用，此时就会报错 OOM ，即所谓的内存溢出，简单来说就是自己所需要使用的空间比我们拥有的内存大内存不够使用所造成的内存溢出。</p><p>内存的释放：即清理那些不可达的对象，是由 GC 决定和执行的，所以 GC 会监控每一个对象的状态，包括申请、引用、被引用和赋值等。释放对象的根本原则就是对象不会再被使用。</p><h4 id="内存泄漏的原因"><a href="#内存泄漏的原因" class="headerlink" title="内存泄漏的原因"></a>内存泄漏的原因</h4><ul><li><p>静态集合类引起内存泄漏；</p></li><li><p>当集合里面的对象属性被修改后，再调用remove()方法时不起作用。JDK1.8 貌似修正了引用对象修改参数，导致hashCode变更的问题；</p></li><li><p>监听器 Listener 各种连接 Connection，没有及时关闭；</p></li><li><p>内部类和外部模块的引用（尽量使用静态内部类）；</p></li><li><p>单例模式（静态类持有引用，导致对象不可回收）；</p></li></ul><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ul><li>尽早释放无用对象的引用，及时关闭使用的资源，数据库连接等；</li><li>特别注意一些像 HashMap 、ArrayList 的集合对象，它们经常会引发内存泄漏。当它们被声明为 static 时，它们的生命周期就会和应用程序一样长。</li><li>注意 事件监听 和 回调函数 。当一个监听器在使用的时候被注册，但不再使用之后却未被反注册。</li></ul><h4 id="内存溢出的情况和解决方法"><a href="#内存溢出的情况和解决方法" class="headerlink" title="内存溢出的情况和解决方法"></a>内存溢出的情况和解决方法</h4><ul><li>OOM for Heap (java.lang.OutOfMemoryError: Java heap space)</li></ul><p>此 OOM 是由于 JVM 中 heap 的最大值不满足需要，将设置 heap 的最大值调高即可，如，-Xmx8G。</p><ul><li>OOM for StackOverflowError (Exception in thread “main” java.lang.StackOverflowError)</li></ul><p>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出 StackOverflowError 异常。</p><p>如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出 OutOfMemoryError 异常。</p><p>检查程序是否有深度递归。</p><ul><li>OOM for Perm (java.lang.OutOfMemoryError: PermGen space)</li></ul><p>调高 Perm 的最大值，即 -XX:MaxPermSize 的值调大。</p><ul><li>OOM for GC (java.lang.OutOfMemoryError: GC overhead limit exceeded)</li></ul><p>此 OOM 是由于 JVM 在 GC 时，对象过多，导致内存溢出，建议调整 GC 的策略，在一定比例下开始 GC 而不要使用默认的策略，或者将新代和老代设置合适的大小，需要进行微调存活率。</p><p>改变 GC 策略，在老代 80% 时就是开始 GC ，并且将<code>-XX:SurvivorRatio（-XX:SurvivorRatio=8）</code>和<code>-XX:NewRatio（-XX:NewRatio=4）</code>设置的更合理。</p><ul><li>OOM for native thread created (java.lang.OutOfMemoryError: unable to create new native thread)</li></ul><p>将 heap 及 perm 的最大值下调，并将线程栈调小，即 -Xss 调小，如：-Xss128k。</p><p>在 JVM 内存不能调小的前提下，将 -Xss 设置较小，如：-Xss:128k。</p><ul><li>OOM for allocate huge array (Exception in thread “main”: java.lang.OutOfMemoryError: Requested array size exceeds VM limit)</li></ul><p>此类信息表明应用程序试图分配一个大于堆大小的数组。例如，如果应用程序 new 一个数组对象，大小为 512M，但是最大堆大小为 256M，因此 OutOfMemoryError 会抛出，因为数组的大小超过虚拟机的限制。</p><ol><li>首先检查 heap 的 -Xmx 是不是设置的过小;</li><li>如果 heap 的 -Xmx 已经足够大，那么请检查应用程序是不是存在 bug，例如：应用程序可能在计算数组的大小时，存在算法错误，导致数组的 size 很大，从而导致巨大的数组被分配。</li></ol><ul><li>OOM for small swap (Exception in thread “main”: java.lang.OutOfMemoryError: request <size> bytes for <reason>. Out of swap space? )</reason></size></li></ul><p>由于从 native 堆中分配内存失败，并且堆内存可能接近耗尽。</p><ol><li>检查 os 的 swap 是不是没有设置或者设置的过小;</li><li>检查是否有其他进程在消耗大量的内存，从而导致当前的 JVM 内存不够分配。</li></ol><ul><li>OOM for exhausted native memory (java.lang.OutOfMemoryErr java.io.FileInputStream.readBytes(Native Method))</li></ul><p>从错误日志来看，在 OOM 后面没有提示引起 OOM 的原因，进一步查看 stack trace 发现，导致 OOM 的原因是由Native Method 的调用引起的，另外检查 Java heap ，发现 heap 的使用正常，因而需要考虑问题的发生是由于 Native memory 被耗尽导致的。</p><p>从根本上来说，解决此问题的方法应该通过检测发生问题时的环境下，native memory 为什么被占用或者说为什么 native memory 越来越小，从而去解决引起 Native memory 减小的问题。但是如果此问题不容易分析时，可以通过以下方法或者结合起来处理。</p><ol><li>cpu 和 os 保证是 64 位的，并且 jdk 也换为 64 位的。</li><li>将 java heap 的 -Xmx 尽量调小，但是保证在不影响应用使用的前提下。</li><li>限制对 native memory 的消耗，比如：将 thread 的 -Xss 调小，并且限制产生大量的线程；限制文件的 io 操作次数和数量；限制网络的使用等等。</li></ol><blockquote><p>Java 的类加载过程</p></blockquote><p>JVM类加载机制分为五个部分：加载，验证，准备，解析，初始化，下面我们就分别来看一下这五个过程。其中加载、检验、准备、初始化和卸载这个五个阶段的顺序是固定的，而解析则未必。为了支持动态绑定，解析这个过程可以发生在初始化阶段之后。</p><p><img src="http://image.ouyangsihai.cn/FpontTFCT65kRlJvGhuMsP9lkRkZ"></p><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>加载过程主要完成三件事情：</p><ol><li>通过类的全限定名来获取定义此类的二进制字节流</li><li>将这个类字节流代表的静态存储结构转为方法区的运行时数据结构</li><li>在堆中生成一个代表此类的 java.lang.Class 对象，作为访问方法区这些数据结构的入口。</li></ol><h4 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h4><p>此阶段主要确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机的自身安全。</p><ol><li>文件格式验证：基于字节流验证。</li><li>元数据验证：基于**<em>方法区</em>**的存储结构验证。</li><li>字节码验证：基于方法区的存储结构验证。</li><li>符号引用验证：基于方法区的存储结构验证。</li></ol><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>为类变量分配内存，并将其初始化为默认值。（此时为默认值，在初始化的时候才会给变量赋值）即在方法区中分配这些变量所使用的内存空间。例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时在准备阶段过后的初始值为0而不是 123 ；将 value 赋值为 123 的 putstatic 指令是程序被编译后，存放于类构造器方法之中。特例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时 value 的值在准备阶段过后就是 123 。</p><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>把类型中的符号引用转换为直接引用。</p><ul><li>符号引用与虚拟机实现的布局无关，引用的目标并不一定要已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的 Class 文件格式中。</li><li>直接引用可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在内存中存在</li></ul><p>主要有以下四种：</p><ol><li>类或接口的解析</li><li>字段解析</li><li>类方法解析</li><li>接口方法解析</li></ol><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>初始化阶段是执行类构造器方法的过程。方法是由编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成的。虚拟机会保证方法执行之前，父类的方法已经执行完毕。如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生成()方法。</p><p>Java 中，对于初始化阶段，有且只有以下五种情况才会对要求类立刻“初始化”（加载，验证，准备，自然需要在此之前开始）：</p><ol><li>使用 new 关键字实例化对象、访问或者设置一个类的静态字段（被 final 修饰、编译器优化时已经放入常量池的例外）、调用类方法，都会初始化该静态字段或者静态方法所在的类。</li><li>初始化类的时候，如果其父类没有被初始化过，则要先触发其父类初始化。</li><li>使用 java.lang.reflect 包的方法进行反射调用的时候，如果类没有被初始化，则要先初始化。</li><li>虚拟机启动时，用户会先初始化要执行的主类（含有main）</li><li>jdk 1.7后，如果 java.lang.invoke.MethodHandle的实例最后对应的解析结果是 REF_getStatic、REF_putStatic、REF_invokeStatic 方法句柄，并且这个方法所在类没有初始化，则先初始化。</li></ol><blockquote><p>聊聊双亲委派机制</p></blockquote><p><img src="http://image.ouyangsihai.cn/FoFkvh_XGVUdHkp3F6dYBpwE8tgb"></p><p><strong>工作过程</strong></p><p>如果一个类加载器收到了类加载器的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父加载器去完成，每个层次的类加载器都是如此，因此，所有的加载请求最终都会传送到 Bootstrap 类加载器(启动类加载器)中，只有父类加载反馈自己无法加载这个请求(它的搜索范围中没有找到所需的类)时，子加载器才会尝试自己去加载。</p><p><strong>优点</strong></p><p>Java 类随着它的加载器一起具备了一种带有优先级的层次关系.</p><p>例如类 java.lang.Object ，它存放在 rt.jar 之中，无论哪一个类加载器都要加载这个类，最终都是双亲委派模型最顶端的 Bootstrap 类加载器去加载，因此 Object 类在程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户编写了一个称为 “java.lang.Object” 的类，并存放在程序的 ClassPath 中，那系统中将会出现多个不同的 Object 类，java类型体系中最基础的行为也就无法保证，应用程序也将会一片混乱。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm面试题收集一 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
